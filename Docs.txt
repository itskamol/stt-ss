

TO THE MAXIMUM EXTENT PERMITTED BY APPLICABLE LAW, THE DOCUMENT IS PROVIDED "AS IS" AND "WITH ALL
FAULTS AND ERRORS". OUR COMPANY MAKES NO REPRESENTATIONS OR WARRANTIES, EXPRESS OR IMPLIED,
INCLUDING BUT NOT LIMITED TO, WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR
NON-INFRINGEMENT. IN NO EVENT WILL OUR COMPANY BE LIABLE FOR ANY SPECIAL, CONSEQUENTIAL,
INCIDENTAL, OR INDIRECT DAMAGES, INCLUDING, AMONG OTHERS, DAMAGES FOR LOSS OF BUSINESS PROFITS,
BUSINESS INTERRUPTION OR LOSS OF DATA, CORRUPTION OF SYSTEMS, OR LOSS OF DOCUMENTATION,
WHETHER BASED ON BREACH OF CONTRACT, TORT (INCLUDING NEGLIGENCE), OR OTHERWISE, IN CONNECTION
WITH THE USE OF THE DOCUMENT, EVEN IF OUR COMPANY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
DAMAGES OR LOSS.


1 Overview
1.1 Introduction
Intelligent Security API (hereinafter referred to as ISAPI) is an application layer protocol based on HTTP (Hypertext
Transfer Protocol) and adopts the REST (Representational State Transfer) architecture for communication between
security devices (cameras, DVRs, NVRs, etc.) and the platform or client software. Since established in 2013, ISAPI has
had more than 11,000 APIs for different functions, including device management, vehicle recognition, parking lot
management, intelligent facial application, access control management, interrogation management, and recording
management. It is applicable to industries such as traffic, fire protection, education, and security inspection.
1.2 Product Scope
Access Control
Face Recognition Terminals
ACT-T1331RU、ACT-T1331WRU、ACT-T1341MFRU、ACT-T1341MRU、DS-K1A330、DS-K1A330W、DSK1A340FWX、DS-K1A340FX、DS-K1A340WX、DS-K1A340WX#India、DS-K1A340X、DS-K1T331、DSK1T331W、DS-K1T341A、DS-K1T341AM、DS-K1T341AM-S、DS-K1T341AMF、DS-K1T341AMF-S、DSK1T341AMHUN#India、DS-K1T341B、DS-K1T341BMI-T、DS-K1T341BMW、DS-K1T341BMWI-T、DSK1T341CM、DS-K1T341CMF、DS-K1T341CMFW、DS-K1T341CMW、DS-K1T341M、DS-K1T342DWX、DSK1T342DX、DS-K1T342EFWX、DS-K1T342EWX、DS-K1T342EX、DS-K1T342MFWX、DS-K1T342MFX、DSK1T342MWX、DS-K1T342MX、DS-K1T343EFWX、DS-K1T343EFX、DS-K1T343EWX、DS-K1T343EX、DSK1T343MFWX、DS-K1T343MFX、DS-K1T343MFX#India、DS-K1T343MWX、DS-K1T343MX、DS-K1T607、
DS-K1T607E、DS-K1T607TEF#India、DS-K1T642、DS-K1T642E、DS-K1T642EF、DS-K1T642EFW、DSK1T642EW、DS-K1T642M、DS-K1T642MF、DS-K1T642MFW、DS-K1T642MW、DS-K1T643MWX-T、DSK1T643MX-T、DS-K1T671、DS-K1T671AM、DS-K1T671AMW、DS-K1T671BM、DS-K1T671BMF、DSK1T671BMFW、DS-K1T671BMW、DS-K1T671BTM、DS-K1T671BTMF、DS-K1T671BTMFW、DSK1T671BTMW、DS-K1T671M、DS-K1T671M#RUBB、DS-K1T671M#turkey、DS-K1T671M-L、DSK1T671MF、DS-K1T671MF-L、DS-K1T671T、DS-K1T671TM、DS-K1T671TM-3XF、DS-K1T671TMF、DSK1T671TMFW、DS-K1T671TMW、DS-K1T672、DS-K1T672DWX-T、DS-K1T672DX-T、DS-K1T672E、DSK1T672M、DS-K1T672MW、DS-K1T673DWX、DS-K1T673DX、DS-K1T673TDGX、DS-K1T673TDWX、DSK1T673TDX、DS-K1T680D、DS-K1T680D-E1、DS-K1T680DF、DS-K1T680DF-E1、DS-K1T680DFG、DSK1T680DFW、DS-K1T680DG、DS-K1T680DW、DS-K1T690M-E1、DS-K1T690M-T、DS-K1T690MF-X、DSK1T690MW、DS-K1T6Q-F71M、DS-K1T6QT-F72DWX、DS-K1T6QT-F72DX、DS-K1T6QT-F72TDGX、DSK1T6QT-F72TDWX、DS-K1T6QT-F72TDX、DS-K1TA70MI-T、DS-K1TV41MF#Asia、DS-K5604A-3XF/V、DSK5671-3XF/ZU、DS-K5671-W、DS-K5671-ZH、DS-K5671-ZU、DS-K5671-ZV、DS-K5671-ZV(B)#IN、DSK5671A-ZU、DS-K5671B-ZH、DS-K5671B-ZU、DS-K5671B-ZV、DS-K5672MW-Z、VDP-T331#CATC、
VDP-T341#CATC
1.3
Terms And Definitions
1.3.1 Access Permission
Users can set who can open which doors at what time. The access permission contains information about the person,
time, and door.
1.3.2 Person Type
Persons can be divided into normal persons, visitors, and blocklist persons according to different areas. In the access
control system, normal persons have permanent permissions to access the specified areas, visitors have temporary
permissions to access the specified areas, and blocklist persons do not have the permissions to access the specified
areas.
1.3.3 Credential Type


Credentials are the data which are used for recognizing specific persons. Cards, fingerprints, and face pictures can be
the credentials and linked to the specified persons. When the device detects the credential, it can recognize the person
whom the credential links to via the comparison algorithm.
1.3.4 EZVIZ Cloud Storage
1.3.5 Event
The cloud storage service provided by EZVIZ.
It refers to the information uploaded by the device. The event is uploaded by the device in real time for the immediate
response from the client or the platform. If the device is offline, the event will be stored in the cache first and then it will
be uploaded again when the connection is restored.
1.3.6 Listen
After the platform starts listening service, when an event occurs, the event information will be sent to the listening port
of the platform based on the IP address and port No., then the connection will be closed.
1.3.7 Listening Host
1.3.8 Person-Based Access Control
The listening host service can be enabled to receive the event information from devices.
The person ID is the unique identifier for person management, and the card, fingerprint, face picture are the person’s
credentials which are linked via the person ID. Permissions are also linked via the person ID.
1.4 Symbols And Acronyms
ACS: Access Control System. The access control system controls the entrance and exit channels. The system consists of
card readers, access controllers, electric locks, exit buttons, cards, application software, etc.
EZVIZ: EZVIZ (Easy View/Vision).
admin: administrator
HTTP: Hypertext Transfer Protocol
1.5 Update History
2 Application Scenario
No update record
When you integrate devices via ISAPI, the device acts as the server to listen on the fixed port and the user's application
acts as the client to actively log in to the device for communication. To achieve the above goals, the device should be
configured with a fixed IP address and the requests from the client can reach the server.


3 Layers in the Network Model
ISAPI is an application layer protocol based on HTTP, thereby it inherits all specifications and properties from HTTP.
Protocols frequently used along with ISAPI include SADP (Search Active Device Protocol) based on multicast for
discovering and activating devices, RTSP (Real-Time Streaming Protocol) based on TCP/UDP for live view and video
playback of the devices, etc.
4 ISAPI Framework
4.1 Overview


Note:
In general, ISAPI refers to the communication protocol based on the HTTP standard. As ISAPI is usually used along with
RTSP (Real-Time Streaming Protocol), the RTSP standard is brought into the ISAPI system.
The meta data scheme for transmitting additional information of the stream is extended based on the RTSP standard to
transmit the video stream and the structured intelligent information of the stream simultaneously. It is compatible with
the RTSP standard.
4.2 Activation
The purpose of activation is to ensure that the user can set the password for the device and the password meets the
security requirement. After the device is activated, you can use the related functions.
ISAPI is a communication protocol running in the application layer. When activating the device via ISAPI, you should
know the device's IP address and make sure that the device is connected to the client.
The web application built in the device supports activating the device via ISAPI. When you enter the device's IP address
in the address bar of the web browser on the PC, you can activate the device according to the activation guide.
If you want to activate the device on your own application, you need to integrate the activation function via ISAPI. The
API calling flow and related APIs are shown below.


Firstly, two operations are defined:
bytesToHexstring: it is used to convert a byte array (the length is N) to a hexadecimal string (the length is 2N). For
example, 127,10,23 -> 7f0a17
hexStringToBytes: it is used to convert a hexadecimal string (the length is 2N) to a byte array (the length is N). For
example, 7f0a17 -> 127,10,23
The basic interaction flow between the client and device is shown below.


1. The client generates a public and private key pair (1024 bits), and gets the 128-byte modulus in the public key
(hereinafter referred to as public key modulus). If the length is longer than 128, the leading 0 needs to be removed.
2. The client converts the public key modulus to a 256-byte public key string via bytesToHexstring and sends the
public key string to the device in XML message (related URI: POST /ISAPI/Security/challenge) after being
encoded by Base64.
3. The device parses the request to obtain a 256-byte public key string decoded by Base64 and converts it to a 128byte
public key modulus via hexStringToBytes. The complete public key is the combination of obtained public key
modulus and public exponent (the default value is '010001').
4. The device generates a 32-byte hexadecimal random string, calls the RSA API to encrypt the random string with
the private key, converts the encrypted data to a string via bytesToHexstring, encodes the string by Base64, and
then sends it to the client.
5. The client decodes the string from the device by Base64, converts it via hexStringToBytes to get the encrypted data,
decrypts the encrypted data with the private key via RSA to obtain a 32-byte hexadecimal random string, converts
the obtained string via hexStringToBytes to get a 16-byte AES key. Then the client uses the AES key to encrypt the
"string consisting of the first 16 characters of the random string and the real password" by AES128
ECB mode (with zero-padding method) to get a ciphertext, converts the ciphertext via bytesToHexstring, encodes it
by Base64, and sends it to the device in XML message (related URI: PUT /ISAPI/System/activate). Note: If the first
16 characters of the random string are aaaabbbbccccdddd and the real password is Abc12345, the data before
encryption is aaaabbbbccccddddAbc12345. This can ensure that the client uses the random string as the key for
encryption.
6. The device decodes the string by Base64, converts it via hexStringToBytes to get the ciphertext, uses the AES key to
decrypt the ciphertext by AES128 ECB mode, and gets the real password via removing the first 16 characters.
7. The device verifies the password and returns the activation result.


Note:
You can get the device's activation status by calling the URI GET /SDK/activateStatus which requires no
authentication.
Devices also support to be activated via SADP (Search Active Device Protocol) which is based on the
communication protocol of the data link layer. With SADP, you do not have to know the IP address of the device
but need to ensure that the device and the application running SADP are connected to the same router. SADP also
supports discovering devices in the LAN, changing the password of the devices, and so on. The HCSadpSDK is
provided for SADP integration, including the developer guide, plug-in, and sample demo which can be used as a
simple SADP tool.
4.3 Security Mechanism
4.3.1 Authentication
When the client applications send requests to the devices, they need to use digest authentication (see details in RFC
7616) for identity authentication.
Currently, all mainstream request class libraries of HTTP have encapsulated digest authentication. The client
applications only need to call APIs of the class library to implement the digest authentication. The sample code is shown
below.
4.3.1.1 C/C++ (libcurl)
// #include <curl/curl.h>
// Callback Function
static size_t OnWriteData(void* buffer, size_t size, size_t nmemb, void* lpVoid)
{
std::string* str = dynamic_cast<std::string*>((std::string *)lpVoid);
if( NULL == str || NULL == buffer )
{
return -1;
}
char* pData = (char*)buffer;
str->append(pData, size * nmemb);
return nmemb;
}
std::string strUrl = "http://192.168.18.84:80/ISAPI/System/deviceInfo";
std::string strResponseData;
CURL *pCurlHandle = curl_easy_init();
curl_easy_setopt(pCurlHandle, CURLOPT_CUSTOMREQUEST, "GET");
curl_easy_setopt(pCurlHandle, CURLOPT_URL, strUrl.c_str());
// Set the user name and password
curl_easy_setopt(pCurlHandle, CURLOPT_USERPWD, "admin:admin12345");
// Set the authentication method to the digest authentication
curl_easy_setopt(pCurlHandle, CURLOPT_HTTPAUTH, CURLAUTH_DIGEST);
// Set the callback function
curl_easy_setopt(pCurlHandle, CURLOPT_WRITEFUNCTION, OnWriteData);
// Set the parameters of the callback function to get the returned information
curl_easy_setopt(pCurlHandle, CURLOPT_WRITEDATA, &strResponseData);
// Timeout settings for receiving the data. If receiving data is not completed within 5 seconds, the application will exit directly
curl_easy_setopt(pCurlHandle, CURLOPT_TIMEOUT, 5);
// Set the redirection times to avoid too many redirections
curl_easy_setopt(pCurlHandle, CURLOPT_MAXREDIRS, 1);
// Connection timeout duration. If the duration is too short, the client application will be disconnected before the data request sent by the application
reaches the device
curl_easy_setopt(pCurlHandle, CURLOPT_CONNECTTIMEOUT, 5);
CURLcode nRet = curl_easy_perform(pCurlHandle);
if (0 == nRet)
{
// Output the received message
std::cout << strResponseData << std::endl;
}
curl_easy_cleanup(pCurlHandle);
4.3.1.2 C# (WebClient)


// using System.Net;
// using System.Net.Security;
try
{
string strUrl = "http://192.168.18.84:80/ISAPI/System/deviceInfo";
WebClient client = new WebClient();
// Set the user name and password
client.Credentials = new NetworkCredential("admin", "admin12345");
byte[] responseData = client.DownloadData(strUrl);
string strResponseData = Encoding.UTF8.GetString(responseData);
// Output received information
Console.WriteLine(strResponseData);
}
catch (Exception ex)
{
Console.WriteLine(ex.Message);
}
4.3.1.3 Java (HttpClient)
// import org.apache.commons.httpclient.HttpClient;
String url = "http://192.168.18.84:80/ISAPI/System/deviceInfo";
HttpClient client = new HttpClient();
// Set the user name and password
UsernamePasswordCredentials creds = new UsernamePasswordCredentials("admin", "admin12345");
client.getState().setCredentials(AuthScope.ANY, creds);
GetMethod method = new GetMethod(url);
method.setDoAuthentication(true);
int statusCode = client.executeMethod(method);
byte[] responseData = method.getResponseBodyAsString().getBytes(method.getResponseCharSet());
String strResponseData = new String(responseData, "utf-8");
method.releaseConnection();
// Output received information
System.out.println(strResponseData);
4.3.1.4 Python (requests)
# - *- coding: utf-8 -*import
requests
request_url = 'http://192.168.18.84:80/ISAPI/System/deviceInfo'
# Set the authentication information
auth = requests.auth.HTTPDigestAuth('admin', 'admin12345')
# Send the request and receive response
response = requests.get(request_url, auth=auth)
# Output response content
print(response.text)
4.3.2 User Permission
There are three kinds of users with different permissions for access control and management.
Administrator: Has the permission to access all supported resources and should keep activated all the time. It is also
known as "admin".
Operator: Has the permission to access general resources and a part of advanced resources.
Normal User: Only has the permission to access general resources.
4.3.3 Stream Encryption
To enhance the security of the real-time or historical stream from the devices and comply with the laws and regulations
of international markets, ISAPI provides the function of encrypting the stream based on the AES algorithm.
Before enabling the stream encryption function, firstly you need to check whether the device supports stream
encryption and set the stream encryption key and PlayCtrl library decryption key. The interaction process is shown in
the figure below.
Note: After the stream encryption is enabled, you can only decode the stream using the PlayCtrl library .


4.3.4 Information Encryption
During ISAPI integration, some sensitive information, such as the user name and password, in the message needs to be
encrypted to enhance the security for transmission.
There are two methods to encrypt the information for transmission: HTTPS and sensitive information encryption (AES
encryption).
HTTPS (Recommended): Firstly you can enable the HTTPS service of the device. When the client applications
communicate with devices via HTTPS, the information can be transmitted securely.
Sensitive Information Encryption: Sensitive information, such as the user name and password, in the message is
encrypted for transmission. The core of the encryption algorithm is AES. The interaction process is shown below.


4.4 Video Streaming
4.4.1 Audio and Video Stream
ISAPI supports getting and setting stream media parameters of the device, such as video resolution, encoding format,
and stream.
Cameras support standard RTSP (Real-Time Streaming Protocol, see details in RFC 7826). Client applications can get
the stream from devices via RTSP.
For details about real-time streaming and video playback, refer to Real-Time Streaming and Playback.
4.4.2 Metadata
The metadata is the structured intelligent information generated by intelligent devices. When the client applications get
the audio and/or video stream from devices via RTSP, the metadata will be returned by the device at the same time. For
example, to display the face target frame, face information, vehicle target frame, license plate number, vehicle
information, and other information on the video stream, the client applications can overlay the above information on
the video image.
Before using the metadata, you need to enable the metadata function of the device and then get the stream from the
device via RTSP. Some devices support subscribing to the metadata by type. For details about the process of integrating
the metadata function, refer to Metadata Management.
4.5 Message Parsing
4.5.1 Message Format
During the process of communication and interaction via ISAPI, the request and response messages are often text data
in XML or JSON format. Besides that, the data of firmware packages and configuration files is in binary format. A
request can also be in form format with multiple formats of data (multipart/form-data).
4.5.1.1 XML


Generally, the Content-Type in the Headers of the HTTP request is application/xml; charset="UTF-8"
Request and response messages in XML format are all encoded with UTF-8 standards in ISAPI.
4.5.1.2 JSON
The Content-Type in the Headers of the HTTP request is often application/json.
To distinguish between APIs with XML messages and those with JSON messages, ISAPI adds the query parameter
format=json to all request URLs with JSON messages, e.g.,
http://192.168.1.1:80/ISAPI/System/Sensor/thermometrySensor?format=json . Messages of request URLs without
the query parameter format=json are usually in XML format. However, there may be some exceptions, and the message
format is subject to the API definition.
Request and response messages in JSON format are all encoded by UTF-8 in ISAPI.
4.5.1.3 Binary Data
For the firmware and configuration files, the Content-Type in the Headers of an HTTP request is often
application/octet-stream.
4.5.1.4 Form (multipart/form-data)
When multiple pieces of data are submitted at the same time in an ISAPI request (e.g., the person information and face
picture need to be submitted at the same time when a face record is added to the face picture library), the ContentType
in the Headers of the corresponding HTTP request is usually multipart/form-data, boundary=AaB03x, where the
boundary is a variable used to separate the entire HTTP Body into multiple units and each unit is a piece of data with its
own Headers. For the detailed format description, refer to RFC 1867 (Form-Based File Upload in HTML). The example is
as follows. Pay attention to the horizontal lines before and after the boundary.
POST /ISAPI/Intelligent/FDLib/pictureUpload
Content-Type: multipart/form-data; boundary=AaB03x
Content-Length: 56789
--AaB03x
Content-Disposition: form-data; name="PictureUploadData";
Content-Type: text/xml
Content-Length: 1234
<PictureUploadData/>
--AaB03x
Content-Disposition: form-data; name="face_picture"; filename="face_picture.jpg";
Content-Type: image/jpeg
Content-Length: 34567
Picture Data
--AaB03x-
Note:
In RFC specifications, it is strongly recommended to contain the field Content-Length in the entity header, and there is
no requirement that the field Content-Length should be contained in the header of each form element. The absence of
field Content-Length in the header should be considered when the client and device programs parse the form data.
4.5.2 Annotation
The field descriptions of ISAPI request and response messages are marked as annotations in the example messages as
shown below.


<?xml version="1.0" encoding="UTF-8"?>
<NodeList xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--ro, req, object, node list, attr:version{req, string, version No., range:[,]}-->
<Node>
<!--ro, opt, object, node information-->
<id>
<!--ro, req, int, node No., range:[,], step:, unit:, unitType:-->1
</id>
<enabled>
<!--ro, opt, bool, whether to enable-->true
</enabled>
<nodeName>
<!--ro, req, string, node name, range:[1,32]-->test
</nodeName>
<level>
<!--ro, opt, enum, level, subType:string,
[level1#level 1,level2#level 2,level3#level 3]-->level1
</level>
</Node>
</NodeList>
{
"name": "test",
/*ro, req, string, name, range:[1,32]*/
"type": "type1",
/*ro, req, enum, type, subType:string, [type1#type 1,type2#type 2]*/
"enabled": true,
/*ro, opt, bool, enable or not, desc:xxxxxxx*/
"NodeList": {
/*opt, object, node list, dep:and,{$.enabled,eq,true}*/
"scene": 1,
/*req, enum, scene, subType:int, [1#scene 1,2#scene 2,3#scene 3]*/
"ID": 1
/*req, int, No., range:[1,8], step:, unit:, unitType:*/
}
}
Key annotations are shown in the table below.


Annotation Description
ro
wo
req
opt
dep
object
list
subType
int
float
bool
enum
subType
desc
Attribute: ReadOnly
Attribute:
WriteOnly
Attribute:
Required
Attribute:
Optional
Attribute:
Dependent
Remark
This
field can only be obtained and cannot be edited.
This field can only be edited and cannot be obtained.
This field is required for request messages sent to the device and response
messages returned from the device.
This field is optional for request messages sent to the device and response
messages returned from the device.
This field is valid and required when specific conditions are satisfied.
Field Type: Object The field of type object contains multiple sub-fields.
Field Type: List
Field Type: String
Field Type: Int
The subType following it refers to the data type of sub-items in the list.
The range following it refers to the maximum and the minimum string size of the
field.
The range following it refers to the maximum and the minimum value of the field.
Field Type: Float The range following it refers to the maximum and the minimum value of the field.
Field Type:
Boolean
Field Type:
Enumeration
Sub-Type of Field
The value can be true or false.
The subType following it indicates that the enumerators are of type string or int.
The [] following the subType contains all enumerators.
When the type of field is list or enum, the value of subType is the data type of each
sub-object.
Field Description The detailed description of the field.
4.5.3 Capability Set
ISAPI has designed capability sets for almost all functions, APIs, and fields. URLs for getting the capability set end with
/capabilities. Some URLs may contain query parameters in the format: /capabilities?format=json&type=xxx.
There are two types of fields in the capability message of ISAPI: whether the device supports a function and the value
range of a field in an API.
Whether the device supports a function:
it is often in the format isSupportXxxxxxxx, which indicates that whether the device supports a function and a set of
APIs for implementing this function.
{
"isSupportMap": true,
/*ro, opt, bool, whether it supports the e-map function, desc:/ISAPI/SDT/Management/map/capabilities?format=json*/
"isSupportAlgTrainResourceInfo": true,
/*ro, opt, bool, whether it supports only getting the resource information of the algorithm training platform,
desc:/ISAPI/SDT/algorithmTraining/ResourceInfo?format=json*/
"isSupportAlgTrainAuthInfo": true,
/*ro, opt, bool, whether it supports ony getting the authorization information of the algorithm training platform,
desc:/ISAPI/SDT/algorithmTraining/SoftLock/AuthInfo?format=json*/
"isSupportAlgTrainNodeList": true,
/*ro, opt, bool, whether it supports only getting the node information of the algorithm training platform, desc:/ISAPI/SDT/algorithmTraining/NodeList?
format=json*/
"isSupportNAS": true
/*ro, opt, bool, whether it supports mounting and unmounting NAS, desc:/ISAPI/SDT/Management/NAS/capabilities?format=json*/
}


The value range of the field: the maximum value, minimum value, the maximum size, the minimum size, options,
and so on of each field of the API.
{
"boolType": {
/*req, object, example of the capability of type bool*/
"@opt": [true, false]
/*req, array, options, subType: bool*/
},
"integerType": {
/*req, object, example of the capability of type integer*/
"@min": 0,
/*ro, req, int, the minimum value*/
"@max": 100
/*ro, req, int, the maximum value*/
},
"stringType": {
/*req, object, example of the capability of type string*/
"@min": 0,
/*ro, req, int, the minimum string size*/
"@max": 32
/*ro, req, int, the maximum string size*/
},
"enumType": {
/*req, object, capability example of type enum*/
"@opt": ["enum1", "enum2", "enum3"]
/*req, array, options, subType: string*/
}
}
Note: For the same capability set, devices of different models and versions may return different results. The values
shown in this document are only examples for reference. The capability set actually returned by the device takes
precedence.
4.5.4 Time Format
ISAPI adopts ISO 8601 Standard Time Format, which is the same as W3C Standard Date and Time Formats.
Format: YYYY-MM-DDThh:mm:ss.sTZD
YYYY = the year consisting of four decimal digits
MM = the month consisting of two decimal digits (01-January, 02-February, and so forth)
DD = the day consisting of two decimal digits (01 to 31)
hh = the hour consisting of two decimal digits (00 to 23, a.m. and p.m. are not allowed)
mm = the minute consisting of two decimal digits (00 to 59)
ss = the second consisting of two decimal digits (00 to 59)
s = one or more digits representing the fractional part of a second
TZD = time zone identifier (Z or +hh:mm or -hh:mm)
Example: 2017-08-16T20:17:06.123+08:00 refers to 20:17:06.123 on August 16, 2017 (local time which is 8 hours
ahead of UTC). The plus sign (+) indicates that the local time is ahead of UTC, and the minus sign (-) means that the
local time is behind UTC.
After the DST is enabled, the local time and time difference will change compared with UTC, and the values of related
fields also need to be changed. Disabling the DST will bring into the opposite effect.
Example: In 1986, the DST was in effect from May 4 at 2:00 a.m. (GMT+8). During the DST period, the clocks were
moved one hour ahead, which means that there was one less hour on that day. When the DST ends at 2:00 a.m. on
September 14, 1986, the clocks were moved one hour back and there was an extra hour on that day. The changes of the
time are as follows:
DST Starts: 1986-05-04T02:00:00+08:00 --> 1986-05-04T03:00:00+09:00
DST Ends: 1986-09-14T02:00:00+09:00 --> 1986-09-14T01:00:00+08:00
Notes:
The time difference cannot be simply used to determine the time zone. Because when the DST starts, the time
difference will change and it cannot represent the actual time zone.
Both TZ (UTC time, e.g., 1986-05-03T18:00:00Z) and TD (local time and time difference, e.g., 1986-0504T02:00:00+08:00)
meet the time format standards of ISO 8601. In ISAPI, the TD format is recommended to be
used in messages sent from the user applications and the devices.


For representing the time difference information and forward compatibility, an extra field timeDiff is added as
shown in the example below. User applications need to support both TD format and TZ format when parsing the
time in the messages returned by devices.
A few old-version devices will return the time in TZ format.
{
"dateTime": "1986-05-03T18:00:00Z", /*device time. The value in TZ format is the UTC time and the value in TD format is the time difference between the
device's local time and UTC*/
"timeDiff": "+08:00" /*optional, time difference between the local time and UTC time. If this field does not exist, the user application will convert
the dateTime into the local time for use*/
}
4.5.5 Character Set
To prevent characters not commonly used from resulting in exceptions in device programs and user applications, ISAPI
limits the valid field values of type string to a specific range of characters. Character sets allowed to be used in the fields
of type string in ISAPI are listed below.
Single-byte character set: lowercase letters (a-z), uppercase letters (A-Z), digits (0-9), and special characters (see
details in the table below).
Multi-byte character set: language characters based on Unicode and encoded by UTF-8 (UTF-8 encoding is a
transformation format of Unicode character set. For details, refer to RFC 2044).
No. Name
1 Open Parenthesis
Close Parenthesis
2
3
4
Plus Sign
Comma
5 Minus Sign
Period
6
7
8
Semicolon
Equal Sign
9 At Sign
Special Character No. Name
(
)
+
,
-
.
;
=
@
10 Open Square Bracket [
11 Close Square Bracket ]
12 Underscore
13 Open Brace
14 Close Brace
15 Space
16 Exclamation Mark
17 Octothorpe
!
#
The valid characters that can be used in some special fields are listed below.
User name: lowercase letters (a-z), uppercase letters (A-Z), digits (0-9), and characters from No. 1 to No. 30 in the
special character table.
Password: User Name: lowercase letters (a-z), uppercase letters (A-Z), digits (0-9), and characters from No. 1 to
No. 33 in the special character table.
_
{
}
18 Dollar Sign
19 Percent Sign
20 Ampersand
Special Character
$
%
&
21 Close Single Quotation Mark '
22 Asterisk
*
23 Slash
24 Smaller Than
25 Greater Than
26 Question Mark
27 Caret
/
<
>
?
^
28 Open Single Quotation Mark '
|
29 Vertical Bar
30 Tilde
31 Double Quotation Marks
32 Colon
33 Backslash
~
"
:
|


Names displayed on the UI (device name, person name, face picture library name, etc.): lowercase letters (a-z),
uppercase letters (A-Z), digits (0-9), characters from No. 1 to No. 15 in the special character table, and multi-byte
characters.
Normal fields of type string support lowercase letters (a-z), uppercase letters (A-Z), digits (0-9), characters from
No. 1 to No. 15 in the special character table, and multi-byte characters by default.
4.5.6 Error Processing
When requesting via ISAPI failed (the HTTP status code is not 200), the device will return the HTTP status code and
ISAPI error code. For HTTP status codes, refer to 10 Status Code Definitions in RFC 2616. For ISAPI error codes, refer to
the Error Code Dictionary.
Message Example:
HTTP/1.1 403 Forbidden
Content-Type: application/json; charset="UTF-8"
Date: Thu, 15 Jul 2021 20:43:30 GMT
Content-Length: 229
Connection: Keep-Alive
{
"requestURL": "/ISAPI/Event/triggers/notifications/channels/whiteLightAlarm",
"statusCode": 4,
"statusString": "Invalid Operation",
"subStatusCode": "notSupport",
"errorCode": 1073741825,
"errorMsg": "notSupport"
}
4.6 Event Uploading
4.6.1 Arming
When the rules configured on the device are triggered, the device will generate event messages (e.g., motion detection,
face capture, vehicle capture, etc.) and actively upload them to the client. ISAPI supports three methods to receive event
messages uploaded by the device, that is, in arming mode, in listening mode, and via subscription.
Arming via ISAPI depends on the HTTP persistent connection. The client sends a request to establish the arming
connection with the device by calling GET /ISAPI/Event/notification/alertStream and keeps the connection alive.
Then the device will send event messages to the client through the connection.
Note:
The devices' responses are in form format (multipart/form-data). Depending on whether the event message
consists of multiple pieces of data, each subpart in the form corresponds to an event or a part of an event. For
example, the face capture event contains the face information in JSON format and the face picture data in binary
format, which means that there will be multiple subparts in the form.
When the device does not generate any event message within 5 seconds, the device will send a heartbeat message
to the client for checking the status of the arming connection.
4.6.2 Subscription
Subscription via ISAPI is basically the same as the arming. The difference is that the API for establishing the subscription
connection is POST /ISAPI/Event/notification/subscribeEvent. After the connection is established, you can
subscribe to specific video channels, event types, and so on by the request Body. Then the device will only send event
messages in the subscription list to the client.
For details about the API calling flow and related APIs, refer to Event Arming and Subscription Management.
4.6.3 Listening
In the listening mode, when an alarm is triggered or an event occurred, the device will actively upload the alarm/event
message to the address specified for receiving alarms/events. You need to configure the address on the device for
receiving the alarm/event notification and make sure that the device is valid.


Note:
The client and the event service can be the same program.
In the listening mode, the device will not upload the heartbeat message.
For details about the APIs of setting the address for receiving the event message, refer to HTTP Alarm Receiving Host
Management.
5 User Management
5.1 Introduction to the Function
When the device is activated, you can log in to it via the admin account and corresponding password, and manage users
as needed, including:
1. Change the password of an admin account. The user name cannot be edited.
2. Add, edit, and delete other users, including the user type, password, user name, and so on. A Non-admin user can
log in to and operate the device after being created.
Note:
1. The common user types:
Administrator (admin): has the permission of accessing all resources supported by the device, and can operate
all functions of the device. The admin account cannot be deleted.
Operator (operator): has the permission to view. Their operation permissions are assigned by admin.
Operator accounts are created by the administrator only.
User (viewer): has the permission to view only. They have no operation permission. User accounts are created
by the administrator only.
2. User password:
To ensure the security of account information, it is recommended to create a password using eight to sixteen
characters, including at least two kinds of the following categories: digits, lower case letters, upper case letters,
and special characters, and the user name is not allowed in the password.
Risky passwords include the following categories: less than 8 characters, containing only one type of
characters, same as the user name or reversed user name. To protect user data privacy and improve security,
it is recommended to use a strong password.
The password strength rule is as follows:


a. Strong password: including at least three kinds of the categories (digits, lower case letters, upper case
letters, and special characters).
b. Medium password: a combination of digits and special characters, or lower case letters and special
characters, or upper case letters and special characters, or lower case letters and upper case letters.
c. Weak password: a combination of digits and lower case letters or digits and upper case letters.
5.2 API Calling Flow
1. Get the user management capability of devices on the client software: GET
/ISAPI/Security/users/<indexID>/capabilities.
2. Add device users on the client software: POST /ISAPI/Security/users?security=<security>&iv=<iv>.
Remarks:
Only admin can create other types of users, and creating users requires login password verification
(<loginPassword>) of admin.
If the user account is inactivated, it's required to log in to the account and change the user password (PUT
/ISAPI/Security/users/<indexID>?security=<security>&iv=<iv>). The account is activated when the
password is changed.
When the account is inactivated, it's not allowed to perform any operations except changing the user
password. Otherwise, an error (0x0020000f) will be returned.
3. Edit the user information on the client software: PUT /ISAPI/Security/users/<indexID>?security=
<security>&iv=<iv>.
Remarks:
It requires login password verification of admin when admin changes the user password. The account turns
inactivated when the user password is changed by admin. Once logging out, the user needs to change the
password first for the next login.
When non-admin users changed their passwords, the account remains activated.
4. Delete users on the client software: DELETE /ISAPI/Security/users?loginPassword=<loginPassword>&security=
<security>&iv=<iv>.
Remarks:
Only admin can delete users, and deleting users requires login password verification of admin.
5. Get the user information, including user name, activation status (<userActivationStatus>), and so on.
Get a single user information: GET /ISAPI/Security/users/<indexID>?security=<security>&iv=<iv>.
Get the information about all users: GET /ISAPI/Security/users?security=<security>&iv=<iv>.
Get the information about online users: GET /ISAPI/Security/onlineUser. Online users refer to users who logged
in to the device. The information such as user name, user type, and IP address can be obtained.
Remarks:
If multiple attempts of admin login password verification failed in the process of adding, editing, or deleting users,
the admin will be locked. The remaining attempts are defined by the field retryTimes in the response message.
The new password cannot be the same as the last password. Otherwise, an error (0x400010E8) will be returned.
5.3 Exception Handling
Error Code


statusCode statusString subStatusCode
4
Invalid
Operation
errorCode errorMsg
cannotSameAsOldPassword 0x400010E8
New
password
cannot be the
same as the
old one.
4
4
Invalid
Operation
Invalid
Operation
6
Invalid
Content
theAccountIsNotActivated
loginPasswordError
0x0020000f
0x4000000C
The account
is not
activated.
Incorrect
login
password.
administratorPasswordError 0x60000042
Incorrect
administrator
password.
6 EZVIZ Access Services
6.1 Introduction to the Function
Configure EZVIZ access service parameters, including whether to enable EZVIZ services, the server address, and the
verification code, etc.
6.2 API Calling Flow
1. Get the capability of configuring EZVIZ access services: GET /ISAPI/System/Network/EZVIZ/capabilities.
2. Get the parameters of EZVIZ access service: GET /ISAPI/System/Network/EZVIZ?security=<security>&iv=<iv>.
3. Set the parameters of EZVIZ access service: PUT /ISAPI/System/Network/EZVIZ?security=<security>&iv=<iv>.
Note: The verification code is used when device are added to the EZVIZ App. It can also be used as the stream
encryption key.
7 EZVIZ Storage Configuration
7.1 Introduction to the Function
Devices can access the EZVIZ storage services based on the configured parameters.
Note:
1. The storage services are based on the access services. After registration, the access services will be automatically
connected to the storage services. Therefore, configuring the service address for the cloud services is not required.
2. Here we only configure the parameters for videos related to events. You can configure the parameters for pictures
to be uploaded during alarm subscription (via pictureURLType in /ISAPI/Event/notification/subscribeEvent)
and alarm receiving in arming mode.
Description
New password
cannot be the
same as the old
one. Please
change the
password and try
again.
The account is not
activated.
Incorrect login
password.
Please enter the
correct password.
If you forgot the
password, you can
reset the
password.
Remarks


7.2 API Calling Flow
1. Get the capability of configuring EZVIZ access services: GET /ISAPI/System/Network/EZVIZ/capabilities. If
isSupportEZVIZCloud exists and its value is "true", it indicates that this function is supported.
2. Get the capability of configuring EZVIZ storage services: GET
/ISAPI/System/Network/EZVIZ/cloudStorage/capabilities?format=json.
3. (Optional) Configure the channel's encoding parameters according to the capability returned in the previous step.
4. (Optional) Get the parameters of EZVIZ storage service: GET /ISAPI/System/Network/EZVIZ/cloudStorage?
format=json.
5. Configure the parameters of EZVIZ storage service: PUT /ISAPI/System/Network/EZVIZ/cloudStorage?
format=json.
6. Configuring the parameters of EZVIZ storage service is not supported currently.
Note: When the device uploads videos to EZVIZ, stream of 5-second video to be uploaded will be retained in the cache
of the device, which may affect its performance. You can configure the encoding parameters to improve the fluency of
the video. Otherwise, the stream to be uploaded may have shuttering frames.


8 Subscribe to Videos Related to Events
8.1 Introduction to the Function
Supports subscribing to videos (to be uploaded) related to specific events (by channel or by event).
Scenario: Storage can be saved if only videos related to specific events are required. And for the same storage space,
more clients can be provided with storage services.
8.2 API Calling Flow
1. Get the capability of configuring EZVIZ access services: GET /ISAPI/System/Network/EZVIZ/capabilities. If
isSupportRecordsSubscribe or isSupportChannelRecordsSubscribe exists and the value is "true", it indicates that
this function is supported.
2. Get the capability of subscribing to the videos related to specific events: GET
/ISAPI/System/Network/EZVIZ/cloudStorage/recordsSubscribe/capabilities?format=json.
3. (Optional) Get the parameters of subscribing to the videos related to specific events: GET
/ISAPI/System/Network/EZVIZ/cloudStorage/recordsSubscribe?format=json.
4. Configure the parameters for subscribing to the videos related to specific events: PUT
/ISAPI/System/Network/EZVIZ/cloudStorage/recordsSubscribe?format=json.
5. Get the capability of subscribing to the videos related to specific events (a single channel): GET
/ISAPI/System/Network/EZVIZ/cloudStorage/recordsSubscribe/channels/<channelID>/capabilities?
format=json.
6. (Optional) Get the parameters of subscribing to the videos related to specific events: GET
/ISAPI/System/Network/EZVIZ/cloudStorage/recordsSubscribe/channels/<channelID>?format=json.
7. Configure the parameters for subscribing to the videos related to specific events (a single channel): PUT
/ISAPI/System/Network/EZVIZ/cloudStorage/recordsSubscribe/channels/<channelID>?format=json.


9 Check the Statistics of Videos Uploaded/to be Uploaded
9.1 Introduction to the Function
After subscribing to the videos related to specific events, users may be concerned with the number of videos that have
been uploaded or videos to be uploaded. Users can select the videos to be uploaded or check the network when
exception occurs.
9.2 API Calling Flow
1. Get the capability of configuring EZVIZ access services: GET /ISAPI/System/Network/EZVIZ/capabilities. If
isSupportRecordsSubscribeStatistics exists and its value is "true", it indicates that this function is supported.
2. Get the capability of checking the statistics of videos: GET
/ISAPI/System/Network/EZVIZ/cloudStorage/recordsSubscribe/statistics/capabilities?format=json.
3. Get the statistics of videos: POST /ISAPI/System/Network/EZVIZ/cloudStorage/recordsSubscribe/statistics?
format=json.
10 Listening Service
10.1 Introduction to the Function
When an event occurs, the device creates connection with the client and uploads alarm information. Meanwhile, the
listening host receives data from the device. The IP address and the port No. of the listening host should be configured
for the device. The HTTP listening service supports subscribing to specific events when adding or editing the listening
host. Only the specified events will be uploaded by the device.(currently not available for the device)
10.2 API Calling Flow
10.2.1 Listening Service


1. Check whether the device supports configuring listening host parameters:
Get the configuration capability of the listening host: GET /ISAPI/Event/notification/httpHosts/capabilities.
If the node <HttpHostNotificationCap> exists in the returned message and its value is true, it indicates that the
device supports configuring listening host parameters.
2. Configure the parameters of the listening host:
Configure the parameters of all listening hosts: PUT /ISAPI/Event/notification/httpHosts?security=
<security>&iv=<iv>;
Get the parameters of all listening hosts: GET /ISAPI/Event/notification/httpHosts?security=<security>&iv=
<iv>;
Configure the parameters of a listening host: PUT /ISAPI/Event/notification/httpHosts/<hostID>?security=
<security>&iv=<iv>;
Get the parameters of a listening host: GET /ISAPI/Event/notification/httpHosts/<hostID>?security=
<security>&iv=<iv>;
3. Enable the listening service:
The user needs to enable the listening service of the listening host.
4. (Optional) Test the listening service:


4. (Optional) Test the listening service:
The platform applies the command to the device to test whether the listening host is available for the device: POST
/ISAPI/Event/notification/httpHosts/<hostID>/test.
5. The listening host receives event information from the device:
When an event occurs, the device creates connection with the client and uploads alarm information. Meanwhile,
the listening host receives data from the device. See details in Event Message Grammar.
Remark: You can also configure the listening parameters such as the timeout.
10.2.2 Event Message Grammar
1. Without Binary Data:
When an event occurs or an alarm is triggered, the event/alarm information can be with binary data (such as pictures)
and without binary data.
The Content-Type in the Headers of the HTTP request sent by the device is usually application/xml or
application/json as follows:
Alarm Message Sent by the Device
POST Request_URI HTTP/1.1 <!--/Request_URI, related URI: POST /ISAPI/Event/notification/httpHosts-->
Host: data_gateway_ip:port <!--Host: HTTP server's domain name / IP address and port No., related URI: POST /ISAPI/Event/notification/httpHosts-->
Accept-Language: zh-cn
Date: YourDate
Content-Type: application/xml; <!--content type, which is used for the upper layer to distinguish different formats when parsing the message-->
Content-Length: text_length
Connection: keep-alive <!--maintain the connection between the device and the server for better transmission performance-->
<EventNotificationAlert/>
Response by the Listening Host
HTTP/1.1 200 OK
Date: YourDate
Connection: close
2. With Binary Data
The format of the data sent by the device is HTTP form (multipart/form-data). The Content-Type in the Headers of the
HTTP request sent by the device is usually multipart/form-data, boundary=<frontier>: boundary is a variable, which
is used to divide the HTTP Body into multiple units and each unit has its Headers and Body. See details in RFC 1867
(Form-based File Upload in HTML). Please note the -- before and after the boundary.
Alarm Message Sent by the Device
POST Request_URI HTTP/1.1 <!--Request_URI, related URI: POST /ISAPI/Event/notification/httpHosts-->
Host: device_ip:port <!--Host: HTTP server's domain name / IP address and port No., related URI: POST /ISAPI/Event/notification/httpHosts-->
Accept-Language: zh-cn
Date: YourDate
Content-Type: multipart/form-data;boundary=<frontier>
Content-Length: text_length
Connection: keep-alive <!--maintain the connection between the device and the server for better transmission performance-->
--<frontier>
Content-Disposition: form-data; name="Event_Type"
Content-Type: text/xml <!--maintain the connection between the device and the server for better transmission performance-->
<EventNotificationAlert/>
--<frontier>
Content-Disposition: form-data; name="Picture_Name"
Content-Length: image_length
Content-Type: image/jpeg
[picture data]
--<frontier>-
Response by the Listening Host


HTTP/1.1 200 OK
Date: YourDate
Connection: close
Here are the descriptions of the main keywords.
keyword
example
description
Content-Type
boundary
ContentDisposition
filename
ContentLength
multipart/form-data;
boundary=frontier
frontier
form-data;
name="Picture_Name";
"Picture_Name"
10
10.3
Exception Handling
10.3.1 Error Codes
statusCode statusString subStatusCode errorCode errorMsg Description
6
Invalid
Content
eventNotSupport 0x60001024
11 Device Upgrade
11.1 Introduction to the Function
The platform or client software or web client under the LAN upgrades devices via ISAPI.
The sequence diagram of upgrading devices by the platform is shown below.
11.2 API Calling Flow
Event subscription is not
supported.
Remarks
Content type, multipart/form-data refers to data in form format.
Separator of the form message. A form message starts with --boundary
and ends with --boundary--.
Content description. form-data refers to data in the form format.
File name. The file refers to the form message.
Content length. The length of the content which starts from \r\n to the
next --boundary.


1. Upgrade devices.
Upgrade the device firmware: POST /ISAPI/System/updateFirmware.
2. Get the device upgrade progress.
Get the device upgrade progress: GET /ISAPI/System/upgradeStatus.
3. Reboot devices.
Reboot devices: PUT /ISAPI/System/reboot.
12 Device Peripherals Upgrade
12.1 Introduction to the Function
The platform or client software or web client under the LAN upgrades device peripherals via ISAPI.
The sequence diagram of upgrading device peripherals by the platform is shown below.
12.2 API Calling Flow


1. Get the device system capability GET /ISAPI/System/capabilities and check whether the device supports
upgrading peripherals. If the field isSupportAcsUpdate is returned and its value is true, it indicates that the device
supports this function, otherwise, the device does not support this function.
2. Get the capability of upgrading the peripherals module GET /ISAPI/System/AcsUpdate/capabilities, and get the
types and IDs of peripherals that support upgrading.
3. The platform sends the upgrade command POST /ISAPI/System/updateFirmware?type=<type>&moduleAddress=
<moduleAddress>&id=<indexID>. In the URL type refers to the peripheral type, moduleAddress refers to the
peripheral module address, and indexID refers to the ID of peripheral to be upgraded. The platform will apply the
upgrade peripheral package to the device.
4. Get the peripheral upgrade progress GET /ISAPI/System/upgradeStatus?type=<Type>.
5. Log in to the device again.
6. Get the peripheral latest version information.
13 Person and Credential Management
13.1 Introduction to the Function
The person and credential management function is person-based, and is for managing persons, credentials (cards,
fingerprints, face pictures, and iris data), and permission schedules which control the permissions for persons to enter
and exit the controlled areas. Its architecture is shown below.


This document mainly introduces the calling flows for person management and credential management (card,
fingerprint, face picture, iris data management). For details about the calling flow for permission schedule management,
refer to the “Management of Permission Schedules for Persons and Access Points”.
14 Person Management
14.1 Introduction to the Function
Person management includes searching, applying, adding, editing, and deleting persons.
14.2 API Calling Flow
14.2.1 Check Whether the Device Supports Person Management


Before calling the API for person management, make sure that the device supports person management.
1. Check whether the device supports person management: GET /ISAPI/AccessControl/capabilities; if the node
isSupportUserInfo is returned and its value is true, it indicates that the device supports person management.
2. Search, apply, add, and edit persons.
3. If the node isSupportUserInfo is returned and its value is false, it indicates that the device does not support person
management.
Note:
The person ID (EmployeeNo) is the unique identifier for person and credential management. After calling GET
/ISAPI/AccessControl/capabilities, through the child nodes of EmployeeNoInfo which are employeeNo,
characterType, and isSupportCompress, the maximum string length and character types of the person ID supported by
the device can be checked. Generally, devices support up to 32 bytes and any type of characters. But for access
controllers and distribution-type access control devices, check through the child nodes mentioned above.
14.2.2 Person Search


The person search function is for searching the number of persons and person information added to the
device.
1. Check whether the device supports person search: GET /ISAPI/AccessControl/UserInfo/capabilities?
format=json; if the value of the node supportFunction contains “get”, it indicates that the device supports person
search.


2. Search the number of persons: GET /ISAPI/AccessControl/UserInfo/Count?format=json; the returned value of
the node userNumber is the number of the persons added to the device.
3. Search person information: POST /ISAPI/AccessControl/UserInfo/Search?format=json; the person information
is returned by page.
4. If the value of the node supportFunction does not contain “get”, it indicates that the device does not support
person search.
Note:
The value of the node maxRecordNum returned by calling GET /ISAPI/AccessControl/UserInfo/capabilities?
format=json is the maximum number of persons supported by the device.
14.2.3 Person Applying
Person information can be applied to the device via the person applying function. If the person has been
added to the device, the person information will be edited; if the person has not been added to the device,
the person information will be applied to the device.
1. Check whether the device supports person applying: GET /ISAPI/AccessControl/UserInfo/capabilities?


format=json; if the value of the node supportFunction contains “setUp”, it indicates that the device supports
person applying.
2. Apply person information: PUT /ISAPI/AccessControl/UserInfo/SetUp?format=json.
3. If the value of the node supportFunction does not contain setUp, it indicates that the device does not support
person applying.
Note:
Check whether the person has been added to the device via the node employeeNo returned after calling the API for
person applying.
14.2.4 Person Adding
Person can be added to the device via the person adding function. If the person has been added to the
device, the device will report an error; if the person has not been added to the device, the person will be
added to the device.


1. Check whether the device supports person adding: GET /ISAPI/AccessControl/UserInfo/capabilities?
format=json; if the value of the node supportFunction contains “post”, it indicates that the device supports person
adding.
2. Add persons: POST /ISAPI/AccessControl/UserInfo/Record?format=json.
3. If the value of the node supportFunction does not contain “post”, it indicates that the device does not support
person adding.
Note:
Check whether the person has been added to the device via the node employeeNo returned after calling the API for
person adding.
14.2.5 Person Information Editing


Person information added to the device can be edited via the person information editing function. If the
person has been added to the device, the person information will be edited; if the person has not been
added to the device, the device will report an error.
1. Check whether the device supports person information editing: GET
/ISAPI/AccessControl/UserInfo/capabilities?format=json; if the value of the node supportFunction contains
“put”, it indicates that the device supports person information editing.
2. Edit Person Information: PUT /ISAPI/AccessControl/UserInfo/Modify?format=json.
3. If the value of the node supportFunction does not contain “put”, it indicates that the device does not support
person information editing.
Note:
Check whether the person has been added to the device via the node employeeNo returned after calling the API for
person information editing.
14.2.6 Person Deleting


The person added to the device can be deleted via the person deleting function. The device will not report
an error if the person to be deleted is not added to the device.
1. Check whether the device supports person deleting: GET /ISAPI/AccessControl/capabilities; if the node
isSupportUserInfoDetailDelete is returned and its value is “true”, it indicates that the device supports person
deleting.
2. Delete persons: PUT /ISAPI/AccessControl/UserInfoDetail/Delete?format=json; if calling succeeded, it
indicates that the device has started to execute person deleting, but it does not indicate that the device has deleted
the person.
3. Get the progress of deleting person information: GET /ISAPI/AccessControl/UserInfoDetail/DeleteProcess;
repeatedly call this API to get the progress of person deleting.
4. If the node isSupportUserInfoDetailDelete is returned and its value is “false”, it indicates that the device does not


support person deleting.
Note:
When the person is deleted, the information on the credentials (the card, fingerprint, face picture, and iris data) linked
via the person ID will also be deleted.
15 Card Management
15.1 Introduction to the Function
Card management includes searching, applying, adding, editing, deleting, and collecting cards.
15.2 API Calling Flow
15.2.1 Check Whether the Device Supports Card Management
Before calling the API for card management, make sure that the device supports card management.
1. Check whether the device supports card management: GET /ISAPI/AccessControl/capabilities; if the node
isSupportCardInfo is returned and its value is “true”, it indicates that the device supports card management.
2. Search, apply, add, edit, and delete cards.
3. If the node isSupportCardInfo is returned and its value is “false”, it indicates that the device does not support card
management.


Note:
Before applying, adding, or editing cards on the device, make sure that the related person information linked to the
person ID has been applied to the device.
The value of the node numberPerPerson returned by calling GET
/ISAPI/AccessControl/CardInfo/capabilities?format=json is the maximum number of cards supported per
person. If the value returned is 255, it indicates that the number of cards per person is unlimited. If the node is not
returned, it indicates that the maximum number of cards can be applied is 5.
Manage cards of different card number lengths by calling [GET/PUT]
/ISAPI/AccessControl/CardVerificationRule?format=json.
15.2.2 Card Search


The card search function is for searching the number of cards and card information applied to the device.


1. Check whether the device supports card search: GET /ISAPI/AccessControl/CardInfo/capabilities?
format=json; if the value of the node supportFunction contains “get”, it indicates that the device supports card
search.
2. Search the number of specified persons’ cards: GET /ISAPI/AccessControl/CardInfo/Count?
format=json&employeeNo=<employeeNo>; the returned value of the node cardNumber is the number of the cards
added to the specified persons.
3. Search the number of all persons’ cards: GET /ISAPI/AccessControl/CardInfo/Count?format=json; the returned
value of the node cardNumber is the number of the cards added to all persons.
4. Search card information: POST /ISAPI/AccessControl/CardInfo/Search?format=json; the card information is
returned by page.
5. If the value of the node supportFunction does not contain “get”, it indicates that the device does not support card
search.
Note:
The value of the node maxRecordNum returned by calling GET /ISAPI/AccessControl/CardInfo/capabilities?
format=json is the maximum number of cards supported by the device.
15.2.3 Card Applying


Card information can be applied to the device via the card applying function. If the card has been added to
the device, the card information will be edited; if the card has not been added to the device, the card
information will be added to the device.
1. Check whether the device supports card applying: GET /ISAPI/AccessControl/CardInfo/capabilities?
format=json; if the value of the node supportFunction contains “setUp”, it indicates that the device supports card
applying.
2. Apply card information: PUT /ISAPI/AccessControl/CardInfo/SetUp?format=json.
3. If the value of the node supportFunction does not contain “setUp”, it indicates that the device does not support
card applying.
Note:
Check whether the card has been added to the device via the node cardNo returned after calling the API for card
applying.
15.2.4 Card Adding


Card information can be added to the device via the card adding function. If the card has been added to the
device, the device will report an error; if the card has not been added to the device, the card information will
be added to the device.
1. Check whether the device supports card adding: GET /ISAPI/AccessControl/CardInfo/capabilities?
format=json; if the value of the node supportFunction contains “post”, it indicates that the device supports card
adding.
2. Add card information: POST /ISAPI/AccessControl/CardInfo/Record?format=json.
3. If the value of the node supportFunction does not contain “post”, it indicates that the device does not support card
adding.
Note:
Check whether the card has been added to the device via the node cardNo returned after calling the API for card
adding.
15.2.5 Card Information Editing


Card information on the device can be edited via the card information editing function. If the card has been
added to the device, the card information will be edited; if the card has not been added to the device, the
device will report an error.
1. Check whether the device supports card information editing: GET
/ISAPI/AccessControl/CardInfo/capabilities?format=json; if the value of the node supportFunction contains
“put”, it indicates that the device supports card information editing.
2. Edit card information: PUT /ISAPI/AccessControl/CardInfo/Modify?format=json.
3. If the value of the node supportFunction does not contain “put”, it indicates that the device does not support card
information editing.
Note:
Check whether the card has been added to the device via the node cardNo returned after calling the API for card
information editing.


15.2.6 Card Deleting
The card information on the device can be deleted via the card deleting function. The device will not report
an error if the card information to be deleted is not added to the device.
1. Check whether the device supports card deleting: GET /ISAPI/AccessControl/CardInfo/capabilities?
format=json; if the value of the node supportFunction contains “delete”, it indicates that the device supports card
deleting.
2. Delete cards: PUT /ISAPI/AccessControl/CardInfo/Delete?format=json; if calling succeeded, it indicates that the
device has deleted the cards.
3. If the value of the node supportFunction does not contain “delete”, it indicates that the device does not support
card deleting.
15.2.7 Card Collecting


The card collecting function is for collecting the card No., card type, etc.
1. Check whether the device supports card collecting: GET /ISAPI/AccessControl/capabilities; if the node
isSupportCaptureCardInfo is returned and its value is “true”, it indicates that the device supports card collecting.
2. Collect card information: GET /ISAPI/AccessControl/CaptureCardInfo?format=json.
3. If the node isSupportCaptureCardInfo is returned and its value is “false”, it indicates that the device does not
support card collecting.
16 Fingerprint Management
16.1 Introduction to the Function
Fingerprint management includes searching, applying, deleting, and collecting fingerprints.
16.2 API Calling Flow


16.2.1 Check Whether the Device Supports Fingerprint Management
Before calling the API for fingerprint management, make sure that the device supports fingerprint
management.
1. Check whether the device supports fingerprint management: GET /ISAPI/AccessControl/capabilities; if the
node isSupportFingerPrintCfg is returned and its value is “true”, it indicates that the device supports fingerprint
management.
2. Search, apply, add, and edit fingerprints.
3. If the node isSupportFingerPrintCfg is returned and its value is “false”, it indicates that the device does not support
fingerprint management.
Note:
Before applying the fingerprint information to the device, make sure that the related person information linked to
the person ID has been applied to the device.
The maximum number of fingerprints that can be applied to the device per person is 10 (the 10 fingerprints of a
person).


16.2.2 Fingerprint Search


The fingerprint search function is for searching the number of fingerprints and fingerprint information
added to the device.
1. Check whether the device supports fingerprint search: GET
/ISAPI/AccessControl/FingerPrintCfg/capabilities?format=json; if calling succeeded, it indicates that the
device supports fingerprint search.
2. Search the number of the specified persons’ fingerprints: GET /ISAPI/AccessControl/FingerPrint/Count?
format=json&employeeNo=<employeeNo>; the returned value of the node numberOfFP is the number of the added
fingerprints of the specified persons.
3. Search the number of fingerprints of all persons: GET /ISAPI/AccessControl/FingerPrint/Count?format=json;
the returned value of the node numberOfFP is the number of the added fingerprints of all persons.
4. Search fingerprint information: POST /ISAPI/AccessControl/FingerPrintUpload?format=json; the fingerprint
information is returned by page. If the value of the child node status of the node FingerPrintInfo is “NoFP”, it
indicates that all fingerprint information are returned.
5. If calling failed, it indicates that the device does not support fingerprint search.
Note:
The value of the node fingerPrintCapacity returned by calling GET
/ISAPI/AccessControl/CardReaderCfg/<cardReaderID>?format=json is the maximum number of fingerprints
supported by the card reader.
The value of the node fingerPrintNum returned by calling GET
/ISAPI/AccessControl/CardReaderCfg/<cardReaderID>?format=json is the number of fingerprints added to the
card reader.
16.2.3 Fingerprint Applying


Fingerprint information can be applied to the device via the fingerprint applying function. If the fingerprint
has been added to the device, the fingerprint information will be edited; if the fingerprint has not been
added to the device, the fingerprint will be added to the device.
1. Check whether the device supports fingerprint applying: GET
/ISAPI/AccessControl/FingerPrintCfg/capabilities?format=json; if the node isSupportSetUp is returned and
its value is “true”, it indicates that the device supports fingerprint applying.
2. Apply fingerprint information: POST /ISAPI/AccessControl/FingerPrint/SetUp?format=json.
3. If the node isSupportSetUp is returned and its value is false, it indicates that the device does not support
fingerprint applying.
Note:
Check whether the fingerprint has been added to the device via the nodes employeeNo and fingerPrintID returned after
calling the API for fingerprint applying.
16.2.4 Fingerprint Adding


Fingerprint information can be added to the device via the fingerprint adding function. If the fingerprint has
been added to the device, the device will report an error; if the fingerprint has not been added to the device,
the fingerprint will be added to the device.
1. Check whether the device supports fingerprint adding: GET
/ISAPI/AccessControl/FingerPrintCfg/capabilities?format=json; if calling succeeded, it indicates that the
device supports fingerprint adding.
2. Add fingerprint information: POST /ISAPI/AccessControl/FingerPrintDownload?format=json; if calling
succeeded, it indicates that the device has started to execute fingerprint adding, but it does not indicate that the
device has added the fingerprint.
3. Get the progress of fingerprint adding: GET /ISAPI/AccessControl/FingerPrintProgress?format=json;
repeatedly call this API to get the progress of fingerprint adding.


4. If calling failed, it indicates that the device does not support fingerprint adding.
Note:
Check whether the fingerprint has been added to the device via the nodes employeeNo and fingerPrintID returned after
calling the API for fingerprint adding.
16.2.5 Fingerprint Information Editing
The fingerprint information on the device can be edited via the fingerprint information editing function. If
the fingerprint has been added to the device, the fingerprint information will be edited; if the fingerprint
has not been added to the device, the device will report an error.
1. Check whether the device supports fingerprint information editing: GET
/ISAPI/AccessControl/FingerPrintCfg/capabilities?format=json; if calling succeeded, it indicates that the
device supports fingerprint information editing.
2. Edit fingerprint information: POST /ISAPI/AccessControl/FingerPrintModify?format=json.
3. If calling failed, it indicates that the device does not support fingerprint information editing.
Note:


Check whether the fingerprint has been added to the device via the nodes employeeNo and fingerPrintID returned
after calling the API for fingerprint information editing.
When the fingerprint information is edited, only the fingerprint parameters will be edited; the fingerprint data will
not be edited.
16.2.6 Fingerprint Deleting


The fingerprint information on the device can be deleted via the fingerprint deleting function. The device
will not report an error if the fingerprint information to be deleted is not added to the device.
1. Check whether the device supports fingerprint deleting: GET /ISAPI/AccessControl/capabilities; if the node
isSupportFingerPrintDelete is returned and its value is “true”, it indicates that the device supports fingerprint
deleting.


2. Delete fingerprint information: PUT /ISAPI/AccessControl/FingerPrint/Delete?format=json; if calling
succeeded, it indicates that the device has started to execute fingerprint deleting, but it does not indicate that the
device has deleted the fingerprints.
3. Get the progress of fingerprint deleting: GET /ISAPI/AccessControl/FingerPrint/DeleteProcess?format=json;
repeatedly call this API to get the progress of fingerprint deleting.
4. If the node isSupportFingerPrintDelete is returned and its value is “false”, it indicates that the device does not
support fingerprint deleting.
16.2.7 Fingerprint Collecting
The fingerprint collecting function is for collecting the fingerprint data, fingerprint quality, etc.
1. Check whether the device supports fingerprint collecting: GET /ISAPI/AccessControl/capabilities; if the node
isSupportCaptureFingerPrint is returned and its value is “true”, it indicates that the device supports fingerprint
collecting.
2. Collect fingerprint information: POST /ISAPI/AccessControl/CaptureFingerPrint.
3. If the node isSupportCaptureFingerPrint is returned and its value is “false”, it indicates that the device does not
support fingerprint collecting.


17 Face Picture Management
17.1 Introduction to the Function
Face picture management includes searching, applying, adding, editing, deleting, and collecting face pictures.
17.2 API Calling Flow
17.2.1 Check Whether the Device Supports Face Picture Management
Before calling the API for face picture management, make sure that the device supports face picture
management.
1. Check whether the device supports face picture management: GET /ISAPI/AccessControl/capabilities; if the
node isSupportFDLib is returned and its value is “true”, it indicates that the device supports face picture
management.
2. Search, apply, add, edit, and delete face pictures.
3. If the node isSupportFDLib is returned and its value is “false”, it indicates that the device does not support face
picture management.
Note:
Before applying, adding, or editing face picture information on the device, make sure that the related person


information linked to the person ID has been applied to the device, and make sure that the device has its face
picture library by calling GET /ISAPI/Intelligent/FDLib?format=json (if the device has no face picture library,
then create the face picture library by calling POST /ISAPI/Intelligent/FDLib?format=json), and the ID of the
library of face pictures captured in visible light (FDID) is 1.
If the value of the node mode returned by calling GET /ISAPI/AccessControl/FaceRecognizeMode/capabilities?
format=json contains “deepMode”, it indicates that the device supports the deep mode, which compares face
pictures captured in infrared light. For devices which support the deep mode, if the face picture library ID (FDID) is
2, face pictures captured in infrared light will be applied to the face picture library and be used for face picture
comparison; if the face picture library ID (FDID) is 1, face pictures captured in visible light will be applied to the face
picture library and be displayed on the device.
Switch between the deep mode and normal mode: [GET/PUT] /ISAPI/AccessControl/FaceRecognizeMode?
format=json; the modes can be switched via the node mode.
17.2.2 Face Picture Search


The face picture search function is for searching the number of face pictures and face picture information
added to the device.
1. Check whether the device supports face picture search: GET /ISAPI/Intelligent/FDLib/capabilities?
format=json; if the value of the node supportFunction contains “get”, it indicates that the device supports face
picture search.
2. Search the number of face pictures in the specified face picture libraries: GET /ISAPI/Intelligent/FDLib/Count?
format=json&FDID=<FDID>&faceLibType=<faceLibType>; the returned value of the node recordDataNumber is the
number of the added face pictures of the specified face picture libraries.
3. Search the number of face pictures in all face picture libraries: GET /ISAPI/Intelligent/FDLib/Count?
format=json; the returned value of the node recordDataNumber is the number of face pictures in all face picture
libraries.
4. Search face picture information: POST /ISAPI/Intelligent/FDLib/FDSearch?format=json; the face picture
information is returned by page.
5. If the value of the node supportFunction does not contain “get”, it indicates that the device does not support face
picture search.
Note:
The value of the node FDRecordDataMaxNum returned by calling GET /ISAPI/Intelligent/FDLib/capabilities?
format=json is the maximum number of face pictures supported by the device.
17.2.3 Face Picture Applying


Face picture information can be applied to the device via the face picture applying function. If the face
picture has been added to the device, the face picture information will be edited; if the face picture has not
been added to the device, the face picture information will be added to the device.
1. Check whether the device supports face picture applying: GET /ISAPI/Intelligent/FDLib/capabilities?
format=json; if the value of the node supportFunction contains “setUp”, it indicates that the device supports face
picture applying.
2. Apply face picture information: PUT /ISAPI/Intelligent/FDLib/FDSetUp?format=json.
3. If the value of the node supportFunction does not contain “setUp”, it indicates that the device does not support face
picture applying.
Note:
Check whether the face picture has been added to the device via the node FPID returned by calling the API for face
picture applying, and link the face picture to the person information via the node FPID in face picture management and
the node employeeNo in person management.
17.2.4 Face Picture Adding


Face picture information can be added to the device via the face picture adding function. If the face picture
has been added to the device, the device will report an error; if the face picture has not been added to the
device, the face picture information will be added to the device.
1. Check whether the device supports face picture adding: GET /ISAPI/Intelligent/FDLib/capabilities?
format=json; if the value of the node supportFunction contains “post”, it indicates that the device supports face
picture adding.
2. Add face picture information: POST /ISAPI/Intelligent/FDLib/FaceDataRecord?format=json.
3. If the value of the node supportFunction does not contain “post”, it indicates that the device does not support face
picture adding.
Note:
Check whether the face picture has been added to the device via the node FPID returned by calling the API for face
picture adding, and link the face picture to the person information via the node FPID in face picture management and
the node employeeNo in person management.
17.2.5 Face Picture Information Editing


Face picture information on the device can be edited via the face picture information editing function. If the
face picture has been added to the device, the face picture information will be edited; if the face picture has
not been added to the device, the device will report an error.
1. Check whether the device supports face picture information editing: GET
/ISAPI/Intelligent/FDLib/capabilities?format=json; if the value of the node supportFunction contains “put”,
it indicates that the device supports face picture information editing.
2. Edit face picture information: PUT /ISAPI/Intelligent/FDLib/FDModify?format=json.
3. If the value of the node supportFunction does not contain “put”, it indicates that the device does not support face
picture information editing.
Note:
Check whether the face picture has been added to the device via the node FPID returned by calling the API for face
picture information editing, and link the face picture to the person information via the node FPID in face picture
management and the node employeeNo in person management.


17.2.6 Face Picture Deleting
The face picture information on the device can be deleted via the face picture deleting function. The device
will not report an error if the face picture to be deleted is not added to the device.
1. Check whether the device supports face picture deleting: GET /ISAPI/Intelligent/FDLib/capabilities?
format=json; if the value of the node supportFunction contains “delete”, it indicates that the device supports face
picture deleting.
2. Delete face pictures: PUT /ISAPI/Intelligent/FDLib/FDSearch/Delete?format=json&FDID=<FDID>&faceLibType=
<FDType>; if calling succeeded, it indicates that the device has deleted the face pictures.
3. If the value of the node supportFunction does not contain “delete”, it indicates that the device does not support
face picture deleting.
Note:
All the face picture libraries and the face picture information in the libraries on the device can be deleted by calling
DELETE /ISAPI/Intelligent/FDLib?format=json.


17.2.7 Face Picture Collecting
Face picture data, face picture quality grades, etc., can be collected via the face picture collecting function.
1. Check whether the device supports face picture collecting: GET /ISAPI/AccessControl/capabilities; if the node
isSupportCaptureFace is returned and its value is “true”, it indicates that the device supports face picture (captured
in visible light) collecting. If the node isSupportCaptureInfraredFace is returned and its value is “true”, it indicates
that the device supports face picture (captured in infrared light) collecting.
2. Collect face picture information: POST /ISAPI/AccessControl/CaptureFaceData.
If the node captureProgress is returned, and the value is 100, it indicates that the face picture has been collected,
and the binary data or URL of the collected face picture will be parsed.


If the node captureProgress is returned and the value is 0, it indicates that the face picture has not been collected,
and you need to get the progress of face picture collecting.
3. Get the progress of face picture collecting: GET /ISAPI/AccessControl/CaptureFaceData/Progress; repeatedly
call this API to get the progress of face picture collecting.
Repeatedly call this API until the node captureProgress is returned and its value is 100, which indicates that the
face picture has been collected and the binary data and URL of the face picture will be parsed.
If the value of the node captureProgress is 0 and the value of the isCurRequestOver is true, which indicates that the
face picture collecting failed, stop calling the API.
4. If the node isSupportCaptureFace is returned and its value is “false”, it indicates that the device does not support
face picture collecting.
18 Iris Data Management
18.1 Introduction to the Function
Iris data management includes searching, applying, adding, editing, deleting, and collecting iris data.
18.2 API Calling Flow
18.2.1 Check Whether the Device Supports Iris Data Management


Before calling the API for iris data management, make sure that the device supports iris data management:
1. Check whether the device supports iris data management: GET /ISAPI/AccessControl/capabilities; if the node
isSupportIrisInfo is returned and its value is true, it indicates that the device supports iris data management.
2. Search, apply, add, edit, and delete iris data.
3. If the node isSupportIrisInfo is returned and its value is false, it indicates that the device does not support iris data
management.
Note:
Before applying, adding, and editing the iris data on the device, make sure that the related person information
linked to the person ID has been applied to the device.
Data for up to two irises of each person (two eyes of each person) can be applied to the device.
18.2.2 Iris Data Search


The iris data search function is for searching the number of irises and iris information added to the device.
1. Check whether the device supports iris data search: GET /ISAPI/AccessControl/IrisInfo/capabilities?
format=json; if the node supportFunction is returned, and the value contains “get”, it indicates that the device
supports iris data search.
2. Search the number of irises: GET /ISAPI/AccessControl/IrisInfo/count?format=json; the value of the node
IrisNumber is the number of added irises on the device.
3. Search iris information: POST /ISAPI/AccessControl/IrisInfo/search?format=json; the searched iris
information will be returned by page.


4. If the value of the node supportFunction does not contain “get”, it indicates that the device does not support iris
data search.
Note:
The value of the node maxRecordNum returned by calling GET /ISAPI/AccessControl/IrisInfo/capabilities?
format=json is the maximum number of irises supported by the device.
18.2.3 Iris Data Applying
The iris data applying function is for applying iris information to the device. If the iris data has already been
applied to the device, the information about the iris will be edited; if the iris data has not been applied to
the device, the iris information will be added to the device.
1. Check whether the device supports iris data applying: GET /ISAPI/AccessControl/IrisInfo/capabilities?
format=json; if the node supportFunction is returned and the value contains “setUp”, it indicates that the device
supports iris data applying.
2. Iris Data Applying: PUT /ISAPI/AccessControl/IrisInfo/setup?format=json.
3. If the value of the node supportFunction does not contain “setUp”, it indicates that the device does not support iris


data applying.
Note:
Check whether the iris data have been applied to the device via the nodes employeeNo and id returned by calling the
API for iris data applying.
18.2.4 Iris Data Adding
The iris data adding function is for adding the iris data to the device. If the iris data have already been
added to the device, the device will report an error; if the iris data have not been added to the device, the
iris data will be added to the device.
1. Check whether the device supports iris data adding: GET /ISAPI/AccessControl/IrisInfo/capabilities?
format=json; if the value of the node supportFunction contains “post”, it indicates that the device supports iris data
applying.
2. Add iris data: POST /ISAPI/AccessControl/IrisInfo/record?format=json.
3. If the value of the node supportFunction does not contain “post”, it indicates that the device does not support iris
data applying.


Note:
Check whether the iris data have been applied to the device via the nodes employeeNo and id returned by calling the
API for iris data adding.
18.2.5 Iris Data Editing
The iris data editing function is for editing the applied iris information on the device. If the iris data have
already been added to the device, the iris information will be edited; if the iris data have not been added to
the device, the device will report an error.
1. Check whether the device supports iris data editing: GET /ISAPI/AccessControl/IrisInfo/capabilities?
format=json; if the value of the node supportFunction contains “put”, it indicates that the device supports iris data
editing.
2. Edit iris information: PUT /ISAPI/AccessControl/IrisInfo/modify?format=json.
3. If the value of the node supportFunction does not contain “put”, it indicates that the device does not support iris
data editing.
Note:


Check whether the iris data have been applied to the device via the nodes employeeNo and id returned by calling the
API for iris data editing.
18.2.6 Iris Data Deleting
The iris data deleting function is for deleting the applied iris information on the device. If the iris data to be
deleted have not been applied to the device, the device will not report an error.
1. Check whether the device supports iris data deleting: GET /ISAPI/AccessControl/IrisInfo/capabilities?
format=json; if the value of the node supportFunction contains “delete”, it indicates that the device supports iris
data deleting.
2. Delete iris information: PUT /ISAPI/AccessControl/IrisInfo/delete?format=json; if calling succeeded, it
indicates that the iris information has been deleted.
3. If the value of the node supportFunction does not contain “delete”, it indicates that the device does not support iris
data deleting.
18.2.7 Iris Data Collecting


The iris data collecting function is for collecting iris data and information.
1. Check whether the device supports iris data collecting: GET /ISAPI/AccessControl/capabilities; if the node
isSupportCaptureIrisData is returned and its value is “true”, it indicates that the device supports iris data collecting.
2. Collect iris information: POST /ISAPI/AccessControl/captureIrisData?format=json; if calling succeeded, it
indicates that the device has started to execute the collection.
3. Get the progress of iris data collecting: GET /ISAPI/AccessControl/captureIrisData/progress?format=json;
repeatedly call this API until the value of captureProgress is returned and is 100, which indicates that the collecting


completed.
4. If the node isSupportCaptureIrisData is returned and its value is “false”, it indicates that the device does not
support iris data collecting.
19 Holiday Schedule of Voice Prompt
19.1 Introduction to the Function
19.2 API Calling Flow
You can configure TTS texts or audio files of access authentication for holiday schedule.




ISAPI Protocol Calling Flow: 1.Check whether the device supports holiday schedule of voice prompt (get the
capability of access control): GET /ISAPI/AccessControl/capabilities?format=json; if the node
isSupportTTSTextHolidayPlan is returned and its value is "true", it indicates that the device supports holiday schedule
management of voice prompt; 2.Get the capability of holiday schedule parameters of voice prompt: GET
/ISAPI/AccessControl/Verification/ttsText/holidayPlan/capabilities?format=json; 3.Get holiday schedule of
voice prompt: GET /ISAPI/AccessControl/Verification/ttsText/holidayPlan/<holidayPlanID>?format=json;
configureholiday schedule of voice prompt: PUT
/ISAPI/AccessControl/Verification/ttsText/holidayPlan/<holidayPlanID>?format=json; delete holiday schedule
of voice prompt: DELETE /ISAPI/AccessControl/Verification/ttsText/holidayPlan/<holidayPlanID>?
format=json; 4.Check whether the device supports searching for holiday schedule of voice prompt (get the capability of
access control): GET /ISAPI/AccessControl/capabilities?format=json; if the node
isSupportTTSTextSearchHolidayPlan is returned and its value is "true", it indicates that the device supports searching for
holiday schedule parameters; 5.Get the capability of searching for holiday schedule parameters of voice prompt: GET
/ISAPI/AccessControl/Verification/ttsText/holidayPlan/capabilities?format=json; 6.Search for holiday
schedule of voice prompt: POST /ISAPI/AccessControl/Verification/ttsText/searchHolidayPlan?format=json;
20 Daily Schedule of Voice Prompt
20.1 Introduction to the Function
You can configure TTS texts or audio files of access authentication for daily schedule. The priority of holiday schedule is
higher than that of daily schedule. If the current day is in holiday schedule, voice prompt for holiday schedule will be
played; if the current day is not in holiday schedule, voice prompt for daily schedule will be played.
20.2 API Calling Flow


ISAPI Protocol Calling Flow: 1.Check whether the device supports daily schedule of voice prompt (get the capability
of access control): GET /ISAPI/AccessControl/capabilities?format=json; if the node isSupportTTSText is returned
and its value is "true", it indicates that the device supports daily schedule management of voice prompt; 2.Get the
capability of daily schedule parameters of voice prompt: GET
/ISAPI/AccessControl/Verification/ttsText/capabilities?format=json; 3.Get and configure daily schedule of
voice prompt: GET/PUT /ISAPI/AccessControl/Verification/ttsText?format=json;
21 API Reference
21.1 Device Basic Information Management
21.1.1 Set the device information parameters
Request URL
PUT /ISAPI/System/deviceInfo


Query Parameter
None
Request Message
<?xml version="1.0" encoding="UTF-8"?>
<DeviceInfo xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--ro, req, object, device information, attr:version{opt, string, protocolVersion}-->
<deviceName>
<!--req, string, device name, range:[1,128]-->test
</deviceName>
<deviceID>
<!--req, string, device No., range:[1,128]-->test
</deviceID>
<deviceDescription>
<!--opt, string, device description, range:[1,128]-->test
</deviceDescription>
<deviceLocation>
<!--opt, string, location, range:[1,128]-->hangzhou
</deviceLocation>
<deviceStatus>
<!--ro, opt, enum, device status, subType:string, desc:“normal”, “abnormal”-->normal
</deviceStatus>
<DetailAbnormalStatus>
<!--ro, opt, object, error status details,it is valid only when deviceStatus is "abnormal", desc:it is valid only when deviceStatus is abnormal-->
<hardDiskFull>
<!--ro, opt, bool, read-only,whether the error of "HDD full" occurred: "true"-yes,"false"-no-->true
</hardDiskFull>
<hardDiskError>
<!--ro, opt, bool, read-only,whether the error of "HDD error" occurred: "true"-yes,"false"-no-->true
</hardDiskError>
<ethernetBroken>
<!--ro, opt, bool, read-only,whether the error of "network disconnected" occurred: "true"-yes,"false"-no-->true
</ethernetBroken>
<ipaddrConflict>
<!--ro, opt, bool, IP address is conflicted.-->true
</ipaddrConflict>
<illegalAccess>
<!--ro, opt, bool, illegal access-->true
</illegalAccess>
<recordError>
<!--ro, opt, bool, read-only,whether the error of "recording exception" occurred: "true"-yes,"false"-no-->true
</recordError>
<raidLogicDiskError>
<!--ro, opt, bool, read-only,whether the error of "RAID exception" occurred: "true"-yes,"false"-no-->true
</raidLogicDiskError>
<spareWorkDeviceError>
<!--ro, opt, bool, read-only,whether the error of "working device exception" occurred: "true"-yes,"false"-no-->true
</spareWorkDeviceError>
</DetailAbnormalStatus>
<systemContact>
<!--ro, opt, string, contact information of the device, range:[1,32]-->STD-CGI
</systemContact>
<model>
<!--ro, req, string, device model, range:[1,64]-->iDS-9632NX-I8/X
</model>
<serialNumber>
<!--ro, req, string, device serial No., range:[1,48]-->iDS-9632NX-I8/X1620181209CCRRC77605411WCVU
</serialNumber>
<macAddress>
<!--ro, req, string, MAC Address, range:[1,64]-->44:47:cc:c8:d9:e4
</macAddress>
<firmwareVersion>
<!--ro, req, string, device firmware version, range:[1,64]-->V4.1.40
</firmwareVersion>
<firmwareReleasedDate>
<!--ro, opt, string, compile date of the device firmware version-->2019-11-01
</firmwareReleasedDate>
<encoderVersion>
<!--ro, opt, string, device encoder version No., range:[1,32]-->V7.3
</encoderVersion>
<encoderReleasedDate>
<!--ro, opt, string, compile date of the device encoder version-->2019-11-02
</encoderReleasedDate>
<bootVersion>
<!--ro, opt, string, boot version, range:[1,16]-->V1.3.4
</bootVersion>
<bootReleasedDate>
<!--ro, opt, string, release date of boot-->2019-11-03
</bootReleasedDate>
<panelVersion>
<!--ro, opt, string, panel version, range:[1,32]-->V1.0
</panelVersion>
<hardwareVersion>
<!--ro, opt, string, hardware version, range:[1,16]-->0x0
</hardwareVersion>
<decoderVersion>
<!--ro, opt, string, device decoder version, range:[1,32]-->V1.0
</decoderVersion>
<decoderReleasedDate>


<decoderReleasedDate>
<!--ro, opt, string, compile date of the device decoder version-->2019-01-01
</decoderReleasedDate>
<softwareVersion>
<!--ro, opt, string, read-only,software version, range:[1,32]-->V1.23
</softwareVersion>
<capacity>
<!--ro, opt, int, read-only,unit: MB,device capacity, range:[1,10240], desc:unit: MB-->1
</capacity>
<usedCapacity>
<!--ro, opt, int, read-only,unit: MB,capacity usage, range:[1,10240], desc:unit: MB-->1
</usedCapacity>
<deviceType>
<!--ro, req, enum, device type, subType:string, desc:“Blade”, “BladePS”, “CVR”, “DM”, “DMbehavior”, “DVR”, “DVS”, “DockStation”, “FA”, “FD”, “FS”,
“HAWK”, “HMCP”, “HybirdNVR”, “IPCamera”, “IPDome”, “IPZoom”, “InfoReleaseSys”, “InfoTerminal’， “MCU”， “NVR”, “PHA”, “PURE”, “RFID”, “SipServer”, “Switch”,
“lightFace”, “Visitor”, “PWA”, “PHAPro”, “ACS”, “VIS”, “FacePaymentTerminal”, “InteractiveTerminal”, “Cabinet”, “VoiceSpeaker”, “PowerAmplifier”,
“FireControlMatrix”, “PagingMicrophone”, “ElevatorControl”, “conferencePlat” (interactive tablet), “AIOT”, “OPCA”, “NetworkReceiver”, “PanicAlarmPanel”,
“bodyCamera”, “videoMatrix”, “EmbeddedCentralController”, “networkMic”, “IPA”, “PersonnelChannel”, “MediaComponentGateway”-->Blade
</deviceType>
<telecontrolID>
<!--opt, int, keyfob ID, range:[1,255]-->1
</telecontrolID>
<supportBeep>
<!--ro, opt, bool, whether to support buzzer-->true
</supportBeep>
<supportVideoLoss>
<!--ro, opt, bool, whether the device supports video loss-->true
</supportVideoLoss>
<firmwareVersionInfo>
<!--ro, opt, string, firmware version information, range:[1,32]-->test
</firmwareVersionInfo>
<actualFloorNum>
<!--ro, opt, int, actual number of floors,which is between 1 and 128, range:[1,128]-->1
</actualFloorNum>
<localZoneNum>
<!--ro, opt, int, number of zones (local), range:[0,16]-->1
</localZoneNum>
<alarmOutNum>
<!--ro, opt, int, number of alarm outputs, range:[0,16]-->1
</alarmOutNum>
<distanceResolution>
<!--ro, opt, float, distance resolution, range:[0.000,0.999]-->0.000
</distanceResolution>
<angleResolution>
<!--ro, opt, float, angle resolution, range:[0.000,0.999]-->0.000
</angleResolution>
<speedResolution>
<!--ro, opt, float, resolution of speed,unit: m/s, range:[0.000,0.999]-->0.000
</speedResolution>
<detectDistance>
<!--ro, opt, float, detection distance, range:[0.000,0.999]-->0.000
</detectDistance>
<relayNum>
<!--ro, opt, int, number of relays (local), range:[0,16]-->1
</relayNum>
<electroLockNum>
<!--ro, opt, int, number of locks (local), range:[0,16]-->1
</electroLockNum>
<sirenNum>
<!--ro, opt, int, number of sirens, range:[0,16]-->1
</sirenNum>
<alarmLamp>
<!--ro, opt, int, number of alarm lamps, range:[0,16]-->1
</alarmLamp>
<RS485Num>
<!--ro, opt, int, number of 485, range:[0,16]-->1
</RS485Num>
<radarVersion>
<!--ro, opt, string, radar version, range:[1,32]-->test
</radarVersion>
<cameraModuleVersion>
<!--ro, opt, string, camera modulo version, range:[1,32]-->test
</cameraModuleVersion>
<mainversion>
<!--ro, opt, int, main version No., range:[1,255]-->1
</mainversion>
<subversion>
<!--ro, opt, int, sub version No., range:[1,255]-->1
</subversion>
<upgradeversion>
<!--ro, opt, int, update version No., range:[1,255]-->1
</upgradeversion>
<customizeversion>
<!--ro, opt, int, custom version No., range:[1,255]-->1
</customizeversion>
<companyName>
<!--ro, opt, string, manufacturer name, range:[1,32]-->test
</companyName>
<copyright>
<!--ro, opt, string, version information, range:[1,32]-->test
</copyright>
<systemName>
<!--ro, opt, enum, storage system name, subType:string, desc:“storageManagement” (storage management system), “distributedStorageManagement”
(distributed storage management system)-->storageManagement


</systemName>
<systemStatus>
<!--ro, opt, enum, system status, subType:string, desc:“configured”, “unConfigured” (not configured)-->configured
</systemStatus>
<isLeaderDevice>
<!--ro, opt, bool, whether it is the corresponding device of the resource IP address-->true
</isLeaderDevice>
<clusterVersion>
<!--ro, opt, string, cluster version, range:[1,32], desc:it is valid when isLeaderDevice returns true-->test
</clusterVersion>
<manufacturer>
<!--ro, opt, enum, manufacturer information, subType:string, desc:it is used to distinguish OEM device. "hikvision” (Hikvision devices), "” (neutral
devices), “Hostone” (Hostone devices)-->hikvision
</manufacturer>
<centralStorageVersion>
<!--ro, opt, string, center storage version, range:[1,16]-->test
</centralStorageVersion>
<powerOnMode>
<!--ro, opt, enum, startup mode, subType:string, desc:“button” (press button to power on), “adapter” (connect adapter to power on)-->button
</powerOnMode>
<customizedInfo>
<!--ro, opt, string, custom project No., range:[1,32], desc:no value will be returned if it is baseline device. custom project No. will be returned if
is custom device-->test
</customizedInfo>
<verificationCode>
<!--ro, opt, string, device verification code-->test
</verificationCode>
<supportUrl>
<!--ro, opt, string, service portal-->test
</supportUrl>
<subSerialNumber>
<!--ro, opt, string, sub serial No.-->test
</subSerialNumber>
<languageType opt="chinese,english,spanish,portuguese,italian,french,russian,turkish,greek,czech,brazilianPortuguese">
<!--ro, opt, enum, language type, subType:string, attr:opt{req, string}, desc:“chinese”, “english”, “spanish”, “portuguese”, “italian”, “french”,
“russian”, “turkish”, “greek”, “czech”, “brazilianPortuguese”, “slovenian”, “swedish”, “norwegian”, “romanian”, “danish”, “german”, “polish”, “dutch”,
“hungarian”, “slovak”, “serbian”, “southAmericanSpanish”, “ukrainian”, “croatian”, “irish”, “bulgarian”, “hebrew”, “thai”, “indonesian”, “arabic”,
“traditionalChinese”-->chinese
</languageType>
<DockStation>
<!--ro, opt, object, dock station configuration-->
<Platform>
<!--ro, opt, object, platform configuration-->
<type>
<!--ro, req, enum, platform type: none,9533,8618,ISAPI, subType:string, desc:“none”, “9533”, “8618”, “ISAPI”-->none
</type>
<ip>
<!--ro, opt, string, IP address, range:[1,32]-->test
</ip>
<port>
<!--ro, opt, int, communication port, range:[1,65535]-->1
</port>
<userName>
<!--ro, req, string, user name,which is used for the dock station to log in to platform, range:[1,32]-->test
</userName>
<password>
<!--ro, req, string, password, range:[1,16]-->test
</password>
</Platform>
<centralStorageBackupEnabled>
<!--ro, opt, bool, whether to enable central storage backup-->true
</centralStorageBackupEnabled>
</DockStation>
<webVersion>
<!--ro, opt, string, Web version No., range:[1,32]-->test
</webVersion>
<deviceRFProgramVersion>
<!--ro, opt, string, device RF program version, range:[1,32]-->test
</deviceRFProgramVersion>
<securityModuleSerialNo>
<!--ro, opt, string, security module serial No., range:[1,32]-->test
</securityModuleSerialNo>
<securityModuleVersion>
<!--ro, opt, string, security module version, range:[1,32]-->test
</securityModuleVersion>
<securityChipVersion>
<!--ro, opt, string, security chip version, range:[1,32]-->test
</securityChipVersion>
<securityModuleKeyVersion>
<!--ro, opt, string, security module key version, range:[1,32]-->test
</securityModuleKeyVersion>
<UIDLampRecognition>
<!--ro, opt, object, recognize the device information by UID-->
<enabled>
<!--ro, opt, bool, whether to enable the function-->true
</enabled>
</UIDLampRecognition>
<confDeviceIdPrefix>
<!--ro, opt, bool, whether the meeting uses the device name as its prefix-->true
</confDeviceIdPrefix>
<OEMCode>
<!--ro, opt, enum, manufacturer OME code, subType:int, desc:1 (Hikvision device), 0 (neutral device)-->1
</OEMCode>
<simpleAlgorithmVersion>


<simpleAlgorithmVersion>
<!--ro, opt, string, single algorithm version, desc:for fire control analyzer, it only supports one recognition algorithm if this node is returned to
the device information-->test
</simpleAlgorithmVersion>
<bootTime>
<!--ro, opt, datetime, boot time-->1970-01-01T00:00:00+08:00
</bootTime>
<intelligentAnalysisEngineModel>
<!--ro, opt, string, engine model, range:[1,32]-->test
</intelligentAnalysisEngineModel>
<marketType>
<!--ro, opt, enum, market type, subType:int, desc:0 (invalid), 1 (distribution type), 2 (industry type)-->0
</marketType>
<algorithmVersion>
<!--ro, opt, string, HCNN algorithm version, desc:its Data Dictionary is provided by research institute for matching the algorithm model-->test
</algorithmVersion>
<firmware>
<!--ro, opt, string, firmware version, desc:its Data Dictionary is provided by research institute for matching the algorithm model-->test
</firmware>
<engineList>
<!--ro, opt, object, list of device computing power, desc:it returns engine No. by number of GPU chips-->
<engine>
<!--ro, opt, int, returned engine No.-->1
</engine>
</engineList>
<platform>
<!--ro, opt, enum, platform type, subType:int, desc:1 (TX1), 2 (P4), 3 (3559), 4 (3519), 5 (3516)-->1
</platform>
<platformName>
<!--ro, opt, string, the platform where the algorithm runs, desc:TX1/K81: NVR, KT: data center,H5: front-end device, H7: front-end device, K82: NVR, G3:
front-end device-->test
</platformName>
<touchScreenVersionInfo>
<!--ro, opt, string, touch screen module version-->test
</touchScreenVersionInfo>
<protocolFileURL>
<!--ro, opt, string, protocol notice URI, range:[1,32]-->test
</protocolFileURL>
<recycleRecordEnabled>
<!--ro, opt, bool, whether to enable overwritten recording-->false
</recycleRecordEnabled>
<decordChannelNums>
<!--ro, opt, int, number of decoding channels-->0
</decordChannelNums>
<VGANums>
<!--ro, opt, int, number of VGA ports-->0
</VGANums>
<USBNums>
<!--ro, opt, int, number of USB ports-->0
</USBNums>
<auxoutNums>
<!--ro, opt, int, number of auxiliary ports-->0
</auxoutNums>
<expansionBoardVersion>
<!--ro, opt, string, extension board version information, range:[1,32]-->test
</expansionBoardVersion>
<initWizzardDisplay>
<!--ro, opt, bool, whether it displays initialization wizard, desc:it is only used for displaying configuration of applications integrated to the
wizard, such as local GUI and Hik-Connect app by default, the value is true. it is false after the local GUI configures the wizard-->true
</initWizzardDisplay>
<beaconID>
<!--ro, opt, string, device RF program version No., range:[0,32], desc:by default, it is the current value-->test
</beaconID>
<isResetDeviceLanguage>
<!--ro, opt, bool, whether it supports resetting the device language (only for Admin and Installer), desc:if the value is true, the Hik-Connect app and
the Web Client display device information in the target language; if the value is false, the Hik-Connect app and the Web Client display the original device
information-->false
</isResetDeviceLanguage>
<dispalyNum>
<!--ro, opt, int, number of windows-->0
</dispalyNum>
<bspVersion>
<!--ro, opt, string, BSP software version-->test
</bspVersion>
<dspVersion>
<!--ro, opt, string, DSP software version-->test
</dspVersion>
<localUIVersion>
<!--ro, opt, string, local UI version-->test
</localUIVersion>
<detectorType>
<!--ro, opt, enum, detector type, subType:string, desc:“PDA” (photo-diode array)-->PDA
</detectorType>
<wiegandOutNum>
<!--ro, opt, int, number of Wiegand outputs, range:[0,1]-->1
</wiegandOutNum>
<ChipVersionInfoList>
<!--ro, opt, object, chip version information list-->
<ChipVersionInfo>
<!--ro, opt, object, chip version information-->
<ID>
<!--ro, req, int, chip No., range:[0,1], desc:the No.s of chips of different types can be duplicate. Users can distinguish them by chip type and
chip No. together-->1
</ID>


</ID>
<type>
<!--ro, req, enum, chip type, subType:string, desc:"MCU", "FPGA", "MSTAR"-->MCU
</type>
<firmwareVersion>
<!--ro, req, string, chip firmware version, range:[0,64]-->1.0.0
</firmwareVersion>
</ChipVersionInfo>
</ChipVersionInfoList>
<personBagLinkAlgoEngineVersion>
<!--ro, opt, string, engine version of the person & package linkage module, range:[0,64], desc:this node is for analyzer (security inspection)-->1.0.0
</personBagLinkAlgoEngineVersion>
<BIOSVersion>
<!--ro, opt, string, BIOS version, range:[0,16]-->test
</BIOSVersion>
<contactInformation>
<!--ro, opt, string, contact information, range:[0,64]-->test
</contactInformation>
<materialScanAlgorithmVersion>
<!--opt, string, material scan algorithm version, range:[0,64], desc:algorithm version of imaging radar panel for material scan-->test
</materialScanAlgorithmVersion>
</DeviceInfo>
Response Message
<?xml version="1.0" encoding="UTF-8"?>
<ResponseStatus xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--ro, req, object, response message, attr:version{ro, req, string, protocolVersion}-->
<requestURL>
<!--ro, req, string, request URL-->null
</requestURL>
<statusCode>
<!--ro, req, enum, status code, subType:int, desc:0:OK;1:OK;2:Device Busy;3:Device Error;4:Invalid Operation;5:Invalid XML Format;6:Invalid XML
Content;7:Reboot Required;-->0
</statusCode>
<statusString>
<!--ro, req, enum, status description, subType:string, desc:OK, Device Busy, Device Error, Invalid Operation, Invalid XML Format, Invalid XML Content,
Reboot-->OK
</statusString>
<subStatusCode>
<!--ro, req, string, sub status code, desc:sub status code-->OK
</subStatusCode>
</ResponseStatus>
21.1.2 Get device information parameters
Request URL
GET /ISAPI/System/deviceInfo
Query Parameter
None
Request Message
None
Response Message
<?xml version="1.0" encoding="UTF-8"?>
<DeviceInfo xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--ro, req, object, device information, attr:version{opt, string, protocolVersion}-->
<deviceName>
<!--ro, req, string, device name, range:[1,128]-->test
</deviceName>
<deviceID>
<!--ro, req, string, device No., range:[1,128]-->test
</deviceID>
<deviceDescription>
<!--ro, opt, string, device description, range:[1,128]-->test
</deviceDescription>
<deviceLocation>
<!--ro, opt, string, device location, range:[1,128]-->hangzhou
</deviceLocation>
<deviceStatus>
<!--ro, opt, enum, device status, subType:string, desc:"normal", "abnormal"-->normal
</deviceStatus>
<DetailAbnormalStatus>
<!--ro, opt, object, error status details, desc:it is valid only when deviceStatus is "abnormal"-->
<hardDiskFull>
<!--ro, opt, bool, the disk is full-->true
</hardDiskFull>
<hardDiskError>
<!--ro, opt, bool, the disk error-->true


<!--ro, opt, bool, the disk error-->true
</hardDiskError>
<ethernetBroken>
<!--ro, opt, bool, network disconnected-->true
</ethernetBroken>
<ipaddrConflict>
<!--ro, opt, bool, IP address conflicted-->true
</ipaddrConflict>
<illegalAccess>
<!--ro, opt, bool, illegal access-->true
</illegalAccess>
<recordError>
<!--ro, opt, bool, recording exception-->true
</recordError>
<raidLogicDiskError>
<!--ro, opt, bool, virtual disk exception in the array-->true
</raidLogicDiskError>
<spareWorkDeviceError>
<!--ro, opt, bool, backup device exception-->true
</spareWorkDeviceError>
</DetailAbnormalStatus>
<systemContact>
<!--ro, opt, string, manufacturer, range:[1,32]-->STD-CGI
</systemContact>
<model>
<!--ro, req, string, device model, range:[1,64]-->iDS-9632NX-I8/X
</model>
<serialNumber>
<!--ro, req, string, device serial No., range:[1,48]-->iDS-9632NX-I8/X1620181209CCRRC77605411WCVU
</serialNumber>
<macAddress>
<!--ro, req, string, MAC address, range:[1,64]-->44:47:cc:c8:d9:e4
</macAddress>
<firmwareVersion>
<!--ro, req, string, device firmware version, range:[1,64]-->V4.1.40
</firmwareVersion>
<firmwareReleasedDate>
<!--ro, opt, string, release date of the device firmware version-->2019-11-01
</firmwareReleasedDate>
<encoderVersion>
<!--ro, opt, string, device encoder version No., range:[1,32]-->V7.3
</encoderVersion>
<encoderReleasedDate>
<!--ro, opt, string, compile date of the device encoder version-->2019-11-02
</encoderReleasedDate>
<bootVersion>
<!--ro, opt, string, BOOT version No., range:[1,16]-->V1.3.4
</bootVersion>
<bootReleasedDate>
<!--ro, opt, string, release date of boot-->2019-11-03
</bootReleasedDate>
<panelVersion>
<!--ro, opt, string, panel version, range:[1,32]-->V1.0
</panelVersion>
<hardwareVersion>
<!--ro, opt, string, hardware version, range:[1,16]-->0x0
</hardwareVersion>
<decoderVersion>
<!--ro, opt, string, device decoder version No., range:[1,32]-->V1.0
</decoderVersion>
<decoderReleasedDate>
<!--ro, opt, string, compile date of the device decoder version-->2019-01-01
</decoderReleasedDate>
<softwareVersion>
<!--ro, opt, string, software version, range:[1,32]-->V1.23
</softwareVersion>
<capacity>
<!--ro, opt, int, device capacity, range:[1,10240], desc:unit: MB-->1
</capacity>
<usedCapacity>
<!--ro, opt, int, used capacity of the device, range:[1,10240], desc:unit: MB-->1
</usedCapacity>
<deviceType>
<!--ro, req, enum, device type, subType:string, desc:"Blade", "BladePS", “CVR", "DM", "DMbehavior", "DVR", "DVS", "DockStation", "FA", "FD", "FS",
"HAWK", "HMCP", "HybirdNVR", "IPCamera", "IPDome", "IPZoom", "InfoReleaseSys", "InfoTerminal’， "MCU"， "NVR", "PHA", "PURE", "RFID", "SipServer", "Switch",
"lightFace", "Visitor", "PWA", "PHAPro", "ACS", "VIS", "FacePaymentTerminal", "InteractiveTerminal", "Cabinet", "VoiceSpeaker", "PowerAmplifier",
"FireControlMatrix", "PagingMicrophone", "ElevatorControl", "conferencePlat" (interactive tablet), "AIOT", "OPCA", "NetworkReceiver", "PanicAlarmPanel",
"bodyCamera", "videoMatrix", "EmbeddedCentralController", "networkMic"-->Blade
</deviceType>
<subDeviceType>
<!--ro, opt, enum, subType:string-->accessControlTerminal
</subDeviceType>
<telecontrolID>
<!--ro, opt, int, remote control control ID, range:[1,255]-->1
</telecontrolID>
<supportBeep>
<!--ro, opt, bool, whether to support buzzer-->true
</supportBeep>
<supportVideoLoss>
<!--ro, opt, bool, whether the device supports video loss-->true
</supportVideoLoss>
<firmwareVersionInfo>
<!--ro, opt, string, firmware version information, range:[1,32]-->B-R-H5-0
</firmwareVersionInfo>


</firmwareVersionInfo>
<actualFloorNum>
<!--ro, opt, int, actual number of floors, range:[1,128]-->1
</actualFloorNum>
<localZoneNum>
<!--ro, opt, int, number of local zones, range:[0,16]-->1
</localZoneNum>
<alarmOutNum>
<!--ro, opt, int, number of alarm outputs, range:[0,16]-->1
</alarmOutNum>
<alarmInNum>
<!--ro, opt, int, number of alarm inputs, range:[0,16]-->1
</alarmInNum>
<distanceResolution>
<!--ro, opt, float, distance resolution, range:[0.000,0.999]-->0.000
</distanceResolution>
<angleResolution>
<!--ro, opt, float, angle resolution, range:[0.000,0.999]-->0.000
</angleResolution>
<speedResolution>
<!--ro, opt, float, speed resolution, range:[0.000,0.999]-->0.000
</speedResolution>
<detectDistance>
<!--ro, opt, float, detection distance, range:[0.000,0.999]-->0.000
</detectDistance>
<relayNum>
<!--ro, opt, int, number of relays (local), range:[0,16]-->1
</relayNum>
<electroLockNum>
<!--ro, opt, int, number of local electronic locks, range:[0,16]-->1
</electroLockNum>
<sirenNum>
<!--ro, opt, int, number of sirens, range:[0,16]-->1
</sirenNum>
<alarmLamp>
<!--ro, opt, int, number of strobe lights, range:[0,16]-->1
</alarmLamp>
<RS485Num>
<!--ro, opt, int, number of local RS-485, range:[0,16]-->1
</RS485Num>
<radarVersion>
<!--ro, opt, string, radar version, range:[1,32]-->test
</radarVersion>
<cameraModuleVersion>
<!--ro, opt, string, camera module version, range:[1,32]-->test
</cameraModuleVersion>
<mainversion>
<!--ro, opt, int, main version No., range:[1,255]-->1
</mainversion>
<subversion>
<!--ro, opt, int, sub version No., range:[1,255]-->1
</subversion>
<upgradeversion>
<!--ro, opt, int, updated version No., range:[1,255]-->1
</upgradeversion>
<customizeversion>
<!--ro, opt, int, customized version No., range:[1,255]-->1
</customizeversion>
<companyName>
<!--ro, opt, string, manufacturer name, range:[1,32]-->test
</companyName>
<copyright>
<!--ro, opt, string, copyright Information, range:[1,32]-->test
</copyright>
<systemName>
<!--ro, opt, enum, storage system name, subType:string, desc:"storageManagement" (storage management system), "distributedStorageManagement"
(distributed storage management system)-->storageManagement
</systemName>
<systemStatus>
<!--ro, opt, enum, system status, subType:string, desc:"configured", "unConfigured" (not configured)-->configured
</systemStatus>
<isLeaderDevice>
<!--ro, opt, bool, whether it is the corresponding device of the resource IP address-->true
</isLeaderDevice>
<clusterVersion>
<!--ro, opt, string, system cluster version, range:[1,32], desc:this node is valid when the value of isLeaderDevice is true-->test
</clusterVersion>
<manufacturer>
<!--ro, opt, enum, manufacturer information, subType:string, desc:it is used to distinguish OEM device. "hikvision” (Hikvision devices), "” (neutral
devices), “Hostone” (Hostone devices)-->hikvision
</manufacturer>
<centralStorageVersion>
<!--ro, opt, string, center storage version, range:[1,16]-->test
</centralStorageVersion>
<powerOnMode>
<!--ro, opt, enum, startup mode, subType:string, desc:"button" (press button to power on), "adapter" (connect adapter to power on)-->button
</powerOnMode>
<customizedInfo>
<!--ro, opt, string, customized project No., range:[1,32], desc:no value will be returned if it is baseline device. custom project No. will be returned
if is custom device-->test
</customizedInfo>
<verificationCode>
<!--ro, opt, string, device verification code-->test
</verificationCode>
<supportUrl>


<supportUrl>
<!--ro, opt, string, service portal-->test
</supportUrl>
<subSerialNumber>
<!--ro, opt, string, sub serial No.-->test
</subSerialNumber>
<languageType opt="chinese,english,spanish,portuguese,italian,french,russian,turkish,greek,czech,brazilianPortuguese">
<!--ro, opt, enum, language type, subType:string, attr:opt{req, string}, desc:"chinese", "english", "spanish", "portuguese", "italian", "french",
"russian", "turkish", "greek", "czech", "brazilianPortuguese", "slovenian", "swedish", "norwegian", "romanian", "danish", "german", "polish", "dutch",
"hungarian", "slovak", "serbian", "southAmericanSpanish", "ukrainian", "croatian", "irish", "bulgarian", "hebrew", "thai", "indonesian", "arabic",
"traditionalChinese"-->chinese
</languageType>
<DockStation>
<!--ro, opt, object, dock station information configuration-->
<Platform>
<!--ro, opt, object, platform dock station information configuration-->
<type>
<!--ro, req, enum, platform which is connected to the dock station, subType:string, desc:"none", "9533", "8618", "ISAPI"-->none
</type>
<ip>
<!--ro, opt, string, IP address, range:[1,32]-->test
</ip>
<port>
<!--ro, opt, int, communication port, range:[1,65535]-->1
</port>
<userName>
<!--ro, req, string, user name, range:[1,32]-->test
</userName>
</Platform>
<centralStorageBackupEnabled>
<!--ro, opt, bool, whether to enable center storage backup-->true
</centralStorageBackupEnabled>
</DockStation>
<webVersion>
<!--ro, opt, string, Web version No., range:[1,32]-->test
</webVersion>
<deviceRFProgramVersion>
<!--ro, opt, string, device RF program version No., range:[1,32]-->test
</deviceRFProgramVersion>
<securityModuleSerialNo>
<!--ro, opt, string, security module serial No., range:[1,32]-->test
</securityModuleSerialNo>
<securityModuleVersion>
<!--ro, opt, string, security module version No., range:[1,32]-->test
</securityModuleVersion>
<securityChipVersion>
<!--ro, opt, string, security chip version No., range:[1,32]-->test
</securityChipVersion>
<securityModuleKeyVersion>
<!--ro, opt, string, security module key version No., range:[1,32]-->test
</securityModuleKeyVersion>
<UIDLampRecognition>
<!--ro, opt, object, recognize the device information by UID-->
<enabled>
<!--ro, opt, bool, whether to enable-->true
</enabled>
</UIDLampRecognition>
<confDeviceIdPrefix>
<!--ro, opt, bool, whether the meeting uses the device name as its prefix-->true
</confDeviceIdPrefix>
<OEMCode>
<!--ro, opt, enum, manufacturer OME code, subType:int, desc:1 (Hikvision device), 0 (neutral device)-->1
</OEMCode>
<simpleAlgorithmVersion>
<!--ro, opt, string, single algorithm version, desc:for fire control analyzer, it only supports one recognition algorithm if this node is returned to
the device information-->test
</simpleAlgorithmVersion>
<bootTime>
<!--ro, opt, datetime, system boot time, desc:ISO8601 time (TD format, local time and time difference)-->1970-01-01T08:00:00+08:00
</bootTime>
<intelligentAnalysisEngineModel>
<!--ro, opt, string, engine model, range:[1,32]-->test
</intelligentAnalysisEngineModel>
<marketType>
<!--ro, opt, enum, market type, subType:int, desc:0 (invalid), 1 (distribution type), 2 (industry type)-->0
</marketType>
<algorithmVersion>
<!--ro, opt, string, HCNN algorithm version, desc:its Data Dictionary is provided by research institute for matching the algorithm model-->test
</algorithmVersion>
<firmware>
<!--ro, opt, string, firmware version, desc:its Data Dictionary is provided by research institute for matching the algorithm model-->test
</firmware>
<engineList>
<!--ro, opt, object, list of device computing power, desc:it returns engine No. by number of GPU chips-->
<engine>
<!--ro, opt, int, returned engine No.-->1
</engine>
</engineList>
<platform>
<!--ro, opt, enum, platform type, subType:int, desc:1 (TX1), 2 (P4), 3 (3559), 4 (3519), 5 (3516)-->1
</platform>
<platformName>
<!--ro, opt, string, the platform where the algorithm runs, desc:TX1/K81: NVR, KT: data center,H5: front-end device, H7: front-end device, K82: NVR, G3:
front-end device-->test


front-end device-->test
</platformName>
<touchScreenVersionInfo>
<!--ro, opt, string, touch screen module version-->test
</touchScreenVersionInfo>
<protocolFileURL>
<!--ro, opt, string, protocol notice URI, range:[1,32]-->test
</protocolFileURL>
<recycleRecordEnabled>
<!--ro, opt, bool, whether to enable overwritten recording-->false
</recycleRecordEnabled>
<decordChannelNums>
<!--ro, opt, int, number of decoding channels-->0
</decordChannelNums>
<VGANums>
<!--ro, opt, int, number of VGA ports-->0
</VGANums>
<USBNums>
<!--ro, opt, int, number of USB ports-->0
</USBNums>
<auxoutNums>
<!--ro, opt, int, number of auxiliary ports-->0
</auxoutNums>
<expansionBoardVersion>
<!--ro, opt, string, extension board version information, range:[1,32]-->test
</expansionBoardVersion>
<initWizzardDisplay>
<!--ro, opt, bool, whether it displays initialization wizard, desc:it is only used for displaying configuration of applications integrated to the
wizard, such as local GUI and Hik-Connect app. By default, the value is true; it is false after the wizard is configured on the local GUI-->true
</initWizzardDisplay>
<beaconID>
<!--ro, opt, string, device RF program version No., range:[0,32], desc:by default, it is the current value-->test
</beaconID>
<isResetDeviceLanguage>
<!--ro, opt, bool, whether to reset the language, desc:only available for Admin/Installer: true-after the language reset, the device information will be
displayed in the target language on Hik-Connect Mobile Client and Web Client; false-after the language reset, the device information will be displayed in
the original language on Hik-Connect Mobile Client and Web Client-->false
</isResetDeviceLanguage>
<dispalyNum>
<!--ro, opt, int, number of windows-->0
</dispalyNum>
<bspVersion>
<!--ro, opt, string, BSP software version-->test
</bspVersion>
<dspVersion>
<!--ro, opt, string, DSP software version-->test
</dspVersion>
<localUIVersion>
<!--ro, opt, string, local UI version-->test
</localUIVersion>
<OPCASubType>
<!--ro, opt, enum, the sub type of optical physical and chemical analyzer, subType:string, desc:"pump"; "autoSampler" (auto sampler); "detector";
"columnOven" (column oven); "detector"; "pump"; "columnOven" (column oven); "autoSampler" (auto sampler)-->detector
</OPCASubType>
<wiegandOutNum>
<!--ro, opt, int, number of Wiegand outputs, range:[0,1]-->1
</wiegandOutNum>
<ChipVersionInfoList>
<!--ro, opt, object, chip version information list-->
<ChipVersionInfo>
<!--ro, opt, object, chip version information-->
<ID>
<!--ro, req, int, chip No., range:[0,1], desc:the No.s of chips of different types can be duplicate. Users can distinguish them by chip type and
chip No. together-->1
</ID>
<type>
<!--ro, req, enum, chip type, subType:string, desc:"MCU", "FPGA", "MSTAR"-->MCU
</type>
<firmwareVersion>
<!--ro, req, string, chip firmware version, range:[0,64]-->1.0.0
</firmwareVersion>
</ChipVersionInfo>
</ChipVersionInfoList>
<personBagLinkAlgoEngineVersion>
<!--ro, opt, string, engine version of the person & package linkage module, range:[0,64], desc:this node is for analyzer (security inspection)-->1.0.0
</personBagLinkAlgoEngineVersion>
<BIOSVersion>
<!--ro, opt, string, BIOS version, range:[0,16]-->V1.3.4
</BIOSVersion>
<contactInformation>
<!--ro, opt, string, contact information, range:[0,64]-->test
</contactInformation>
<temperatureModuleVersionInfo>
<!--ro, opt, string, temperature measurement component version-->test
</temperatureModuleVersionInfo>
<PedestrianWarningModuleVersion>
<!--ro, opt, object, pedestrian warning module information, desc:this node is returned only for pedestrian warning devices-->
<pedestrianWarningMCUVersion>
<!--ro, opt, string, MCU program version, range:[0,32]-->V1.3.4
</pedestrianWarningMCUVersion>
<pedestrianWarningRadarVersion>
<!--ro, opt, string, the program version of pedestrian warning radar, range:[0,32]-->V1.3.4
</pedestrianWarningRadarVersion>
<pedestrianRangingModuleVersion>
<!--ro, opt, string, the program version of the pedestrian distance measurement module, range:[0,32]-->V1.3.4


<!--ro, opt, string, the program version of the pedestrian distance measurement module, range:[0,32]-->V1.3.4
</pedestrianRangingModuleVersion>
</PedestrianWarningModuleVersion>
<encryptionModel>
<!--ro, opt, string, device encryption model, range:[0,16], desc:it cannot be modified and is a hexadecimal digit currently-->test
</encryptionModel>
<UWBVersion>
<!--ro, opt, string, UWB version, range:[1,32]-->V1.3.0
</UWBVersion>
<audioBoard>
<!--ro, opt, object, audio board information-->
<audioBoardModel>
<!--ro, opt, string, audio board model, range:[0,32], desc:currently only C8 and R8 are supported-->C8
</audioBoardModel>
<audioBoardVersion>
<!--ro, opt, string, audio board version, range:[0,32]-->V1.0.0 build 211210
</audioBoardVersion>
</audioBoard>
<materialScanAlgorithmVersion>
<!--ro, opt, string, material scan algorithm version, range:[0,64], desc:algorithm version of imaging radar panel for material scan-->test
</materialScanAlgorithmVersion>
<regionVersion>
<!--ro, opt, enum, region version, subType:string, desc:"basic" (basic version); "australia" (Australia version)-->basic
</regionVersion>
<productionDate>
<!--ro, opt, date-->2022-04-02
</productionDate>
<wifiModuleMACAddress>
<!--ro, opt, string, range:[1,48]-->44:47:cc:c8:d9:e4
</wifiModuleMACAddress>
<displayInterfaceSize>
<!--ro, opt, float, range:[0.0,16.0], unit:in-->0
</displayInterfaceSize>
<releaseRegion>
<!--ro, opt, enum, Release Area, subType:string-->China
</releaseRegion>
<shortSerialNumber>
<!--ro, req, string, range:[1,9]-->test
</shortSerialNumber>
</DeviceInfo>
21.1.3 Get configuration capability of the device information parameters
Request URL
GET /ISAPI/System/deviceInfo/capabilities
Query Parameter
None
Request Message
None
Response Message
<?xml version="1.0" encoding="UTF-8"?>
<DeviceInfo xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--ro, req, object, device information, attr:version{opt, string, protocolVersion}-->
<deviceName min="1" max="128">
<!--ro, req, string, device name, range:[1,128], attr:min{opt, string},max{opt, string}-->test
</deviceName>
<deviceID min="1" max="128">
<!--ro, opt, string, device ID, range:[1,128], attr:min{opt, string},max{opt, string}-->123456
</deviceID>
<deviceDescription min="1" max="128">
<!--ro, opt, string, device description, range:[1,128], attr:min{opt, string},max{opt, string}-->test
</deviceDescription>
<deviceLocation opt="STD-CGI">
<!--ro, opt, string, device location, range:[1,32], attr:opt{opt, string}-->hangzhou
</deviceLocation>
<systemContact opt="STD-CGI">
<!--ro, opt, string, manufacturer, range:[1,32], attr:opt{opt, string}-->test
</systemContact>
<model min="1" max="64">
<!--ro, opt, string, device model, range:[1,64], attr:min{opt, string},max{opt, string}-->iDS-9632NX-I8/X
</model>
<serialNumber min="1" max="48">
<!--ro, opt, string, device serial No., range:[1,48], attr:min{opt, string},max{opt, string}-->iDS-9632NX-I8/X1620181209CCRRC77605411WCVU
</serialNumber>
<macAddress min="1" max="64">
<!--ro, opt, string, MAC address, range:[1,64], attr:min{opt, string},max{opt, string}-->44:47:cc:c8:d9:e4
</macAddress>
<firmwareVersion min="1" max="64">
<!--ro, opt, string, device firmware version, range:[1,64], attr:min{opt, string},max{opt, string}-->V4.1.40
</firmwareVersion>
<firmwareReleasedDate min="1" max="64">


<firmwareReleasedDate min="1" max="64">
<!--ro, opt, string, release date of the device firmware version, range:[1,64], attr:min{opt, string},max{opt, string}-->build 181129
</firmwareReleasedDate>
<encoderVersion min="1" max="64">
<!--ro, opt, string, device description, range:[1,64], attr:min{opt, string},max{opt, string}-->V7.3
</encoderVersion>
<encoderReleasedDate min="1" max="64">
<!--ro, opt, string, release date, range:[1,64], attr:min{opt, string},max{opt, string}-->build 20161223
</encoderReleasedDate>
<bootVersion min="1" max="16">
<!--ro, opt, string, BOOT version No., range:[1,16], attr:min{opt, string},max{opt, string}-->V1.3.4
</bootVersion>
<bootReleasedDate min="1" max="16">
<!--ro, opt, string, release date of boot, range:[1,16], attr:min{opt, string},max{opt, string}-->100316
</bootReleasedDate>
<hardwareVersion min="1" max="16">
<!--ro, opt, string, hardware version, range:[1,16], attr:min{opt, string},max{opt, string}-->0x0
</hardwareVersion>
<deviceType
opt="IPCamera,IPDome,DVR,HybirdNVR,NVR,DVS,IPZoom,CVR,DockStation,RFID,InfoReleaseSys,MCU,SipServer,PHA,PWA,InfoTerminal,Switch,Visitor,PHAPro,ACS,VIS,FaceP
aymentTerminal,InteractiveTerminal,Cabinet,VoiceSpeaker,PowerAmplifier,FireControlMatrix,PagingMicrophone,ElevatorControl,conferencePlat,OPCA,NetworkReceive
r,PanicAlarmPanel,videoMatrix,EmbeddedCentralController,networkMic,PersonnelChannel,MediaComponentGateway,ImagingRadarPanel,TrafficTerminalServer,securityRa
dar">
<!--ro, opt, string, device type, attr:opt{opt, string}, desc:PWA continues to be used in wireless security control panel (Ax Pro series)-->IPCamera
</deviceType>
<subDeviceType opt="accessControlTerminal,attendanceCheckDevice,multiChannelAccessController,personAndIdCardDevice,doorStation,mainStation">
<!--ro, opt, string, attr:opt{req, string}-->accessControlTerminal
</subDeviceType>
<telecontrolID min="1" max="16">
<!--ro, opt, int, remote control ID, range:[1,16], attr:min{opt, string},max{opt, string}-->8
</telecontrolID>
<subChannelEnabled>
<!--ro, opt, bool, whether to enable two channels-->true
</subChannelEnabled>
<thrChannelEnabled>
<!--ro, opt, bool, whether to enable three channels-->true
</thrChannelEnabled>
<powerOnMode opt="button,adapter" def="button">
<!--ro, opt, enum, device startup mode, subType:string, attr:opt{opt, string},def{opt, string}, desc:"button", "adapter"-->button
</powerOnMode>
<customizedInfo min="0" max="128">
<!--ro, opt, string, device custom No., range:[0,128], attr:min{req, int},max{req, int}, desc:for baseline devices, returing this node is not required-
>test
</customizedInfo>
<languageType
opt="chinese,english,spanish,portuguese,italian,french,russian,turkish,greek,czech,brazilianPortuguese,slovenian,swedish,norwegian,romanian,danish,german,po
lish,dutch,hungarian,slovak,serbian,southAmericanSpanish,ukrainian,croatian,irish,bulgarian,hebrew,thai,indonesian,arabic,traditionalChinese,lithuanian,angl
icism">
<!--ro, opt, string, language type, range:[1,32], attr:opt{opt, string}, desc:"chinese", "english", "spanish", "portuguese", "italian", "french",
"russian", "turkish", "greek", "czech", "brazilianPortuguese", "slovenian", "swedish", "norwegian", "romanian", "danish", "german", "polish", "dutch",
"hungarian", "slovak", "serbian", "southAmericanSpanish", "ukrainian", "croatian", "irish", "bulgarian", "hebrew", "thai", "indonesian", "arabic",
"traditionalChinese"-->chinese
</languageType>
<localZoneNum min="0" max="16">
<!--ro, opt, int, number of local zones, range:[0,16], attr:min{opt, string},max{opt, string}-->1
</localZoneNum>
<alarmOutNum min="0" max="16">
<!--ro, opt, int, number of alarm outputs, range:[0,16], attr:min{opt, string},max{opt, string}-->1
</alarmOutNum>
<relayNum min="0" max="16">
<!--ro, opt, int, number of local relays, range:[0,16], attr:min{opt, string},max{opt, string}-->1
</relayNum>
<electroLockNum min="0" max="16">
<!--ro, opt, int, number of local electronic locks, range:[0,16], attr:min{opt, string},max{opt, string}-->1
</electroLockNum>
<sirenNum min="0" max="16">
<!--ro, opt, int, number of sirens, range:[0,16], attr:min{opt, string},max{opt, string}-->1
</sirenNum>
<alarmLamp min="0" max="16">
<!--ro, opt, int, number of strobe lights, range:[0,16], attr:min{opt, string},max{opt, string}-->1
</alarmLamp>
<RS485Num min="0" max="16">
<!--ro, opt, int, number of local RS-485, range:[0,16], attr:min{opt, string},max{opt, string}-->1
</RS485Num>
<DockStation>
<!--ro, opt, object, dock station information configuration-->
<Platform>
<!--ro, opt, object, platform dock station information configuration-->
<type opt="none, 9533, 8618, ISAPI">
<!--ro, req, enum, platform which is connected to the dock station, subType:string, attr:opt{opt, string}, desc:“none”, “9533”, “8618”, “ISAPI”-
>none
</type>
<ip>
<!--ro, opt, string, IP address, range:[1,32]-->0.0.0.0
</ip>
<port>
<!--ro, opt, int, port No., range:[1,65535]-->1
</port>
<userName>
<!--ro, req, string, user name, range:[1,32]-->test
</userName>
<password>
<!--ro, req, string, password, range:[1,16]-->test
</password>


</Platform>
<centralStorageBackupEnabled opt="true, false">
<!--ro, opt, bool, whether to enable center storage backup, attr:opt{opt, string}, desc:when it is enabled, the device uploads all data to the center
storage for backup before uploading them to the platform; when it is disabled, the device uploads data to the platform directly, and for those important
data, the platform will apply the file list to the device for center storage (related URI: /ISAPI/ContentMgmt/record/control/centralStorageBackup), then the
device will upload the data with storage URI to the platform-->true
</centralStorageBackupEnabled>
<isSupportManufacturer>
<!--ro, opt, bool, whether it supports configuring third-party manufacturer for the dock station,
desc:/ISAPI/Traffic/dockStation/slot/Manufacturer/capabilities?format=json-->true
</isSupportManufacturer>
</DockStation>
<webVersion>
<!--ro, opt, string, Web version No., range:[1,32]-->1.0
</webVersion>
<deviceRFProgramVersion>
<!--ro, opt, string, device RF program version No., range:[1,32]-->1.0
</deviceRFProgramVersion>
<securityModuleSerialNo>
<!--ro, opt, string, security module serial No., range:[1,48]-->1.0
</securityModuleSerialNo>
<securityModuleVersion>
<!--ro, opt, string, security module version No., range:[1,32]-->1.0
</securityModuleVersion>
<securityChipVersion>
<!--ro, opt, string, security chip version No., range:[1,32]-->1.0
</securityChipVersion>
<securityModuleKeyVersion>
<!--ro, opt, string, security module key version No., range:[1,32]-->1.0
</securityModuleKeyVersion>
<UIDLampRecognition>
<!--ro, opt, object, recognize the device information by UID-->
<enabled opt="true,false">
<!--ro, opt, bool, whether to enable, attr:opt{opt, string}-->true
</enabled>
</UIDLampRecognition>
<confDeviceIdPrefix opt="true,false">
<!--ro, opt, bool, whether the meeting uses the device name as its prefix, attr:opt{opt, string}-->true
</confDeviceIdPrefix>
<simpleAlgorithmVersion min="0" max="10">
<!--ro, opt, string, single algorithm version, attr:min{req, int},max{req, int}-->test
</simpleAlgorithmVersion>
<bootTime>
<!--ro, opt, datetime, system boot time-->1970-01-01T00:00:00+08:00
</bootTime>
<isSupportNewVersionDevlanguageSwitch>
<!--ro, opt, bool, whether it supports switching languages for the new protocol version-->true
</isSupportNewVersionDevlanguageSwitch>
<intelligentAnalysisEngineModel>
<!--ro, opt, string, engine model, range:[1,32]-->K81
</intelligentAnalysisEngineModel>
<marketType opt="0,1,2">
<!--ro, opt, enum, market type, subType:int, attr:opt{req, string}, desc:0 (invalid), 1 (distribution type), 2 (industry type)-->0
</marketType>
<protocolFileURL min="1" max="32">
<!--ro, opt, string, protocol notice URI, attr:min{opt, string},max{opt, string}-->test
</protocolFileURL>
<recycleRecordEnabled opt="true,false">
<!--ro, opt, bool, whether to enable overwritten recording, attr:opt{req, string}-->false
</recycleRecordEnabled>
<decordChannelNums>
<!--ro, opt, int, number of decoding channels-->0
</decordChannelNums>
<VGANums>
<!--ro, opt, int, number of VGA ports-->0
</VGANums>
<USBNums>
<!--ro, opt, int, number of USB ports-->0
</USBNums>
<auxoutNums>
<!--ro, opt, int, number of auxiliary ports-->0
</auxoutNums>
<expansionBoardVersion min="0" max="32">
<!--ro, opt, string, extension board version information, range:[0,32], attr:min{req, int},max{req, int}-->test
</expansionBoardVersion>
<initWizzardDisplay opt="true,false">
<!--ro, opt, bool, whether it displays initialization wizard, attr:opt{req, string}, desc:it is only used for displaying configuration of applications
integrated to the wizard, such as local GUI and Hik-Connect app. By default, the value is true; it is false after the wizard is configured on the local GUI->true
</initWizzardDisplay>
<beaconID
min="0" max="32">
<!--ro, opt, string, device RF program version No., range:[0,32], attr:min{req, int},max{req, int}, desc:by default, it is the current value-->test
</beaconID>
<isResetDeviceLanguage opt="true,false">
<!--ro, opt, bool, whether to reset the language, attr:opt{req, string}, desc:only available for Admin/Installer: true-after the language reset, the
device information will be displayed in the target language on Hik-Connect Mobile Client and Web Client; false-after the language reset, the device
information will be displayed in the original language on Hik-Connect Mobile Client and Web Client-->false
</isResetDeviceLanguage>
<dispalyNum>
<!--ro, opt, int, number of device screens-->2
</dispalyNum>
<bspVersion min="1" max="1">
<!--ro, opt, string, BSP version, attr:min{req, int},max{req, int}-->test
</bspVersion>


</bspVersion>
<dspVersion min="1" max="1">
<!--ro, opt, string, DSP version, attr:min{req, int},max{req, int}-->test
</dspVersion>
<localUIVersion min="1" max="1">
<!--ro, opt, string, local UI version, attr:min{req, int},max{req, int}-->test
</localUIVersion>
<OPCASubType opt="PDA,pump,column,autoSampler">
<!--ro, opt, enum, the sub type of optical physical and chemical analyzer, subType:string, attr:opt{req, string}, desc:"detector"; "pump"; "columnOven"
(column oven); "autoSampler" (auto sampler)-->detector
</OPCASubType>
<wiegandOutNum min="0" max="1">
<!--ro, opt, int, number of Wiegand outputs, range:[0,1], attr:min{opt, string},max{opt, string}-->1
</wiegandOutNum>
<ChipVersionInfoList size="6">
<!--ro, opt, object, chip version information list, attr:size{req, int}-->
<ChipVersionInfo>
<!--ro, opt, object, chip version information-->
<ID min="0" max="1">
<!--ro, req, int, chip No., range:[0,1], attr:min{req, int},max{req, int}, desc:the No.s of chips of different types can be duplicate. Users can
distinguish them by chip type and chip No. together-->1
</ID>
<type opt="MCU,FPGA,MSTAR">
<!--ro, req, enum, chip type, subType:string, attr:opt{req, string}, desc:"MCU", "FPGA", "MSTAR"-->MCU
</type>
<firmwareVersion min="0" max="64">
<!--ro, req, string, chip firmware version, range:[0,64], attr:min{req, int},max{req, int}-->1.0.0
</firmwareVersion>
</ChipVersionInfo>
</ChipVersionInfoList>
<personBagLinkAlgoEngineVersion min="0" max="64">
<!--ro, opt, string, engine version of the person & package linkage module, range:[0,64], attr:min{req, int},max{req, int}, desc:this node is for
analyzer (security inspection)-->1.0.0
</personBagLinkAlgoEngineVersion>
<BIOSVersion min="0" max="16">
<!--ro, opt, string, BIOS version, range:[0,16], attr:min{req, int},max{req, int}-->V1.3.4
</BIOSVersion>
<contactInformation min="0" max="64">
<!--ro, opt, string, contact information, range:[0,64], attr:min{req, int},max{req, int}-->test
</contactInformation>
<PedestrianWarningModuleVersion>
<!--ro, opt, object, pedestrian warning module information, desc:this node is returned only for pedestrian warning devices-->
<pedestrianWarningMCUVersion min="1" max="32">
<!--ro, opt, string, MCU program version, range:[0,16], attr:min{req, int},max{req, int}-->V1.3.4
</pedestrianWarningMCUVersion>
<pedestrianWarningRadarVersion min="1" max="32">
<!--ro, opt, string, the program version of pedestrian warning radar, range:[0,16], attr:min{req, int},max{req, int}-->V1.3.4
</pedestrianWarningRadarVersion>
<pedestrianRangingModuleVersion min="1" max="32">
<!--ro, opt, string, the program version of the pedestrian distance measurement module, range:[0,16], attr:min{req, int},max{req, int}-->V1.3.4
</pedestrianRangingModuleVersion>
</PedestrianWarningModuleVersion>
<encryptionModel min="0" max="16">
<!--ro, opt, string, device encryption model, range:[0,16], attr:min{req, int},max{req, int}, desc:it cannot be modified and is a hexadecimal digit
currently-->test
</encryptionModel>
<UWBVersion min="1" max="32">
<!--ro, opt, string, UWB version, range:[1,32], attr:min{req, int},max{req, int}-->V1.3.4
</UWBVersion>
<audioBoard>
<!--ro, opt, object, audio board information-->
<audioBoardModel min="0" max="32">
<!--ro, opt, string, audio board model, range:[0,32], attr:min{req, int},max{req, int}, desc:currently only C8 and R8 are supported-->C8
</audioBoardModel>
<audioBoardVersion min="0" max="32">
<!--ro, opt, string, audio board version, range:[0,32], attr:min{req, int},max{req, int}-->V1.0.0 build 211210
</audioBoardVersion>
</audioBoard>
<materialScanAlgorithmVersion min="0" max="64">
<!--ro, opt, string, material scan algorithm version, range:[0,64], attr:min{req, int},max{req, int}, desc:algorithm version of imaging radar panel for
material scan-->1.0.0
</materialScanAlgorithmVersion>
<productionDate>
<!--ro, opt, date-->2022-04-02
</productionDate>
<wifiModuleMACAddress min="1" max="48">
<!--ro, opt, string, range:[1,48], attr:min{req, int},max{req, int}-->44:47:cc:c8:d9:e4
</wifiModuleMACAddress>
<isSupportExportDeviceFingerFile>
<!--ro, opt, bool-->true
</isSupportExportDeviceFingerFile>
<isSupportPromptMessage>
<!--ro, opt, bool-->true
</isSupportPromptMessage>
<shortSerialNumber min="1" max="9">
<!--ro, req, string, range:[1,9], attr:min{req, int},max{req, int}-->test
</shortSerialNumber>
</DeviceInfo>
21.2 User Management


21.2.1 Log in to the device by digest
Request URL
GET /ISAPI/Security/userCheck
Query Parameter
None
Request Message
None
Response Message
<?xml version="1.0" encoding="UTF-8"?>
<userCheck xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--ro, req, object, attr:version{req, string, protocolVersion}-->
<statusValue>
<!--ro, req, enum, status code, subType:int, desc:"200"(succeeded), "401"(failed)-->200
</statusValue>
<statusString>
<!--ro, opt, enum, status, subType:string, desc:"OK", "Unauthorized"-->OK
</statusString>
<isDefaultPassword>
<!--ro, opt, bool-->true
</isDefaultPassword>
<isRiskPassword>
<!--ro, opt, bool-->true
</isRiskPassword>
<isActivated>
<!--ro, opt, bool-->true
</isActivated>
<residualValidity>
<!--ro, opt, int-->1
</residualValidity>
<lockStatus>
<!--ro, opt, enum, locking status, subType:string, desc:"unlock", "locked"-->unlock
</lockStatus>
<unlockTime>
<!--ro, opt, int, unlocking remaining time, unit:s-->1
</unlockTime>
<retryLoginTime>
<!--ro, opt, int, remaining login attempts-->1
</retryLoginTime>
</userCheck>
21.2.2 Set information for a single user
Request URL
PUT /ISAPI/Security/users/<indexID>?security=<security>&iv=<iv>
Query Parameter
Parameter Name Parameter Type Description
indexID
string
security
iv
Request Message
<?xml version="1.0" encoding="UTF-8"?>
<User xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--req, object, user, attr:version{req, string, protocolVersion}-->
<id>
<!--req, int, user parameter No., range:[1,16], desc:supported range: [1,16]-->1
</id>
<enabled>
<!--opt, bool, whether to enable user-->true
</enabled>
<userName>
<!--req, string, user name, range:[1,32]-->test
</userName>
<phoneNum>
<!--wo, opt, string, phone number, range:[1,11], desc:the sensitive information should be encrypted-->test
</phoneNum>
string
string
-
-
-


</phoneNum>
<emailAddress>
<!--wo, opt, string, email address, range:[1,32], desc:the sensitive information should be encrypted-->test
</emailAddress>
<password>
<!--wo, req, string, password, range:[1,16], desc:the sensitive information should be encrypted-->test
</password>
<duressPassword>
<!--wo, opt, string, duress password, range:[1,16], desc:the sensitive information should be encrypted-->test
</duressPassword>
<keypadPassword>
<!--wo, opt, string, keypad password, range:[1,16], desc:the sensitive information should be encrypted. The keypad password is required when the
security control panel is armed or disarmed via keypad-->test
</keypadPassword>
<singleKeypadEnable>
<!--opt, bool, whether to enable the one-time keypad password-->true
</singleKeypadEnable>
<invalidkeypadPassword>
<!--opt, bool, whether the current keypad password is invalid, desc:it is valid after setting singleKeypadEnable-->true
</invalidkeypadPassword>
<userOperateType>
<!--opt, enum, user type, subType:int,
desc:1 (if userOperateType is 1 or none, password is valid. if method is POST, password is required. otherwise this node is optional)
2 (if userOperateType is 2, keypadPassword is valid. if method is POST, keypadPassword is required. otherwise this node is optional)
3 (if userOperateType is 3,both passwordkeypad and Password is valid. if method is POST, password and keypadPassword is required. otherwise this node is
optional) 1 (network user), 2 (keypad user), 3 (network user and keypad user)-->1
</userOperateType>
<bondIpAddressList>
<!--opt, object, list of socket IP address that bound to the user-->
<bondIpAddress>
<!--opt, object, socket IP address that bound to the user-->
<id>
<!--req, int, bounded IP address No., range:[1,16], desc:it starts from 1-->1
</id>
<ipAddress>
<!--opt, string, bounded IPv4 address, range:[1,32]-->test
</ipAddress>
<ipv6Address>
<!--opt, string, bounded IPv6 address, range:[1,32]-->test
</ipv6Address>
</bondIpAddress>
</bondIpAddressList>
<bondMacAddressList>
<!--opt, object, list of MAC address that bound to the user-->
<bondMacAddress>
<!--opt, object, MAC address that bound to the user-->
<id>
<!--req, int, bounded MAC address No., range:[1,16], desc:It starts from 1-->1
</id>
<macAddress>
<!--opt, string, bounded MAC address, range:[1,32]-->test
</macAddress>
</bondMacAddress>
</bondMacAddressList>
<userLevel>
<!--opt, enum, user level, subType:string, desc:"Administrator", "Operator", "Viewer", "installer", "manufacturer", "single" (single user),
"installerAdmin" (installation admin), "installEmployee" (installation employee)-->Administrator
</userLevel>
<attribute>
<!--opt, object, user's special attributes-->
<inherent>
<!--opt, bool, whether it can be deleted, desc:true (the user cannot be deleted), false / the node is invalid (the user can be deleted)-->true
</inherent>
</attribute>
<loginPassword>
<!--req, string, confirm password, range:[1,16], desc:confirming password is required when adding and editing user information. Encrypting the sensitive
information is required when the confirm password is transmitted via HTTP-->King726014
</loginPassword>
<cardList>
<!--opt, object, list of cards that belong to the user-->
<card>
<!--opt, object, card-->
<id>
<!--opt, int, No., range:[1,16]-->1
</id>
<name>
<!--opt, string, name, range:[1,32]-->test
</name>
</card>
</cardList>
<remoteCtrlList>
<!--opt, object, list of keyfobs that belong to the user-->
<remoteCtrl>
<!--opt, object, keyfob-->
<id>
<!--opt, int, No., range:[1,16]-->1
</id>
<name>
<!--opt, string, name, range:[1,32]-->test
</name>
</remoteCtrl>
</remoteCtrlList>
<PasswordPeriodPrompt>
<!--opt, object, configure notifications of the password validity period, desc:if the password validity period expired, a notification of password


expired shall be prompted during logging-in, but the expired password does not affect the usage-->
<passwordPeriodType>
<!--req, enum, notification type of the password validity period, subType:string, desc:"permanent" (take effect permanently), "byDate" (take effect by
day). Take effect permanently: notifications of the password expired shall not prompted permanently. Take effect by day: notification of password expired
shall be prompted in time, but password changing is not required in using-->permanent
</passwordPeriodType>
<passwordPeriodbyDate>
<!--opt, int, validity period of the password taking effect by day, range:[1,1200], unit:天, dep:and,
{$.User.PasswordPeriodPrompt.passwordPeriodType,eq,byDate}-->90
</passwordPeriodbyDate>
</PasswordPeriodPrompt>
</User>
Response Message
<?xml version="1.0" encoding="UTF-8"?>
<ResponseStatus xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--ro, req, object, response message, attr:version{ro, req, string, protocolVersion}-->
<requestURL>
<!--ro, req, string, request URL-->null
</requestURL>
<statusCode>
<!--ro, req, enum, status code, subType:int, desc:0 (OK), 1 (OK), 2 (Device Busy), 3 (Device Error), 4 (Invalid Operation), 5 (Invalid XML Format), 6
(Invalid XML Content), 7 (Reboot Required)-->0
</statusCode>
<statusString>
<!--ro, req, enum, status description, subType:string, desc:"OK" (succeeded), "Device Busy", "Device Error", "Invalid Operation", "Invalid XML Format",
"Invalid XML Content", "Reboot" (reboot device)-->OK
</statusString>
<subStatusCode>
<!--ro, req, string, sub status code, desc:sub status code, which describes the error in details-->OK
</subStatusCode>
<lockStatus>
<!--ro, opt, enum, lock status, subType:string, desc:"lock", "unlock". It is returned when verifying loginPassword failed-->lock
</lockStatus>
<retryTimes>
<!--ro, opt, int, remaining attempts, range:[0,6], desc:it is returned when verifying loginPassword failed-->1
</retryTimes>
</ResponseStatus>
21.2.3 Get information about a single user
Request URL
GET /ISAPI/Security/users/<indexID>?security=<security>&iv=<iv>
Query Parameter
Parameter Name Parameter Type Description
indexID
string
security
iv
string
string
Request Message
None
Response Message
<?xml version="1.0" encoding="UTF-8"?>
<User xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--ro, req, object, user, attr:version{req, string, protocolVersion}-->
<id>
<!--ro, req, int, user parameter No.-->1
</id>
<enabled>
<!--ro, opt, bool, whether to enable user-->true
</enabled>
<userName>
<!--ro, req, string, user name, range:[1,32]-->test
</userName>
<phoneNum>
<!--ro, opt, string, phone number, range:[1,11], desc:the sensitive information should be encrypted-->test
</phoneNum>
<emailAddress>
<!--ro, opt, string, Email Address, range:[1,32], desc:the sensitive information should be encrypted-->test
</emailAddress>
<duressPassword>
-
-
-


<duressPassword>
<!--ro, opt, string, duress password, range:[1,16], desc:the sensitive information should be encrypted-->test
</duressPassword>
<keypadPassword>
<!--ro, opt, string, Keypad Password, range:[1,16], desc:the sensitive information should be encrypted. entering password is required when the security
control panel is armed or disarmed via keypad-->test
</keypadPassword>
<singleKeypadEnable>
<!--ro, opt, bool, whether to enable the keypad password for one time-->true
</singleKeypadEnable>
<invalidkeypadPassword>
<!--ro, opt, bool, whether the current keypad password is invalid, desc:it is valid after setting singleKeypadEnable-->true
</invalidkeypadPassword>
<userOperateType>
<!--ro, opt, enum, user type, subType:int,
desc:1 (if userOperateType is 1 or none, password is valid. if method is POST, password is required. otherwise this node is optional)
2 (if userOperateType is 2, keypadPassword is valid. if method is POST, keypadPassword is required. otherwise this node is optional)
3 (if userOperateType is 3,both passwordkeypad and Password is valid. if method is POST, password and keypadPassword is required. otherwise this node is
optional) 1 (network user), 2 (keypad user), 3 (network user and keypad user)-->1
</userOperateType>
<bondIpAddressList>
<!--ro, opt, object, list of socket IP address that bound to the user-->
<bondIpAddress>
<!--ro, opt, object, socket IP address that bound to the user-->
<id>
<!--ro, req, int, bounded IP address No., range:[1,16], desc:it starts from 1-->1
</id>
<ipAddress>
<!--ro, opt, string, bounded IPv4 address, range:[1,32]-->test
</ipAddress>
<ipv6Address>
<!--ro, opt, string, bounded IPv6 address, range:[1,128]-->test
</ipv6Address>
</bondIpAddress>
</bondIpAddressList>
<bondMacAddressList>
<!--ro, opt, object, list of mac address that bound to the user-->
<bondMacAddress>
<!--ro, opt, object, mac address that bound to the user-->
<id>
<!--ro, req, int, bounded mac address No., range:[1,16], desc:It starts from 1-->1
</id>
<macAddress>
<!--ro, opt, string, bounded mac address, range:[1,32]-->test
</macAddress>
</bondMacAddress>
</bondMacAddressList>
<userLevel>
<!--ro, opt, enum, user level, subType:string, desc:"Administrator", "Operator", "Viewer" (viewer, which is not applied on devices currently),
"installer", "manufacturer", "single" (single user, which is not applied on devices currently), "installerAdmin" (installation admin), "installEmployee"
(installation employee), "Employee" (for attendance), "DepartmentManager" (department manager, for attendance)-->Administrator
</userLevel>
<attribute>
<!--ro, opt, object, user's special attributes-->
<inherent>
<!--ro, opt, bool, whether it can be deleted, desc:true: the user cannot be deleted. false / the node is invalid: the user can be deleted-->true
</inherent>
</attribute>
<cardList>
<!--ro, opt, object, list of cards that belong to the user-->
<card>
<!--ro, opt, object, card-->
<id>
<!--ro, opt, int, No., range:[1,16]-->1
</id>
<name>
<!--ro, opt, string, name, range:[1,32]-->test
</name>
</card>
</cardList>
<remoteCtrlList>
<!--ro, opt, object, list of keyfobs that belong to the user-->
<remoteCtrl>
<!--ro, opt, object, keyfob-->
<id>
<!--ro, opt, int, No., range:[1,16]-->1
</id>
<name>
<!--ro, opt, string, name, range:[1,32]-->test
</name>
</remoteCtrl>
</remoteCtrlList>
<userNo>
<!--ro, opt, int, displayed No. corresponding to the user ID, desc:the No. is used on the App and the Web Client and reporting alarms to ARC. it is
valid to all user types. the format of the No. is 500 + id-->501
</userNo>
<adminType>
<!--ro, opt, enum, admin type, subType:string, desc:for hybrid security control panel, it is used for distinguishing whether the administrator account
is created on the cloud or in the local area network. It is displayed both on the App and the Web Client. "Cloud" (user account created on the cloud), "LAN"
(user account created on LAN)-->Cloud
</adminType>
<installerType>
<!--ro, opt, enum, installer type, subType:string, desc:for hybrid security control panel, it is used for distinguishing whether the installer account
is created on the cloud or in the local area network. It is displayed both on the App and the Web Client. "Cloud" (user account created on the cloud), "LAN"


is created on the cloud or in the local area network. It is displayed both on the App and the Web Client. "Cloud" (user account created on the cloud), "LAN"
(user account created on LAN)-->Cloud
</installerType>
<PasswordPeriodPrompt>
<!--ro, opt, object, configure notifications of the password validity period, desc:if the password validity period expired, a notification of password
expired shall be prompted during logging-in, but the expired password does not affect the usage-->
<passwordPeriodType>
<!--ro, req, enum, notification type of the password validity period, subType:string, desc:"permanent" (take effect permanently), "byDate" (take
effect by day). Take effect permanently: notifications of the password expired shall not prompted permanently. Take effect by day: notification of password
expired shall be prompted in time, but password changing is not required in using-->permanent
</passwordPeriodType>
<passwordPeriodbyDate>
<!--ro, opt, int, validity period of the password taking effect by day, range:[1,1200], unit:天, dep:and,
{$.User.PasswordPeriodPrompt.passwordPeriodType,eq,byDate}-->90
</passwordPeriodbyDate>
</PasswordPeriodPrompt>
<userActivationStatus>
<!--ro, opt, bool, user activation status, desc:true (activated; default value), false (inactivated)-->true
</userActivationStatus>
<invalidDuressPassword>
<!--ro, opt, bool, whether current duress password is invalid, desc:if the duress password is not configured, the value is true-->true
</invalidDuressPassword>
</User>
21.2.4 Get the configuration capability of a specific user
Request URL
GET /ISAPI/Security/users/<indexID>/capabilities
Query Parameter
Parameter Name Parameter Type Description
indexID
string
Request Message
None
Response Message
<?xml version="1.0" encoding="UTF-8"?>
<User xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--ro, req, object, user, attr:version{req, string, protocolVersion}-->
<id min="1" max="64">
<!--ro, req, int, user parameter No., range:[1,64], attr:min{req, int},max{req, int}-->1
</id>
<enabled opt="true,false">
<!--ro, opt, bool, whether to enable user, attr:opt{req, string}-->true
</enabled>
<userName min="1" max="32">
<!--ro, req, string, user name, range:[1,32], attr:min{req, int},max{req, int}-->test
</userName>
<phoneNum min="1" max="11">
<!--ro, opt, string, phone number, range:[1,11], attr:min{req, int},max{req, int}, desc:it can replace userName for login. The sensitive information
should be encrypted-->test
</phoneNum>
<emailAddress min="1" max="32">
<!--ro, opt, string, email address, range:[1,32], attr:min{req, int},max{req, int}, desc:it can replace userName for login. The sensitive information
should be encrypted-->test
</emailAddress>
<oldPassword min="1" max="16">
<!--ro, opt, string, old password before the current logging-in, range:[1,16], attr:min{req, int},max{req, int}, desc:the password will not be returned->null
</oldPassword>
<password
min="1" max="16">
<!--ro, req, string, current password, range:[1,16], attr:min{req, int},max{req, int}, desc:the password will not be returned-->null
</password>
<duressPassword min="1" max="16">
<!--ro, opt, string, duress password, which is used for special password which is under duress, the sensitive information should be encrypted, range:
[1,16], attr:min{req, int},max{req, int}, desc:the password will not be returned-->null
</duressPassword>
<keypadPassword min="1" max="16">
<!--ro, opt, string, keypad password, range:[1,16], attr:min{req, int},max{req, int}, desc:the password will not be returned-->null
</keypadPassword>
<singleKeypadEnable opt="true,false">
<!--ro, opt, bool, whether to enable the one-time keypad password, attr:opt{req, string}-->true
</singleKeypadEnable>
<invalidkeypadPassword opt="true,false">
<!--ro, opt, bool, whether the current keypad password is invalid, attr:opt{req, string}, desc:it is valid after setting singleKeypadEnable-->true
</invalidkeypadPassword>
<userOperateType opt="1,2,3">
<!--ro, opt, enum, user type, subType:int, attr:opt{req, string}, desc:operator accounts shared from the cloud can log in to the cloud, the Web Client,
the local device, operator accounts created on the cloud and LAN can only log in to local device 1 (network user), 2 (keypad user), 3 (network user and
keypad user)-->1
</userOperateType>
-


</userOperateType>
<bondIpAddressList>
<!--ro, opt, array, list of socket IP address that bound to the user, subType:object-->
<bondIpAddress>
<!--ro, opt, object, socket IP address that bound to the user-->
<id>
<!--ro, req, int, bounded IP address No., range:[1,16]-->1
</id>
<ipAddress>
<!--ro, opt, string, bounded IPv4 address, range:[1,32]-->test
</ipAddress>
<ipv6Address>
<!--ro, opt, string, bounded IPv6 address, range:[1,32]-->test
</ipv6Address>
</bondIpAddress>
</bondIpAddressList>
<bondMacAddressList>
<!--ro, opt, array, list of MAC address that bound to the user, subType:object-->
<bondMacAddress>
<!--ro, opt, object, MAC address that bound to the user-->
<id>
<!--ro, req, int, bounded MAC address No., range:[1,16]-->1
</id>
<macAddress>
<!--ro, opt, string, bounded MAC address, range:[1,32]-->test
</macAddress>
</bondMacAddress>
</bondMacAddressList>
<userLevel opt="Administrator,Operator,Viewer,installer,manufacturer,single,installerAdmin,installEmployee,Employee,DepartmentManager">
<!--ro, opt, enum, user type, subType:string, attr:opt{req, string}, desc:"Administrator", "Operator", "Viewer" (viewer, which is not applied on devices
currently), "installer", "manufacturer", "single" (single user, which is not applied on devices currently), "installerAdmin" (installation admin),
"installEmployee" (installation employee), "Employee" (for attendance), "DepartmentManager" (department manager, for attendance)-->Administrator
</userLevel>
<attribute>
<!--ro, opt, object, user's special attributes-->
<inherent>
<!--ro, opt, bool, whether it can be deleted, desc:true (the user cannot be deleted), false / the node is invalid (the user can be deleted)-->true
</inherent>
</attribute>
<belongUserId>
<!--ro, opt, int, upper-level user ID, range:[0,16], desc:0 (no upper-level user)-->1
</belongUserId>
<belongOrgNo>
<!--ro, opt, int, organization No., range:[1,16]-->1
</belongOrgNo>
<cardList>
<!--ro, opt, object, list of cards that belong to the user-->
<card>
<!--ro, opt, object, card-->
<id>
<!--ro, opt, int, No., range:[1,16]-->1
</id>
<name>
<!--ro, opt, string, name, range:[1,32]-->test
</name>
</card>
</cardList>
<remoteCtrlList>
<!--ro, opt, array, list of keyfobs that belong to the user, subType:object-->
<remoteCtrl>
<!--ro, opt, object, keyfob-->
<id>
<!--ro, opt, int, No., range:[1,16]-->1
</id>
<name>
<!--ro, opt, string, name, range:[1,32]-->test
</name>
</remoteCtrl>
</remoteCtrlList>
<userNo min="501" max="null">
<!--ro, opt, int, displayed No. corresponding to the user ID, attr:min{req, int},max{req, int},
desc:the No. is used on the App and the Web Client and reporting alarms to ARC. It is valid to all user types. The format of the No. is 500 + id adding
userNo for supporting distinguishing users from user names on some ARC
scenario: department. residents in one department shall share a security control panel and ARC service. Only one resident shall be the administrator. for
this scenario, after adding residents as users on the ARC, user ID of the server and App users shall be linked, for contacting the corresponding user when
problems occur. All users shall know their numbers on the ARC after creating their App accounts-->1
</userNo>
<adminType opt="Cloud,LAN">
<!--ro, opt, enum, admin type, subType:string, attr:opt{req, string}, desc:for hybrid security control panel, it is used for distinguishing whether the
administrator account is created on the cloud or in the local area network. It is displayed both on the App and the Web Client. "Cloud" (user account
created on the cloud), "LAN" (user account created on LAN)-->Cloud
</adminType>
<installerType opt="Cloud,LAN">
<!--ro, opt, enum, installer type, subType:string, attr:opt{req, string}, desc:for hybrid security control panel, it is used for distinguishing whether
the installer account is created on the cloud or in the local area network. It is displayed both on the App and the Web Client. "Cloud" (user account
created on the cloud), "LAN" (user account created on LAN)-->Cloud
</installerType>
<PasswordPeriodPrompt>
<!--ro, opt, object, configure notifications of the password validity period, desc:if the password validity period expired, a notification of password
expired shall be prompted during logging-in. password changing is not required in using-->
<passwordPeriodType opt="permanent,byDate" def="permanent">
<!--ro, req, enum, notification type of the password validity period, subType:string, attr:opt{req, string},def{req, string}, desc:"permanent" (take
effect permanently), "byDate" (take effect by day). Take effect permanently: notifications of the password expired shall not prompted permanently. Take
effect by day: notification of password expired shall be prompted in time, but password changing is not required in using-->permanent


effect by day: notification of password expired shall be prompted in time, but password changing is not required in using-->permanent
</passwordPeriodType>
<passwordPeriodbyDate min="1" max="1200" def="90">
<!--ro, opt, int, validity period of the password taking effect by day, range:[1,1200], unit:天, dep:and,
{$.User.PasswordPeriodPrompt.passwordPeriodType,eq,byDate}, attr:min{req, int},max{req, int},def{req, int}-->90
</passwordPeriodbyDate>
</PasswordPeriodPrompt>
<userActivationStatus opt="true,false">
<!--ro, opt, bool, user activation status, attr:opt{req, string}, desc:true (activated; default value), false (inactivated)-->true
</userActivationStatus>
<invalidDuressPassword opt="true,false">
<!--ro, opt, bool, whether current duress password is invalid, attr:opt{req, string}-->true
</invalidDuressPassword>
<userID min="1" max="64">
<!--ro, opt, string, user No., range:[1,64], attr:min{req, int},max{req, int}, desc:UUID (unique ID of the user)-->test
</userID>
</User>
21.2.5 Get information about all users
Request URL
GET /ISAPI/Security/users?security=<security>&iv=<iv>
Query Parameter
Parameter Name Parameter Type Description
security
string
iv
string
Request Message
None
Response Message
<?xml version="1.0" encoding="UTF-8"?>
<UserList xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--ro, req, object, user list, attr:version{req, string, protocolVersion}-->
<User>
<!--ro, opt, object, user-->
<id>
<!--ro, req, int, user parameter No., range:[1,64]-->1
</id>
<enabled>
<!--ro, opt, bool, whether to enable user-->true
</enabled>
<userName>
<!--ro, req, string, user name, range:[1,32]-->test
</userName>
<phoneNum>
<!--ro, opt, string, phone number, range:[1,11], desc:the sensitive information should be encrypted-->test
</phoneNum>
<emailAddress>
<!--ro, opt, string, email address, range:[1,32], desc:the sensitive information should be encrypted-->test
</emailAddress>
<duressPassword>
<!--ro, opt, string, duress password, range:[1,16], desc:the sensitive information should be encrypted-->test
</duressPassword>
<keypadPassword>
<!--ro, opt, string, keypad password, range:[1,16], desc:the sensitive information should be encrypted. entering password is required when the
security control panel is armed or disarmed via keypad-->test
</keypadPassword>
<singleKeypadEnable>
<!--ro, opt, bool, whether to enable the one-time keypad password-->true
</singleKeypadEnable>
<invalidkeypadPassword>
<!--ro, opt, bool, whether the current keypad password is invalid, desc:it is valid after setting singleKeypadEnable-->true
</invalidkeypadPassword>
<userOperateType>
<!--ro, opt, enum, user type, subType:int,
desc:1 (if userOperateType is 1 or none, password is valid. if method is POST, password is required. otherwise this node is optional)
2 (if userOperateType is 2, keypadPassword is valid. if method is POST, keypadPassword is required. otherwise this node is optional)
3 (if userOperateType is 3,both passwordkeypad and Password is valid. if method is POST, password and keypadPassword is required. otherwise this node is
optional) 1 (network user), 2 (keypad user), 3 (network user and keypad user)-->1
</userOperateType>
<bondIpAddressList>
<!--ro, opt, object, list of socket IP address that bound to the user-->
<bondIpAddress>
<!--ro, opt, object, socket IP address that bound to the user-->
<id>
<!--ro, req, int, bounded IP address No., range:[1,16], desc:it starts from 1-->1
</id>
<ipAddress>
-
-


<ipAddress>
<!--ro, opt, string, bounded IPv4 address, range:[1,32]-->test
</ipAddress>
<ipv6Address>
<!--ro, opt, string, bounded IPv6 address, range:[1,128]-->test
</ipv6Address>
</bondIpAddress>
</bondIpAddressList>
<bondMacAddressList>
<!--ro, opt, object, list of mac address that bound to the user-->
<bondMacAddress>
<!--ro, opt, object, mac address that bound to the user-->
<id>
<!--ro, req, int, bounded mac address No., range:[1,16], desc:it starts from 1-->1
</id>
<macAddress>
<!--ro, opt, string, bounded mac address, range:[1,32]-->test
</macAddress>
</bondMacAddress>
</bondMacAddressList>
<userLevel>
<!--ro, opt, enum, user level, subType:string, desc:"Administrator", "Operator", "Viewer" (viewer, which is not applied on devices currently),
"installer", "manufacturer", "single" (single user, which is not applied on devices currently), "installerAdmin" (installation admin), "installEmployee"
(installation employee), "Employee" (for attendance), "DepartmentManager" (department manager, for attendance)-->Administrator
</userLevel>
<attribute>
<!--ro, opt, object, user's special attributes-->
<inherent>
<!--ro, opt, bool, whether it can be deleted, desc:true (the user cannot be deleted), false / the node is invalid (the user can be deleted)-->true
</inherent>
</attribute>
<cardList>
<!--ro, opt, object, list of cards that belong to the user-->
<card>
<!--ro, opt, object, card-->
<id>
<!--ro, opt, int, No., range:[1,16]-->1
</id>
<name>
<!--ro, opt, string, name, range:[1,32]-->test
</name>
</card>
</cardList>
<remoteCtrlList>
<!--ro, opt, object, list of keyfobs that belong to the user-->
<remoteCtrl>
<!--ro, opt, object, keyfob-->
<id>
<!--ro, opt, int, No., range:[1,16]-->1
</id>
<name>
<!--ro, opt, string, name, range:[1,32]-->test
</name>
</remoteCtrl>
</remoteCtrlList>
<userNo>
<!--ro, opt, int, displayed No. corresponding to the user ID, desc:the No. is used on the App and the Web Client and reporting alarms to ARC. it is
valid to all user types. the format of the No. is 500 + id-->501
</userNo>
<adminType>
<!--ro, opt, enum, admin type, subType:string, desc:for hybrid security control panel, it is used for distinguishing whether the administrator account
is created on the cloud or in the local area network. It is displayed both on the App and the Web Client. "Cloud" (user account created on the cloud), "LAN"
(user account created on LAN)-->Cloud
</adminType>
<installerType>
<!--ro, opt, enum, installer type, subType:string, desc:for hybrid security control panel, it is used for distinguishing whether the installer account
is created on the cloud or in the local area network. It is displayed both on the App and the Web Client. "Cloud" (user account created on the cloud), "LAN"
(user account created on LAN)-->Cloud
</installerType>
<PasswordPeriodPrompt>
<!--ro, opt, object, configure notifications of the password validity period, desc:if the password validity period expired, a notification of password
expired shall be prompted during logging-in. password changing is not required in using-->
<passwordPeriodType>
<!--ro, req, enum, notification type of the password validity period, subType:string, desc:"permanent" (take effect permanently), "byDate" (take
effect by day). Take effect permanently: notifications of the password expired shall not prompted permanently. Take effect by day: notification of password
expired shall be prompted in time, but password changing is not required in using-->permanent
</passwordPeriodType>
<passwordPeriodbyDate>
<!--ro, opt, int, validity period of the password taking effect by day, range:[1,1200], unit:天, dep:and,
{$.User.PasswordPeriodPrompt.passwordPeriodType,eq,byDate}-->90
</passwordPeriodbyDate>
</PasswordPeriodPrompt>
<userActivationStatus>
<!--ro, opt, bool, user activation status, desc:true (activated; default value), false (inactivated)-->true
</userActivationStatus>
<invalidDuressPassword>
<!--ro, opt, bool, whether current duress password is invalid, desc:if the duress password is not configured, the value is true-->true
</invalidDuressPassword>
<userID>
<!--ro, opt, string, user No., range:[1,64], desc:UUID (unique ID of the user)-->test
</userID>
</User>
</UserList>


21.2.6 Set information about all users
Request URL
PUT /ISAPI/Security/users?security=<security>&iv=<iv>
Query Parameter
Parameter Name Parameter Type Description
security
string
iv
Request Message
string
-
-


<?xml version="1.0" encoding="UTF-8"?>
<UserList xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--req, object, user list, attr:version{req, string, protocolVersion}-->
<User>
<!--opt, object, user-->
<id>
<!--req, int, user parameter No., range:[1,64]-->1
</id>
<enabled>
<!--opt, bool, whether to enable user-->true
</enabled>
<userName>
<!--req, string, user name, range:[1,32]-->test
</userName>
<password>
<!--wo, req, string, password, range:[1,16], desc:the sensitive information should be encrypted-->test
</password>
<keypadPassword>
<!--wo, opt, string, keypad password, range:[1,16], desc:the sensitive information should be encrypted. The keypad password is required when the
security control panel is armed or disarmed via keypad-->test
</keypadPassword>
<userOperateType>
<!--opt, enum, user type, subType:int, desc:1 (network user), 2 (keypad user), 3 (network and keypad user). When userOperateType is 1 or none, the
node password is valid and it is required when the method is POST. When userOperateType is 2, the node keypadPassword is valid and it is required when the
method is POST. When userOperateType is 3, both nodes password and keypadPassword are valid and they are required when the method is POST.-->1
</userOperateType>
<bondIpAddressList>
<!--opt, object, list of socket IP address that bound to the user-->
<bondIpAddress>
<!--opt, object, socket IP address that bound to the user-->
<id>
<!--req, int, bounded IP address No., range:[1,16], desc:it starts from 1-->1
</id>
<ipAddress>
<!--opt, string, bounded IPv4 address, range:[1,32]-->test
</ipAddress>
<ipv6Address>
<!--opt, string, bounded IPv6 address, range:[1,32]-->test
</ipv6Address>
</bondIpAddress>
</bondIpAddressList>
<bondMacAddressList>
<!--opt, object, list of MAC address that bound to the user-->
<bondMacAddress>
<!--opt, object, MAC address that bound to the user-->
<id>
<!--req, int, bounded MAC address No., range:[1,16], desc:it starts from 1-->1
</id>
<macAddress>
<!--opt, string, bounded MAC address, range:[1,32]-->test
</macAddress>
</bondMacAddress>
</bondMacAddressList>
<userLevel>
<!--opt, enum, user level, subType:string, desc:"Administrator", "Operator", "Viewer", "installer", "manufacturer", "single" (single user),
"installerAdmin" (installation admin), "installEmployee" (installation employee)-->Administrator
</userLevel>
<attribute>
<!--opt, object, user's special attributes-->
<inherent>
<!--opt, bool, whether it can be deleted, desc:true (the user cannot be deleted), false/the node is invalid (the user can be deleted)-->true
</inherent>
</attribute>
<loginPassword>
<!--req, string, confirm password, range:[1,16], desc:confirming password is required when adding and editing user information. Encrypting the
sensitive information is required when the confirm password is transmitted via HTTP-->King726014
</loginPassword>
<PasswordPeriodPrompt>
<!--opt, object, configure notifications of the password validity period, desc:if the password validity period expired, a notification of password
expired shall be prompted during logging-in. password changing is not required in using-->
<passwordPeriodType>
<!--req, enum, notification type of the password validity period, subType:string, desc:"permanent" (take effect permanently), "byDate" (take effect
by day). Take effect permanently: notifications of the password expired shall not prompted permanently. Take effect by day: notification of password expired
shall be prompted in time, but password changing is not required in using-->permanent
</passwordPeriodType>
<passwordPeriodbyDate>
<!--opt, int, validity period of the password taking effect by day, range:[1,1200], unit:天, dep:and,
{$.User.PasswordPeriodPrompt.passwordPeriodType,eq,byDate}-->90
</passwordPeriodbyDate>
</PasswordPeriodPrompt>
<userID>
<!--opt, string, user No., range:[1,64], desc:UUID (unique ID of the user)-->test
</userID>
</User>
</UserList>
Response Message


<?xml version="1.0" encoding="UTF-8"?>
<ResponseStatus xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--ro, req, object, response message, attr:version{ro, req, string, protocolVersion}-->
<requestURL>
<!--ro, req, string, request URL-->null
</requestURL>
<statusCode>
<!--ro, req, enum, status code, subType:int, desc:0 (OK), 1 (OK), 2 (Device Busy), 3 (Device Error), 4 (Invalid Operation), 5 (Invalid XML Format), 6
(Invalid XML Content), 7 (Reboot Required)-->0
</statusCode>
<statusString>
<!--ro, req, enum, status information, subType:string, desc:"OK" (succeeded), "Device Busy", "Device Error", "Invalid Operation", "Invalid XML Format",
"Invalid XML Content", "Reboot" (reboot device)-->OK
</statusString>
<subStatusCode>
<!--ro, req, string, sub status code, which describes the error in details, desc:sub status code, which describes the error in details-->OK
</subStatusCode>
<lockStatus>
<!--ro, opt, enum, lock status, subType:string, desc:"lock", "unlock". It is returned when verifying loginPassword failed-->lock
</lockStatus>
<retryTimes>
<!--ro, opt, int, remaining attempts, range:[0,6], desc:it is returned when verifying loginPassword failed-->1
</retryTimes>
</ResponseStatus>
21.2.7 Set the user permission of the device
Request URL
PUT /ISAPI/Security/UserPermission
Query Parameter
None
Request Message
<?xml version="1.0" encoding="UTF-8"?>
<UserPermissionList xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--req, object, list of user permissions, attr:version{req, string, protocolVersion}-->
<UserPermission>
<!--req, object, user permissions-->
<id>
<!--req, string, index, range:[1,32]-->test
</id>
<userID>
<!--req, string, user ID, range:[1,32]-->test
</userID>
<userType>
<!--req, enum, user type, subType:string, desc:"admin" (administrator, who has all permissions and can review and edit user's permission), "operator"
(operator, who has default permissions), "viewer" (viewer, who has default permissions), "installer", "manufacturer", "single" (single user),
"installerAdmin" (installation admin), "installEmployee" (installation employee)-->admin
</userType>
<localPermission>
<!--opt, object, local permission node, dep:or,{$.UserPermissionList.UserPermission.localPermission.operationScheduleEnabled,eq,true}-->
<backup>
<!--opt, bool, whether to enable the backup permission (of all channels), desc:true (enable), false (disable)-->true
</backup>
<record>
<!--opt, bool, whether to enable the recording permission (of all channels), desc:true (enable), false (disable)-->true
</record>
<playBack>
<!--opt, bool, whether to enable the playback permission (of all channels), desc:true (enable), false (disable)-->true
</playBack>
<preview>
<!--opt, bool, whether to enable the live view permission (of all channels), desc:true (enable), false (disable)-->true
</preview>
<videoChannelPermissionList>
<!--opt, object, list of configuring permission for video channel-->
<videoChannelPermission>
<!--opt, object, configure the permission for a single video channel-->
<id>
<!--req, string, video channel ID, range:[1,32]-->test
</id>
<playBack>
<!--opt, bool, whether to enable the playback permission of the current channel, desc:true (enable), false (disable)-->true
</playBack>
<preview>
<!--opt, bool, whether to enable the live view permission of the current channel, desc:true (enable), false (disable)-->true
</preview>
<record>
<!--opt, bool, whether to enable the recording permission of the current channel, desc:true (enable), false (disable)-->true
</record>
<backup>
<!--opt, bool, whether to enable the backup permission of the current channel, desc:true (enable), false (disable)-->true
</backup>


</backup>
<playBackDoubleVerification>
<!--opt, bool, whether to enable double verification permission for playback of the current channel, desc:true (enable), false (disable)-->true
</playBackDoubleVerification>
<backupDoubleVerification>
<!--opt, bool, whether to enable the recording permission for backup of the current channel, desc:true (enable), false (disable)-->true
</backupDoubleVerification>
</videoChannelPermission>
</videoChannelPermissionList>
<ptzControl>
<!--req, bool, whether to enable the PTZ control permission (of all channels), desc:true (enable), false (disable)-->true
</ptzControl>
<ptzChannelPermissionList>
<!--opt, object, list of permission for PTZ control of the video channels-->
<ptzChannelPermission>
<!--req, object, the permission for PTZ control of a specific video channel-->
<id>
<!--req, string, video channel ID, range:[1,32]-->test
</id>
<ptzControl>
<!--opt, bool, whether to enable the PTZ control permission of the current channel, desc:true (enable), false (disable)-->true
</ptzControl>
</ptzChannelPermission>
</ptzChannelPermissionList>
<logOrStateCheck>
<!--opt, bool, whether to enable permission for checking logs and device status, desc:true (enable), false (disable)-->true
</logOrStateCheck>
<parameterConfig>
<!--opt, bool, whether to enable the remote parameters setting permission of the device, desc:true (enable), false (disable)-->true
</parameterConfig>
<restartOrShutdown>
<!--opt, bool, whether to enable the permission to reboot or power off, desc:true (enable), false (disable)-->true
</restartOrShutdown>
<upgrade>
<!--opt, bool, whether to enable the upgrade permission, desc:true (enable), false (disable)-->true
</upgrade>
<manageChannel>
<!--opt, bool, whether to enable the channel management permission, desc:true (enable), false (disable)-->true
</manageChannel>
<AIModelManagement>
<!--opt, bool, whether to enable permission for operation on the AI model packet, desc:true (enable), false (disable)-->true
</AIModelManagement>
<AITaskManagement>
<!--opt, bool, whether to enable permission for managemengt and operation on the AI model packet, desc:true (enable), false (disable)-->true
</AITaskManagement>
<subSysOrZoneArm>
<!--opt, bool, arm permission of partition/alarm zone-->true
</subSysOrZoneArm>
<subSysOrZoneDisarm>
<!--opt, bool, disarm permission of partition/alarm zone-->true
</subSysOrZoneDisarm>
<operateOutput>
<!--opt, bool, permission for operation on relay-->true
</operateOutput>
<subSystemList>
<!--opt, object, partition list, desc:the user can link to the subsystem when adding or configuring operator-->
<subSystem>
<!--opt, int, partition, range:[1,64]-->1
</subSystem>
</subSystemList>
<localFileMgr>
<!--opt, bool-->true
</localFileMgr>
<LEDConfig>
<!--opt, bool-->true
</LEDConfig>
<logMgr>
<!--opt, bool-->true
</logMgr>
<TIPConfig>
<!--opt, bool-->true
</TIPConfig>
<securityFunctionCfg>
<!--opt, bool-->true
</securityFunctionCfg>
<netWorkCfg>
<!--opt, bool-->true
</netWorkCfg>
<ISUPAccess>
<!--opt, bool-->true
</ISUPAccess>
<timeMgr>
<!--opt, bool-->true
</timeMgr>
<HDDMgr>
<!--opt, bool-->true
</HDDMgr>
<securitySystemMaintenance>
<!--opt, bool-->true
</securitySystemMaintenance>
<securityCheckingPicExport>
<!--opt, bool-->true
</securityCheckingPicExport>
<securityCheckingPicDelete>


<securityCheckingPicDelete>
<!--opt, bool-->true
</securityCheckingPicDelete>
<operationScheduleList>
<!--opt, array, subType:object, dep:or,{$.UserPermissionList.UserPermission.localPermission.operationScheduleEnabled,eq,true}-->
<operationSchedule>
<!--opt, object-->
<operationScheduleEnabled>
<!--opt, bool-->true
</operationScheduleEnabled>
<operationDetailItem>
<!--opt, enum, subType:string-->arm
</operationDetailItem>
<timeRange>
<!--opt, object-->
<beginTime>
<!--opt, time-->00:00:00
</beginTime>
<endTime>
<!--opt, time-->00:00:00
</endTime>
</timeRange>
</operationSchedule>
</operationScheduleList>
</localPermission>
<remotePermission>
<!--opt, object, remote permission node-->
<record>
<!--opt, bool, whether to enable the recording permission (of all channels), desc:true (enable), false (disable)-->true
</record>
<playBack>
<!--opt, bool, whether to enable the playback permission (of all channels), desc:true (enable), false (disable)-->true
</playBack>
<preview>
<!--opt, bool, whether to enable the live view permission (of all channels), desc:true (enable), false (disable)-->true
</preview>
<videoChannelPermissionList>
<!--opt, object, list of configuring permission for video channel-->
<videoChannelPermission>
<!--opt, object, configure the permission for a single video channel-->
<id>
<!--req, string, video channel ID, range:[1,32]-->test
</id>
<preview>
<!--opt, bool, whether to enable the live view permission of the current channel, desc:true (enable), false (disable)-->true
</preview>
<playBack>
<!--opt, bool, whether to enable the playback permission of the current channel, desc:true (enable), false (disable)-->true
</playBack>
<record>
<!--opt, bool, whether to enable the recording permission of the current channel, desc:true (enable), false (disable)-->true
</record>
<playBackDoubleVerification>
<!--opt, bool, whether to enable double verification permission for playback of the current channel, desc:true (enable), false (disable)-->true
</playBackDoubleVerification>
</videoChannelPermission>
</videoChannelPermissionList>
<ptzControl>
<!--opt, bool, whether to enable the PTZ control permission (of all channels), desc:true (enable), false (disable)-->true
</ptzControl>
<ptzChannelPermissionList>
<!--opt, object, list of permission for PTZ control of the video channels-->
<ptzChannelPermission>
<!--opt, object, the permission for PTZ control of a specific video channel-->
<id>
<!--req, string, video channel ID, range:[1,32], desc:/ISAPI/PTZCtrl/channels/ID-->test
</id>
<ptzControl>
<!--opt, bool, whether to enable the PTZ control permission of the current channel, desc:true (enable), false (disable)-->true
</ptzControl>
</ptzChannelPermission>
</ptzChannelPermissionList>
<logOrStateCheck>
<!--opt, bool, whether to enable permission for checking logs and device status-->true
</logOrStateCheck>
<parameterConfig>
<!--opt, bool, whether to enable the remote parameters setting permission of the device-->true
</parameterConfig>
<restartOrShutdown>
<!--opt, bool, whether to enable the permission to reboot or power off-->true
</restartOrShutdown>
<upgrade>
<!--opt, bool, whether to enable the upgrade permission-->true
</upgrade>
<upgradeNotShow>
<!--opt, bool, the upgrade is not displayed, desc:whether to support upgrade permission both for the admin user and installer user to ensure
compatibility, true (support), false or this node is not returned (not support)-->true
</upgradeNotShow>
<voiceTalk>
<!--opt, bool, whether to enable the two-way audio permission (of all channels)-->true
</voiceTalk>
<transParentChannel>
<!--opt, bool, whether to enable the transparent channel, desc:namely, the serial port control-->true
</transParentChannel>
<contorlLocalOut>


<contorlLocalOut>
<!--opt, bool, whether to enable the local output control permission-->true
</contorlLocalOut>
<manageChannel>
<!--opt, bool, whether to enable the channel management permission-->true
</manageChannel>
<alarmOutOrUpload>
<!--opt, bool, whether to enable permission for alarm uploading and output-->true
</alarmOutOrUpload>
<IRAID>
<!--opt, object, permission for Iraid quick configuration-->
<rapidConfiguration>
<!--opt, bool, whether to enable permission for Iraid quick configuration-->true
</rapidConfiguration>
<reset>
<!--opt, bool, whether to enable permission for restoring Iraid configuration-->true
</reset>
</IRAID>
<LEDConfig>
<!--opt, bool, whether it allows the user to edit the LED configuration-->true
</LEDConfig>
<AIModelManagement>
<!--opt, bool, whether to enable permission for operation on the AI model packet-->true
</AIModelManagement>
<AITaskManagement>
<!--opt, bool, whether to enable permission for management and operation on AI tasks-->true
</AITaskManagement>
<materialReview>
<!--opt, bool, material checking permission, desc:information release-->true
</materialReview>
<programReview>
<!--opt, bool, program checking permission, desc:information release-->true
</programReview>
<uploadMaterial>
<!--opt, bool, upload material, desc:information release-->true
</uploadMaterial>
<addProgram>
<!--opt, bool, program editing permission, desc:add, delete, and edit-->true
</addProgram>
<addSchedule>
<!--opt, bool, schedule editing permission, desc:add, delete, and edit-->true
</addSchedule>
<programPlay>
<!--opt, bool, information playing permission-->true
</programPlay>
<terminalMgr>
<!--opt, bool, terminal management permission, desc:set the backlight and logo light parameters of the terminal-->true
</terminalMgr>
<shopSmart>
<!--opt, bool, permission for shop smart-->true
</shopSmart>
<materialReplace>
<!--opt, bool, permission to replace materials-->true
</materialReplace>
<scheduleRelease>
<!--opt, bool, permission for releasing schedule-->true
</scheduleRelease>
<scheduleReview>
<!--opt, bool, schedule checking-->true
</scheduleReview>
<addTerminal>
<!--opt, bool, terminal adding-->true
</addTerminal>
<terminalDispatch>
<!--opt, bool, permission to relocate terminals, desc:to relocate the terminals under this organization to lower-level organizations-->true
</terminalDispatch>
<addUser>
<!--opt, bool, the permission of editing the user information, desc:add, delete, and edit-->true
</addUser>
<addOrg>
<!--opt, bool, the permission for editing organizations, desc:add, delete, and edit-->true
</addOrg>
<logMgr>
<!--opt, bool, log management-->true
</logMgr>
<dataUpdate>
<!--opt, bool, data update, desc:calling data-->true
</dataUpdate>
<insertMessage>
<!--opt, bool, the permission for cutting texts-->true
</insertMessage>
<notReview>
<!--opt, bool, the permission for free-review-->true
</notReview>
<MgrTerminal>
<!--opt, object, the managed terminals or terminal group-->
<TerminalNoList>
<!--opt, object, terminal No. list-->
<terminalNo>
<!--opt, int, terminal No., range:[1,10]-->1
</terminalNo>
</TerminalNoList>
<TerminalGroupNoList>
<!--opt, object, terminal group list-->


<!--opt, object, terminal group list-->
<terminalGroupNo>
<!--opt, int, terminal group No., range:[1,10]-->1
</terminalGroupNo>
</TerminalGroupNoList>
</MgrTerminal>
<subSysOrZoneArm>
<!--opt, bool, arm permission of partition/alarm zone-->true
</subSysOrZoneArm>
<subSysOrZoneDisarm>
<!--opt, bool, disarm permission of partition/alarm zone-->true
</subSysOrZoneDisarm>
<subSysOrZoneClearArm>
<!--opt, bool, clear alarm permission of partition/alarm zone-->true
</subSysOrZoneClearArm>
<zoneBypass>
<!--opt, bool, bypass permission in alarm zone-->true
</zoneBypass>
<zoneBypassRecover>
<!--opt, bool, bypass recovery permission in alarm zone-->true
</zoneBypassRecover>
<operateOutput>
<!--opt, bool, permission for operation on relay-->true
</operateOutput>
<subSystemList>
<!--opt, object, partition list, desc:the user can link to the subsystem when adding or configuring operator-->
<subSystem>
<!--opt, int, partition, range:[1,64]-->1
</subSystem>
</subSystemList>
<factoryReset>
<!--opt, bool, restore to default parameters-->true
</factoryReset>
<arm>
<!--opt, bool, arm-->true
</arm>
<disarm>
<!--opt, bool, disarm-->true
</disarm>
<LPListAudit>
<!--opt, bool, permission for blockclist and allowlist operations,
desc:users with this permission can import/export/edit/delete/search for blockclist and allowlist; the related URIs are as follows:
URI for searching for the license plate blocklist and allowlist: /ISAPI/Traffic/channels/<ID>/searchLPListAudit;
URI for importing/exporting the license plate blocklist and allowlist data: /ISAPI/Traffic/channels/<ID>/licensePlateAuditData;
URI for editing the license plate list: /ISAPI/Traffic/channels/<channelID>/licensePlateAuditData/record?format=json;
URI for deleting the license plate blocklist and allowlist: /ISAPI/Traffic/channels/<channelID>/licensePlateAuditData/delete?format=json-->true
</LPListAudit>
<applicationWarehouse>
<!--opt, bool, app library management permission, desc:this node is not returned if it is not supported-->true
</applicationWarehouse>
<subSystemManagement>
<!--opt, bool, permission for subsystem management, desc:which includes all the permissions related to subsystem management-->true
</subSystemManagement>
<userOfModifyKeypadPasswordList>
<!--opt, array, list of users allowed to change keypad password, subType:object-->
<userOfModifyKeypadPassword>
<!--opt, object, users allowed to change keypad password-->
<subUserType>
<!--opt, enum, type of sub-users, subType:string, desc:cloudAdmin-cloud admin, localAdmin-local admin, installerAdmin-installer admin,
installEmployee-install employee, localInstaller-local installer, cloudOperator-cloud operator, localOperator-local operator-->cloudAdmin
</subUserType>
</userOfModifyKeypadPassword>
</userOfModifyKeypadPasswordList>
<userOfModifyUserPermissionList>
<!--opt, array, list of users allowed to edit users permission, subType:object-->
<userOfModifyUserPermission>
<!--opt, object, users allowed to edit users permission-->
<subUserType>
<!--opt, enum, type of sub-users, subType:string, desc:cloudAdmin-cloud admin, localAdmin-local admin, installerAdmin-installer admin,
installEmployee-install employee, localInstaller-local installer, cloudOperator-cloud operator, localOperator-local operator-->cloudAdmin
</subUserType>
</userOfModifyUserPermission>
</userOfModifyUserPermissionList>
<falseAlarmMaterialLibMgr>
<!--opt, bool, permission for the false alarm analysis library management-->true
</falseAlarmMaterialLibMgr>
<TIPConfig>
<!--opt, bool-->true
</TIPConfig>
<netWorkCfg>
<!--opt, bool-->true
</netWorkCfg>
<ISUPAccess>
<!--opt, bool-->true
</ISUPAccess>
<timeMgr>
<!--opt, bool-->true
</timeMgr>
<HDDMgr>
<!--opt, bool-->true
</HDDMgr>
</remotePermission>
<passwordValidity>
<!--opt, int, password validity period, range:[0,365], desc:unit: day, [0, 365]; only the administrator can edit-->1


</passwordValidity>
<subUserType>
<!--opt, enum, type of sub-users, subType:string, desc:cloudAdmin-cloud admin, localAdmin-local admin, installerAdmin-installer admin,
installEmployee-install employee, localInstaller-local installer, cloudOperator-cloud operator, localOperator-local operator-->cloudAdmin
</subUserType>
</UserPermission>
</UserPermissionList>
Response Message
<?xml version="1.0" encoding="UTF-8"?>
<ResponseStatus xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--ro, req, object, response message, attr:version{ro, req, string, protocolVersion}-->
<requestURL>
<!--ro, req, string, request URL-->null
</requestURL>
<statusCode>
<!--ro, req, enum, status code, subType:int, desc:0 (OK), 1 (OK), 2 (Device Busy), 3 (Device Error), 4 (Invalid Operation), 5 (Invalid XML Format), 6
(Invalid XML Content), 7 (Reboot Required)-->0
</statusCode>
<statusString>
<!--ro, req, enum, status description, subType:string, desc:“OK” (succeeded), “Device Busy”, “Device Error”, “Invalid Operation”, “Invalid XML Format”,
“Invalid XML Content”, “Reboot” (reboot device)-->OK
</statusString>
<subStatusCode>
<!--ro, req, string, sub status code, desc:sub status code-->OK
</subStatusCode>
<AttachInfo>
<!--ro, opt, object, the additional information of returned status of batch operation, desc:this node is returned when the statusCode is 8 (Batch
Operation)-->
<StatusList>
<!--ro, req, object, status information list-->
<Status>
<!--ro, req, object, status information-->
<index>
<!--ro, req, int, ID, desc:it is used for adding every resource information of the list when recognizing batch adding, and it corresponds to the
resource parameters of the batch adding-->0
</index>
<statusCode>
<!--ro, req, enum, status code, subType:int, desc:it only indicates the status of the subsystem operation, and its return mode is the same with
the above nodes; 0 (OK), 1 (OK), 2 (Device Busy), 3 (Device Error), 4 (Invalid Operation), 5 (Invalid XML Format), 6 (Invalid XML Content), 7 (Reboot
Required)-->0
</statusCode>
<statusString>
<!--ro, req, enum, status information, subType:string, desc:it only indicates the status of the subsystem operation, and its return mode is the
same with the above nodes; "OK" (succeeded), "Device Busy", "Device Error", "Invalid Operation", "Invalid XML Format", "Invalid XML Content", "Reboot"
(reboot device)-->OK
</statusString>
<subStatusCode>
<!--ro, req, string, sub status code, which describes the error in details, range:[1,64], desc:it only indicates the status of the subsystem
operation, and its return mode is the same with the above nodes-->ok
</subStatusCode>
</Status>
</StatusList>
</AttachInfo>
</ResponseStatus>
21.2.8 Get all users' permission
Request URL
GET /ISAPI/Security/UserPermission
Query Parameter
None
Request Message
None
Response Message
<?xml version="1.0" encoding="UTF-8"?>
<UserPermissionList xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--ro, req, array, list of user permissions, subType:object, attr:version{req, string, protocolVersion}-->
<UserPermission>
<!--ro, req, object, user permissions-->
<id>
<!--ro, req, string, index, range:[1,32]-->test
</id>
<userID>
<!--ro, req, string, user ID, range:[1,32]-->test
</userID>


</userID>
<userType>
<!--ro, req, enum, user type, subType:string, desc:"admin" (administrator, who has all permissions and can review and edit user's permission),
"operator" (operator, who has default permissions), "viewer" (viewer, who has default permissions), "installer", "manufacturer", "single" (single user)-
>admin
</userType>
<localPermission>
<!--ro, opt, object, local permission node-->
<backup>
<!--ro, opt, bool, whether to enable the backup permission (of all channels), desc:true (enable), false (disable)-->true
</backup>
<record>
<!--ro, opt, bool, whether to enable the recording permission (of all channels), desc:true (enable), false (disable)-->true
</record>
<playBack>
<!--ro, opt, bool, whether to enable the playback permission (of all channels), desc:true (enable), false (disable)-->true
</playBack>
<preview>
<!--ro, opt, bool, whether to enable the live view permission (of all channels), desc:true (enable), false (disable)-->true
</preview>
<videoChannelPermissionList>
<!--ro, opt, object, list of configuring permission for video channel-->
<videoChannelPermission>
<!--ro, opt, object, configure the permission for a single video channel-->
<id>
<!--ro, req, string, video channel ID, range:[1,32]-->test
</id>
<playBack>
<!--ro, opt, bool, whether to enable the playback permission of the current channel, desc:true (enable), false (disable)-->true
</playBack>
<preview>
<!--ro, opt, bool, whether to enable the live view permission of the current channel, desc:true (enable), false (disable)-->true
</preview>
<record>
<!--ro, opt, bool, whether to enable the recording permission of the current channel, desc:true (enable), false (disable)-->true
</record>
<backup>
<!--ro, opt, bool, whether to enable the backup permission of the current channel, desc:true (enable), false (disable)-->true
</backup>
<playBackDoubleVerification>
<!--ro, opt, bool, whether to enable double verification permission for playback of the current channel, desc:true (enable), false (disable)-
>true
</playBackDoubleVerification>
<backupDoubleVerification>
<!--ro, opt, bool, whether to enable the recording permission for backup of the current channel, desc:true (enable), false (disable)-->true
</backupDoubleVerification>
</videoChannelPermission>
</videoChannelPermissionList>
<ptzControl>
<!--ro, req, bool, whether to enable the PTZ control permission (of all channels), desc:true (enable), false (disable)-->true
</ptzControl>
<ptzChannelPermissionList>
<!--ro, opt, object, list of permission for PTZ control of the video channels-->
<ptzChannelPermission>
<!--ro, req, object, the permission for PTZ control of a specific video channel-->
<id>
<!--ro, req, string, video channel ID, range:[1,32]-->test
</id>
<ptzControl>
<!--ro, opt, bool, whether to enable the PTZ control permission of the current channel, desc:true (enable), false (disable)-->true
</ptzControl>
</ptzChannelPermission>
</ptzChannelPermissionList>
<logOrStateCheck>
<!--ro, opt, bool, whether to enable permission for checking logs and device status, desc:true (enable), false (disable)-->true
</logOrStateCheck>
<parameterConfig>
<!--ro, opt, bool, whether to enable the remote parameters setting permission of the device, desc:true (enable), false (disable)-->true
</parameterConfig>
<restartOrShutdown>
<!--ro, opt, bool, whether to enable the permission to reboot or power off, desc:true (enable), false (disable)-->true
</restartOrShutdown>
<upgrade>
<!--ro, opt, bool, whether to enable the upgrade permission, desc:true (enable), false (disable)-->true
</upgrade>
<manageChannel>
<!--ro, opt, bool, whether to enable the channel management permission, desc:true (enable), false (disable)-->true
</manageChannel>
<AIModelManagement>
<!--ro, opt, bool, whether to enable permission for operation on the AI model packet, desc:true (enable), false (disable)-->true
</AIModelManagement>
<AITaskManagement>
<!--ro, opt, bool, whether to enable permission for managemengt and operation on the AI model packet, desc:true (enable), false (disable)-->true
</AITaskManagement>
<subSysOrZoneArm>
<!--ro, opt, bool, arm permission of partition/alarm zone-->true
</subSysOrZoneArm>
<subSysOrZoneDisarm>
<!--ro, opt, bool, disarm permission of partition/alarm zone-->true
</subSysOrZoneDisarm>
<operateOutput>
<!--ro, opt, bool, permission for operation on relay-->true
</operateOutput>
<supportLinkageSubSystemList>


<!--ro, opt, object, list of the partitions that support linkage-->
<subSystem>
<!--ro, opt, int, the partition that supports linkage, range:[1,64]-->1
</subSystem>
</supportLinkageSubSystemList>
<subSystemList>
<!--ro, opt, array, partition list, subType:object, desc:the user can link to the subsystem when adding or configuring operator-->
<subSystem>
<!--ro, opt, int, partition, range:[1,64]-->1
</subSystem>
</subSystemList>
</localPermission>
<remotePermission>
<!--ro, opt, object, remote permission node-->
<record>
<!--ro, opt, bool, whether to enable the recording permission (of all channels), desc:true (enable), false (disable)-->true
</record>
<playBack>
<!--ro, opt, bool, whether to enable the playback permission (of all channels), desc:true (enable), false (disable)-->true
</playBack>
<preview>
<!--ro, opt, bool, whether to enable the live view permission (of all channels), desc:true (enable), false (disable)-->true
</preview>
<videoChannelPermissionList>
<!--ro, opt, object, list of configuring permission for video channel-->
<videoChannelPermission>
<!--ro, opt, object, configure the permission for a single video channel-->
<id>
<!--ro, req, string, corresponding video channel ID, range:[1,32]-->test
</id>
<preview>
<!--ro, opt, bool, whether to enable the live view permission of the current channel, desc:true (enable), false (disable)-->true
</preview>
<playBack>
<!--ro, opt, bool, whether to enable the playback permission of the current channel, desc:true (enable), false (disable)-->true
</playBack>
<record>
<!--ro, opt, bool, whether to enable the recording permission of the current channel, desc:true (enable), false (disable)-->true
</record>
<playBackDoubleVerification>
<!--ro, opt, bool, whether to enable double verification permission for playback of the current channel, desc:true (enable), false (disable)-
>true
</playBackDoubleVerification>
</videoChannelPermission>
</videoChannelPermissionList>
<ptzControl>
<!--ro, opt, bool, whether to enable the PTZ control permission (of all channels), desc:true (enable), false (disable)-->true
</ptzControl>
<ptzChannelPermissionList>
<!--ro, opt, object, list of permission for PTZ control of the video channels-->
<ptzChannelPermission>
<!--ro, opt, object, the permission for PTZ control of a specific video channel-->
<id>
<!--ro, req, string, video channel ID, range:[1,32], desc:/ISAPI/PTZCtrl/channels/ID-->test
</id>
<ptzControl>
<!--ro, opt, bool, whether to enable the PTZ control permission of the current channel, desc:true (enable), false (disable)-->true
</ptzControl>
</ptzChannelPermission>
</ptzChannelPermissionList>
<logOrStateCheck>
<!--ro, opt, bool, whether to enable permission for checking logs and device status-->true
</logOrStateCheck>
<parameterConfig>
<!--ro, opt, bool, whether to enable the remote parameters setting permission of the device-->true
</parameterConfig>
<restartOrShutdown>
<!--ro, opt, bool, whether to enable the permission to reboot or power off-->true
</restartOrShutdown>
<upgrade>
<!--ro, opt, bool, whether to enable the upgrade permission-->true
</upgrade>
<upgradeNotShow>
<!--ro, opt, bool, the upgrade is not displayed, desc:whether to support upgrade permission both for the admin user and installer user to ensure
compatibility, true (support), false or this node is not returned (not support)-->true
</upgradeNotShow>
<voiceTalk>
<!--ro, opt, bool, whether to enable the two-way audio permission (of all channels)-->true
</voiceTalk>
<transParentChannel>
<!--ro, opt, bool, whether to enable the transparent channel, desc:namely, the serial port control-->true
</transParentChannel>
<contorlLocalOut>
<!--ro, opt, bool, whether to enable the local output control permission-->true
</contorlLocalOut>
<manageChannel>
<!--ro, opt, bool, whether to enable the channel management permission-->true
</manageChannel>
<alarmOutOrUpload>
<!--ro, opt, bool, whether to enable permission for alarm uploading and output-->true
</alarmOutOrUpload>
<IRAID>
<!--ro, opt, object, permission for Iraid quick configuration-->
<rapidConfiguration>


<rapidConfiguration>
<!--ro, opt, bool, whether to enable permission for Iraid quick configuration-->true
</rapidConfiguration>
<reset>
<!--ro, opt, bool, whether to enable permission for restoring Iraid configuration-->true
</reset>
</IRAID>
<LEDConfig>
<!--ro, opt, bool, whether it allows the user to edit the LED configuration-->true
</LEDConfig>
<AIModelManagement>
<!--ro, opt, bool, whether to enable permission for operation on the AI model packet-->true
</AIModelManagement>
<AITaskManagement>
<!--ro, opt, bool, whether to enable permission for management and operation on AI tasks-->true
</AITaskManagement>
<materialReview>
<!--ro, opt, bool, material checking permission, desc:information release-->true
</materialReview>
<programReview>
<!--ro, opt, bool, program checking permission, desc:information release-->true
</programReview>
<uploadMaterial>
<!--ro, opt, bool, upload material, desc:information release-->true
</uploadMaterial>
<addProgram>
<!--ro, opt, bool, program editing permission, desc:add, delete, and edit-->true
</addProgram>
<addSchedule>
<!--ro, opt, bool, schedule editing permission, desc:add, delete, and edit-->true
</addSchedule>
<programPlay>
<!--ro, opt, bool, information playing permission-->true
</programPlay>
<terminalMgr>
<!--ro, opt, bool, terminal management permission, desc:set the backlight and logo light parameters of the terminal-->true
</terminalMgr>
<shopSmart>
<!--ro, opt, bool, permission for shop smart-->true
</shopSmart>
<materialReplace>
<!--ro, opt, bool, permission to replace materials-->true
</materialReplace>
<scheduleRelease>
<!--ro, opt, bool, permission for releasing schedule-->true
</scheduleRelease>
<scheduleReview>
<!--ro, opt, bool, schedule checking-->true
</scheduleReview>
<addTerminal>
<!--ro, opt, bool, terminal adding-->true
</addTerminal>
<terminalDispatch>
<!--ro, opt, bool, permission to relocate terminals, desc:to relocate the terminals under this organization to lower-level organizations-->true
</terminalDispatch>
<addUser>
<!--ro, opt, bool, the permission for editing the user information, desc:add, delete, and edit-->true
</addUser>
<addOrg>
<!--ro, opt, bool, the permission for editing organizations, desc:add, delete, and edit-->true
</addOrg>
<logMgr>
<!--ro, opt, bool, log management-->true
</logMgr>
<dataUpdate>
<!--ro, opt, bool, data update, desc:calling data-->true
</dataUpdate>
<insertMessage>
<!--ro, opt, bool, the permission for cutting texts-->true
</insertMessage>
<notReview>
<!--ro, opt, bool, the permission for free-review-->true
</notReview>
<MgrTerminal>
<!--ro, opt, object, the managed terminals or terminal group-->
<TerminalNoList>
<!--ro, opt, object, terminal No. list-->
<terminalNo>
<!--ro, opt, int, terminal No., range:[1,10]-->1
</terminalNo>
</TerminalNoList>
<TerminalGroupNoList>
<!--ro, opt, object, terminal group list-->
<terminalGroupNo>
<!--ro, opt, int, terminal group No., range:[1,10]-->1
</terminalGroupNo>
</TerminalGroupNoList>
</MgrTerminal>
<subSysOrZoneArm>
<!--ro, opt, bool, arm permission of partition/alarm zone-->true
</subSysOrZoneArm>
<subSysOrZoneDisarm>
<!--ro, opt, bool, disarm permission of partition/alarm zone-->true
</subSysOrZoneDisarm>


<subSysOrZoneClearArm>
<!--ro, opt, bool, clear alarm permission of partition/alarm zone-->true
</subSysOrZoneClearArm>
<zoneBypass>
<!--ro, opt, bool, bypass permission in alarm zone-->true
</zoneBypass>
<zoneBypassRecover>
<!--ro, opt, bool, bypass recovery permission in alarm zone-->true
</zoneBypassRecover>
<operateOutput>
<!--ro, opt, bool, permission for operation on relay-->true
</operateOutput>
<supportLinkageSubSystemList>
<!--ro, opt, object, list of the partitions that support linkage-->
<subSystem>
<!--ro, opt, int, the partition that supports linkage, range:[1,64]-->1
</subSystem>
</supportLinkageSubSystemList>
<subSystemList>
<!--ro, opt, object, partition list, desc:the user can link to the subsystem when adding or configuring operator-->
<subSystem>
<!--ro, opt, int, partition, range:[1,64]-->1
</subSystem>
</subSystemList>
<factoryReset>
<!--ro, opt, bool, restore to default parameters-->true
</factoryReset>
<arm>
<!--ro, opt, bool, arm-->true
</arm>
<disarm>
<!--ro, opt, bool, disarm-->true
</disarm>
<accessControl>
<!--ro, opt, bool, access control-->true
</accessControl>
<restoreTamper>
<!--ro, opt, bool, restore the tamper-proof setting, desc:for usage details, refer to /ISAPI/Security/UserPermission/capabilities-->true
</restoreTamper>
<restoreConfirmedAlarm>
<!--ro, opt, bool, restore the acknowledging alarm setting, desc:for usage details, refer to /ISAPI/Security/UserPermission/capabilities-->true
</restoreConfirmedAlarm>
<LPListAudit>
<!--ro, opt, bool, permission for blockclist and allowlist operations,
desc:users with this permission can import/export/edit/delete/search for blockclist and allowlist; the related URIs are as follows:
URI for searching for the license plate blocklist and allowlist: /ISAPI/Traffic/channels/<ID>/searchLPListAudit;
URI for importing/exporting the license plate blocklist and allowlist data: /ISAPI/Traffic/channels/<ID>/licensePlateAuditData;
URI for editing the license plate list: /ISAPI/Traffic/channels/<channelID>/licensePlateAuditData/record?format=json;
URI for deleting the license plate blocklist and allowlist: /ISAPI/Traffic/channels/<channelID>/licensePlateAuditData/delete?format=json-->true
</LPListAudit>
<applicationWarehouse>
<!--ro, opt, bool, app library management permission, desc:this node is not returned if it is not supported with management permission, users can
perform operations such as importing, deleting and starting HEOP APP-->true
</applicationWarehouse>
<subSystemManagement>
<!--ro, opt, bool, permission for subsystem management, desc:which includes all the permissions related to subsystem management-->true
</subSystemManagement>
<userOfModifyKeypadPasswordList>
<!--ro, opt, array, list of users allowed to change keypad password, subType:object-->
<userOfModifyKeypadPassword>
<!--ro, opt, object, users allowed to change keypad password-->
<subUserType>
<!--ro, opt, enum, type of sub-users, subType:string, desc:cloudAdmin-cloud admin, localAdmin-local admin, installerAdmin-installer admin,
installEmployee-install employee, localInstaller-local installer, cloudOperator-cloud operator, localOperator-local operator-->cloudAdmin
</subUserType>
</userOfModifyKeypadPassword>
</userOfModifyKeypadPasswordList>
<userOfModifyUserPermissionList>
<!--ro, opt, array, list of users allowed to edit users permission, subType:object-->
<userOfModifyUserPermission>
<!--ro, opt, object, users allowed to edit users permission-->
<subUserType>
<!--ro, opt, enum, type of sub-users, subType:string, desc:cloudAdmin-cloud admin, localAdmin-local admin, installerAdmin-installer admin,
installEmployee-install employee, localInstaller-local installer, cloudOperator-cloud operator, localOperator-local operator-->cloudAdmin
</subUserType>
</userOfModifyUserPermission>
</userOfModifyUserPermissionList>
<falseAlarmMaterialLibMgr>
<!--ro, opt, bool, permission for the false alarm analysis library management-->true
</falseAlarmMaterialLibMgr>
</remotePermission>
<passwordValidity>
<!--ro, opt, int, password validity period, range:[0,365], desc:unit: day, [0, 365]; only the administrator can edit-->1
</passwordValidity>
<subUserType>
<!--ro, opt, enum, type of sub-users, subType:string, desc:cloudAdmin-cloud admin, localAdmin-local admin, installerAdmin-installer admin,
installEmployee-install employee, localInstaller-local installer, cloudOperator-cloud operator, localOperator-local operator-->cloudAdmin
</subUserType>
</UserPermission>
</UserPermissionList>


21.2.9 Set permissions for a single user
Request URL
PUT /ISAPI/Security/UserPermission/<indexID>
Query Parameter
Parameter Name Parameter Type Description
indexID
string
Request Message
<?xml version="1.0" encoding="UTF-8"?>
<UserPermission xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--req, object, user permissions, attr:version{req, string, protocolVersion}-->
<id>
<!--req, string, index, range:[1,32]-->test
</id>
<userID>
<!--req, string, user ID, range:[1,32]-->test
</userID>
<userType>
<!--req, enum, user type, subType:string, desc:"admin" (administrator, who has all permissions and can review and edit user's permission), "operator"
(operator, who has default permissions), "viewer" (viewer, who has default permissions), "installer", "manufacturer", "single" (single user),
"installerAdmin" (installation admin), "installEmployee" (installation employee)-->admin
</userType>
<localPermission>
<!--opt, object, local permission node-->
<backup>
<!--opt, bool, whether to enable the backup permission (of all channels), desc:true (enable), false (disable)-->true
</backup>
<record>
<!--opt, bool, whether to enable the recording permission (of all channels), desc:true (enable), false (disable)-->true
</record>
<playBack>
<!--opt, bool, whether to enable the playback permission (of all channels), desc:true (enable), false (disable)-->true
</playBack>
<preview>
<!--opt, bool, whether to enable the live view permission (of all channels), desc:true (enable), false (disable)-->true
</preview>
<videoChannelPermissionList>
<!--opt, object, list of configuring permission for video channel-->
<videoChannelPermission>
<!--opt, object, configure the permission for a single video channel-->
<id>
<!--req, string, video channel ID, range:[1,32]-->test
</id>
<playBack>
<!--opt, bool, whether to enable the playback permission of the current channel, desc:true (enable), false (disable)-->true
</playBack>
<preview>
<!--opt, bool, whether to enable the live view permission of the current channel, desc:true (enable), false (disable)-->true
</preview>
<record>
<!--opt, bool, whether to enable the recording permission of the current channel, desc:true (enable), false (disable)-->true
</record>
<backup>
<!--opt, bool, whether to enable the backup permission of the current channel, desc:true (enable), false (disable)-->true
</backup>
<playBackDoubleVerification>
<!--opt, bool, whether to enable double verification permission for playback of the current channel, desc:true (enable), false (disable)-->true
</playBackDoubleVerification>
<backupDoubleVerification>
<!--opt, bool, whether to enable the recording permission for backup of the current channel, desc:true (enable), false (disable)-->true
</backupDoubleVerification>
</videoChannelPermission>
</videoChannelPermissionList>
<ptzControl>
<!--req, bool, whether to enable the PTZ control permission (of all channels), desc:true (enable), false (disable)-->true
</ptzControl>
<ptzChannelPermissionList>
<!--opt, object, list of permission for PTZ control of the video channels-->
<ptzChannelPermission>
<!--req, object, the permission for PTZ control of a specific video channel-->
<id>
<!--req, string, video channel ID, range:[1,32]-->test
</id>
<ptzControl>
<!--opt, bool, whether to enable the PTZ control permission of the current channel, desc:true (enable), false (disable)-->true
</ptzControl>
</ptzChannelPermission>
</ptzChannelPermissionList>
<logOrStateCheck>
<!--opt, bool, whether to enable permission for checking logs and device status, desc:true (enable), false (disable)-->true
</logOrStateCheck>
<parameterConfig>
-


<parameterConfig>
<!--opt, bool, whether to enable the remote parameters setting permission of the device, desc:true (enable), false (disable)-->true
</parameterConfig>
<restartOrShutdown>
<!--opt, bool, whether to enable the permission to reboot or power off, desc:true (enable), false (disable)-->true
</restartOrShutdown>
<upgrade>
<!--opt, bool, whether to enable the upgrade permission, desc:true (enable), false (disable)-->true
</upgrade>
<upgradeNotShow>
<!--opt, bool-->true
</upgradeNotShow>
<manageChannel>
<!--opt, bool, whether to enable the channel management permission, desc:true (enable), false (disable)-->true
</manageChannel>
<AIModelManagement>
<!--opt, bool, whether to enable permission for operation on the AI model packet, desc:true (enable), false (disable)-->true
</AIModelManagement>
<AITaskManagement>
<!--opt, bool, whether to enable permission for managemengt and operation on the AI model packet, desc:true (enable), false (disable)-->true
</AITaskManagement>
<subSysOrZoneArm>
<!--opt, bool, arm permission of partition/alarm zone-->true
</subSysOrZoneArm>
<subSysOrZoneDisarm>
<!--opt, bool, disarm permission of partition/alarm zone-->true
</subSysOrZoneDisarm>
<operateOutput>
<!--opt, bool, permission for operation on relay-->true
</operateOutput>
<supportLinkageSubSystemList>
<!--opt, object-->
<subSystem>
<!--opt, int, range:[1,64]-->1
</subSystem>
</supportLinkageSubSystemList>
<subSystemList>
<!--opt, object, partition list, desc:partition list-->
<subSystem>
<!--opt, int, partition, range:[1,64]-->1
</subSystem>
</subSystemList>
<localFileMgr>
<!--opt, bool-->true
</localFileMgr>
<LEDConfig>
<!--opt, bool-->true
</LEDConfig>
<logMgr>
<!--opt, bool-->true
</logMgr>
<TIPConfig>
<!--opt, bool-->true
</TIPConfig>
<securityFunctionCfg>
<!--opt, bool-->true
</securityFunctionCfg>
<netWorkCfg>
<!--opt, bool-->true
</netWorkCfg>
<ISUPAccess>
<!--opt, bool-->true
</ISUPAccess>
<timeMgr>
<!--opt, bool-->true
</timeMgr>
<HDDMgr>
<!--opt, bool-->true
</HDDMgr>
<securitySystemMaintenance>
<!--opt, bool-->true
</securitySystemMaintenance>
<securityCheckingPicExport>
<!--opt, bool-->true
</securityCheckingPicExport>
<securityCheckingPicDelete>
<!--opt, bool-->true
</securityCheckingPicDelete>
<operationScheduleList>
<!--opt, array, subType:object, dep:or,{$.UserPermissionList.UserPermission.localPermission.operationScheduleEnabled,eq,true}-->
<operationSchedule>
<!--opt, object-->
<operationScheduleEnabled>
<!--opt, bool-->true
</operationScheduleEnabled>
<operationDetailItem>
<!--opt, enum, subType:string-->arm
</operationDetailItem>
<timeRange>
<!--opt, object-->
<beginTime>
<!--opt, time-->00:00:00
</beginTime>
<endTime>
<!--opt, time-->00:00:00


<!--opt, time-->00:00:00
</endTime>
</timeRange>
</operationSchedule>
</operationScheduleList>
</localPermission>
<remotePermission>
<!--opt, object, remote permission node-->
<record>
<!--opt, bool, whether to enable the recording permission (of all channels), desc:true (enable), false (disable)-->true
</record>
<playBack>
<!--opt, bool, whether to enable the playback permission (of all channels), desc:true (enable), false (disable)-->true
</playBack>
<preview>
<!--opt, bool, whether to enable the live view permission (of all channels), desc:true (enable), false (disable)-->true
</preview>
<videoChannelPermissionList>
<!--opt, object, list of configuring permission for video channel-->
<videoChannelPermission>
<!--opt, object, configure the permission for a single video channel-->
<id>
<!--req, string, video channel ID, range:[1,32]-->test
</id>
<preview>
<!--opt, bool, whether to enable the live view permission of the current channel, desc:true (enable), false (disable)-->true
</preview>
<playBack>
<!--opt, bool, whether to enable the playback permission of the current channel, desc:true (enable), false (disable)-->true
</playBack>
<record>
<!--opt, bool, whether to enable the recording permission of the current channel, desc:true (enable), false (disable)-->true
</record>
<playBackDoubleVerification>
<!--opt, bool, whether to enable double verification permission for playback of the current channel, desc:true (enable), false (disable)-->true
</playBackDoubleVerification>
</videoChannelPermission>
</videoChannelPermissionList>
<ptzControl>
<!--opt, bool, whether to enable the PTZ control permission (of all channels), desc:true (enable), false (disable)-->true
</ptzControl>
<ptzChannelPermissionList>
<!--opt, object, list of permission for PTZ control of the video channels-->
<ptzChannelPermission>
<!--opt, object, the permission for PTZ control of a specific video channel-->
<id>
<!--req, string, video channel ID, range:[1,32], desc:/ISAPI/PTZCtrl/channels/ID-->test
</id>
<ptzControl>
<!--opt, bool, whether to enable the PTZ control permission of the current channel, desc:true (enable), false (disable)-->true
</ptzControl>
</ptzChannelPermission>
</ptzChannelPermissionList>
<logOrStateCheck>
<!--opt, bool, whether to enable permission for checking logs and device status-->true
</logOrStateCheck>
<parameterConfig>
<!--opt, bool, whether to enable the remote parameters setting permission of the device-->true
</parameterConfig>
<restartOrShutdown>
<!--opt, bool, whether to enable the permission to reboot or power off-->true
</restartOrShutdown>
<upgrade>
<!--opt, bool, whether to enable the upgrade permission-->true
</upgrade>
<upgradeNotShow>
<!--opt, bool, the upgrade is not displayed, desc:whether to support upgrade permission both for the admin user and installer user to ensure
compatibility, true (support), false or this node is not returned (not support)-->true
</upgradeNotShow>
<voiceTalk>
<!--opt, bool, whether to enable the two-way audio permission (of all channels)-->true
</voiceTalk>
<transParentChannel>
<!--opt, bool, whether to enable the transparent channel, desc:namely, the serial port control-->true
</transParentChannel>
<contorlLocalOut>
<!--opt, bool, whether to enable the local output control permission-->true
</contorlLocalOut>
<manageChannel>
<!--opt, bool, whether to enable the channel management permission-->true
</manageChannel>
<alarmOutOrUpload>
<!--opt, bool, whether to enable permission for alarm uploading and output-->true
</alarmOutOrUpload>
<IRAID>
<!--opt, object, permission for Iraid quick configuration-->
<rapidConfiguration>
<!--opt, bool, whether to enable permission for Iraid quick configuration-->true
</rapidConfiguration>
<reset>
<!--opt, bool, whether to enable permission for restoring Iraid configuration-->true
</reset>
</IRAID>
<LEDConfig>


<LEDConfig>
<!--opt, bool, whether it allows the user to edit the LED configuration-->true
</LEDConfig>
<AIModelManagement>
<!--opt, bool, whether to enable permission for operation on the AI model packet-->true
</AIModelManagement>
<AITaskManagement>
<!--opt, bool, whether to enable permission for management and operation on AI tasks-->true
</AITaskManagement>
<materialReview>
<!--opt, bool, information release, desc:information release-->true
</materialReview>
<programReview>
<!--opt, bool, program checking permission, desc:information release-->true
</programReview>
<uploadMaterial>
<!--opt, bool, upload material, desc:information release-->true
</uploadMaterial>
<addProgram>
<!--opt, bool, program editing permission, desc:add, delete, and edit-->true
</addProgram>
<addSchedule>
<!--opt, bool, schedule editing permission, desc:add, delete, and edit-->true
</addSchedule>
<programPlay>
<!--opt, bool, information playing permission-->true
</programPlay>
<terminalMgr>
<!--opt, bool, terminal management permission, desc:set the backlight and logo light parameters of the terminal-->true
</terminalMgr>
<shopSmart>
<!--opt, bool, permission for shop smart-->true
</shopSmart>
<materialReplace>
<!--opt, bool, permission to replace materials-->true
</materialReplace>
<scheduleRelease>
<!--opt, bool, permission for releasing schedule-->true
</scheduleRelease>
<scheduleReview>
<!--opt, bool, schedule checking-->true
</scheduleReview>
<addTerminal>
<!--opt, bool, terminal adding-->true
</addTerminal>
<terminalDispatch>
<!--opt, bool, permission to relocate terminals, desc:to relocate the terminals under this organization to lower-level organizations-->true
</terminalDispatch>
<addUser>
<!--opt, bool, the permission for editing the user information, desc:add, delete, and edit-->true
</addUser>
<addOrg>
<!--opt, bool, the permission for editing organizations, desc:add, delete, and edit-->true
</addOrg>
<logMgr>
<!--opt, bool, log management-->true
</logMgr>
<dataUpdate>
<!--opt, bool, data update, desc:calling data-->true
</dataUpdate>
<insertMessage>
<!--opt, bool, the permission for cutting texts-->true
</insertMessage>
<notReview>
<!--opt, bool, the permission for free-review-->true
</notReview>
<MgrTerminal>
<!--opt, object, the managed terminals or terminal group-->
<TerminalNoList size="10">
<!--opt, object, terminal No. list, attr:size{req, int}-->
<terminalNo>
<!--opt, int, terminal No., range:[1,10]-->1
</terminalNo>
</TerminalNoList>
<TerminalGroupNoList size="10">
<!--opt, object, terminal group list, attr:size{req, int}-->
<terminalGroupNo>
<!--opt, int, terminal group No., range:[1,10]-->1
</terminalGroupNo>
</TerminalGroupNoList>
</MgrTerminal>
<subSysOrZoneArm>
<!--opt, bool, arm permission of partition/alarm zone-->true
</subSysOrZoneArm>
<subSysOrZoneDisarm>
<!--opt, bool, disarm permission of partition/alarm zone-->true
</subSysOrZoneDisarm>
<subSysOrZoneClearArm>
<!--opt, bool, clear alarm permission of partition/alarm zone-->true
</subSysOrZoneClearArm>
<zoneBypass>
<!--opt, bool, bypass permission in alarm zone-->true
</zoneBypass>
<zoneBypassRecover>


<!--opt, bool, bypass recovery permission in alarm zone-->true
</zoneBypassRecover>
<operateOutput>
<!--opt, bool, permission for operation on relay-->true
</operateOutput>
<supportLinkageSubSystemList>
<!--opt, object-->
<subSystem>
<!--opt, int, range:[1,64]-->1
</subSystem>
</supportLinkageSubSystemList>
<subSystemList>
<!--opt, object, partition list, desc:partition list-->
<subSystem>
<!--opt, int, partition, range:[1,64]-->1
</subSystem>
</subSystemList>
<factoryReset>
<!--opt, bool, restore to default parameters-->true
</factoryReset>
<arm>
<!--opt, bool, arm-->true
</arm>
<disarm>
<!--opt, bool, disarm-->true
</disarm>
<accessControl>
<!--opt, bool-->true
</accessControl>
<restoreTamper>
<!--opt, bool, restore the tamper-proof setting, desc:for usage details, refer to /ISAPI/Security/UserPermission/capabilities-->true
</restoreTamper>
<restoreConfirmedAlarm>
<!--opt, bool, restore the acknowledging alarm setting, desc:for usage details, refer to /ISAPI/Security/UserPermission/capabilities-->true
</restoreConfirmedAlarm>
<LPListAudit>
<!--opt, bool, permission for blockclist and allowlist operations,
desc:users with this permission can import/export/edit/delete/search for blockclist and allowlist; the related URIs are as follows:
URI for searching for the license plate blocklist and allowlist: /ISAPI/Traffic/channels/<ID>/searchLPListAudit;
URI for importing/exporting the license plate blocklist and allowlist data: /ISAPI/Traffic/channels/<ID>/licensePlateAuditData;
URI for editing the license plate list: /ISAPI/Traffic/channels/<channelID>/licensePlateAuditData/record?format=json;
URI for deleting the license plate blocklist and allowlist: /ISAPI/Traffic/channels/<channelID>/licensePlateAuditData/delete?format=json-->true
</LPListAudit>
<applicationWarehouse>
<!--opt, bool, app library management permission, desc:with management permission, users can perform operations such as importing, deleting and
starting HEOP APP-->true
</applicationWarehouse>
<subSystemManagement>
<!--opt, bool, permission for subsystem management, desc:which includes all the permissions related to subsystem management-->true
</subSystemManagement>
<userOfModifyKeypadPasswordList>
<!--opt, array, list of users allowed to change keypad password, subType:object-->
<userOfModifyKeypadPassword>
<!--opt, object, users allowed to change keypad password-->
<subUserType>
<!--opt, enum, type of sub-users, subType:string, desc:cloudAdmin-cloud admin, localAdmin-local admin, installerAdmin-installer admin,
installEmployee-install employee, localInstaller-local installer, cloudOperator-cloud operator, localOperator-local operator-->cloudAdmin
</subUserType>
</userOfModifyKeypadPassword>
</userOfModifyKeypadPasswordList>
<userOfModifyUserPermissionList>
<!--opt, array, list of users allowed to edit users permission, subType:object-->
<userOfModifyUserPermission>
<!--opt, object, users allowed to edit users permission-->
<subUserType>
<!--opt, enum, type of sub-users, subType:string, desc:cloudAdmin-cloud admin, localAdmin-local admin, installerAdmin-installer admin,
installEmployee-install employee, localInstaller-local installer, cloudOperator-cloud operator, localOperator-local operator-->cloudAdmin
</subUserType>
</userOfModifyUserPermission>
</userOfModifyUserPermissionList>
<falseAlarmMaterialLibMgr>
<!--opt, bool, permission for the false alarm analysis library management-->true
</falseAlarmMaterialLibMgr>
<TIPConfig>
<!--opt, bool-->true
</TIPConfig>
<netWorkCfg>
<!--opt, bool-->true
</netWorkCfg>
<ISUPAccess>
<!--opt, bool-->true
</ISUPAccess>
<timeMgr>
<!--opt, bool-->true
</timeMgr>
<HDDMgr>
<!--opt, bool-->true
</HDDMgr>
</remotePermission>
<passwordValidity>
<!--opt, int, password validity period, range:[0,365], desc:unit: day, [0, 365]; only the administrator can edit-->1
</passwordValidity>
<subUserType>
<!--opt, enum, type of sub-users, subType:string, desc:cloudAdmin-cloud admin, localAdmin-local admin, installerAdmin-installer admin, installEmployee

<!--opt, enum, type of sub-users, subType:string, desc:cloudAdmin-cloud admin, localAdmin-local admin, installerAdmin-installer admin, installEmployeeinstall
employee, localInstaller-local installer, cloudOperator-cloud operator, localOperator-local operator-->cloudAdmin
</subUserType>
</UserPermission>
Response Message
<?xml version="1.0" encoding="UTF-8"?>
<ResponseStatus xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--ro, req, object, response message, attr:version{ro, req, string, protocolVersion}-->
<requestURL>
<!--ro, req, string, request URL-->null
</requestURL>
<statusCode>
<!--ro, req, enum, status code, subType:int, desc:0 (OK), 1 (OK), 2 (Device Busy), 3 (Device Error), 4 (Invalid Operation), 5 (Invalid XML Format), 6
(Invalid XML Content), 7 (Reboot Required)-->0
</statusCode>
<statusString>
<!--ro, req, enum, status information, subType:string, desc:"OK" (succeeded), "Device Busy", "Device Error", "Invalid Operation", "Invalid XML Format",
"Invalid XML Content", "Reboot" (reboot device)-->OK
</statusString>
<subStatusCode>
<!--ro, req, string, sub status code, desc:sub status code-->OK
</subStatusCode>
</ResponseStatus>
21.2.10 Get the permission of a single user
Request URL
GET /ISAPI/Security/UserPermission/<indexID>
Query Parameter
Parameter Name Parameter Type Description
indexID
string
Request Message
None
Response Message
<?xml version="1.0" encoding="UTF-8"?>
<UserPermission xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--ro, req, object, user permissions, attr:version{req, string, protocolVersion}-->
<id>
<!--ro, req, string, index, range:[1,32]-->test
</id>
<userID>
<!--ro, req, string, user ID, range:[1,32]-->test
</userID>
<userType>
<!--ro, req, enum, user type, subType:string, desc:"admin" (administrator, who has all permissions and can review and edit user's permission),
"operator" (operator, who has default permissions), "viewer" (viewer, who has default permissions), "installer", "manufacturer", "single" (single user),
"installerAdmin" (installation admin), "installEmployee" (installation employee)-->admin
</userType>
<localPermission>
<!--ro, opt, object, local permission node-->
<backup>
<!--ro, opt, bool, whether to enable the backup permission (of all channels), desc:true (enable), false (disable)-->true
</backup>
<record>
<!--ro, opt, bool, whether to enable the recording permission (of all channels), desc:true (enable), false (disable)-->true
</record>
<playBack>
<!--ro, opt, bool, whether to enable the playback permission (of all channels), desc:true (enable), false (disable)-->true
</playBack>
<preview>
<!--ro, opt, bool, whether to enable the live view permission (of all channels), desc:true (enable), false (disable)-->true
</preview>
<videoChannelPermissionList>
<!--ro, opt, object, list of configuring permission for video channel-->
<videoChannelPermission>
<!--ro, opt, object, configure the permission for a single video channel-->
<id>
<!--ro, req, string, video channel ID, range:[1,32]-->test
</id>
<playBack>
<!--ro, opt, bool, whether to enable the playback permission of the current channel, desc:true (enable), false (disable)-->true
</playBack>
<preview>
-


<preview>
<!--ro, opt, bool, whether to enable the live view permission of the current channel, desc:true (enable), false (disable)-->true
</preview>
<record>
<!--ro, opt, bool, whether to enable the recording permission of the current channel, desc:true (enable), false (disable)-->true
</record>
<backup>
<!--ro, opt, bool, whether to enable the backup permission of the current channel, desc:true (enable), false (disable)-->true
</backup>
<playBackDoubleVerification>
<!--ro, opt, bool, whether to enable double verification permission for playback of the current channel, desc:true (enable), false (disable)-
>true
</playBackDoubleVerification>
<backupDoubleVerification>
<!--ro, opt, bool, whether to enable the recording permission for backup of the current channel, desc:true (enable), false (disable)-->true
</backupDoubleVerification>
</videoChannelPermission>
</videoChannelPermissionList>
<ptzControl>
<!--ro, req, bool, whether to enable the PTZ control permission (of all channels), desc:true (enable), false (disable)-->true
</ptzControl>
<ptzChannelPermissionList>
<!--ro, opt, object, list of permission for PTZ control of the video channels-->
<ptzChannelPermission>
<!--ro, req, object, the permission for PTZ control of a specific video channel-->
<id>
<!--ro, req, string, video channel ID, range:[1,32]-->test
</id>
<ptzControl>
<!--ro, opt, bool, whether to enable the PTZ control permission of the current channel, desc:true (enable), false (disable)-->true
</ptzControl>
</ptzChannelPermission>
</ptzChannelPermissionList>
<logOrStateCheck>
<!--ro, opt, bool, whether to enable permission for checking logs and device status, desc:true (enable), false (disable)-->true
</logOrStateCheck>
<parameterConfig>
<!--ro, opt, bool, whether to enable the remote parameters setting permission of the device, desc:true (enable), false (disable)-->true
</parameterConfig>
<restartOrShutdown>
<!--ro, opt, bool, whether to enable the permission to reboot or power off, desc:true (enable), false (disable)-->true
</restartOrShutdown>
<upgrade>
<!--ro, opt, bool, whether to enable the upgrade permission, desc:true (enable), false (disable)-->true
</upgrade>
<upgradeNotShow>
<!--ro, opt, bool, the upgrade is not displayed, desc:whether to support upgrade permission both for the admin user and installer user to ensure
compatibility, true (support), false or this node is not returned (not support)-->true
</upgradeNotShow>
<manageChannel>
<!--ro, opt, bool, whether to enable the channel management permission, desc:true (enable), false (disable)-->true
</manageChannel>
<AIModelManagement>
<!--ro, opt, bool, whether to enable permission for operation on the AI model packet, desc:true (enable), false (disable)-->true
</AIModelManagement>
<AITaskManagement>
<!--ro, opt, bool, whether to enable permission for managemengt and operation on the AI model packet, desc:true (enable), false (disable)-->true
</AITaskManagement>
<subSysOrZoneArm>
<!--ro, opt, bool, arm permission of partition/alarm zone-->true
</subSysOrZoneArm>
<subSysOrZoneDisarm>
<!--ro, opt, bool, disarm permission of partition/alarm zone-->true
</subSysOrZoneDisarm>
<operateOutput>
<!--ro, opt, bool, permission for operation on relay-->true
</operateOutput>
<supportLinkageSubSystemList>
<!--ro, opt, object, list of the partitions that support linkage-->
<subSystem>
<!--ro, opt, int, the partition that supports linkage, range:[1,64]-->1
</subSystem>
</supportLinkageSubSystemList>
<subSystemList>
<!--ro, opt, object, partition list, desc:partition list-->
<subSystem>
<!--ro, opt, int, partition, range:[1,64]-->1
</subSystem>
</subSystemList>
<localFileMgr>
<!--ro, opt, bool-->true
</localFileMgr>
<LEDConfig>
<!--ro, opt, bool-->true
</LEDConfig>
<logMgr>
<!--ro, opt, bool-->true
</logMgr>
<TIPConfig>
<!--ro, opt, bool-->true
</TIPConfig>
<securityFunctionCfg>
<!--ro, opt, bool-->true
</securityFunctionCfg>


</securityFunctionCfg>
<netWorkCfg>
<!--ro, opt, bool-->true
</netWorkCfg>
<ISUPAccess>
<!--ro, opt, bool-->true
</ISUPAccess>
<timeMgr>
<!--ro, opt, bool-->true
</timeMgr>
<HDDMgr>
<!--ro, opt, bool-->true
</HDDMgr>
<securitySystemMaintenance>
<!--ro, opt, bool-->true
</securitySystemMaintenance>
<securityCheckingPicExport>
<!--ro, opt, bool-->true
</securityCheckingPicExport>
<securityCheckingPicDelete>
<!--ro, opt, bool-->true
</securityCheckingPicDelete>
<operationScheduleList>
<!--ro, opt, array, subType:object, dep:or,{$.UserPermissionList.UserPermission.localPermission.operationScheduleEnabled,eq,true}-->
<operationSchedule>
<!--ro, opt, object-->
<operationScheduleEnabled>
<!--ro, opt, bool-->true
</operationScheduleEnabled>
<operationDetailItem>
<!--ro, opt, enum, subType:string-->arm
</operationDetailItem>
<timeRange>
<!--ro, opt, object-->
<beginTime>
<!--ro, opt, time-->00:00:00
</beginTime>
<endTime>
<!--ro, opt, time-->00:00:00
</endTime>
</timeRange>
</operationSchedule>
</operationScheduleList>
</localPermission>
<remotePermission>
<!--ro, opt, object, remote permission node-->
<record>
<!--ro, opt, bool, whether to enable the recording permission (of all channels), desc:true (enable), false (disable)-->true
</record>
<playBack>
<!--ro, opt, bool, whether to enable the playback permission (of all channels), desc:true (enable), false (disable)-->true
</playBack>
<preview>
<!--ro, opt, bool, whether to enable the live view permission (of all channels), desc:true (enable), false (disable)-->true
</preview>
<videoChannelPermissionList>
<!--ro, opt, object, list of configuring permission for video channel-->
<videoChannelPermission>
<!--ro, opt, object, configure the permission for a single video channel-->
<id>
<!--ro, req, string, corresponding video channel ID, range:[1,32]-->test
</id>
<preview>
<!--ro, opt, bool, whether to enable the live view permission of the current channel, desc:true (enable), false (disable)-->true
</preview>
<playBack>
<!--ro, opt, bool, whether to enable the playback permission of the current channel, desc:true (enable), false (disable)-->true
</playBack>
<record>
<!--ro, opt, bool, whether to enable the recording permission of the current channel, desc:true (enable), false (disable)-->true
</record>
<playBackDoubleVerification>
<!--ro, opt, bool, whether to enable double verification permission for playback of the current channel, desc:true (enable), false (disable)-
>true
</playBackDoubleVerification>
</videoChannelPermission>
</videoChannelPermissionList>
<ptzControl>
<!--ro, opt, bool, whether to enable the PTZ control permission (of all channels), desc:true (enable), false (disable)-->true
</ptzControl>
<ptzChannelPermissionList>
<!--ro, opt, object, list of permission for PTZ control of the video channels-->
<ptzChannelPermission>
<!--ro, opt, object, the permission for PTZ control of a specific video channel-->
<id>
<!--ro, req, string, video channel ID, range:[1,32], desc:/ISAPI/PTZCtrl/channels/ID-->test
</id>
<ptzControl>
<!--ro, opt, bool, whether to enable the PTZ control permission of the current channel, desc:true (enable), false (disable)-->true
</ptzControl>
</ptzChannelPermission>
</ptzChannelPermissionList>
<logOrStateCheck>
<!--ro, opt, bool, whether to enable permission for checking logs and device status-->true


</logOrStateCheck>
<parameterConfig>
<!--ro, opt, bool, whether to enable the remote parameters setting permission of the device-->true
</parameterConfig>
<restartOrShutdown>
<!--ro, opt, bool, whether to enable the permission to reboot or power off-->true
</restartOrShutdown>
<upgrade>
<!--ro, opt, bool, whether to enable the upgrade permission-->true
</upgrade>
<upgradeNotShow>
<!--ro, opt, bool, the upgrade is not displayed, desc:whether to support upgrade permission both for the admin user and installer user to ensure
compatibility, true (support), false or this node is not returned (not support)-->true
</upgradeNotShow>
<voiceTalk>
<!--ro, opt, bool, whether to enable the two-way audio permission (of all channels)-->true
</voiceTalk>
<transParentChannel>
<!--ro, opt, bool, whether to enable the transparent channel, desc:namely, the serial port control-->true
</transParentChannel>
<contorlLocalOut>
<!--ro, opt, bool, whether to enable the local output control permission-->true
</contorlLocalOut>
<manageChannel>
<!--ro, opt, bool, whether to enable the channel management permission-->true
</manageChannel>
<alarmOutOrUpload>
<!--ro, opt, bool, whether to enable permission for alarm uploading and output-->true
</alarmOutOrUpload>
<IRAID>
<!--ro, opt, object, permission for Iraid quick configuration-->
<rapidConfiguration>
<!--ro, opt, bool, whether to enable permission for Iraid quick configuration-->true
</rapidConfiguration>
<reset>
<!--ro, opt, bool, whether to enable permission for restoring Iraid configuration-->true
</reset>
</IRAID>
<LEDConfig>
<!--ro, opt, bool, whether it allows the user to edit the LED configuration-->true
</LEDConfig>
<AIModelManagement>
<!--ro, opt, bool, whether to enable permission for operation on the AI model packet-->true
</AIModelManagement>
<AITaskManagement>
<!--ro, opt, bool, whether to enable permission for management and operation on AI tasks-->true
</AITaskManagement>
<materialReview>
<!--ro, opt, bool, Information Release, desc:information release-->true
</materialReview>
<programReview>
<!--ro, opt, bool, program checking permission, desc:information release-->true
</programReview>
<uploadMaterial>
<!--ro, opt, bool, upload material, desc:information release-->true
</uploadMaterial>
<addProgram>
<!--ro, opt, bool, program editing permission, desc:add, delete, and edit-->true
</addProgram>
<addSchedule>
<!--ro, opt, bool, schedule editing permission, desc:add, delete, and edit-->true
</addSchedule>
<programPlay>
<!--ro, opt, bool, information playing permission-->true
</programPlay>
<terminalMgr>
<!--ro, opt, bool, terminal management permission, desc:set the backlight and logo light parameters of the terminal-->true
</terminalMgr>
<shopSmart>
<!--ro, opt, bool, permission for shop smart-->true
</shopSmart>
<materialReplace>
<!--ro, opt, bool, permission to replace materials-->true
</materialReplace>
<scheduleRelease>
<!--ro, opt, bool, permission for releasing schedule-->true
</scheduleRelease>
<scheduleReview>
<!--ro, opt, bool, schedule checking-->true
</scheduleReview>
<addTerminal>
<!--ro, opt, bool, terminal adding-->true
</addTerminal>
<terminalDispatch>
<!--ro, opt, bool, permission to relocate terminals, desc:to relocate the terminals under this organization to lower-level organizations-->true
</terminalDispatch>
<addUser>
<!--ro, opt, bool, the permission of editing the user information, desc:add, delete, and edit-->true
</addUser>
<addOrg>
<!--ro, opt, bool, the permission for editing organizations, desc:add, delete, and edit-->true
</addOrg>
<logMgr>
<!--ro, opt, bool, log management-->true


<!--ro, opt, bool, log management-->true
</logMgr>
<dataUpdate>
<!--ro, opt, bool, data update, desc:calling data-->true
</dataUpdate>
<insertMessage>
<!--ro, opt, bool, the permission for cutting texts-->true
</insertMessage>
<notReview>
<!--ro, opt, bool, the permission for free-review-->true
</notReview>
<MgrTerminal>
<!--ro, opt, object, the managed terminals or terminal group-->
<TerminalNoList size="10">
<!--ro, opt, object, terminal No. list, attr:size{req, int}-->
<terminalNo>
<!--ro, opt, int, terminal No., range:[1,10]-->1
</terminalNo>
</TerminalNoList>
<TerminalGroupNoList size="10">
<!--ro, opt, object, terminal group list, attr:size{req, int}-->
<terminalGroupNo>
<!--ro, opt, int, terminal group No., range:[1,10]-->1
</terminalGroupNo>
</TerminalGroupNoList>
</MgrTerminal>
<subSysOrZoneArm>
<!--ro, opt, bool, arm permission of partition/alarm zone-->true
</subSysOrZoneArm>
<subSysOrZoneDisarm>
<!--ro, opt, bool, disarm permission of partition/alarm zone-->true
</subSysOrZoneDisarm>
<subSysOrZoneClearArm>
<!--ro, opt, bool, clear alarm permission of partition/alarm zone-->true
</subSysOrZoneClearArm>
<zoneBypass>
<!--ro, opt, bool, bypass permission in alarm zone-->true
</zoneBypass>
<zoneBypassRecover>
<!--ro, opt, bool, bypass recovery permission in alarm zone-->true
</zoneBypassRecover>
<operateOutput>
<!--ro, opt, bool, permission for operation on relay-->true
</operateOutput>
<supportLinkageSubSystemList>
<!--ro, opt, object, list of the partitions that support linkage-->
<subSystem>
<!--ro, opt, int, the partition that supports linkage, range:[1,64]-->1
</subSystem>
</supportLinkageSubSystemList>
<subSystemList>
<!--ro, opt, object, partition list, desc:partition list-->
<subSystem>
<!--ro, opt, int, partition, range:[1,64]-->1
</subSystem>
</subSystemList>
<factoryReset>
<!--ro, opt, bool, restore to default parameters-->true
</factoryReset>
<arm>
<!--ro, opt, bool, arm-->true
</arm>
<disarm>
<!--ro, opt, bool, disarm-->true
</disarm>
<accessControl>
<!--ro, opt, bool, access control-->true
</accessControl>
<restoreTamper>
<!--ro, opt, bool, restore the tamper-proof setting, desc:for usage details, refer to /ISAPI/Security/UserPermission/capabilities-->true
</restoreTamper>
<restoreConfirmedAlarm>
<!--ro, opt, bool, restore the acknowledging alarm setting, desc:for usage details, refer to /ISAPI/Security/UserPermission/capabilities-->true
</restoreConfirmedAlarm>
<LPListAudit>
<!--ro, opt, bool, permission for blockclist and allowlist operations,
desc:users with this permission can import/export/edit/delete/search for blockclist and allowlist; the related URIs are as follows:
URI for searching for the license plate blocklist and allowlist: /ISAPI/Traffic/channels/<ID>/searchLPListAudit;
URI for importing/exporting the license plate blocklist and allowlist data: /ISAPI/Traffic/channels/<ID>/licensePlateAuditData;
URI for editing the license plate list: /ISAPI/Traffic/channels/<channelID>/licensePlateAuditData/record?format=json;
URI for deleting the license plate blocklist and allowlist: /ISAPI/Traffic/channels/<channelID>/licensePlateAuditData/delete?format=json-->true
</LPListAudit>
<applicationWarehouse>
<!--ro, opt, bool, app library management permission, desc:this node is not returned if it is not supported-->true
</applicationWarehouse>
<subSystemManagement>
<!--ro, opt, bool, permission for subsystem management, desc:which includes all the permissions related to subsystem management-->true
</subSystemManagement>
<userOfModifyKeypadPasswordList>
<!--ro, opt, array, list of users allowed to change keypad password, subType:object-->
<userOfModifyKeypadPassword>
<!--ro, opt, object, users allowed to change keypad password-->
<subUserType>
<!--ro, opt, enum, type of sub-users, subType:string, desc:cloudAdmin-cloud admin, localAdmin-local admin, installerAdmin-installer admin,


<!--ro, opt, enum, type of sub-users, subType:string, desc:cloudAdmin-cloud admin, localAdmin-local admin, installerAdmin-installer admin,
installEmployee-install employee, localInstaller-local installer, cloudOperator-cloud operator, localOperator-local operator-->cloudAdmin
</subUserType>
</userOfModifyKeypadPassword>
</userOfModifyKeypadPasswordList>
<userOfModifyUserPermissionList>
<!--ro, opt, array, list of users allowed to edit users permission, subType:object-->
<userOfModifyUserPermission>
<!--ro, opt, object, users allowed to edit users permission-->
<subUserType>
<!--ro, opt, enum, type of sub-users, subType:string, desc:cloudAdmin-cloud admin, localAdmin-local admin, installerAdmin-installer admin,
installEmployee-install employee, localInstaller-local installer, cloudOperator-cloud operator, localOperator-local operator-->cloudAdmin
</subUserType>
</userOfModifyUserPermission>
</userOfModifyUserPermissionList>
<falseAlarmMaterialLibMgr>
<!--ro, opt, bool, permission for the false alarm analysis library management-->true
</falseAlarmMaterialLibMgr>
<TIPConfig>
<!--ro, opt, bool-->true
</TIPConfig>
<netWorkCfg>
<!--ro, opt, bool-->true
</netWorkCfg>
<ISUPAccess>
<!--ro, opt, bool-->true
</ISUPAccess>
<timeMgr>
<!--ro, opt, bool-->true
</timeMgr>
<HDDMgr>
<!--ro, opt, bool-->true
</HDDMgr>
</remotePermission>
<passwordValidity>
<!--ro, opt, int, password validity period, range:[0,365], desc:unit: day, [0, 365]; only the administrator can edit-->1
</passwordValidity>
<subUserType>
<!--ro, opt, enum, type of sub-users, subType:string, desc:cloudAdmin-cloud admin, localAdmin-local admin, installerAdmin-installer admin,
installEmployee-install employee, localInstaller-local installer, cloudOperator-cloud operator, localOperator-local operator-->cloudAdmin
</subUserType>
</UserPermission>
21.2.11 Get the configuration capability of all users' permission
Request URL
GET /ISAPI/Security/UserPermission/capabilities
Query Parameter
None
Request Message
None
Response Message
<?xml version="1.0" encoding="UTF-8"?>
<UserPermissionList xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--ro, req, object, list of user permissions, attr:version{req, string, protocolVersion}-->
<UserPermission>
<!--ro, req, object, user permissions, desc:it can be edited by the administrator only-->
<id min="1" max="32">
<!--ro, req, string, permission ID, range:[1,32], attr:min{req, int},max{req, int}-->test
</id>
<userID min="1" max="32">
<!--ro, req, string, user ID, range:[1,32], attr:min{req, int},max{req, int}-->test
</userID>
<userType opt="admin,operator,viewer,installer,manufacturer,single">
<!--ro, req, enum, user type, subType:string, attr:opt{req, string}, desc:"admin" (administrator, who has all permissions and can review and edit
user's permission), "operator" (operator, who has default permissions), "viewer" (viewer, who has default permissions), "installer", "manufacturer",
"single" (single user), "installerAdmin" (installation admin), "installEmployee" (installation employee)-->admin
</userType>
<localPermission>
<!--ro, opt, object, whether it supports managing channels locally-->
<backup opt="true,false">
<!--ro, opt, bool, whether the local device supports, attr:opt{req, string}, desc:if this node is returned, it indicates the device supports this
function and can configure whether to enable the permission for users, and this applies to the following node-->true
</backup>
<record opt="true,false">
<!--ro, opt, bool, whether it supports local manual operations, attr:opt{req, string}-->true
</record>
<playBack opt="true,false">
<!--ro, opt, bool, local playback, attr:opt{req, string}-->true
</playBack>
<preview opt="true,false">
<!--ro, opt, bool, local live view, attr:opt{req, string}-->true


<!--ro, opt, bool, local live view, attr:opt{req, string}-->true
</preview>
<videoChannelPermissionList>
<!--ro, opt, object, list of configuring permission for video channel-->
<videoChannelPermission>
<!--ro, opt, object, configure the permission for a single video channel-->
<id min="1" max="32">
<!--ro, opt, string, video channel ID, range:[1,32], attr:min{req, int},max{req, int}-->test
</id>
<playBack opt="true,false">
<!--ro, opt, bool, whether to enable the playback permission of the current channel, attr:opt{req, string}-->true
</playBack>
<preview opt="true,false">
<!--ro, opt, bool, whether to enable the live view permission of the current channel, attr:opt{req, string}-->true
</preview>
<record opt="true,false">
<!--ro, opt, bool, whether to enable the recording permission of the current channel, attr:opt{req, string}-->true
</record>
<backup opt="true,false">
<!--ro, opt, bool, whether to enable the backup permission of the current channel, attr:opt{req, string}-->true
</backup>
<playBackDoubleVerification>
<!--ro, opt, bool, whether to enable double verification permission for playback of the current channel, desc:true (enable), false (disable)-
>true
</playBackDoubleVerification>
<backupDoubleVerification>
<!--ro, opt, bool, whether to enable the recording permission for backup of the current channel, desc:true (enable), false (disable)-->true
</backupDoubleVerification>
</videoChannelPermission>
</videoChannelPermissionList>
<ptzControl opt="true,false">
<!--ro, opt, bool, PTZ control, attr:opt{req, string}-->true
</ptzControl>
<ptzChannelPermissionList>
<!--ro, opt, object, list of permission for PTZ control of the video channels-->
<ptzChannelPermission>
<!--ro, opt, object, local PTZ control-->
<id min="1" max="32">
<!--ro, req, string, video channel ID, range:[1,32], attr:min{req, int},max{req, int}-->test
</id>
<ptzControl opt="true,false">
<!--ro, opt, bool, PTZ control, attr:opt{req, string}-->true
</ptzControl>
</ptzChannelPermission>
</ptzChannelPermissionList>
<logOrStateCheck opt="true,false">
<!--ro, opt, bool, local log searching, attr:opt{req, string}-->true
</logOrStateCheck>
<parameterConfig opt="true,false">
<!--ro, opt, bool, local parameters settings, attr:opt{req, string}-->true
</parameterConfig>
<restartOrShutdown opt="true,false">
<!--ro, opt, bool, local shutdown or reboot, attr:opt{req, string}-->true
</restartOrShutdown>
<upgrade opt="true,false">
<!--ro, opt, bool, local upgrade or format, attr:opt{req, string}-->true
</upgrade>
<manageChannel opt="true,false">
<!--ro, opt, bool, local channels management, attr:opt{req, string}-->true
</manageChannel>
<AIModelManagement>
<!--ro, opt, bool, whether to enable permission for operation on the AI model packet, desc:true (enable), false (disable)-->true
</AIModelManagement>
<AITaskManagement>
<!--ro, opt, bool, whether to enable permission for managemengt and operation on the AI model packet, desc:true (enable), false (disable)-->true
</AITaskManagement>
<subSysOrZoneArm>
<!--ro, opt, bool, arm permission of partition/alarm zone-->true
</subSysOrZoneArm>
<subSysOrZoneDisarm>
<!--ro, opt, bool, disarm permission of partition/alarm zone-->true
</subSysOrZoneDisarm>
<operateOutput>
<!--ro, opt, bool, permission for operation on relay-->true
</operateOutput>
<supportLinkageSubSystemList size="64">
<!--ro, opt, object, list of the partitions that support linkage, attr:size{req, int}-->
<subSystem>
<!--ro, opt, int, the partition that supports linkage, range:[1,64]-->1
</subSystem>
</supportLinkageSubSystemList>
<subSystemList>
<!--ro, opt, object, partition list, desc:read-only,list of partitions-->
<subSystem>
<!--ro, opt, int, partition, range:[1,64]-->1
</subSystem>
</subSystemList>
<localFileMgr opt="true,false">
<!--ro, opt, bool, attr:opt{req, string}-->true
</localFileMgr>
<LEDConfig opt="true,false">
<!--ro, opt, bool, attr:opt{req, string}-->true
</LEDConfig>
<logMgr opt="true,false">


<logMgr opt="true,false">
<!--ro, opt, bool, attr:opt{req, string}-->true
</logMgr>
<TIPConfig opt="true,false">
<!--ro, opt, bool, attr:opt{req, string}-->true
</TIPConfig>
<securityFunctionCfg opt="true,false">
<!--ro, opt, bool, attr:opt{req, string}-->true
</securityFunctionCfg>
<netWorkCfg opt="true,false">
<!--ro, opt, bool, attr:opt{req, string}-->true
</netWorkCfg>
<ISUPAccess opt="true,false">
<!--ro, opt, bool, attr:opt{req, string}-->true
</ISUPAccess>
<timeMgr opt="true,false">
<!--ro, opt, bool, attr:opt{req, string}-->true
</timeMgr>
<HDDMgr opt="true,false">
<!--ro, opt, bool, attr:opt{req, string}-->true
</HDDMgr>
<securitySystemMaintenance opt="true,false">
<!--ro, opt, bool, attr:opt{req, string}-->true
</securitySystemMaintenance>
<securityCheckingPicExport opt="true,false">
<!--ro, opt, bool, attr:opt{req, string}-->true
</securityCheckingPicExport>
<securityCheckingPicDelete opt="true,false">
<!--ro, opt, bool, attr:opt{req, string}-->true
</securityCheckingPicDelete>
<operationScheduleList>
<!--ro, opt, array, subType:object, dep:or,{$.UserPermissionList.UserPermission.localPermission.operationScheduleEnabled,eq,true}-->
<operationSchedule>
<!--ro, opt, object-->
<operationScheduleEnabled opt="true,false">
<!--ro, opt, bool, attr:opt{req, string}-->true
</operationScheduleEnabled>
<operationDetailItem opt="all,arm,disarm,operateOutput">
<!--ro, opt, enum, subType:string, attr:opt{req, string}-->arm
</operationDetailItem>
<timeRange>
<!--ro, opt, object-->
<beginTime>
<!--ro, opt, time-->00:00:00
</beginTime>
<endTime>
<!--ro, opt, time-->00:00:00
</endTime>
</timeRange>
</operationSchedule>
</operationScheduleList>
</localPermission>
<remotePermission>
<!--ro, opt, object, remote permission-->
<record opt="true,false">
<!--ro, opt, bool, remote: manual record, attr:opt{req, string}-->true
</record>
<playBack opt="true,false">
<!--ro, opt, bool, remote playback, attr:opt{req, string}-->true
</playBack>
<preview opt="true,false">
<!--ro, opt, bool, remote: live view, attr:opt{req, string}-->true
</preview>
<videoChannelPermissionList>
<!--ro, opt, object, list of configuring permission for video channel-->
<videoChannelPermission>
<!--ro, opt, object, configure the permission for a single video channel-->
<id min="1" max="32">
<!--ro, req, string, video channel ID, range:[1,32], attr:min{req, int},max{req, int}-->test
</id>
<preview opt="true,false">
<!--ro, opt, bool, remote: live view, attr:opt{req, string}-->true
</preview>
<playBack opt="true,false">
<!--ro, opt, bool, remote playback, attr:opt{req, string}-->true
</playBack>
<record opt="true,false">
<!--ro, opt, bool, remote: manual record, attr:opt{req, string}-->true
</record>
<playBackDoubleVerification>
<!--ro, opt, bool, whether to enable double verification permission for playback of the current channel, desc:true (enable), false (disable)-
>true
</playBackDoubleVerification>
</videoChannelPermission>
</videoChannelPermissionList>
<ptzControl opt="true,false">
<!--ro, opt, bool, remote PTZ control, attr:opt{req, string}-->true
</ptzControl>
<ptzChannelPermissionList>
<!--ro, opt, object, list of permission for PTZ control of the video channels-->
<ptzChannelPermission>
<!--ro, opt, object, local PTZ control-->
<id>
<!--ro, req, string, video channel ID, range:[1,32]-->test
</id>


</id>
<ptzControl opt="true,false">
<!--ro, opt, bool, remote PTZ control, attr:opt{req, string}-->true
</ptzControl>
</ptzChannelPermission>
</ptzChannelPermissionList>
<logOrStateCheck opt="true,false">
<!--ro, opt, bool, remote logs searching, attr:opt{req, string}-->true
</logOrStateCheck>
<parameterConfig opt="true,false">
<!--ro, opt, bool, remote parameters settings, attr:opt{req, string}-->true
</parameterConfig>
<restartOrShutdown opt="true,false">
<!--ro, opt, bool, remote shutdown or reboot, attr:opt{req, string}-->true
</restartOrShutdown>
<upgrade opt="true,false">
<!--ro, opt, bool, remote upgrade or format, attr:opt{req, string}-->true
</upgrade>
<upgradeNotShow opt="true,false">
<!--ro, opt, bool, the upgrade is not displayed, attr:opt{req, string}-->true
</upgradeNotShow>
<voiceTalk opt="true,false">
<!--ro, opt, bool, remote two-way audio, attr:opt{req, string}-->true
</voiceTalk>
<transParentChannel opt="true,false">
<!--ro, opt, bool, remote serial port control, attr:opt{req, string}-->true
</transParentChannel>
<contorlLocalOut opt="true,false">
<!--ro, opt, bool, remote video output control, attr:opt{req, string}-->true
</contorlLocalOut>
<manageChannel opt="true,false">
<!--ro, opt, bool, remote channel management, attr:opt{req, string}-->true
</manageChannel>
<alarmOutOrUpload opt="true,false">
<!--ro, opt, bool, remote alarm upload or output request, attr:opt{req, string}-->true
</alarmOutOrUpload>
<IRAID>
<!--ro, opt, object, whether it supports configuring IRAID to reset configuration permissions-->
<rapidConfiguration opt="true,false">
<!--ro, opt, bool, whether it supports permission fot Iraid quick configuration, attr:opt{req, string}-->true
</rapidConfiguration>
<reset opt="true,false">
<!--ro, opt, bool, whether it supports configuring IRAID to reset configuration permissions, attr:opt{req, string}-->true
</reset>
</IRAID>
<LEDConfig>
<!--ro, opt, bool, whether it allows the user to edit the LED configuration-->true
</LEDConfig>
<AIModelManagement>
<!--ro, opt, bool, whether to enable permission for operation on the AI model packet-->true
</AIModelManagement>
<AITaskManagement>
<!--ro, opt, bool, whether to enable permission for management and operation on AI tasks-->true
</AITaskManagement>
<materialReview>
<!--ro, opt, bool, material checking permission, desc:information release-->true
</materialReview>
<programReview>
<!--ro, opt, bool, program checking permission, desc:information release-->true
</programReview>
<uploadMaterial>
<!--ro, opt, bool, upload material, desc:information release-->true
</uploadMaterial>
<addProgram>
<!--ro, opt, bool, program editing permission, desc:add, delete, and edit-->true
</addProgram>
<addSchedule>
<!--ro, opt, bool, schedule editing permission, desc:add, delete, and edit-->true
</addSchedule>
<programPlay>
<!--ro, opt, bool, information playing permission-->true
</programPlay>
<terminalMgr>
<!--ro, opt, bool, terminal management permission, desc:set the backlight and logo light parameters of the terminal-->true
</terminalMgr>
<shopSmart>
<!--ro, opt, bool, permission for shop smart-->true
</shopSmart>
<materialReplace>
<!--ro, opt, bool, permission to replace materials-->true
</materialReplace>
<scheduleRelease>
<!--ro, opt, bool, permission for releasing schedule-->true
</scheduleRelease>
<scheduleReview>
<!--ro, opt, bool, schedule checking-->true
</scheduleReview>
<addTerminal>
<!--ro, opt, bool, terminal adding-->true
</addTerminal>
<terminalDispatch>
<!--ro, opt, bool, permission to relocate terminals, desc:to relocate the terminals under this organization to lower-level organizations-->true
</terminalDispatch>
<addUser>


<addUser>
<!--ro, opt, bool, the permission for editing the user information, desc:add, delete, and edit-->true
</addUser>
<addOrg>
<!--ro, opt, bool, the permission for editing organizations, desc:add, delete, and edit-->true
</addOrg>
<logMgr>
<!--ro, opt, bool, log management-->true
</logMgr>
<dataUpdate>
<!--ro, opt, bool, data update, desc:calling data-->true
</dataUpdate>
<insertMessage>
<!--ro, opt, bool, the permission for cutting texts-->true
</insertMessage>
<notReview>
<!--ro, opt, bool, the permission for free-review-->true
</notReview>
<MgrTerminal>
<!--ro, opt, object, the managed terminals or terminal group-->
<TerminalNoList size="10">
<!--ro, opt, object, terminal No. list, attr:size{req, int}-->
<terminalNo>
<!--ro, opt, int, terminal No., range:[1,10]-->1
</terminalNo>
</TerminalNoList>
<TerminalGroupNoList size="10">
<!--ro, opt, object, terminal group list, attr:size{req, int}-->
<terminalGroupNo>
<!--ro, opt, int, terminal group No., range:[1,10]-->1
</terminalGroupNo>
</TerminalGroupNoList>
</MgrTerminal>
<subSysOrZoneArm>
<!--ro, opt, bool, arm permission of partition/alarm zone-->true
</subSysOrZoneArm>
<subSysOrZoneDisarm>
<!--ro, opt, bool, disarm permission of partition/alarm zone-->true
</subSysOrZoneDisarm>
<subSysOrZoneClearArm>
<!--ro, opt, bool, clear alarm permission of partition/alarm zone-->true
</subSysOrZoneClearArm>
<zoneBypass>
<!--ro, opt, bool, bypass permission in alarm zone-->true
</zoneBypass>
<zoneBypassRecover>
<!--ro, opt, bool, bypass recovery permission in alarm zone-->true
</zoneBypassRecover>
<operateOutput>
<!--ro, opt, bool, permission for operation on relay-->true
</operateOutput>
<supportLinkageSubSystemList size="64">
<!--ro, opt, object, list of the partitions that support linkage, attr:size{req, int}-->
<subSystem>
<!--ro, opt, int, the partition that supports linkage, range:[1,64]-->1
</subSystem>
</supportLinkageSubSystemList>
<subSystemList>
<!--ro, opt, object, partition list, desc:read-only,list of partitions-->
<subSystem>
<!--ro, opt, int, partition, range:[1,64]-->1
</subSystem>
</subSystemList>
<factoryReset>
<!--ro, opt, bool, restore to default parameters-->true
</factoryReset>
<arm>
<!--ro, opt, bool, arm-->true
</arm>
<disarm>
<!--ro, opt, bool, disarm-->true
</disarm>
<accessControl>
<!--ro, opt, bool, access control-->true
</accessControl>
<restoreTamper opt="true,false">
<!--ro, opt, bool, restore the tamper-proof setting, attr:opt{req, string}, desc:whether to restore tampering,this node is only valid for installer->true
</restoreTamper>
<restoreConfirmedAlarm
opt="true,false">
<!--ro, opt, bool, restore the acknowledging alarm setting, attr:opt{req, string}, desc:acknowledge alarm: for the linked zone, when an alarm is
triggered in one zone, the system records the logs and reports a normal alarm. Within the interval of the linked zone, an alarm will also be triggered in
another zone, and the system will generate logs about reporting and recording the alarm acknowledgment-->true
</restoreConfirmedAlarm>
<LPListAudit opt="true,false">
<!--ro, opt, bool, permission for blockclist and allowlist operations, attr:opt{req, string},
desc:users with this permission can import/export/edit/delete/search for blockclist and allowlist; the related URIs are as follows:
URI for searching for the license plate blocklist and allowlist: /ISAPI/Traffic/channels/<ID>/searchLPListAudit;
URI for importing/exporting the license plate blocklist and allowlist data: /ISAPI/Traffic/channels/<ID>/licensePlateAuditData;
URI for editing the license plate list: /ISAPI/Traffic/channels/<channelID>/licensePlateAuditData/record?format=json;
URI for deleting the license plate blocklist and allowlist: /ISAPI/Traffic/channels/<channelID>/licensePlateAuditData/delete?format=json-->true
</LPListAudit>
<applicationWarehouse opt="true,false">
<!--ro, opt, bool, app library management permission, attr:opt{req, string}, desc:this node is not returned if it is not supported-->true


</applicationWarehouse>
<subSystemManagement opt="true,false">
<!--ro, opt, bool, permission for subsystem management, attr:opt{req, string}, desc:this node is not returned if it is not supported which includes
all the permissions related to subsystem management-->true
</subSystemManagement>
<userOfModifyKeypadPasswordList size="7">
<!--ro, opt, array, list of users allowed to change keypad password, subType:object, attr:size{req, int}-->
<userOfModifyKeypadPassword>
<!--ro, opt, object, users allowed to change keypad password-->
<subUserType opt="cloudAdmin,localAdmin,installerAdmin,installEmployee,localInstaller,cloudOperator,localOperator">
<!--ro, opt, enum, type of sub-users, subType:string, attr:opt{req, string}, desc:cloudAdmin-cloud admin, localAdmin-local admin,
installerAdmin-installer admin, installEmployee-install employee, localInstaller-local installer, cloudOperator-cloud operator, localOperator-local
operator-->cloudAdmin
</subUserType>
</userOfModifyKeypadPassword>
</userOfModifyKeypadPasswordList>
<userOfModifyUserPermissionList size="7">
<!--ro, opt, array, list of users allowed to edit users permission, subType:object, attr:size{req, int}-->
<userOfModifyUserPermission>
<!--ro, opt, object, users allowed to edit users permission-->
<subUserType opt="cloudAdmin,localAdmin,installerAdmin,installEmployee,localInstaller,cloudOperator,localOperator">
<!--ro, opt, enum, type of sub-users, subType:string, attr:opt{req, string}, desc:cloudAdmin-cloud admin, localAdmin-local admin,
installerAdmin-installer admin, installEmployee-install employee, localInstaller-local installer, cloudOperator-cloud operator, localOperator-local
operator-->cloudAdmin
</subUserType>
</userOfModifyUserPermission>
</userOfModifyUserPermissionList>
<falseAlarmMaterialLibMgr opt="true,false">
<!--ro, opt, bool, permission for the false alarm analysis library management, attr:opt{req, string}-->true
</falseAlarmMaterialLibMgr>
<TIPConfig opt="true,false">
<!--ro, opt, bool, attr:opt{req, string}-->true
</TIPConfig>
<netWorkCfg opt="true,false">
<!--ro, opt, bool, attr:opt{req, string}-->true
</netWorkCfg>
<ISUPAccess opt="true,false">
<!--ro, opt, bool, attr:opt{req, string}-->true
</ISUPAccess>
<timeMgr opt="true,false">
<!--ro, opt, bool, attr:opt{req, string}-->true
</timeMgr>
<HDDMgr opt="true,false">
<!--ro, opt, bool, attr:opt{req, string}-->true
</HDDMgr>
</remotePermission>
<passwordValidity min="0" max="365">
<!--ro, opt, int, password validity period, range:[0,365], attr:min{req, int},max{req, int}, desc:unit: day; only the administrator can edit-->1
</passwordValidity>
<adminType opt="cloudAdmin,localAdmin">
<!--ro, opt, enum, type of admin users, subType:string, attr:opt{req, string}, desc:cloudAdmin-cloud admin, localAdmin-local admin-->cloudAdmin
</adminType>
<installerType opt="installerAdmin,installEmployee,localInstaller">
<!--ro, opt, enum, type of installer users, subType:string, attr:opt{req, string}, desc:cloudAdmin-cloud admin, localAdmin-local admin-->cloudAdmin
</installerType>
<operatorType opt="cloudOperator,localOperator">
<!--ro, opt, enum, type of operator users, subType:string, attr:opt{req, string}, desc:cloudOperator-cloud operator, localOperator-local operator-
>cloudOperator
</operatorType>
</UserPermission>
</UserPermissionList>
21.3 Time Management
21.3.1 Get the parameters of a specific NTP (Network Time Protocol) server
Request URL
GET /ISAPI/System/time/ntpServers
Query Parameter
None
Request Message
None
Response Message


<?xml version="1.0" encoding="UTF-8"?>
<NTPServerList xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--ro, req, array, NTP server information list, subType:object, attr:version{req, string, protocolVersion}-->
<NTPServer>
<!--ro, opt, object, NTP server information-->
<id>
<!--ro, req, string, ID-->1
</id>
<addressingFormatType>
<!--ro, req, enum, NTP server address type, subType:string, desc:"ipaddress" (IP address), "hostname" (domain name)-->hostname
</addressingFormatType>
<hostName>
<!--ro, opt, string, NTP server domain name, range:[1,64]-->hik12345
</hostName>
<ipAddress>
<!--ro, opt, string, IPv4 address, range:[1,32]-->192.168.1.112
</ipAddress>
<ipv6Address>
<!--ro, opt, string, IPv6 address, range:[1,128]-->1030:C9B4:FF12:48AA:1A2B
</ipv6Address>
<portNo>
<!--ro, opt, int, port No., range:[1,65535], desc:the default port No. is 123-->123
</portNo>
<synchronizeInterval>
<!--ro, opt, int, time synchronization interval, range:[1,10800], unit:min-->1440
</synchronizeInterval>
<enabled>
<!--ro, opt, bool, whether to enable, desc:disabled (by default)-->false
</enabled>
</NTPServer>
</NTPServerList>
21.3.2 Get the parameters of a NTP server
Request URL
GET /ISAPI/System/time/ntpServers/<NTPServerID>
Query Parameter
Parameter Name Parameter Type Description
NTPServerID
string
Request Message
None
Response Message
<?xml version="1.0" encoding="UTF-8"?>
<NTPServer xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--ro, req, object, NTP server information, attr:version{req, string, protocolVersion}-->
<id>
<!--ro, req, string, ID-->1
</id>
<addressingFormatType>
<!--ro, req, enum, IP address type of NTP server, subType:string, desc:"ipaddress" (IP address), "hostname" (domain name)-->hostname
</addressingFormatType>
<hostName>
<!--ro, opt, string, NTP server domain name, range:[1,64]-->hik12345
</hostName>
<ipAddress>
<!--ro, opt, string, IPv4 address, range:[1,32], desc:IPv4 address-->192.168.1.112
</ipAddress>
<ipv6Address>
<!--ro, opt, string, IPv6 address, range:[1,128], desc:IPv6 address-->1030:C9B4:FF12:48AA:1A2B
</ipv6Address>
<portNo>
<!--ro, opt, int, port No., range:[1,65535], step:1, desc:port No.-->1
</portNo>
<synchronizeInterval>
<!--ro, opt, int, time synchronization interval, range:[1,10800], step:1, unit:min, desc:NTP time synchronization interval, unit: minute-->1440
</synchronizeInterval>
<enabled>
<!--ro, opt, bool-->false
</enabled>
</NTPServer>
-
21.3.3 Set the parameters of a NTP server


Request URL
PUT /ISAPI/System/time/ntpServers/<NTPServerID>
Query Parameter
Parameter Name Parameter Type Description
NTPServerID
string
Request Message
<?xml version="1.0" encoding="UTF-8"?>
<NTPServer xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--req, object, NTP server information, attr:version{req, string, protocolVersion}-->
<id>
<!--req, string, ID-->1
</id>
<addressingFormatType>
<!--req, enum, IP address type of NTP server, subType:string, desc:"ipaddress" (IP address), "hostname" (domain name)-->hostname
</addressingFormatType>
<hostName>
<!--opt, string, NTP server domain name地址去掉, range:[1,64]-->hik12345
</hostName>
<ipAddress>
<!--opt, string, IPv4 address, range:[1,32], desc:IPv4 address-->192.168.1.112
</ipAddress>
<ipv6Address>
<!--opt, string, IPv6 address, range:[1,128], desc:IPv6 address-->1030:C9B4:FF12:48AA:1A2B
</ipv6Address>
<portNo>
<!--opt, int, port No., range:[1,65535], step:1, desc:port No.-->1
</portNo>
<synchronizeInterval>
<!--opt, int, time synchronization interval, range:[1,10800], step:1, unit:min, desc:NTP time synchronization interval, unit: minute-->1440
</synchronizeInterval>
<enabled>
<!--opt, bool-->false
</enabled>
</NTPServer>
Response Message
<?xml version="1.0" encoding="UTF-8"?>
<ResponseStatus xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--ro, req, object, response message, attr:version{ro, req, string, protocolVersion}-->
<requestURL>
<!--ro, req, string, request URL-->null
</requestURL>
<statusCode>
<!--ro, req, enum, status code, subType:int, desc:0 (OK), 1 (OK), 2 (Device Busy), 3 (Device Error), 4 (Invalid Operation), 5 (Invalid XML Format), 6
(Invalid XML Content), 7 (Reboot Required)-->0
</statusCode>
<statusString>
<!--ro, req, enum, status description, subType:string, desc:"OK" (succeeded), "Device Busy", "Device Error", "Invalid Operation", "Invalid XML Format",
"Invalid XML Content", "Reboot" (reboot device)-->OK
</statusString>
<subStatusCode>
<!--ro, req, string, sub status code, desc:sub status code-->OK
</subStatusCode>
</ResponseStatus>
-
21.3.4 Get device time synchronization management parameters
Request URL
GET /ISAPI/System/time
Query Parameter
None
Request Message
None
Response Message


<?xml version="1.0" encoding="UTF-8"?>
<Time xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--ro, opt, object, time management, attr:version{opt, string, protocolVersion}-->
<timeMode>
<!--ro, req, enum, time synchronization mode, subType:string, desc:“NTP” (NTP time synchronization), “manual” (manual time synchronization), “satellite”
(satellite time synchronization), “platform” (platform time synchronization), “NONE” (time synchronization is not allowed or no time synchronization
source), “GB28181” (GB28181 time synchronization)-->NTP
</timeMode>
<localTime>
<!--ro, opt, string, local time, range:[0,256], dep:and,{$.Time.timeMode,eq,manual}-->2019-02-28T10:50:44+08:00
</localTime>
<timeZone>
<!--ro, opt, string, time zone, range:[0,256], dep:and,{$.Time.timeMode,eq,manual},{$.Time.timeMode,eq,NTP}-->CST8:00:00DST00:30:00,M4.1.0/02:00:00,M10.5.0/02:00:00
</timeZone>
<satelliteInterval>
<!--ro,
opt, int, satellite time synchronization interval, step:1, unit:min, desc:unit: minute-->60
</satelliteInterval>
<isSummerTime>
<!--ro, opt, bool, whether the device time returned currently is in DST (Daylight Saving Time) system-->true
</isSummerTime>
<platformType>
<!--ro, opt, enum, platform type, subType:string, dep:and,{$.Time.timeMode,eq,platform}, desc:exists only when the timeMode is selected as platform-
>EZVIZ
</platformType>
<platformNo>
<!--ro, opt, int, platform No., range:[1,2], dep:and,{$.Time.timeMode,eq,GB28181}, desc:it is the only ID, which is configured via platformNo in
GB28181List, related URI: /ISAPI/System/Network/SIP/<SIPServerID>-->1
</platformNo>
</Time>
21.3.5 Set device time synchronization management parameters
Request URL
PUT /ISAPI/System/time
Query Parameter
None
Request Message
<?xml version="1.0" encoding="UTF-8"?>
<Time xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--req, object, time management, attr:version{opt, string, protocolVersion}-->
<timeMode>
<!--req, enum, time synchronization mode, subType:string, desc:“NTP” (NTP time synchronization), “manual” (manual time synchronization), “satellite”
(satellite time synchronization), “platform” (platform time synchronization), “NONE” (time synchronization is not allowed or no time synchronization
source), “GB28181” (GB28181 time synchronization)-->NTP
</timeMode>
<localTime>
<!--opt, string, local time, range:[0,256], dep:and,{$.Time.timeMode,eq,manual}-->2019-02-28T10:50:44+08:00
</localTime>
<timeZone>
<!--opt, string, time zone, range:[0,256], dep:and,{$.Time.timeMode,eq,manual},{$.Time.timeMode,eq,NTP}-->CST8:00:00DST00:30:00,M4.1.0/02:00:00,M10.5.0/02:00:00
</timeZone>
<satelliteInterval>
<!--opt,
int, satellite time synchronization interval, step:1, unit:min, desc:unit: minute-->60
</satelliteInterval>
<isSummerTime>
<!--opt, bool, whether the time returned by the current device is that in the DST (daylight saving time)-->true
</isSummerTime>
<platformType>
<!--opt, enum, platform type, subType:string, dep:and,{$.Time.timeMode,eq,platform}, desc:exists only when the timeMode is selected as platform, related
URI: /ISAPI/System/Network/EZVIZ-->EZVIZ
</platformType>
<platformNo>
<!--opt, int, platform No., range:[1,2], dep:and,{$.Time.timeMode,eq,GB28181}, desc:it is the only ID, which is configured via platformNo in
GB28181List, related URI: /ISAPI/System/Network/SIP/<SIPServerID>-->1
</platformNo>
</Time>
Response Message


<?xml version="1.0" encoding="UTF-8"?>
<ResponseStatus xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--ro, req, object, response message, attr:version{ro, req, string, protocolVersion}-->
<requestURL>
<!--ro, req, string, request URL-->null
</requestURL>
<statusCode>
<!--ro, req, enum, status code, subType:int, desc:0 (OK), 1 (OK), 2 (Device Busy), 3 (Device Error), 4 (Invalid Operation), 5 (Invalid XML Format), 6
(Invalid XML Content), 7 (Reboot Required)-->0
</statusCode>
<statusString>
<!--ro, req, enum, status description, subType:string, desc:“OK” (succeeded), “Device Busy”, “Device Error”, “Invalid Operation”, “Invalid XML Format”,
“Invalid XML Content”, “Reboot” (reboot device)-->OK
</statusString>
<subStatusCode>
<!--ro, req, string, sub status code, desc:sub status code-->OK
</subStatusCode>
<FailedNodeInfoList>
<!--ro, opt, object, information list of failed nodes, desc:for the manual time synchronization of central analysis cluster, this field is returned if
time synchronization failed-->
<FailedNodeInfo>
<!--ro, opt, object, information of failed nodes-->
<nodeID>
<!--ro, req, string, node ID, range:[0,64]-->test
</nodeID>
<nodeIP>
<!--ro, req, string, node IP, range:[0,20]-->test
</nodeIP>
<reason>
<!--ro, opt, string, reason why the node failed to synchronize time, range:[0,128]-->test
</reason>
</FailedNodeInfo>
</FailedNodeInfoList>
</ResponseStatus>
21.3.6 Get the capability of device time synchronization management
Request URL
GET /ISAPI/System/time/capabilities
Query Parameter
None
Request Message
None
Response Message


<?xml version="1.0" encoding="UTF-8"?>
<Time xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--ro, opt, object, time management capability set, attr:version{opt, string, protocolVersion}-->
<timeMode opt="NTP,manual,satellite,SDK,28181,ONVIF,ALL(任何支持的校时方式都允许校时),NONE(不允校时或无校时源),platform">
<!--ro, req, enum, time synchronization mode, subType:string, attr:opt{opt, string}, desc:“NTP” (NTP time synchronization), “manual” (manual time
synchronization), “satellite” (satellite time synchronization), “platform” (platform time synchronization), “NONE” (time synchronization is not allowed or
no time synchronization source), “GB28181” (GB28181 time synchronization)-->NTP
</timeMode>
<localTime min="0" max="256">
<!--ro, opt, string, local time, range:[0,256], attr:min{opt, string},max{opt, string}-->test
</localTime>
<timeZone min="0" max="256">
<!--ro, opt, string, time zone, range:[0,256], attr:min{opt, string},max{opt, string}-->test
</timeZone>
<satelliteInterval min="0" max="3600">
<!--ro, opt, int, satellite time synchronization interval, step:1, unit:min, attr:min{opt, string},max{opt, string}, desc:unit: minute-->60
</satelliteInterval>
<timeType opt="local,UTC">
<!--ro, opt, enum, time type, subType:string, attr:opt{opt, string}, desc:“local” (local time), “UTC” (UTC time)-->local
</timeType>
<platformType opt="EZVIZ">
<!--ro, opt, enum, platform type, subType:string, dep:and,{$.Time.timeMode,eq,platform}, attr:opt{opt, string}, desc:platform type-->EZVIZ
</platformType>
<platformNo min="1" max="2">
<!--ro, opt, int, platform No., range:[1,2], dep:and,{$.Time.timeMode,eq,GB28181}, attr:min{req, int},max{req, int}, desc:it is the only ID, which is
configured via platformNo in GB28181List, related URI: /ISAPI/System/Network/SIP/<SIPServerID>-->1
</platformNo>
<isSupportHistoryTime>
<!--ro, opt, bool, supported capability of the historical time synchronization list, desc:related URI: /ISAPI/System/time/historyInfo?format=json-->true
</isSupportHistoryTime>
<isSupportTimeFilter>
<!--ro, opt, bool, supported capability of filtering time synchronization, desc:related URI: /ISAPI/System/time/filter/capabilities?format=json-->true
</isSupportTimeFilter>
<displayFormat opt="MM/dd/yyyy hh:mm,mm,dd-MM-yyyy hh,MM-dd-yyyy hh:mm,yyyy-MM-dd hh:mm">
<!--ro, opt, enum, time display format, subType:string, attr:opt{req, string}, desc:if this node is returned, it indicates that the device supports
configuring time display format, related URI: /ISAPI/System/time/timeType?format=json-->MM/dd/yyyy hh:mm
</displayFormat>
<isSupportSyncDeviceNTPInfoToCamera>
<!--ro, opt, bool, the capability of synchronizing device’s NTP service information with the camera, desc:related URI:
/ISAPI/System/time/SyncDeviceNTPInfoToCamera/capabilities?format=json-->true
</isSupportSyncDeviceNTPInfoToCamera>
<isSupportNTPService>
<!--ro, opt, bool-->true
</isSupportNTPService>
</Time>
21.3.7 Get the configuration capability of parameters of a specific NTP (Network Time
Protocol) server
Request URL
GET /ISAPI/System/time/ntpServers/capabilities
Query Parameter
None
Request Message
None
Response Message


<?xml version="1.0" encoding="UTF-8"?>
<NTPServerList xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--ro, req, array, NTP server information list, subType:object, attr:version{opt, string, protocolVersion}-->
<NTPServer>
<!--ro, opt, object, NTP server information-->
<id>
<!--ro, req, string, ID-->1
</id>
<addressingFormatType opt="ipaddress,hostname">
<!--ro, req, enum, NTP server address type, subType:string, attr:opt{req, string}, desc:"ipaddress" (IP address), "hostname" (domain name)-->hostname
</addressingFormatType>
<hostName min="1" max="64">
<!--ro, opt, string, NTP server domain name, range:[1,64], attr:min{req, int},max{req, int}-->hik12345
</hostName>
<ipAddress min="1" max="32">
<!--ro, opt, string, IPv4 address, range:[1,32], attr:min{req, int},max{req, int}, desc:IPv4 address-->192.168.1.112
</ipAddress>
<ipv6Address min="1" max="128">
<!--ro, opt, string, IPv6 address, range:[1,128], attr:min{req, int},max{req, int}, desc:IPv6 address-->1030:C9B4:FF12:48AA:1A2B
</ipv6Address>
<portNo min="1" max="65535">
<!--ro, opt, int, port No., range:[1,65535], attr:min{req, int},max{req, int}, desc:the default port No. is 123-->123
</portNo>
<synchronizeInterval min="1" max="10800">
<!--ro, opt, int, time synchronization interval, unit:min, attr:min{req, int},max{req, int}-->1440
</synchronizeInterval>
<enabled opt="true,false">
<!--ro, opt, bool, whether to enable, attr:opt{req, string}, desc:true (enable), false (disable)-->true
</enabled>
</NTPServer>
</NTPServerList>
21.3.8 Set parameters of all NTP servers
Request URL
PUT /ISAPI/System/time/ntpServers
Query Parameter
None
Request Message
<?xml version="1.0" encoding="UTF-8"?>
<NTPServerList xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--req, array, NTP server information list, subType:object, attr:version{opt, string, protocolVersion}-->
<NTPServer>
<!--opt, object, NTP server information-->
<id>
<!--req, string, ID-->1
</id>
<addressingFormatType>
<!--req, enum, NTP server address type, subType:string, desc:"ipaddress" (IP address), "hostname" (domain name)-->hostname
</addressingFormatType>
<hostName>
<!--opt, string, NTP server domain name, range:[1,64]-->hik12345
</hostName>
<ipAddress>
<!--opt, string, IPv4 address, range:[1,32]-->192.168.1.112
</ipAddress>
<ipv6Address>
<!--opt, string, IPv6 address, range:[1,128]-->1030:C9B4:FF12:48AA:1A2B
</ipv6Address>
<portNo>
<!--opt, int, port No., range:[1,65535], desc:the default port No. is 123-->123
</portNo>
<synchronizeInterval>
<!--opt, int, time synchronization interval, range:[1,10800], unit:min-->1440
</synchronizeInterval>
<enabled>
<!--opt, bool, whether to enable, desc:disabled (by default)-->false
</enabled>
</NTPServer>
</NTPServerList>
Response Message


<?xml version="1.0" encoding="UTF-8"?>
<ResponseStatus xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--ro, req, object, response message, attr:version{ro, req, string, protocolVersion}-->
<requestURL>
<!--ro, req, string, request URL-->/ISAPI/xxxx
</requestURL>
<statusCode>
<!--ro, req, enum, status code, subType:int, desc:0 (OK), 1 (OK), 2 (Device Busy), 3 (Device Error), 4 (Invalid Operation), 5 (Invalid XML Format), 6
(Invalid XML Content), 7 (Reboot Required)-->0
</statusCode>
<statusString>
<!--ro, req, enum, status description, subType:string, desc:"OK" (succeeded), "Device Busy", "Device Error", "Invalid Operation", "Invalid XML Format",
"Invalid XML Content", "Reboot" (reboot device)-->OK
</statusString>
<subStatusCode>
<!--ro, req, string, sub status code, desc:sub status code-->OK
</subStatusCode>
</ResponseStatus>
21.4 Log Management
21.4.1 Search for log information
Request URL
POST /ISAPI/ContentMgmt/logSearch
Query Parameter
None
Request Message
<?xml version="1.0" encoding="UTF-8"?>
<CMSearchDescription xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--req, object, log search, attr:version{opt, string, protocolVersion}-->
<searchID>
<!--req, string, search ID, range:[1,32], desc:UUID/GUID for record search. It is used to check whether the current search requester is the same as the
previous one. If they are the same, the search record will be stored in the device for faster search next time.-->test
</searchID>
<trackIDList>
<!--opt, array, channel list, subType:object-->
<trackID>
<!--req, int, channel No., desc:channel No.-->1
</trackID>
</trackIDList>
<metaId>
<!--req, enum, log type, subType:string, desc:{log.std-cgi.com/<majorType>/<minorType>}, <majorType>-major type of log, <minorType>-minor type of log,
see remarks for detailed log type definitions; "log.std-cgi.com/Alarm/methaneConcentrationException", "log.stdcgi.com/Alarm/methaneLightIntensityException",
"log.std-cgi.com/Alarm/fishingShipDetection"-->log.std-cgi.com/Alarm/methaneConcentrationException
</metaId>
<timeSpanList>
<!--opt, array, list of time periods, subType:object, desc:list of time periods-->
<timeSpan>
<!--opt, object, time period, desc:time period-->
<startTime>
<!--req, datetime, start time-->1970-01-01T00:00:00Z
</startTime>
<endTime>
<!--req, datetime, end time-->1970-01-01T01:00:00Z
</endTime>
</timeSpan>
</timeSpanList>
<searchResultPostion>
<!--opt, int, the start position of the search result, desc:the start position of the search result in the result list-->100
</searchResultPostion>
<maxResults>
<!--opt, int, the maximum number of records supported in this search, range:[0,100]-->0
</maxResults>
<onlySmart>
<!--opt, bool, whether to search for logs with smart information, desc:the value of this node is false by default-->false
</onlySmart>
<logLevel>
<!--opt, enum, subType:string-->emergency
</logLevel>
<alarmLevel>
<!--opt, enum, subType:string-->high
</alarmLevel>
</CMSearchDescription>
Response Message


<?xml version="1.0" encoding="UTF-8"?>
<CMSearchResult xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--ro, req, object, log search result, attr:version{opt, string, protocolVersion}-->
<searchID>
<!--ro, req, string, search ID, range:[1,32], desc:UUID/GUID for record search. It is used to check whether the current search requester is the same as
the previous one. If they are the same, the search record will be stored in the device for faster search next time-->test
</searchID>
<responseStatus>
<!--ro, req, bool, search status-->true
</responseStatus>
<responseStatusStrg>
<!--ro, req, enum, search status string, subType:string, desc:"OK" (search completed), "NO MATCHES" (no matched data), "MORE" (more data waiting to be
searched)-->OK
</responseStatusStrg>
<totalMatches>
<!--ro, opt, int, total number of matched results-->12
</totalMatches>
<numOfMatches>
<!--ro, opt, int, number of results returned this time, range:[0,100]-->24
</numOfMatches>
<matchList>
<!--ro, opt, array, list of matched data records, subType:object-->
<searchMatchItem>
<!--ro, opt, object, single matched record-->
<logDescriptor>
<!--ro, opt, object, log description-->
<metaId>
<!--ro, req, string, log type for search, desc:log.std-cgi.com/<majorType>/<minorType>, "<majorType>" (major type of log), "<minorType>" (minor
type of log), see remarks for detailed log type definitions-->log.std-cgi.com/Alarm/24HZoneAlarm
</metaId>
<StartDateTime>
<!--ro, req, datetime, log time-->1970-01-01T00:30:00Z
</StartDateTime>
<localID>
<!--ro, opt, string, channel No.-->1
</localID>
<paraType>
<!--ro, opt, string, parameter type-->test
</paraType>
<userName>
<!--ro, opt, string, user name-->Admin
</userName>
<infoContent>
<!--ro, opt, string, log information content-->test
</infoContent>
<logInfo>
<!--ro, opt, object, log information-->
<OpenDoorRecord>
<!--ro, opt, object, video intercom unlocking record-->
<type>
<!--ro, req, enum, unlocking type, subType:string, desc:"password" (unlocking by password), "hijack" (unlocking by duress), "card" (unlocking
by card), "resident" (unlocking by resident), "center" (unlocking by management center)-->password
</type>
</OpenDoorRecord>
<VisAlarmRecord>
<!--ro, opt, object, video intercom alarm record-->
<type>
<!--ro, req, enum, alarm type, subType:string, desc:"zone" (zone alarm), "dismantle" (tampering alarm), "hijack" (duress alarm), "passwordErr"
(password error alarm), "doorNotOpen" (unlocking-door-failed alarm), "doorNotClose" (locking-door-failed alarm), "SOS" (SOS alarm), "callReq" (device call
request alarm), "smartLockHijackFingerPrint" (smart lock duress alarm (fingerprint)), ‘smartLockHijackPassword" (smart lock duress alarm (password)),
"smartLockBreaking" (forced-open door alarm), "smartLockBeLocked" (lock-up door alarm), "smartLockLowBattery" (smart-lock-battery-low alarm)-->zone
</type>
</VisAlarmRecord>
</logInfo>
<ipAddress>
<!--ro, opt, string, device IP address, range:[1,32]-->10.20.30.10
</ipAddress>
<object>
<!--ro, opt, enum, operation object, subType:string, desc:"network", "keypad", "remoteCtrl" (remote control), "card"-->network
</object>
<params>
<!--ro, opt, string, log parameters, desc:parameters (zone No., etc.)-->test
</params>
<seq>
<!--ro, opt, string, device serial No., range:[1,32]-->test
</seq>
<additionInformation>
<!--ro, opt, string, additional information, range:[1,128], desc:additional information of log-->test
</additionInformation>
<panelUser>
<!--ro, opt, string, user name of the operation panel, range:[0,16]-->admin
</panelUser>
<diskNumber>
<!--ro, opt, int, HDD No., range:[0,10000]-->0
</diskNumber>
<alarmInPort>
<!--ro, opt, int, alarm input port, range:[0,1000]-->0
</alarmInPort>
<alarmOutPort>
<!--ro, opt, int, alarm output port, range:[0,10000]-->0
</alarmOutPort>
<remoteHostIPAddress>


<remoteHostIPAddress>
<!--ro, opt, string, remote host IP address, range:[1,32]-->10.12.25.23
</remoteHostIPAddress>
<logLevel>
<!--ro, opt, enum, subType:string-->emergency
</logLevel>
<alarmLevel>
<!--ro, opt, enum, subType:string-->high
</alarmLevel>
<moduleName>
<!--ro, opt, string, range:[1,32]-->test
</moduleName>
</logDescriptor>
</searchMatchItem>
</matchList>
</CMSearchResult>
21.4.2 Set log server parameters
Request URL
PUT /ISAPI/System/logServer
Query Parameter
None
Request Message
<?xml version="1.0" encoding="UTF-8"?>
<LogServer xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--opt, object, attr:version{req, string, protocolVersion}-->
<enabled>
<!--req, bool, false"-->true
</enabled>
<addressingFormatType>
<!--req, enum, server address type, subType:string, desc:"ipaddress", "hostname"-->ipaddress
</addressingFormatType>
<hostName>
<!--opt, string, host name-->test
</hostName>
<ipAddress>
<!--opt, string, IP address-->test
</ipAddress>
<ipv6Address>
<!--opt, string, IPv6 address-->test
</ipv6Address>
<portNo>
<!--opt, int, server port No.-->1
</portNo>
<transmissionEncryption>
<!--opt, bool, encrypt the transmitted data-->true
</transmissionEncryption>
<checkCertificate>
<!--opt, bool, whether to enable certificate verification-->true
</checkCertificate>
<uploadInterval>
<!--opt, int, log upload interval, range:[1,24], desc:log upload interval-->1
</uploadInterval>
<protocolType>
<!--opt, enum, subType:string-->tcp
</protocolType>
<sysLogCacheSize>
<!--opt, int, range:[10,3000]-->1000
</sysLogCacheSize>
<sysLogLevel>
<!--opt, enum, subType:string-->emergency
</sysLogLevel>
<serverLogLevel>
<!--opt, enum, subType:string-->emergency
</serverLogLevel>
<alarmLogCacheSize>
<!--opt, int, range:[10,3000]-->1000
</alarmLogCacheSize>
</LogServer>
Response Message


<?xml version="1.0" encoding="UTF-8"?>
<ResponseStatus xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--ro, req, object, response message, attr:version{ro, req, string, protocolVersion}-->
<requestURL>
<!--ro, req, string, request URL-->null
</requestURL>
<statusCode>
<!--ro, req, enum, status code, subType:int, desc:0 (OK), 1 (OK), 2 (Device Busy), 3 (Device Error), 4 (Invalid Operation), 5 (Invalid XML Format), 6
(Invalid XML Content), 7 (Reboot Required)-->0
</statusCode>
<statusString>
<!--ro, req, enum, status information, subType:string, desc:"OK" (succeeded), "Device Busy", "Device Error", "Invalid Operation", "Invalid XML Format",
"Invalid XML Content", "Reboot" (reboot device)-->OK
</statusString>
<subStatusCode>
<!--ro, req, string, sub status code, which describes the error in details, desc:sub status code, which describes the error in details-->OK
</subStatusCode>
</ResponseStatus>
21.4.3 Get log server parameters
Request URL
GET /ISAPI/System/logServer
Query Parameter
None
Request Message
None
Response Message
<?xml version="1.0" encoding="UTF-8"?>
<LogServer xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--ro, opt, object, attr:version{req, string, protocolVersion}-->
<enabled>
<!--ro, req, bool, false"-->true
</enabled>
<addressingFormatType>
<!--ro, req, enum, server address type, subType:string, desc:"ipaddress", "hostname"-->ipaddress
</addressingFormatType>
<hostName>
<!--ro, opt, string, host name-->test
</hostName>
<ipAddress>
<!--ro, opt, string, IP address-->test
</ipAddress>
<ipv6Address>
<!--ro, opt, string, IPV6 address-->test
</ipv6Address>
<portNo>
<!--ro, opt, int, server port No.-->1
</portNo>
<transmissionEncryption>
<!--ro, opt, bool, encrypt the transmitted data-->true
</transmissionEncryption>
<checkCertificate>
<!--ro, opt, bool, whether to enable certificate verification-->true
</checkCertificate>
<uploadInterval>
<!--ro, opt, int, log uploading interval, range:[1,24], desc:unit: hour, the default value is 1-->1
</uploadInterval>
<protocolType>
<!--ro, opt, enum, subType:string-->tcp
</protocolType>
<sysLogCacheSize>
<!--ro, opt, int, range:[10,3000]-->1000
</sysLogCacheSize>
<sysLogLevel>
<!--ro, opt, enum, subType:string-->emergency
</sysLogLevel>
<serverLogLevel>
<!--ro, opt, enum, subType:string-->emergency
</serverLogLevel>
<alarmLogCacheSize>
<!--ro, opt, int, range:[10,3000]-->1000
</alarmLogCacheSize>
</LogServer>


21.4.4 Get the configuration capability of log servers
Request URL
GET /ISAPI/System/logServer/capabilities
Query Parameter
None
Request Message
None
Response Message
<?xml version="1.0" encoding="UTF-8"?>
<LogServerCap xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--ro, opt, object, attr:version{req, string, protocolVersion}-->
<enabled opt="true,false">
<!--ro, opt, bool, attr:opt{req, string}-->test
</enabled>
<addressingFormatType opt="ipaddress,hostname">
<!--ro, req, string, address type, attr:opt{req, string}-->test
</addressingFormatType>
<hostName min="1" max="10">
<!--ro, opt, string, attr:min{req, int},max{req, int}-->test
</hostName>
<ipAddress min="1" max="10">
<!--ro, opt, string, attr:min{req, int},max{req, int}-->test
</ipAddress>
<ipv6Address min="1" max="10">
<!--ro, opt, string, attr:min{req, int},max{req, int}-->test
</ipv6Address>
<portNo min="1" max="10">
<!--ro, opt, int, attr:min{req, int},max{req, int}-->1
</portNo>
<transmissionEncryption opt="true,false">
<!--ro, opt, bool, encrypt the transmitted data, attr:opt{req, bool}-->true
</transmissionEncryption>
<checkCertificate opt="true,false">
<!--ro, opt, bool, whether to enable certificate verification, attr:opt{req, bool}-->true
</checkCertificate>
<uploadInterval min="1" max="24" def="1">
<!--ro, opt, int, log upload interval, attr:min{req, int},max{req, int},def{req, int}-->1
</uploadInterval>
<protocolType opt="tcp,udp">
<!--ro, opt, enum, subType:string, attr:opt{req, string}-->tcp
</protocolType>
<sysLogCacheSize min="10" max="3000" def="1000">
<!--ro, opt, int, range:[10,3000], attr:min{req, int},max{req, int},def{req, int}-->1000
</sysLogCacheSize>
<sysLogLevel opt="emergency,alert,critical,error,warning,notice,information,debug">
<!--ro, opt, enum, subType:string, attr:opt{req, string}-->emergency
</sysLogLevel>
<serverLogLevel opt="emergency,alert,critical,error,warning,notice,information,debug">
<!--ro, opt, enum, subType:string, attr:opt{req, string}-->emergency
</serverLogLevel>
<alarmLogCacheSize min="10" max="3000" def="1000">
<!--ro, opt, int, range:[10,3000], attr:min{req, int},max{req, int},def{req, int}-->1000
</alarmLogCacheSize>
</LogServerCap>
21.5 System Maintenance
21.5.1 Get the system service capability (JSON format)
Request URL
GET /ISAPI/System/capabilities?format=json
Query Parameter
None
Request Message
None
Response Message


{
"statusCode": 1,
/*ro, opt, int, status code, desc:1 (succeeded). It is required when an error occurred*/
"statusString": "ok",
/*ro, opt, string, status description, range:[1,64], desc:ok (succeeded). It is required when an error occurred*/
"subStatusCode": "ok",
/*ro, opt, string, sub status code, range:[1,64], desc:"ok" (succeeded). It is required when an error occurred*/
"errorCode": 1,
/*ro, req, int, error code, desc:when the value of statusCode is not 1, it corresponds to subStatusCode*/
"errorMsg": "ok",
/*ro, req, string, error information, desc:this node is required when the value of statusCode is not 1*/
"isSupportBlackFDControl": true,
/*ro, opt, bool, whether it supports list management*/
"isSupportExecuteControl": true,
/*ro, opt, bool, whether it supports arming management*/
"isSupportEventUpload": true,
/*ro, opt, bool, whether it supports uploading events*/
"isSupportSDKServer": true,
/*ro, opt, bool, whether it supports SDK service configuration*/
"isSupportAI": true,
/*ro, opt, bool, whether the applications support functions related to AI algorithm, desc:functions include AI algorithm management, task analysis,
event uploading, which will be displayed or hidden in the web*/
"isSupportBehavior": true,
/*ro, opt, bool, whether the applications support functions related to behavior analysis algorithm, desc:functions include behavior analysis algorithm
management, task analysis, event uploading, which will be displayed or hidden in the web*/
"isSupportAlgorithm": true,
/*ro, opt, bool, whether it supports the algorithm library, desc:if this node does not exist, you need to call
/ISAPI/Intelligent/algorithm/capabilities?format=json by GET method to check whether the device supports the algorithm library*/
"isSupportHttpHosts": true,
/*ro, opt, bool, whether it supports security control panel configuration, desc:related URI: /ISAPI/Event/notification/httpHosts/capabilities?
format=json*/
"isSupportDST": true,
/*ro, opt, bool, whether the device supports Daylight Saving Time (DST)*/
"isSupportEhome": true
/*ro, opt, bool, whether the device supports ISUP functions*/
}
21.5.2 Import device configuration file
Request URL
POST /ISAPI/System/configurationData?security=<security>&iv=<iv>&secretkey=<secretkey>
Query Parameter
Parameter Name Parameter Type Description
security
string
iv
secretkey
string
string
Request Message
None
Response Message
<?xml version="1.0" encoding="UTF-8"?>
<ResponseStatus xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--ro, req, object, response message, attr:version{ro, req, string, protocolVersion}-->
<requestURL>
<!--ro, req, string, request URL-->null
</requestURL>
<statusCode>
<!--ro, req, enum, status code, subType:int, desc:0:OK;1:OK;2:Device Busy;3:Device Error;4:Invalid Operation;5:Invalid XML Format;6:Invalid XML
Content;7:Reboot Required;-->0
</statusCode>
<statusString>
<!--ro, req, enum, status description, subType:string, desc:OK, Device Busy, Device Error, Invalid Operation, Invalid XML Format, Invalid XML Content,
Reboot-->OK
</statusString>
<subStatusCode>
<!--ro, req, string, error description, desc:detailed description of the error code-->OK
</subStatusCode>
</ResponseStatus>
21.5.3 Export device configuration file
-
-
-


Request URL
GET /ISAPI/System/configurationData?security=<security>&iv=<iv>&secretkey=<secretkey>
Query Parameter
Parameter Name Parameter Type Description
security
string
iv
secretkey
Request Message
None
Response Message
None
21.5.4 Get the system security capability
Request URL
GET /ISAPI/Security/capabilities
Query Parameter
None
Request Message
None
Response Message
<?xml version="1.0" encoding="UTF-8"?>
<SecurityCap xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--ro, req, object, system security capability, attr:version{req, string, protocolVersion}-->
<supportUserNums>
<!--ro, opt, int, supported maximum number of users-->0
</supportUserNums>
<userBondIpNums>
<!--ro, opt, int, supported maximum number of IP addresses that can be bound-->0
</userBondIpNums>
<userBondMacNums>
<!--ro, opt, int, supported maximum number of MAC addresses that can be bound-->0
</userBondMacNums>
<isSupCertificate>
<!--ro, opt, bool, whether the device supports authentication-->true
</isSupCertificate>
<issupIllegalLoginLock>
<!--ro, opt, bool, whether the device supports locking login-->true
</issupIllegalLoginLock>
<isSupportOnlineUser>
<!--ro, opt, bool, whether the device supports the online user configuration-->true
</isSupportOnlineUser>
<isSupportAnonymous>
<!--ro, opt, bool, whether the device supports anonymous login-->true
</isSupportAnonymous>
<isSupportStreamEncryption>
<!--ro, opt, bool, whether the device supports stream encryption-->true
</isSupportStreamEncryption>
<securityVersion opt="1,2">
<!--ro, opt, int, encryption capability set, attr:opt{req, string}, desc:the encryption capability of each version consists of two parts: encryption
algorithm and the range of encrypted nodes currently 1 refers to AES128 encryption and 2 refers to AES256 encryption, the range of encrypted nodes is
described in each protocol-->1
</securityVersion>
<keyIterateNum>
<!--ro, opt, int, secret key iteration times, dep:or,{$.SecurityCap.securityVersion,eq,1},{$.SecurityCap.securityVersion,eq,2}, desc:this node depends
on the node securityVersion, the range is between 100 and 1000-->100
</keyIterateNum>
<isSupportUserCheck>
<!--ro, opt, bool, whether the device supports verifying the login password when editing (editing/adding/deleting) user parameters, dep:or,
{$.SecurityCap.securityVersion,eq,0},{$.SecurityCap.securityVersion,eq,1}, desc:it is an added capability, which indicates that whether supporting the login
password verification for editing/adding/deleting user parameters, this node depends on the node securityVersion, which means that it is only valid for the
versions that support encrypting the sensitive information-->true
</isSupportUserCheck>
<isSupportGUIDFileDataExport>
<!--ro, opt, bool, whether the device supports exporting the device's GUID file, desc:related URI: /ISAPI/Security/GUIDFileData-->true
</isSupportGUIDFileDataExport>
<isSupportSecurityQuestionConfig>
string
string
-
-
-


<!--ro, opt, bool, whether the device supports answering security questions, desc:related URI: /ISAPI/Security/questionConfiguration-->true
</isSupportSecurityQuestionConfig>
<supportSecurityNode opt="wirelessServer,wirelessDial">
<!--ro, opt, string, additional node for supporting sensitive information encryption, attr:opt{req, string},
desc:in the earlier version of the solution for encrypting the sensitive information via ISAPI (i.e., the solution for transmitting plaintext via ISAPI),
some URIs containing sensitive information are left out now these URIs need to be encrypted for transmission, this capability node is added to be compatible
with old devices
if wirelessServer in this node is returned, it indicates that the following sensitive information should be encrypted
/ISAPI/System/Network/interfaces/<ID>/wirelessServer/capabilities, /ISAPI/System/Network/interfaces/<ID>/wirelessServer, if wirelessDial in this
node is returned, it indicates that the following sensitive information should be encrypted
/ISAPI/System/Network/WirelessDial/Interfaces,
/ISAPI/System/Network/WirelessDial/Interfaces/<ID>-->wirelessServer
</supportSecurityNode>
<isSupportGetOnlineUserListSC>
<!--ro, opt, bool, whether the device supports searching the online user list, desc:related URI: /ISAPI/Security/onlineUser-->true
</isSupportGetOnlineUserListSC>
<SecurityLimits>
<!--ro, opt, object, capability of configuring security limit parameters-->
<LoginPasswordLenLimit min="1" max="16">
<!--ro, opt, string, length limit of the user's login password, attr:min{req, int},max{req, int}-->1
</LoginPasswordLenLimit>
<SecurityAnswerLenLimit min="1" max="128">
<!--ro, opt, string, length limit of the security question's answer, attr:min{req, int},max{req, int}-->1
</SecurityAnswerLenLimit>
</SecurityLimits>
<RSAKeyLength opt="512,1024,2048" def="2048">
<!--ro, opt, enum, HTTPS certificate length, subType:int, attr:opt{req, string},def{req, string}, desc:512, 1024, 2048-->2048
</RSAKeyLength>
<isSupportONVIFUserManagement>
<!--ro, opt, bool, whether the device supports user management of Open Network Video Interface Protocol-->true
</isSupportONVIFUserManagement>
<WebCertificateCap>
<!--ro, opt, object, HTTP authentication capability, desc:if this node is not returned, it indicates that device supports basic and digest
authentication-->
<CertificateType opt="basic,digest,digest/basic">
<!--ro, req, enum, certificate type, subType:string, attr:opt{req, string}, desc:“basic” (basic authentication), “digest” (digest authentication),
“digest/basic” (digest/basic authentication)-->basic
</CertificateType>
<SecurityAlgorithm>
<!--ro, opt, object, security algorithm, dep:or,{$.SecurityCap.WebCertificateCap.CertificateType,eq,digest},
{$.SecurityCap.WebCertificateCap.CertificateType,eq,digest/basic}-->
<algorithmType opt="MD5,SHA256,MD5/SHA256">
<!--ro, opt, enum, algorithm type, subType:string, attr:opt{req, string}, desc:“MD5”, “SHA256”, “MD5/SHA256”-->MD5
</algorithmType>
</SecurityAlgorithm>
</WebCertificateCap>
<isSupportConfigFileImport>
<!--ro, opt, bool, whether the device supports importing the configuration file, desc:true (support), this node is not returned (not support)-->true
</isSupportConfigFileImport>
<isSupportConfigFileExport>
<!--ro, opt, bool, whether the device supports exporting the configuration file, desc:true (support), this node is not returned (not support)-->true
</isSupportConfigFileExport>
<cfgFileSecretKeyLenLimit min="0" max="16">
<!--ro, opt, int, length limit of the configuration file's verification key, attr:min{req, int},max{req, int}-->1
</cfgFileSecretKeyLenLimit>
<supportIPCActivatePassword>
<!--ro, opt, bool, whether the device supports configuring the password for activating the network camera-->true
</supportIPCActivatePassword>
<isIrreversible>
<!--ro, opt, bool, whether the device supports irreversible password storage, desc:If this function is not supported, the plaintext password of the user
information will be stored in the device; otherwise, the password will be hashed for storage in the device.-->true
</isIrreversible>
<salt>
<!--ro, opt, string, the specific salt used by the user to log in-->test
</salt>
<isSupportOnvifInfo>
<!--ro, opt, bool, whether the device supports getting the Open Network Video Interface Protocol, desc:true (support), this node is not returned (not
support)-->true
</isSupportOnvifInfo>
<isSupportPictureURlCertificate opt="true,false">
<!--ro, opt, bool, whether the device supports configuring parameters for picture URL authentication, attr:opt{req, string}, desc:if this node is not
returned, it indicates the digest authentication for picture URL by default-->true
</isSupportPictureURlCertificate>
<isSupportGB35114Certificate>
<!--ro, opt, bool, whether supports GB35114 protocol and CA/SIP authentication certificate-->true
</isSupportGB35114Certificate>
<isSupportAuthenticationMode opt="uKey,private">
<!--ro, opt, enum, verification mode, subType:string, attr:opt{req, string}, desc:“uKey”, “private”-->private
</isSupportAuthenticationMode>
<isSupportUnloggedUserPermissionConfig opt="true,false">
<!--ro, opt, bool, whether the device supports configuring permission for users that have not logged in, attr:opt{req, string}-->true
</isSupportUnloggedUserPermissionConfig>
<isSupportUserNamePasswordCheckUpgrade>
<!--ro, opt, bool, whether the device supports upgrading the verification of the user name and password, desc:if this node is not returned, it indicates
that device does not support this function-->true
</isSupportUserNamePasswordCheckUpgrade>
<isSupportDeviceCertificatesManagement>
<!--ro, opt, bool, whether the device supports device certificate management, desc:if this node is not returned, it indicates that device does not
support this function-->true
</isSupportDeviceCertificatesManagement>
<isSupportSIPCertificatesManagement>
<!--ro, opt, bool, whether the device supports SIP certificate management, desc:this node is returned if the device supports this function and not
returned if device does not support this function, related URI: /ISAPI/Security/SIPCertificate, additional node: <SIPCertificatesManagementCap>-->true
</isSupportSIPCertificatesManagement>


</isSupportSIPCertificatesManagement>
<isSupportDeviceSelfSignCertExport>
<!--ro, opt, bool, whether the device supports exporting self-signed certificate-->true
</isSupportDeviceSelfSignCertExport>
<isSupportSecurityEmail>
<!--ro, opt, bool, whether the device supports configuring the security email, desc:if this node is not returned, it indicates that device does not
support this function-->true
</isSupportSecurityEmail>
<isSupportRTSPCertificate opt="true,false">
<!--ro, opt, bool, whether the device supports RTSP certificate management, attr:opt{req, string}-->true
</isSupportRTSPCertificate>
<maxIllegalLoginTimes min="3" max="20" def="5">
<!--ro, opt, int, maximum failed illegal login attempts, range:[3,20], attr:min{req, int},max{req, int},def{req, int}, desc:this node is valid when the
value of the node issupportIllegalLoginLock is true and will be returned when the maximum failed attempts of illegally logging in to the device reach the
limit-->3
</maxIllegalLoginTimes>
<SecurityAdvanced>
<!--ro, opt, object, security advanced parameters-->
<securityEnhanced>
<!--ro, opt, bool, whether the device supports security reinforcement-->true
</securityEnhanced>
<noOperationEnabled>
<!--ro, req, bool, whether to enable the control timeout when there is no operation-->true
</noOperationEnabled>
<noOperationTime min="1" max="60" def="15">
<!--ro, req, int, control timeout when there is no operation, range:[1,60], unit:min, attr:min{req, int},max{req, int},def{req, int}-->15
</noOperationTime>
<isSupportDigestStatus>
<!--ro, opt, bool, digest status-->true
</isSupportDigestStatus>
<passwordLimitLevel opt="middling,high">
<!--ro, opt, enum, password strength limit level, subType:string, attr:opt{req, string},
desc:the configured password is required by the following limit
“middling” (middle level), “high” (high level), middle level password contains 8 to 16 characters, including at least 2 types of the following characters:
digits, lower case letters, upper case letters, and special characters; high level password contains 8 to 16 characters, including at least 3 types of the
following characters: digits, lower case letters, upper case letters, and special characters-->middling
</passwordLimitLevel>
</SecurityAdvanced>
<LoginLinkNum>
<!--ro, opt, object, number of controls logging in at the same time-->
<maxLinkNum min="1" max="128" def="50">
<!--ro, req, int, maximum number of controls logging in at the same time, range:[1,128], attr:min{req, int},max{req, int},def{req, int}-->50
</maxLinkNum>
</LoginLinkNum>
<isSupportCCClientCertificate>
<!--ro, opt, bool, whether the device supports the CC (Client Certificate) function-->true
</isSupportCCClientCertificate>
<passwordValidity min="0" max="365">
<!--ro, opt, string, range of the password validity period, range:[0,365], attr:min{req, int},max{req, int}, desc:if this node is returned, it indicates
that the device supports configuring the password validity period, and only the administrator can edit the configuration-->1
</passwordValidity>
<isSupportResetChannelPassword>
<!--ro, opt, bool, whether the device supports resetting the password of the channel-->true
</isSupportResetChannelPassword>
<DoubleVerificationCap>
<!--ro, opt, object, secondary authentication capability-->
<isSupportUsersConfig>
<!--ro, opt, bool, whether the device supports configuring users for secondary authentication-->true
</isSupportUsersConfig>
<isSupportUsersPermissionConfig>
<!--ro, opt, bool, whether the device supports configuring user permission for secondary authentication-->true
</isSupportUsersPermissionConfig>
</DoubleVerificationCap>
<isSupportUserSearch>
<!--ro, opt, bool, whether the device supports searching users-->true
</isSupportUserSearch>
<keypadPassword min="1" max="10">
<!--ro, opt, int, keypad password length, attr:min{req, int},max{req, int}, desc:When the password length of different user types is different, this
node only indicates the keypad password length of the administrator; otherwise, the keypad password length of all user types is the same and defined by the
value of this node-->1
</keypadPassword>
<installerKeypadPassword min="1" max="10">
<!--ro, opt, int, keypad password length of the installer, attr:min{req, int},max{req, int}-->1
</installerKeypadPassword>
<operatorKeypadPassword min="1" max="10">
<!--ro, opt, int, keypad password length of the operator, attr:min{req, int},max{req, int}-->1
</operatorKeypadPassword>
<userOperateType opt="1,2,3">
<!--ro, opt, enum, user type, subType:int, attr:opt{req, string}, desc:1 (network user), 2 (keypad user), 3 (network user and keypad user)-->1
</userOperateType>
<isSptUserEnabled>
<!--ro, opt, bool, whether the device supports configuring parameters for enabling the user-->true
</isSptUserEnabled>
<isSptAdminCap>
<!--ro, opt, bool, whether the device supports getting the admin permission capability-->true
</isSptAdminCap>
<isSupportBackLogCfg>
<!--ro, opt, bool, whether the device supports configuring basic parameters of the background log-->true
</isSupportBackLogCfg>
<isSupportBackLogExport>
<!--ro, opt, bool, whether the device supports exporting the background log-->true
</isSupportBackLogExport>
<isSupportModifyInnerPassword opt="true,false">
<!--ro, opt, bool, whether the device supports editing its built-in passwords,, attr:opt{req, string}, desc:such as the database password, system


account password-->true
</isSupportModifyInnerPassword>
<isSupportEncryptCertificate>
<!--ro, opt, bool, whether the device supports certificate encryption, desc:/ISAPI/Security/deviceCertificate-->true
</isSupportEncryptCertificate>
<maxIllegalLoginLockTime min="1" max="120" def="30.00">
<!--ro, opt, int, lock time range, range:[1,120], unit:min, attr:min{req, int},max{req, int},def{req, int}-->1
</maxIllegalLoginLockTime>
<cloudSensitiveInfoEncryptType>
<!--ro, opt, string, encryption type of the cloud sensitive information, desc:the current device returns the value "2.1", which indicates that the
method of generating the key for encrypting the sensitive information is SHA256 (calc_sha256 (user, salt, SHA256 (user+salt2+SHA256 (user+salt+password))) +
AaBbCcDd1234!@#$)-->2.1
</cloudSensitiveInfoEncryptType>
<isSupportCertificateCustomID>
<!--ro, opt, bool, whether the device supports using the user's custom ID to configure the certificate-->true
</isSupportCertificateCustomID>
<isSupportResetLANPassword>
<!--ro, opt, bool, whether the device supports resetting the device's password in the LAN, desc:related URI:
/ISAPI/Security/resetPassword/certification?format=json-->true
</isSupportResetLANPassword>
<isSupportPicHttpsCertificatesManagement>
<!--ro, opt, bool, whether the device supports managing the HTTPS certificate for pictures, desc:true (support), this node is not returned (not
support)-->true
</isSupportPicHttpsCertificatesManagement>
<isSupportAKSKImport>
<!--ro, opt, bool, whether the device supports importing AKSK, desc:true (support), this node is not returned (not support)-->true
</isSupportAKSKImport>
<isSupportAKSKExport>
<!--ro, opt, bool, whether the device supports exporting AKSK, desc:true (support), this node is not returned (not support)-->true
</isSupportAKSKExport>
<isSupportAKSKReset>
<!--ro, opt, bool, whether the device supports resetting AKSK, desc:true (support), this node is not returned (not support)-->true
</isSupportAKSKReset>
<ExportCertificateFile>
<!--ro, opt, object, whether the device supports exporting the certificate, desc:related URI: POST
/ISAPI/Security/serverCertificate/exportCertificateFile-->
<type opt="GB35114,GB35114Service">
<!--ro, req, enum, types of certificates that can be exported, subType:string, attr:opt{req, string}, desc:“GB35114” (support exporting GB35114
certificate for the client), “GB35114Service” (support exporting GB35114 certificate for the server)-->GB35114
</type>
</ExportCertificateFile>
<isSupportGB351114FDWSFCertificate>
<!--ro, opt, bool, whether the device supports FDWSF certificate management, desc:true (support), this node is not returned (not support), related URIs:
/ISAPI/Security/GB351114/FDWSFCertificate/capabilities?format=json, POST /ISAPI/Security/GB351114/FDWSFCertificate?format=json, GET
/ISAPI/Security/GB351114/FDWSFCertificate?format=json, and DELETE /ISAPI/Security/GB351114/FDWSFCertificate?format=json-->true
</isSupportGB351114FDWSFCertificate>
<isSupportMediaObjectEncryption>
<!--ro, opt, bool, whether supports setting encryption parameters of the private target in media data for the specified video channel, desc:if this
function is supported, this node will be returned and its value is true; otherwise, this node will not be returned. Related URI:
/ISAPI/Security/MediaObjectEncryption/capabilities?format=json-->true
</isSupportMediaObjectEncryption>
<isSupportDisclaimer>
<!--ro, opt, bool, whether support configuring the product disclaimer, desc:if this function is supported, this node will be returned and its value is
true; otherwise, this node will not be returned. Related URI: /ISAPI/Security/disclaimer/capabilities?format=json-->true
</isSupportDisclaimer>
<isSupportSoftwareLicense>
<!--ro, opt, bool, whether support configuring the product open source statement, desc:if this function is supported, this node will be returned and its
value is true; otherwise, this node will not be returned. Related URI: /ISAPI/Security/softwareLicense?format=json-->true
</isSupportSoftwareLicense>
<isSupportInstallerCap>
<!--ro, opt, bool, whether the device supports getting the installer permission, desc:if this function is supported, this node will be returned and its
value is true; otherwise, this node will not be returned. Related URI: /ISAPI/Security/UserPermission/installer/capabilities?format=json-->true
</isSupportInstallerCap>
<isSupportResetPasswordFile>
<!--ro, opt, bool, whether the device supports exporting and importing the secret key file of device in the LAN, desc:Related URI:
/ISAPI/Security/resetPassword/keyFile/capabilities?format=json-->true
</isSupportResetPasswordFile>
<isNotSupportLogSeverCertificate>
<!--ro, opt, bool, whether the device support importing log server certificate, desc:related URI: /ISAPI/Security/serverCertificate/certificate-->true
</isNotSupportLogSeverCertificate>
</SecurityCap>
21.5.5 Set device language parameters
Request URL
PUT /ISAPI/System/DeviceLanguage
Query Parameter
None
Request Message


<?xml version="1.0" encoding="UTF-8"?>
<DeviceLanguage xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--req, object, languages supported by the device, attr:version{req, string, protocolVersion}-->
<language>
<!--req, enum, language, subType:string, desc:"SimChinese" (simplified Chinese), "TraChinese" (traditional Chinese), "English", "Russian", "Bulgarian",
"Hungarian", "Greek", "German", "Italian", "Czech", "Slovakia", "French", "Polish", "Dutch", "Portuguese", "Spanish", "Romanian", "Turkish", "Japanese",
"Danish", "Swedish", "Norwegian", "Finnish", "Korean", "Thai", "Estonia", "Vietnamese", "Hebrew", "Latvian", "Arabic", "Sovenian" (Slovenian), "Croatian",
"Lithuanian", "Serbian", "BrazilianPortuguese" (Brazilian Portuguese), "Indonesian", "Ukrainian", "EURSpanish"-->SimChinese
</language>
</DeviceLanguage>
Response Message
<?xml version="1.0" encoding="UTF-8"?>
<ResponseStatus xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--ro, req, object, response message, attr:version{ro, req, string, protocolVersion}-->
<requestURL>
<!--ro, req, string, request URL-->null
</requestURL>
<statusCode>
<!--ro, req, enum, status code, subType:int, desc:0 (OK), 1 (OK), 2 (Device Busy), 3 (Device Error), 4 (Invalid Operation), 5 (Invalid XML Format), 6
(Invalid XML Content), 7 (Reboot Required)-->0
</statusCode>
<statusString>
<!--ro, req, enum, status information, subType:string, desc:"OK" (succeeded), "Device Busy", "Device Error", "Invalid Operation", "Invalid XML Format",
"Invalid XML Content", "Reboot" (reboot device)-->OK
</statusString>
<subStatusCode>
<!--ro, req, string, sub status code, which describes the error in details, desc:sub status code, which describes the error in details-->OK
</subStatusCode>
</ResponseStatus>
21.5.6 Get the languages supported by the device
Request URL
GET /ISAPI/System/DeviceLanguage
Query Parameter
None
Request Message
None
Response Message
<?xml version="1.0" encoding="UTF-8"?>
<DeviceLanguage xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--ro, req, object, languages supported by the device, attr:version{req, string, protocolVersion}-->
<language>
<!--ro, req, enum, language, subType:string, desc:"SimChinese"-simplified Chinese, "TraChinese"-traditional Chinese, "English", "Russian", "Bulgarian",
"Hungarian", "Greek", "German", "Italian", "Czech", "Slovakia", "French", "Polish", "Dutch", "Portuguese", "Spanish", "Romanian", "Turkish", "Japanese",
"Danish", "Swedish", "Norwegian", "Finnish", "Korean", "Thai", "Estonia", "Vietnamese", "Hebrew", "Latvian", "Arabic", "Sovenian"-Slovenian, "Croatian",
"Lithuanian", "Serbian", "BrazilianPortuguese"-Brazilian Portuguese, "Indonesian", "Ukrainian", "EURSpanish“-->SimChinese
</language>
</DeviceLanguage>
21.5.7 Get the capability of configuring the device language
Request URL
GET /ISAPI/System/DeviceLanguage/capabilities
Query Parameter
None
Request Message
None
Response Message


<?xml version="1.0" encoding="UTF-8"?>
<DeviceLanguage xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--ro, opt, object, device language configuration, attr:version{req, string, protocolVersion}-->
<language
opt="SimChinese,TraChinese,English,Russian,Bulgarian,Hungarian,Greek,German,Italian,Czech,Slovakia,French,Polish,Dutch,Portuguese,Spanish,Romanian,Turkish,J
apanese,Danish,Swedish,Norwegian,Finnish,Korean,Thai,Estonia,Vietnamese,Hebrew,Latvian,Arabic,Sovenian,Croatian,Lithuanian,Serbian,BrazilianPortuguese,Indon
esian,Ukrainian,EURSpanish,Uzbek,Kazak,Kirghiz,Farsi,Azerbaidzhan,Burmese,Mongolian,Anglicism">
<!--ro, req, enum, language, subType:string, attr:opt{req, string}, desc:"SimChinese" (simplified Chinese), "TraChinese" (traditional Chinese),
"English", "Russian", "Bulgarian", "Hungarian", "Greek", "German", "Italian", "Czech", "Slovakia", "French", "Polish", "Dutch", "Portuguese", "Spanish",
"Romanian", "Turkish", "Japanese", "Danish", "Swedish", "Norwegian", "Finnish", "Korean", "Thai", "Estonia", "Vietnamese", "Hebrew", "Latvian", "Arabic",
"Sovenian" (Slovenian), "Croatian", "Lithuanian", "Serbian", "BrazilianPortuguese" (Brazilian Portuguese), "Indonesian", "Ukrainian", "EURSpanish"-
>SimChinese
</language>
<upgradeFirmWareEnabled>
<!--ro, opt, bool, whether to enable upgrading the firmware-->true
</upgradeFirmWareEnabled>
</DeviceLanguage>
21.5.8 Set SSH parameters
Request URL
PUT /ISAPI/System/Network/ssh
Query Parameter
None
Request Message
<?xml version="1.0" encoding="UTF-8"?>
<SSH xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--wo, opt, object, attr:version{opt, string, protocolVersion}-->
<enabled>
<!--wo, req, bool, whether to enable the function-->true
</enabled>
<port>
<!--wo, opt, int-->22
</port>
</SSH>
Response Message
<?xml version="1.0" encoding="UTF-8"?>
<ResponseStatus xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--ro, req, object, response message, attr:version{ro, req, string, protocolVersion}-->
<requestURL>
<!--ro, req, string, request URL-->null
</requestURL>
<statusCode>
<!--ro, req, enum, status code, subType:int, desc:0 (OK), 1 (OK), 2 (Device Busy), 3 (Device Error), 4 (Invalid Operation), 5 (Invalid XML Format), 6
(Invalid XML Content), 7 (Reboot Required)-->0
</statusCode>
<statusString>
<!--ro, req, enum, read-only,status description: OK,Device Busy,Device Error,Invalid Operation,Invalid XML Format,Invalid XML Content,Reboot,Additional
Error, subType:string, desc:"OK" (succeeded), "Device Busy", "Device Error", "Invalid Operation", "Invalid XML Format", "Invalid XML Content", "Reboot"
(reboot device)-->OK
</statusString>
<subStatusCode>
<!--ro, req, string, sub status code, which describes the error in details, desc:sub status code, which describes the error in details-->OK
</subStatusCode>
</ResponseStatus>
21.5.9 Get the storage capability of the device
Request URL
GET /ISAPI/ContentMgmt/capabilities
Query Parameter
None
Request Message
None


Response Message
<?xml version="1.0" encoding="UTF-8"?>
<RacmCap xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--ro, req, object, device storage capability, attr:version{req, string, protocolVersion}-->
<isSupportZeroChan>
<!--ro, opt, bool, whether the device supports channel-zero, desc:related URI: /ISAPI/ContentMgmt/ZeroVideo/channels-->true
</isSupportZeroChan>
<inputProxyNums>
<!--ro, opt, int, supported number of digital channels, desc:related URI: /ISAPI/ContentMgmt/InputProxy/channels/<ID>-->0
</inputProxyNums>
<eSATANums>
<!--ro, opt, int, supported number of eSATA interfaces-->0
</eSATANums>
<miniSASNums>
<!--ro, opt, int, supported number of miniSAS interfaces-->0
</miniSASNums>
<nasNums>
<!--ro, opt, int, supported number of NAS devices, desc:related URI: /ISAPI/ContentMgmt/Storage/nas-->0
</nasNums>
<ipSanNums>
<!--ro, opt, int, supported number of IPSANs-->0
</ipSanNums>
<isSupportRaid>
<!--ro, opt, bool, whether the device supports RAID-->true
</isSupportRaid>
<isSupportExtHdCfg>
<!--ro, opt, bool, whether the device supports advanced HDD management-->true
</isSupportExtHdCfg>
<isSupportTransCode>
<!--ro, opt, bool, whether the device supports live view transcoding-->true
</isSupportTransCode>
<isSupportIpcImport>
<!--ro, opt, bool, whether the device supports importing the configuration file of the network camera, desc:related URI:
/ISAPI/ContentMgmt/InputProxy/ipcConfig-->true
</isSupportIpcImport>
<NasMountType>
<!--ro, opt, bool, Nas type-->true
<isNFSSupportAuthentication>
<!--ro, opt, bool, whether the device supports NFS authentication-->true
</isNFSSupportAuthentication>
<isCIFSSupportAuthentication>
<!--ro, opt, bool, whether the device supports CIFS authentication-->true
</isCIFSSupportAuthentication>
</NasMountType>
<isSupportIpcStreamType>
<!--ro, opt, bool, whether the device supports the stream type of the network camera-->true
</isSupportIpcStreamType>
<isSupportIOInputProxy>
<!--ro, opt, bool, whether the device supports dynamic input channels, desc:related URI: /ISAPI/ContentMgmt/IOProxy/inputs-->true
</isSupportIOInputProxy>
<isSupportIOOutputProxy>
<!--ro, opt, bool, whether the device supports dynamic output channels, desc:related URI: /ISAPI/ContentMgmt/IOProxy/outputs-->true
</isSupportIOOutputProxy>
<isSupportPTZRs485Proxy>
<!--ro, opt, bool, whether the device supports dynamic PTZ RS-485 channels, desc:related URI: /ISAPI/ContentMgmt/PTZCtrlProxy/capabilities-->true
</isSupportPTZRs485Proxy>
<isSupportSrcIDSearch>
<!--ro, opt, bool, whether the device supports stream ID search-->true
</isSupportSrcIDSearch>
<isSupportReversePlayback>
<!--ro, opt, bool, whether the device supports reverse playback-->true
</isSupportReversePlayback>
<isSupportSMARTTest>
<!--ro, opt, bool, whether the device supports HDD detection, desc:related URI: /ISAPI/ContentMgmt/Storage/hdd/SMARTTest/config-->true
</isSupportSMARTTest>
<isSupportDownloadByTime>
<!--ro, opt, bool, whether the device supports downloading by time, desc:related URI: /ISAPI/ContentMgmt/download/capabilities-->true
</isSupportDownloadByTime>
<pictureSearchType
opt="AllEvent,CMR,MOTION,ALARM,EDR,ALARMANDMOTION,Command,pir,wlsensor,callhelp,facedetection,FieldDetection,scenechangedetection,LineDetection,
regionEntrance,regionExiting,loitering,group,rapidMove,parking,unattendedBaggage,attendedBaggage,vehicleDetection,manual,manualSnapShot,playSnapShot,safetyH
elmet,
personQueueCounting,personQueueTime,violentMotion,leavePosition,advReachHeight,peopleNumChange,mixedTargetDetection,illegalParking,pedestrian,construction,r
oadblock,
abandonedObject,trafficAccident,fogDetection,smokeDetection,personDensity,failDown,accessController,videoInterCom,GJD,Luminite,OPTEX,securityControlPanel,ge
tUp,toiletTarry,
playCellphone,vehicleMonitor,vibrationDetection,running,retention,spacingChange,yardTarry,keyPersonGetUp,sitQuietly,standUp,plateRecognition,smoking,onThePh
one,fatigueDriving,
notLookingStraightAhead,leaveThePost,seatBelt,sunglasses,identityAbnormal,ForwardCollisionWarning,LaneDepartureWarning,BlindSpotDetection,HeadwayMonitoringW
arning,
PedestrianCollisionWarning,SuddenSpeedUp,SuddenSpeedDown,SuddenLeftTurn,SuddenRightTurn,Turnover,NotYieldToPedestrian,unregisteredStreetVendor,stallOutsideS
hop,stallOccupyingRoad,
illegalHeap,illegalParkingofNonMotorVehicle,illegalOutdoorAdvertisement,packGarbage,stallUnderUmbrella,dustbinOverflow,exposeGarbage,hangClothingAlongStreet,allPic,ATMPanel,
ATMSurround,ATMFace,ATMSafetyCabin,loitering,smokeDetectAlarm,temperatureIntervalMeasurement,AIOP,tail,abnormalFace,normalFace,multiFace,callFace,sunglasses
Face,humanEnter,operateOverTime,stickUp,installScanner,objectPlacedOrTaken,fakeCard,securityChecking,pothole,crack,roadMaint,imageCapture,ReID,methaneConcen
trationException,methaneLightIntensityException,bannerDetection,variableDataEvent,shipChannelAbnormal,radarVideoDetection">
<!--ro,
opt, enum, picture search type, subType:string, attr:opt{req, string}, desc:“AllEvent”, “CMR”, “MOTION”, “ALARM”, “EDR”, “ALARMANDMOTION”,
“pir:PIR”, “wlsensor”, “callhelp”, “facedetection”, “FieldDetection”, “scenechangedetection”, “LineDetection”, “regionEntrance”, “regionExiting”,
“loitering”, “group”, “rapidMove”, “parking”, “unattendedBaggage”, “attendedBaggage”, “vehicleDetection”, “manual”, “manualSnapShot”, “playSnapShot”,
“safetyHelmet”, ”personQueueCounting”, “personQueueTime”, “violentMotion”, “leavePosition”, “advReachHeight”, “peopleNumChange”, “mixedTargetDetection”,


“safetyHelmet”, ”personQueueCounting”, “personQueueTime”, “violentMotion”, “leavePosition”, “advReachHeight”, “peopleNumChange”, “mixedTargetDetection”,
“illegalParking”, “pedestrian”, “construction”, “roadblock”, “evidence”, “crosslane”, “vehicleexist”, “lanechange”, “wrongdirection”, “congestion”,
“turnround”, “parallelParking”, “abandonedObject”, “trafficAccident”, “fogDetection”, “smokeDetection”, “personDensity”, “failDown”, “accessController”,
“videoInterCom”, “GJD”, “Luminite”, “OPTEX”, “securityControlPanel”, “getUp”, “toiletTarry”, “playCellphone”, “vehicleMonitor”, “running”, “retention”,
“spacingChange”, “yardTarry”, “keyPersonGetUp”, “sitQuietly”, “standup”, “plateRecognition”, “smoking”, “onThePhone”, “fatigueDriving”,
“notLookingStraightAhead”, “leaveThePost”, “seatbelt”, “sunglasses”, “identityAbnormal”, “ForwardCollisionWarning”, “LaneDepartureWarning”,
“BlindSpotDetection”, “HeadwayMonitoringWarning”, “PedestrianCollisionWarning”, “SuddenSpeedUp”, “SuddenSpeedDown”, “SuddenLeftTurn”, “SuddenRightTurn”,
“Turnover”, “NotYieldToPedestrian;allPic”, “ATMPanel”, “ATMSurround”, “ATMFace”, “ATMSafetyCabin”, “smokeDetectAlarm”, “temperatureIntervalMeasurement”,
“AIOP”, “tail”, “abnormalFace”, “normalFace;callFace”, “sunglassesFace”, “humanEnter”, “operateOverTime”, “stickup”, “installScanner”,
“objectPlacedOrTaken”, “fakeCard”, “securityChecking”, “pothole”, “crack”, “roadMaint”, “imageCapture”, “ReID”, “thermalVehicleDetection”,
“methaneConcentrationException”, “methaneLightIntensityException”, “bannerDetection”, “waterQualityDetection”, “waterLevelDetection”, “parallelParking”,
“methaneConcentrationException”, “variableDataEvent”, “VOCsGasDetection”, “shipChannelAbnormal”, ”radarVideoDetection”, “AIDfogDetection:AID”-->AllEvent
</pictureSearchType>
<recordSearchType
opt="AllEvent,CMR,MOTION,ALARM,EDR,ALARMANDMOTION,Command,pir,wlsensor,callhelp,facedetection,FieldDetection,scenechangedetection,LineDetection,
regionEntrance,regionExiting,loitering,group,rapidMove,parking,unattendedBaggage,attendedBaggage,vehicleDetection,manual,manualSnapShot,playSnapShot,safetyH
elmet,
failDown,personDensityDetection,smokeDetection,vibrationDetection,unregisteredStreetVendor,stallOutsideShop,stallOccupyingRoad,illegalHeap,illegalParkingofN
on-MotorVehicle,
illegalOutdoorAdvertisement,packGarbage,stallUnderUmbrella,dustbinOverflow,exposeGarbage,hangClothingAlongStreet,ATMPanel,ATMSurround,ATMFace,ATMSafetyCabin
,temperatureIntervalMeasurement,AIOP,securityChecking,scheduledRecordUpload,variableDataEvent">
<!--ro, opt, enum, video search type, subType:string, attr:opt{req, string}, desc:“AllEvent”, “CMR”, “MOTION”, “ALARM”, “EDR”, “ALARMANDMOTION”, “pir”,
“wlsensor”, “callhelp”, “facedetection”, “FieldDetection”, “scenechangedetection”, “LineDetection”, “regionEntrance”, “regionExiting”, “loitering”, “group”,
“rapidMove”, “parking”, “unattendedBaggage”, “attendedBaggage”, “vehicleDetection”, “manual”, “manualSnapShot”, “playSnapShot”, “safetyHelmet”,
“personDensityDetection”, “smokeDetection”, “ATMPanel”, “ATMSurround”, “ATMFace”, “ATMSafetyCabin”, “temperatureIntervalMeasurement”, “AIOP”,
“securityChecking”, “scheduledRecordUpload”, “thermalVehicleDetection”, “waterQualityDetection”, “waterLevelDetection”, “methaneConcentrationException”,
“variableDataEvent”-->AllEvent
</recordSearchType>
<isSupportActivateIpc>
<!--ro, opt, bool, whether the device supports activating the network camera-->true
</isSupportActivateIpc>
<isSupportCheckIpcSecurity>
<!--ro, opt, object, whether the device supports IPC security verification-->
<isSupportCheckPassword>
<!--ro, opt, bool, whether the device supports password detection-->true
</isSupportCheckPassword>
</isSupportCheckIpcSecurity>
<isSupportMainAndSubRecord>
<!--ro, opt, bool, whether the device supports the main stream and sub-stream recording-->true
</isSupportMainAndSubRecord>
<isSupportSyncIPCPassword>
<!--ro, opt, bool, whether the device supports synchronizing the password of the network camera-->true
</isSupportSyncIPCPassword>
<isSupportTransferIPC>
<!--ro, opt, bool, whether the device supports transparent transmission of the network camera-->true
</isSupportTransferIPC>
<isSupportSmartSearch>
<!--ro, opt, bool, whether the device supports video dual-VCA, desc:related URI: /ISAPI/ContentMgmt/SmartSearch/capabilities-->true
</isSupportSmartSearch>
<isSupportPOS>
<!--ro, opt, bool, whether the device supports POS-->true
</isSupportPOS>
<isSupportLinkNum>
<!--ro, opt, bool, whether the device supports getting the number of links, desc:related URI: /ISAPI/ContentMgmt/InputProxy/channels/<ID>/linkNum-->true
</isSupportLinkNum>
<isSupportPassBackBasicCfg>
<!--ro, opt, bool, whether the device supports configuring basic parameters of the CVR copy-back function, desc:related URI:
/ISAPI/ContentMgmt/record/passback/basicCfg/capabilities-->true
</isSupportPassBackBasicCfg>
<PassBackTaskConfig>
<!--ro, opt, object, capability of managing tasks of the CVR copy-back function-->
<isSupportAddTask>
<!--ro, opt, bool, whether the device supports adding a task, desc:related URI: /ISAPI/ContentMgmt/record/passback/addTask/capabilities-->true
</isSupportAddTask>
<isSupportSearchTask>
<!--ro, opt, bool, whether the device supports searching tasks, desc:related URI: /ISAPI/ContentMgmt/record/passback/searchTask/capabilities-->true
</isSupportSearchTask>
<isSupportControlTask>
<!--ro, opt, bool, whether the device supports controlling the task, desc:related URI: /ISAPI/ContentMgmt/record/passback/controlTask/capabilities-
>true
</isSupportControlTask>
<isSupportDeleteTask>
<!--ro, opt, bool, whether the device supports deleting the task, desc:related URI: /ISAPI/ContentMgmt/record/passback/deleteTask/capabilities-->true
</isSupportDeleteTask>
</PassBackTaskConfig>
<PassBackPlanConfig>
<!--ro, opt, object, capability of configuring the CVR copy-back schedule-->
<isSupportAddPlan>
<!--ro, opt, bool, whether the device supports adding a schedule, desc:related URI: /ISAPI/ContentMgmt/record/passback/addPlan/capabilities-->true
</isSupportAddPlan>
<isSupportSearchPlan>
<!--ro, opt, bool, whether the device supports searching schedules, desc:related URI: /ISAPI/ContentMgmt/record/passback/searchPlan/capabilities-
>true
</isSupportSearchPlan>
<isSupportDeletePlan>
<!--ro, opt, bool, whether the device supports deleting the schedule, desc:related URI: /ISAPI/ContentMgmt/record/passback/deletePlan/capabilities-
>true
</isSupportDeletePlan>
</PassBackPlanConfig>
<IRAIDCap>
<!--ro, opt, object, network array capability-->
<isSupportIRAIDRapidConfiguration>
<!--ro, opt, bool, whether the device supports the rapid IRAID configuration, desc:related URI:
/ISAPI/ContentMgmt/Storage/IRAID/RapidConfiguration/capabilities-->true
</isSupportIRAIDRapidConfiguration>


</isSupportIRAIDRapidConfiguration>
</IRAIDCap>
<isSupportStorageExtraInfo>
<!--ro, opt, bool, whether the device supports configuring additional storage information, desc:related URI:
/ISAPI/ContentMgmt/Storage/ExtraInfo/capabilities-->true
</isSupportStorageExtraInfo>
<isSupportRecordStatus>
<!--ro, opt, bool, whether the device supports getting the recording status, desc:related URI: /ISAPI/ContentMgmt/channels/<ID>/record/capabilities-
>true
</isSupportRecordStatus>
<isSupportRacmChannelsCap>
<!--ro, opt, bool, whether the device supports the Rcam capability by channel, desc:related URI: /ISAPI/ContentMgmt/channels/<ID>/capabilities-->true
</isSupportRacmChannelsCap>
<LockCap>
<!--ro, opt, object, capability of locking and unlocking video, desc:/ISAPI/ContentMgmt/record/control/locks/capabilities-->
<LockByName>
<!--ro, opt, object, lock/unlock video by file name-->
<TrackId>
<!--ro, req, string, channel stream ID, desc:channel No. * 100 + stream type (-1: main stream, -2: sub-stream)-->101
</TrackId>
<recordName min="1" max="100">
<!--ro, req, string, video file name, range:[1,100], attr:min{req, int},max{req, int}-->test
</recordName>
<command opt="lock,unlock">
<!--ro, req, enum, operation command, subType:string, attr:opt{req, string}, desc:“lock”, “unlock”-->lock
</command>
<duration min="1" max="10">
<!--ro, opt, int, lock time, unit:s, dep:and,{$.LockByName.command,eq,lock}, attr:min{req, int},max{req, int}, desc:0: lock permanently-->1
</duration>
<recorderCode min="1" max="100">
<!--ro, opt, string, video recorder No., attr:min{req, int},max{req, int}-->test
</recorderCode>
<policeCode min="1" max="100">
<!--ro, opt, string, police No., attr:min{req, int},max{req, int}-->test
</policeCode>
</LockByName>
<LockByTime>
<!--ro, opt, object, lock/unlock video by time-->
<TrackId>
<!--ro, req, string, channel stream ID, desc:channel No. * 100 + stream type (-1: main stream, -2: sub-stream)-->101
</TrackId>
<recordType opt="ALL,MANUAL,CMR,MOTION,ALARM,EDR,ALARMANDMOTION,COMMAND,SMART">
<!--ro, req, enum, recording type, subType:string, attr:opt{req, string}, desc:“ALL” (all videos), “MANUAL” (manual recording), “CMR” (capture by
schedule), “MOTION” (capture motion detection pictures), “ALARM” (capture alarm pictures), “EDR”(capture alarm pictures or motion detection pictures),
“ALARMANDMOTION” (capture alarm pictures and motion detection pictures), “Command” (command-based recording), “SMART” (smart recording)-->ALL
</recordType>
<startDateTime>
<!--ro, req, datetime, video segment start time-->1970-01-01T00:00:00+08:00
</startDateTime>
<endDateTime>
<!--ro, req, datetime, video segment end time-->1970-01-01T00:00:00+08:00
</endDateTime>
<command opt="lock,unlock">
<!--ro, req, enum, operation command, subType:string, attr:opt{req, string}, desc:“lock”, “unlock”-->lock
</command>
<duration min="1" max="10">
<!--ro, opt, int, lock time, unit:s, dep:and,{$.LockByName.command,eq,lock}, attr:min{req, int},max{req, int}, desc:0: lock permanently-->1
</duration>
</LockByTime>
</LockCap>
<isSupportForamtAll>
<!--ro, opt, bool, whether the device supports formatting all HDDs, desc:related URI: /ISAPI/ContentMgmt/Storage/hdd/format-->true
</isSupportForamtAll>
<isSupportExtendCabinetCfg>
<!--ro, opt, bool, whether it supports enclosure configuration, desc:related URI: /ISAPI/ContentMgmt/Storage/ExtendCabinet/capabilities-->true
</isSupportExtendCabinetCfg>
<diskGroupNums>
<!--ro, opt, int, supported number of disk groups, desc:related URI: /ISAPI/ContentMgmt/Storage/diskGroup-->0
</diskGroupNums>
<ExternalDevice>
<!--ro, opt, object, external device storage-->
<USB>
<!--ro, opt, object, USB information-->
<debugLogOutput>
<!--ro, opt, bool, whether to enable the debugging log, desc:related URI: /ISAPI/ContentMgmt/Storage/externalDevice/USB?format=json-->true
</debugLogOutput>
<isSupportCapturePackage>
<!--ro, opt, bool, whether the device supports configuring capture and filter function of a USB, desc:related URI:
/ISAPI/ContentMgmt/Storage/externalDevice/USB/capturePackage/capabilities?format=json-->true
</isSupportCapturePackage>
<isSupportStreamStorage>
<!--ro, opt, bool, whether the device supports saving stream to a USB, desc:related URI:
/ISAPI/ContentMgmt/Storage/externalDevice/USB/streamStorage/capabilities?format=json-->true
</isSupportStreamStorage>
</USB>
</ExternalDevice>
<customProtocolNums>
<!--ro, opt, int, number of custom protocols connected via IPC, desc:related URI: /ISAPI/ContentMgmt/InputProxy/customProtocols-->0
</customProtocolNums>
<isSupportIPCTiming>
<!--ro, opt, bool, whether the device supports synchronizing the time of the network camera, desc:relate to enableTiming on URI:
/ISAPI/ContentMgmt/InputProxy/channels/<ID>-->true
</isSupportIPCTiming>
<isSupportLogConfig>


<isSupportLogConfig>
<!--ro, opt, bool, whether the device supports log configuration, desc:related URI: /ISAPI/ContentMgmt/logConfig/capabilities-->true
</isSupportLogConfig>
<SecurityLog>
<!--ro, opt, object, security log-->
<isSupportSecurityLog>
<!--ro, opt, bool, whether the device supports the security log-->true
</isSupportSecurityLog>
<isSupportLogServer>
<!--ro, opt, bool, whether it supports security log server configuration-->true
</isSupportLogServer>
<isSupportLogServerTest>
<!--ro, opt, bool, whether it supports security log server test-->true
</isSupportLogServerTest>
<SecurityLogTypeList>
<!--ro, req, array, list of security log types, subType:object-->
<SecurityLogType>
<!--ro, opt, object, list of log types-->
<primaryType>
<!--ro, req, enum, main log type, subType:string, desc:“Event”, “Operation”, “Other” (other types), “All” (all types)-->Event
</primaryType>
<secondaryType opt="test">
<!--ro, req, enum, sub type, subType:string, attr:opt{req, string}, desc:see other types on the appendix. “all” (all types)-->all
</secondaryType>
</SecurityLogType>
</SecurityLogTypeList>
</SecurityLog>
<isSupportGetBackupDevice>
<!--ro, opt, bool, whether the device supports getting the backup device, desc:related URI: /ISAPI/ContentMgmt/Storage/backup/device?format=json-->true
</isSupportGetBackupDevice>
<isSupportAutoBackup>
<!--ro, opt, bool, whether the device supports automatic backup, desc:related URI: /ISAPI/ContentMgmt/Storage/backup/auto/capabilities?format=json-
>true
</isSupportAutoBackup>
<certificateValidationEnabled>
<!--ro, opt, bool, whether to enable the certification validation, desc:related to certificateValidationEnabled on URI:
/ISAPI/ContentMgmt/InputProxy/channels/<ID>-->true
</certificateValidationEnabled>
<defaultAdminPortEnabled>
<!--ro, opt, bool, whether to enable the default communication port, desc:related to defaultAdminPortEnabled on the URI:
/ISAPI/ContentMgmt/InputProxy/channels/<ID>-->true
</defaultAdminPortEnabled>
<iSptInputProxyChanCap>
<!--ro, opt, bool, whether the device supports getting the capability set of the digital channels, desc:related URI:
/ISAPI/ContentMgmt/InputProxy/channels/capabilities-->true
</iSptInputProxyChanCap>
<isSupportLogDataPackage>
<!--ro, opt, bool, whether the device supports exporting the log files, desc:related URI: /ISAPI/ContentMgmt/logSearch/dataPackage-->true
</isSupportLogDataPackage>
<logSearchTimeSpanNums>
<!--ro, opt, int, number of time periods for log search, desc:relate to timeSpanList on URI: /ISAPI/ContentMgmt/logSearch中CMSearchDescription-->0
</logSearchTimeSpanNums>
<CloudStorageServerCap>
<!--ro, opt, object, capability of the cloud storage service-->
<isSupportCloudStorageParameter>
<!--ro, opt, bool, whether the device supports configuring the cloud storage parameters, desc:related URI:
/ISAPI/ContentMgmt/Storage/cloudServer/capabilities?format=json-->true
</isSupportCloudStorageParameter>
<isSupportCloudStoragePool>
<!--ro, opt, bool, whether the device supports configuring the cloud storage pool, desc:related URI:
/ISAPI/ContentMgmt/Storage/cloudServer/pool/capabilities?format=json-->true
</isSupportCloudStoragePool>
<supportChannelsNum>
<!--ro, opt, int, number of channels supported by the cloud storage-->0
</supportChannelsNum>
</CloudStorageServerCap>
<isSupportWebPrivatePlaybackByUTC>
<!--ro, opt, bool, whether it supports playback based on Web private protocol-->true
</isSupportWebPrivatePlaybackByUTC>
<isSupportFindCommonFileByUTC>
<!--ro, opt, bool, whether it supports extending the time zone for searching files-->true
</isSupportFindCommonFileByUTC>
<isSupportFindEventFileByUTC>
<!--ro, opt, bool, whether it supports extending the time zone for searching files by event-->true
</isSupportFindEventFileByUTC>
<isSupportSmartSearchRecordByUTC>
<!--ro, opt, bool, whether it supports extending the time zone for VCA search-->true
</isSupportSmartSearchRecordByUTC>
<isSupportMRDSearchByTimeZone>
<!--ro, opt, bool, whether it supports extending the time zone for searching files by calendar-->true
</isSupportMRDSearchByTimeZone>
<isSupportSearchRecordLabelByUTC>
<!--ro, opt, bool, whether it supports extending the time zone for searching video tags-->true
</isSupportSearchRecordLabelByUTC>
<isSupportSearchPictureByUTC>
<!--ro, opt, bool, whether it supports extending the time zone for searching pictures-->true
</isSupportSearchPictureByUTC>
<isSupportSmartSearchPictureByUTC>
<!--ro, opt, bool, whether it supports extending the time zone for searching pictures with smart information-->true
</isSupportSmartSearchPictureByUTC>
<isSupportFindLogByUTC>
<!--ro, opt, bool, whether it supports extending the time zone for searching log-->true
</isSupportFindLogByUTC>
<isSupportUploadRecordByUTC>


<!--ro, opt, bool, whether it supports extending the time zone for uploading files to cloud storage-->true
</isSupportUploadRecordByUTC>
<isSupportPlaybackByUTC>
<!--ro, opt, bool, whether it supports extending the time zone for playback by time and locating by time-->true
</isSupportPlaybackByUTC>
<isSupportFaceDetecttionAlarmByTimeZone>
<!--ro, opt, bool, whether it supports reporting face detection by UTC time, desc:the time should be before isSupportCountingSearchByUTC and after
isSupportPlaybackByUTC-->true
</isSupportFaceDetecttionAlarmByTimeZone>
<isSupportSourceModify>
<!--ro, opt, bool, whether it supports configuring parameters of the LAN IPC, desc:related URI: /ISAPI/ContentMgmt/InputProxy/sourceModify/capabilities->true
</isSupportSourceModify>
<isSupportCountingSearchByUTC>
<!--ro,
opt, bool, whether it supports searching people counting results by UTC time-->true
</isSupportCountingSearchByUTC>
<isSupportCluster>
<!--ro, opt, bool, whether it supports cluster function, desc:related URI: /ISAPI/ContentMgmt/Cluster-->true
</isSupportCluster>
<supportAIDTFSType opt="illegalParking,wrongdirection,crosslane,vehicleexist,lanechange,turnround,evidence">
<!--ro, opt, enum, supported AIDTFS types, subType:string, attr:opt{req, string}, desc:“illegalParking”, “wrongdirection” (wrong-way driving),
“crosslane”(driving on the lane line), “vehicleexist” (vehicle on non-motor vehicle lane), “lanechange” (illegal lane change detection), “turnround”
(illegal U-turning detection), “evidence” (face picture collection)-->illegalParking
</supportAIDTFSType>
<isSupportMisinfoStateSearch>
<!--ro, opt, bool, whether it supports searching by false alarm status-->true
</isSupportMisinfoStateSearch>
<isSupportOneKeyOperationStorageData>
<!--ro, opt, bool, whether it supports one-touch configuration for storage data, desc:related URI: /ISAPI/ContentMgmt/Storage/oneKey/capabilities?
format=json-->true
</isSupportOneKeyOperationStorageData>
<eventRecordSearch>
<!--ro, opt, object, whether the device supports searching videos by event, desc:related URI: /ISAPI/ContentMgmt/eventRecordSearch?format=json-->
<eventType opt="faceContrast,faceSnap,vehicleMatchResult,hawkResult,VMD,alarmIn,inquestAlarm,behavior,posAlarm,accessControllerEvent,IOTD,trialAlarm">
<!--ro, opt, enum, event type, subType:string, attr:opt{req, string}, desc:“vehicleMatchResult” (vehicle comparison), “hawkResult” (video analysis
task), “faceContrast” (face picture comparison), “faceSnap” (face capture)-->faceContrast
</eventType>
<recordChannelListSize>
<!--ro, opt, int, maximum size of the value of recordChannelList-->16
</recordChannelListSize>
<triggerChannelsSize>
<!--ro, opt, int, maximum size of the value of triggerChannels-->16
</triggerChannelsSize>
<auxEventType opt="faceContrastFailure,faceContrastSuccess">
<!--ro, opt, enum, search sub type of the event, subType:string, attr:opt{req, string}, desc:“faceContrastFailure” (face picture comparison failed),
“faceContrastSuccess” (face picture comparison succeeded)-->faceContrastFailure
</auxEventType>
<inquestParam>
<!--ro, opt, object, interrogation event, dep:and,{$.EventSearchDescription.eventType,eq,inquestAlarm}-->
<inquestEventType opt="any,inquestStart,inquestStop,inquestTag,inquestSegment">
<!--ro, opt, enum, interrogation information, subType:string, attr:opt{req, string}, desc:“any”, “inquestStart” (interrogation start), ‘inquestStop”
(interrogation stop), “inquestTag” (marked information), “inquestSegment” (interrogation segment status)-->any
</inquestEventType>
<roomIndex min="1" max="65535">
<!--ro, opt, int, interrogation room No., attr:min{req, int},max{req, int}, desc:it starts from 1-->1
</roomIndex>
</inquestParam>
<behavior>
<!--ro, opt, object, behavior analysis, dep:and,{$.EventSearchDescription.eventType,eq,behavior}-->
<behaviorEventType
opt="any,linedetection,regionEntrance,regionExiting,fielddetection,loitering,parking,violentMotion,group,unattendedBaggage,attendedBaggage,audioAbnormal">
<!--ro, req, enum, behavior analysis event type, subType:string, attr:opt{req, string}, desc:“any”, “linedetection” (line crossing detection),
“regionEntrance”, “regionExiting”, “fielddetection” (intrusion detection), “loitering” (loitering detectionparking), "parking” (parking detection),
“violentMotion", “group” (people gathering), “unattendedBaggage”, “attendedBaggage” (object removal), “audioAbnormal” (sudden change of sound intensity
detection)-->any
</behaviorEventType>
</behavior>
<posAlarm>
<!--ro, opt, object, pos event, dep:and,{$.EventSearchDescription.eventType,eq,posAlarm}, desc:it is recorded in the device, not in the internet-->
<caseSensitive opt="true,false">
<!--ro, req, bool, whether it is case-sensitive, attr:opt{req, string}-->false
</caseSensitive>
<combinateMode opt="and,or">
<!--ro, req, enum, keyword combination, subType:string, attr:opt{req, string}, desc:“and”, “or”-->and
</combinateMode>
<keyword size="3">
<!--ro, opt, string, keyword, attr:size{req, int}-->test
</keyword>
</posAlarm>
<trialParam>
<!--ro, opt, object, trial event, dep:and,{$.EventSearchDescription.eventType,eq,trialAlarm}-->
<trialEventType opt="any,trialStart,trialStop,trialTag,trialSegment,trialJudge">
<!--ro, opt, enum, trial information, subType:string, attr:opt{req, string}, desc:“any”, “trialStart” (trial start), ‘trialStop” (trial stop),
“trialTag” (marked information), “trialSegment” (trial segment status), “trialJudge” (trial case information)-->any
</trialEventType>
<caseNo min="0" max="56">
<!--ro, req, string, case No., range:[0,56], attr:min{req, int},max{req, int}-->test
</caseNo>
<caseName>
<!--ro, opt, string, case name, range:[0,100]-->test
</caseName>
<litigant1 min="0" max="32">
<!--ro, opt, string, litigant 1, range:[0,32], attr:min{req, int},max{req, int}-->test
</litigant1>


</litigant1>
<litigant2 min="0" max="32">
<!--ro, opt, string, litigant 2, range:[0,32], attr:min{req, int},max{req, int}-->test
</litigant2>
<chiefJudge min="0" max="32">
<!--ro, opt, string, judge, range:[0,32], attr:min{req, int},max{req, int}-->test
</chiefJudge>
<caseType opt="0,1,2">
<!--ro, opt, enum, case type, subType:int, attr:opt{req, string}, desc:0 (all), 1 (criminal case), 2 (civil case)-->0
</caseType>
</trialParam>
<accessControllerEvent>
<!--ro, opt, object, access control event, dep:and,{$.EventSearchDescription.eventType,eq,accessControllerEvent}-->
<majorEventType>
<!--ro, opt, int, alarm main type, desc:see details in macro definition-->0
</majorEventType>
<subEventType>
<!--ro, opt, int, alarm sub type, desc:see details in macro definition-->0
</subEventType>
<cardNo min="0" max="32">
<!--ro, opt, string, card No., range:[0,32], attr:min{req, int},max{req, int}-->test
</cardNo>
<name min="0" max="32">
<!--ro, opt, string, name, range:[0,32], attr:min{req, int},max{req, int}-->test
</name>
<MACAddr min="0" max="12">
<!--ro, opt, string, MAC address, range:[0,12], attr:min{req, int},max{req, int}-->test
</MACAddr>
</accessControllerEvent>
<IOTD>
<!--ro, opt, object, non-video device event, dep:and,{$.EventSearchDescription.eventType,eq,IOTD}-->
<deviceType opt="0,1,2,3,4,5,6">
<!--ro, opt, enum, device type, subType:int, attr:opt{req, string}, desc:0 (Hikvision access controller), 1 (Hikvision video intercom device), 2
(Hikvision security control panel), 3 (GJD security control panel), 4 (Luminite security control panel), 5 (OPTEX security control panel), 6 (analog camera
sensor device)-->0
</deviceType>
<subEventType>
<!--ro, opt, string, sub event type, desc:see details in the node IoTEventType of Data Dictionary-->test
</subEventType>
<IoTchannelID size="256">
<!--ro, opt, string, channel No., attr:size{req, int}, desc:search all channels if he node not exists-->test
</IoTchannelID>
<caseSensitive opt="true,false">
<!--ro, req, bool, whether it is case-sensitive, attr:opt{req, string}-->false
</caseSensitive>
<combinateMode opt="and,or">
<!--ro, req, enum, keyword combination, subType:string, attr:opt{req, string}, desc:“and”, “or”-->and
</combinateMode>
<keyword size="3">
<!--ro, opt, string, keyword, attr:size{req, int}-->test
</keyword>
<zonNo>
<!--ro, opt, int, zone No., desc:it is valid only when deviceType==2&&subEventType=="zone"-->1
</zonNo>
</IOTD>
</eventRecordSearch>
<isSupportManualRecord>
<!--ro, opt, bool, whether the device supports manual recording, desc:related URI: /ISAPI/ContentMgmt/record/control/manual/capabilities?format=json-
>true
</isSupportManualRecord>
<isSupportRemark>
<!--ro, opt, bool, whether it supports file remarks-->true
</isSupportRemark>
<FileUpload>
<!--ro, opt, object, auto-upload file-->
<enabled>
<!--ro, req, bool, whether it supports uploading the file-->true
</enabled>
</FileUpload>
<PoliceInfoUpload>
<!--ro, opt, object, auto-upload police information-->
<enabled>
<!--ro, req, bool, whether it supports uploading the police information-->true
</enabled>
</PoliceInfoUpload>
<PoliceInfo>
<!--ro, opt, object, police officer information-->
<policeID>
<!--ro, opt, bool, whether the device supports police ID-->true
</policeID>
<policeCode>
<!--ro, opt, bool, whether the device supports police number-->true
</policeCode>
<policeName>
<!--ro, opt, bool, whether the device supports police name-->true
</policeName>
<password>
<!--ro, opt, bool, whether the device supports police password-->true
</password>
<deviceID>
<!--ro, opt, bool, whether the device supports device ID-->true
</deviceID>
<isSupportPoliceFacePicture>
<!--ro, opt, bool, whether the device supports managing the police face picture,


desc:related URI
/ISAPI/ContentMgmt/police/<policeID>?format=json
/ISAPI/ContentMgmt/police?format=json
/ISAPI/ContentMgmt/police/deleteFacePicture?format=json-->true
</isSupportPoliceFacePicture>
</PoliceInfo>
<isSupportAssignChannelID>
<!--ro, opt, bool, whether the device supports specifying the access channel No. when adding the network camera, desc:related to channelID on URI:
/ISAPI/ContentMgmt/InputProxy/channels/<ID>-->true
</isSupportAssignChannelID>
<isSupportAssignStreamID>
<!--ro, opt, bool, whether it supports specifying stream ID of the channel when adding the network camera, desc:related to streamID on URI:
/ISAPI/ContentMgmt/InputProxy/channels/<ID>-->true
</isSupportAssignStreamID>
<PictureSearchSubTypeList>
<!--ro, opt, object, list of picture searching sub type-->
<PictureSearchSubType>
<!--ro, opt, object, searched picture type-->
<mainType>
<!--ro, req, enum, main event type of the searched picture, subType:string, desc:“vehicleDetection”, “HVTVehicleDetection” (mixed-traffic
detection)-->vehicleDetection
</mainType>
<subType opt="all,motorVehicle,nonMotorVehicle,pedestrian">
<!--ro, req, enum, sub type of each main event type, subType:string, attr:opt{req, string}, desc:“all”, “motorVehicle”, “nonMotorVehicle”,
“pedestrian”-->all
</subType>
</PictureSearchSubType>
</PictureSearchSubTypeList>
<isSupportPlaybackStreamIDByUTC>
<!--ro, opt, bool, whether it supports playback by stream ID-->true
</isSupportPlaybackStreamIDByUTC>
<isSupportTimeLockStreamIDByUTC>
<!--ro, opt, bool, whether it supports UTC time for locking and unlocking the video segment by steam ID-->true
</isSupportTimeLockStreamIDByUTC>
<isSupportTimeSearch>
<!--ro, opt, bool, whether it supports searching for recording start and end time by channel, desc:/ISAPI/ContentMgmt/time/search?format=json-->true
</isSupportTimeSearch>
<behaviorEventPicSearch opt="allBehaviorEvent,running,group,violentMotion,failDown,playCellphone,peopleNumChange,leavePosition,retention,sleepOnduty">
<!--ro, opt, string, behavior analysis events whose pictures are supported to be searched, attr:opt{req, string}, desc:it is displayed on the Web Client
currently-->test
</behaviorEventPicSearch>
<perimeterEventPicSearch opt="allPerimeterEvent,linedetection,fielddetection,regionEntrance,regionExiting,loitering">
<!--ro, opt, string, perimeter protection events whose pictures are supported to be searched, attr:opt{req, string}, desc:it is displayed on the Web
Client currently-->test
</perimeterEventPicSearch>
<isSupportSourceStatus>
<!--ro, opt, bool, whether it supports getting source status-->true
</isSupportSourceStatus>
<isSupportSSDSMARTTest>
<!--ro, opt, bool, whether the device supports S.M.A.R.T. detection on SSD, desc:related URI: /ISAPI/ContentMgmt/Storage/ssd/<ID>/SMARTTest/start-->true
</isSupportSSDSMARTTest>
<MobileStorage>
<!--ro, opt, object, storage capability of the mobile HDD-->
<isSupportGetFileTime>
<!--ro, opt, bool, whether it supports getting the file time of the mobile HDD, desc:it supports Non-Hikvision mobile HDD currently.
/ISAPI/ContentMgmt/mobileStorage/fileTime/capabilities?format=json-->true
</isSupportGetFileTime>
</MobileStorage>
<isSupportGetChannelList>
<!--ro, opt, bool, whether it supports getting channels of the Hikvision HDD, desc:it supports Hikvision HDD currently.
/ISAPI/ContentMgmt/Storage/hdd/channelList/capabilities?format=json-->true
</isSupportGetChannelList>
<isSupportCascade>
<!--ro, opt, bool, whether it supports configuring parameters for NVR cascading topology-->true
</isSupportCascade>
<isSupportFileManagement>
<!--ro, opt, bool, whether it supports configuring file management. /ISAPI/ContentMgmt/fileManagement/capabilities?format=json, desc:related URI:
/ISAPI/ContentMgmt/fileManagement/capabilities?format=json-->true
</isSupportFileManagement>
<isSupportPictureInfo>
<!--ro, opt, bool, whether it supports picture search on the SD card of the capture camera-->true
</isSupportPictureInfo>
<isSupportChanStatusPage>
<!--ro, opt, string, whether it supports searching the digital channel by page, desc:related URI:
/ISAPI/ContentMgmt/InputProxy/channels/statusPage/capabilities-->test
</isSupportChanStatusPage>
<isSupportRecordSearchByTargetType>
<!--ro, opt, bool, whether it supports searching the event record by target (pedestrian/vehicles)-->true
</isSupportRecordSearchByTargetType>
<storIpcStartNo>
<!--ro, opt, int, the first IP channel No. of the record, desc:it is supported by Hikmed Imaging Technology-->0
</storIpcStartNo>
<maxRecordIpcNum>
<!--ro, opt, int, number of the IP channels which support recording, desc:it is supported by Hikmed Imaging Technology-->0
</maxRecordIpcNum>
<maxConferenceIpcNum>
<!--ro, opt, int, number of the meeting IP channels, desc:it is supported by Hikmed Imaging Technology-->0
</maxConferenceIpcNum>
<decIpcStartNo>
<!--ro, opt, int, start No. of screen mirroring IP channels, desc:it is supported by Hikmed Imaging Technology-->0
</decIpcStartNo>
<maxDecodeIpcNum>
<!--ro, opt, int, number of screen mirroring IP channels, desc:it is supported by Hikmed Imaging Technology-->0
</maxDecodeIpcNum>


</maxDecodeIpcNum>
<pipIpcStartNo>
<!--ro, opt, int, start No. of the integrated IP channels, desc:it is supported by Hikmed Imaging Technology-->0
</pipIpcStartNo>
<maxPipIpcNum>
<!--ro, opt, int, number of the integrated IP channels, desc:it is supported by Hikmed Imaging Technology-->0
</maxPipIpcNum>
<isSupportLogSearch>
<!--ro, opt, bool, whether it supports log search-->true
</isSupportLogSearch>
<isSupportRecordSearch>
<!--ro, opt, bool, whether it supports video search-->true
</isSupportRecordSearch>
<isSupportRecordDownload>
<!--ro, opt, bool, whether it supports video downloading-->true
</isSupportRecordDownload>
<isSupportPnp opt="true,false">
<!--ro, opt, bool, whether it supports configuring plug-and-play for the network camera, attr:opt{req, string}-->true
</isSupportPnp>
<esataUseage>
<!--ro, opt, enum, storage strategy, subType:string, desc:“backup”, “record”-->backup
</esataUseage>
<subType opt="all,leave,on,sleep">
<!--ro, opt, enum, absence sub type, subType:string, attr:opt{req, string}, desc:“all”, “leave” (absence), “on” (on duty), “sleep” (sleeping on duty)-
>all
</subType>
<isSupportManualBackup>
<!--ro, opt, bool, whether it supports manual backup, desc:related URI: /ISAPI/ContentMgmt/Storage/backup/manual/capabilities?format=json-->true
</isSupportManualBackup>
<isSupportLinkToIPCWeb>
<!--ro, opt, bool, whether it supports going to the Web Client of the network camera (on the digital channel management), desc:it is supported only when
it is used on the device and Web Client in pair-->true
</isSupportLinkToIPCWeb>
<isSupportIPCConfigCSV>
<!--ro, opt, bool, whether the device supports importing the configuration file of the network camera, desc:related URI:
/ISAPI/ContentMgmt/InputProxy/ipcConfigCSV?format=json-->true
</isSupportIPCConfigCSV>
<isSupportExperimentExam>
<!--ro, opt, bool, whether it supports the related function of the experiment exam, desc:related URI: /ISAPI/ContentMgmt/experimentExam/capabilities?
format=json-->true
</isSupportExperimentExam>
<isSupportPOSRecordSearch>
<!--ro, opt, bool, whether it supports POS video research, desc:related URI: /ISAPI/ContentMgmt/POSRecord/search/capabilities-->true
</isSupportPOSRecordSearch>
<isSupportSpare>
<!--ro, opt, bool, whether the device supports hot spare configuration, desc:related capability set: /ISAPI/ContentMgmt/spare/capabilities?format=json-
>true
</isSupportSpare>
<isSupportTracksDates>
<!--ro, opt, bool, whether it supports configuring video schedule by calendar, desc:related URI: /ISAPI/ContentMgmt/record/tracks/dates/capabilities?
format=json-->true
</isSupportTracksDates>
<isSupportRecordAudio>
<!--ro, opt, bool, whether the device supports recording the audio, desc:only the video will be recorded and the video will not be recorded related URI:
/ISAPI/ContentMgmt/recordAudio/<audioID>/capabilities?format=json-->true
</isSupportRecordAudio>
<isSupportSearchAudio>
<!--ro, opt, bool, whether the device supports searching the audio, desc:related URI: /ISAPI/ContentMgmt/recordAudio/search/capabilities?format=json-
>true
</isSupportSearchAudio>
<isSupportAudioDailyDistribution>
<!--ro, opt, bool, whether it supports searching for audio file information by monthly calendar, desc:related URI:
/ISAPI/ContentMgmt/recordAudio/<audioID>/searchDailyDistribution?format=json-->true
</isSupportAudioDailyDistribution>
<isSupportDownloadAudio>
<!--ro, opt, bool, whether it supports downloading audio files by file name, desc:related URI:
/ISAPI/ContentMgmt/recordAudio/fileNameDownload/capabilities?format=json-->true
</isSupportDownloadAudio>
<isSupportDeleteAudio>
<!--ro, opt, bool, whether the device supports deleting the recorded audio file, desc:Related URI: /ISAPI/ContentMgmt/recordAudio/deleteFile?
format=json-->true
</isSupportDeleteAudio>
<isSupportEventRecordCfg>
<!--ro, opt, bool, whether it supports configuring event video parameters, desc:related URI: /ISAPI/ContentMgmt/eventRecordCfg?format=json-->true
</isSupportEventRecordCfg>
<isSupportSearchRemoteAlbum>
<!--ro, opt, bool, whether the device supports searching the remote album information, desc:related URI: /ISAPI/ContentMgmt/searchRemoteAlbum?
format=json-->true
</isSupportSearchRemoteAlbum>
<isNotSupportTracks>
<!--ro, opt, bool, whether it does not support recording schedule, desc:return true if it is not supported NVR/CVRs support recording schedule. this
device does not support configuring recording schedule so the capability is added unsupported URI:
/ISAPI/ContentMgmt/record/tracks/<trackStreamID>/capabilities and /ISAPI/ContentMgmt/record/tracks 和 /ISAPI/ContentMgmt/record/tracks/<trackStreamID>-
>true
</isNotSupportTracks>
<isSupportFileManagement>
<!--ro, opt, bool, whether it supports configuring file management. /ISAPI/ContentMgmt/fileManagement/capabilities?format=json, desc:related URI:
/ISAPI/ContentMgmt/fileManagement/capabilities?format=json-->true
</isSupportFileManagement>
</RacmCap>


21.5.10 Get the system service capability (JSON format)
Request URL
GET /ISAPI/System/capabilities
Query Parameter
None
Request Message
None
Response Message
<?xml version="1.0" encoding="UTF-8"?>
<DeviceCap xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--ro, req, object, system capability of the device, attr:version{opt, string, protocolVersion}-->
<isSupportPreview>
<!--ro, opt, bool, whether the device supports live view-->true
</isSupportPreview>
<isSupportSystemMaintain>
<!--ro, opt, bool, whether the device supports system maintenance, desc:For traffic devices, this node is required and must be true.-->true
</isSupportSystemMaintain>
<isSupportReboot>
<!--ro, opt, bool, whether the device supports rebooting, desc:For traffic devices, this node is required and must be true.-->true
</isSupportReboot>
<isSupportFactoryReset>
<!--ro, opt, bool, whether the device supports restoring to default settings, desc:For traffic devices, this node is required and must be true.-->true
</isSupportFactoryReset>
<isSupportConfigurationData>
<!--ro, opt, bool, whether the device supports importing and exporting the configuration files safely, desc:For traffic devices, this node is required
and must be true.-->true
</isSupportConfigurationData>
<isSupportUpdatefirmware>
<!--ro, opt, bool, whether the device supports upgrading, desc:For traffic devices, this node is required and must be true.-->true
</isSupportUpdatefirmware>
<isSupportDeviceInfo>
<!--ro, opt, bool, whether the device supports getting the device information, desc:For traffic devices, this node is required and must be true.-->true
</isSupportDeviceInfo>
<isSupportTime>
<!--ro, opt, bool, whether the device supports time configuration, desc:For traffic device, this node is required and must be true. For other devices,
the isSupportTimeCap is used to configure time.-->true
</isSupportTime>
<SysCap>
<!--ro, opt, object, system capability-->
<isSupportDst>
<!--ro, opt, bool, whether the device supports DST (Daylight Saving Time)-->true
</isSupportDst>
<NetworkCap>
<!--ro, opt, object, network capability, desc:Related URI: /ISAPI/System/Network/capabilities-->
<isSupportWireless>
<!--ro, req, bool, whether the device supports wireless network-->true
</isSupportWireless>
<isSupportWAN>
<!--ro, opt, bool, whether the device supports WAN (Wide Area Network)-->true
</isSupportWAN>
<isSupportPPPoE>
<!--ro, req, bool, whether the device supports PPPoE (Point to Point Protocol over Ethernet)-->true
</isSupportPPPoE>
<isSupportBond>
<!--ro, req, bool, whether the device supports NIC (Network Interface Card) bonding-->true
</isSupportBond>
<isSupport802_1x>
<!--ro, req, bool, whether the device supports 802.1x protocol-->true
</isSupport802_1x>
<isSupportNtp>
<!--ro, opt, bool, whether the device supports NTP (Network Time Protocol)-->true
</isSupportNtp>
<isSupportFtp>
<!--ro, opt, bool, whether the device supports FTP (File Transfer Protocol)-->true
</isSupportFtp>
<isSupportUpnp>
<!--ro, opt, bool, whether the device supports UPnP (Universal Plug and Play ) protocol-->true
</isSupportUpnp>
<isSupportPNP>
<!--ro, opt, bool, whether the device supports plug-and-play protocol-->true
</isSupportPNP>
<isSupportDdns>
<!--ro, opt, bool, whether the device supports DDNS (Dynamic Domain Name System) service-->true
</isSupportDdns>
<isSupportHttps>
<!--ro, opt, bool, whether the device supports HTTPS (Hypertext Transfer Protocol Secure)-->true
</isSupportHttps>
<isSupport28181>
<!--ro, opt, bool, N/A-->true
</isSupport28181>
<SnmpCap>
<!--ro, opt, object, SNMP (Simple Network Management Protocol) capability-->


<!--ro, opt, object, SNMP (Simple Network Management Protocol) capability-->
<isSupport>
<!--ro, req, bool, whether the device supports SNMP-->true
</isSupport>
</SnmpCap>
<isSupportExtNetCfg>
<!--ro, opt, bool, whether the device supports configuring extended network parameters-->true
</isSupportExtNetCfg>
<isSupportIPFilter>
<!--ro, opt, bool, whether the device supports IP filtering-->true
</isSupportIPFilter>
<isSupportSSH opt="true,false">
<!--ro, opt, bool, whether the device supports SSH, attr:opt{opt, string}-->true
</isSupportSSH>
<isSupportNetPreviewStrategy>
<!--ro, opt, bool, whether the device supports network preview strategy-->true
</isSupportNetPreviewStrategy>
<isSupportEZVIZ>
<!--ro, opt, bool, whether the device supports EZ protocol-->true
</isSupportEZVIZ>
<isSupportEhome>
<!--ro, opt, bool, whether it supports ISUP functions: true (support),this node is not returned (not support)-->true
</isSupportEhome>
<isSupportWirelessDial>
<!--ro, opt, bool, whether the device supports wireless dial-up protocol-->true
</isSupportWirelessDial>
<isSupportWirelessServer>
<!--ro, opt, bool, whether the device supports wireless server-->true
</isSupportWirelessServer>
<isSupportWPS>
<!--ro, opt, bool, whether the device supports Wi-Fi Protected Setup-->true
</isSupportWPS>
<isWirelessMutexWithWirelessServer>
<!--ro, opt, bool, whether the device supports mutual exclusion of wireless access and wireless service-->true
</isWirelessMutexWithWirelessServer>
<isSupportMACFilter>
<!--ro, opt, bool, whether the device supports physical address filtering-->true
</isSupportMACFilter>
<GB28181Cap>
<!--ro, opt, object, N/A-->
<isSupportGB28181Service>
<!--ro, opt, bool, N/A-->true
</isSupportGB28181Service>
</GB28181Cap>
<WPS>
<!--ro, opt, object, Wi-Fi Protected Setup-->
<NetworkInterfaceList size="2">
<!--ro, opt, array, list of network nodes, subType:object, attr:size{opt, string}-->
<NetworkInterface>
<!--ro, opt, object, network node-->
<id>
<!--ro, req, string, NIC index-->1
</id>
<enabled>
<!--ro, req, bool, whether to enable or not-->true
</enabled>
<isSupportAutoConnect>
<!--ro, opt, bool, whether the device supports automatic connection-->true
</isSupportAutoConnect>
<isSupportDevicePinCode>
<!--ro, opt, bool, whether the device supports PIN code-->true
</isSupportDevicePinCode>
<isSupportDevicePinCodeUpdate>
<!--ro, opt, bool, whether the device supports updating the PIN code-->true
</isSupportDevicePinCodeUpdate>
<ApPinCode>
<!--ro, opt, object, PIN code of the access point-->
<ssid min="1" max="1">
<!--ro, opt, string, SSID (Service Set Identifier), attr:min{opt, string},max{opt, string}-->test
</ssid>
<pinCode min="1" max="1">
<!--ro, opt, string, attr:min{opt, string},max{opt, string}-->test
</pinCode>
</ApPinCode>
</NetworkInterface>
</NetworkInterfaceList>
</WPS>
<isSupportRFIDData>
<!--ro, opt, bool, whether the device supports RFID collection configuration-->true
</isSupportRFIDData>
<isSupportwifiProbeSSID>
<!--ro, opt, bool, whether the device supports configuration of Wi-Fi probe SSID-->true
</isSupportwifiProbeSSID>
<isSupportWifiProbe>
<!--ro, opt, bool, whether the device supports Wi-Fi probe-->true
</isSupportWifiProbe>
<verificationCode min="1" max="1">
<!--ro, opt, string, attr:min{opt, string},max{opt, string}-->test
</verificationCode>
<WPSCap>
<!--ro, opt, object, capability of configuring Wi-Fi Protected Setup-->
<isSupport>
<!--ro, req, bool, whether the device supports Wi-Fi Protected Setup-->true
</isSupport>


</isSupport>
<isSupportAutoConnect>
<!--ro, req, bool, whether the device supports automatic connection-->true
</isSupportAutoConnect>
</WPSCap>
<NetWorkMode>
<!--ro, opt, object, network mode configuration-->
<workMode>
<!--ro, opt, string, network mode-->true
</workMode>
</NetWorkMode>
<VerificationCodeModification>
<!--ro, opt, object, device verification code configuration-->
<verificationCodeType opt="normal,empty">
<!--ro, opt, string, verification code type, attr:opt{opt, string}-->true
</verificationCodeType>
<isSupportDeclarationURL>
<!--ro, opt, bool, whether the device supports the hyperlink to the Terms of Service-->true
</isSupportDeclarationURL>
<isSupportPrivacyPolicyURL>
<!--ro, opt, bool, whether the device supports the hyperlink to the Privacy Policy-->true
</isSupportPrivacyPolicyURL>
<verificationCodeModify opt="true,false">
<!--ro, opt, bool, whether the device verification code has been modified, attr:opt{opt, string}-->true
</verificationCodeModify>
<Hyperlinks>
<!--ro, opt, object, hyperlink configuration-->
<declarationURL>
<!--ro, opt, string, hyperlink to the Terms of Service-->test
</declarationURL>
<privacyPolicyURL>
<!--ro, opt, string, hyperlink to the Privacy Policy-->test
</privacyPolicyURL>
</Hyperlinks>
<isSupportVerificationCodeCheck>
<!--ro, opt, bool, whether the device supports verifying the verification code-->true
</isSupportVerificationCodeCheck>
<isSupportOldVerificationCode>
<!--ro, opt, bool, whether the device supports the EZ password configuration of old version (the password of old version consists of six
characters)-->true
</isSupportOldVerificationCode>
</VerificationCodeModification>
<isSupportIntegrate>
<!--ro, opt, bool, whether the device supports access protocol configuration-->true
</isSupportIntegrate>
<isSupportPlatformAccess>
<!--ro, opt, bool, whether the device supports platform access-->true
</isSupportPlatformAccess>
<isSupportIntelligentBoost>
<!--ro, opt, bool, whether the device supports intelligent acceleration-->true
</isSupportIntelligentBoost>
<isSupportResourceStatistics>
<!--ro, opt, bool, whether the device supports getting the network resource information-->true
</isSupportResourceStatistics>
<isSupportBandwidthLimit>
<!--ro, opt, bool, whether the device supports bandwidth limit-->true
</isSupportBandwidthLimit>
<isSupportPOEPortsDisableAdaptiveServer>
<!--ro, opt, bool, whether the device supports the POE protocol-->true
</isSupportPOEPortsDisableAdaptiveServer>
<isSupportPOEConfiguration>
<!--ro, opt, bool, whether the device supports configuring the POE NIC parameters-->true
</isSupportPOEConfiguration>
<isSupportGetLinkSocketIP>
<!--ro, opt, bool, whether the device supports getting the SocketIP of the current link-->true
</isSupportGetLinkSocketIP>
<isSupportWebSocket>
<!--ro, opt, bool, whether the device supports WebSocket-->true
</isSupportWebSocket>
<isSupportWebSocketS>
<!--ro, opt, bool, whether the device supports WebSocketS-->true
</isSupportWebSocketS>
<Adaption>
<!--ro, opt, object, network self-adaption configuration-->
<streamType opt="0,1,2,3,4,5,7,8,9,10">
<!--ro, opt, string, stream type that supports network self-adaption during live view, attr:opt{opt, string}, desc:0 (main stream), 1 (substream),
2 (third stream), 3 (fourth stream/virtual stream), 4 (fifth stream), 5 (sixth stream), 7 (seventh stream), 8 (eighth stream), 9 (ninth stream), 10
(tenth stream), and so forth. The index value here is the same as that in the live view structure NET_DVR_PREVIEWINFO of Device Network SDK. Note that 6 is
an invalid value, and from the seventh stream (index value: 7, )the index value is the same as that for live view via RTSP.-->test
</streamType>
<isSupportPlayback>
<!--ro, opt, bool, whether the device supports playback-->true
</isSupportPlayback>
</Adaption>
<isSupportVideoImgDB>
<!--ro, opt, bool, whether the device supports image and video library configuration-->true
</isSupportVideoImgDB>
<isSupportEventDataOverWebSocket opt="true,false">
<!--ro, opt, bool, whether the device supports uploading the event data via WebSocket, attr:opt{opt, string}-->true
</isSupportEventDataOverWebSocket>
<isSupportDynamicHostName>
<!--ro, opt, bool, whether the device supports DDNS (Dynamic Domain Name System) configuration-->true
</isSupportDynamicHostName>
<isSupportTCPAcceleration>
<!--ro, opt, bool, whether the device supports TCP acceleration-->true


<!--ro, opt, bool, whether the device supports TCP acceleration-->true
</isSupportTCPAcceleration>
<isSupportFlowControl>
<!--ro, opt, bool, whether the device supports traffic control-->true
</isSupportFlowControl>
<isSupportEZVIZTiming>
<!--ro, opt, bool, whether the device supports synchronizing time with EZ platform, desc:whether the device supports synchronizing time with EZVIZ
platform-->true
</isSupportEZVIZTiming>
<isSupportTrafficMonitor>
<!--ro, opt, bool, whether the device supports traffic monitoring, desc:Relate URI:
/ISAPI/System/Network/WirelessDial/Interfaces/<ID>/trafficMonitor?format=json-->true
</isSupportTrafficMonitor>
<isSupportDMSAuthInfo>
<!--ro, opt, bool, whether the device supports DMS authentication information management-->true
</isSupportDMSAuthInfo>
<isSupportWiredandWirelessTrafficMonitor>
<!--ro, opt, bool, whether the device supports traffic monitoring (wireless NIC and wired NIC), desc:Related URI:
/ISAPI/System/Network/Interfaces/<ID>/trafficMonitor?format=json-->true
</isSupportWiredandWirelessTrafficMonitor>
<isSupport4G>
<!--ro, opt, bool, whether the device supports 4G module-->true
</isSupport4G>
<isSupport4GConfig>
<!--ro, opt, bool, whether the device supports 4G configuration-->true
</isSupport4GConfig>
<isSupportGRIDServer>
<!--ro, opt, bool, N/A-->true
</isSupportGRIDServer>
<isSupportGRIDInfo>
<!--ro, opt, bool, N/A-->true
</isSupportGRIDInfo>
<isSupportSipTransmit>
<!--ro, opt, bool, whether the device supports configuring SIP transmission parameters-->true
</isSupportSipTransmit>
<isSupportSip>
<!--ro, opt, bool, whether the device supports private SIP (VOIP)-->true
</isSupportSip>
<isSupportWifiCascade>
<!--ro, opt, bool, whether the device supports enabling automatic Wi-Fi cascading, desc:Related URI: /ISAPI/System/Network/wifiCascade?format=json-
>true
</isSupportWifiCascade>
<isSupportRelativeInfo>
<!--ro, opt, bool, whether the device supports getting the information about the connected devices, desc:Related URI:
/ISAPI/System/Network/wifiCascade/relativeInfo?format=json-->true
</isSupportRelativeInfo>
<isSupportEmailEncrypt>
<!--ro, opt, bool, whether the device supports email encryption configuration-->true
</isSupportEmailEncrypt>
<isSupportPortFilter>
<!--ro, opt, bool, whether the device supports port filtering-->true
</isSupportPortFilter>
<isSupportPingDeny>
<!--ro, opt, bool, whether the device supports configuring parameters to prevent the device from being tested using ping command-->true
</isSupportPingDeny>
<isSupportDOSDeny>
<!--ro, opt, bool, whether the device supports configuring parameters to prevent the DoS attack-->true
</isSupportDOSDeny>
<isSupportNetworkStatus>
<!--ro, opt, bool, whether the device supports searching for the network status, desc:Related URI: /ISAPI/System/Network/status?format=json-->true
</isSupportNetworkStatus>
<isSupportEZVIZQRcode>
<!--ro, opt, bool, whether the device supports getting the EZ QR code, desc:whether the device supports getting the EZVIZ QR code-->true
</isSupportEZVIZQRcode>
<isSupportEZVIZUnbind>
<!--ro, opt, bool, whether the device supports unbinding from EZ, desc:whether the device supports unbinding from EZVIZ-->true
</isSupportEZVIZUnbind>
<isSupportPingTest>
<!--ro, opt, bool, whether the device supports ping test, desc:Related URI: /ISAPI/System/Network/pingtest/capabilities-->true
</isSupportPingTest>
<isSupportMOTCloudPlateform>
<!--ro, opt, bool, whether the device supports configuring parameters for accessing the cloud platform service, desc:Related URI:
/ISAPI/System/Network/Traffic/MOTCloudPlateform/capabilities?format=json-->true
</isSupportMOTCloudPlateform>
<isSupportSpectrumScan>
<!--ro, opt, bool, whether the device supports frequency spectrum scanning, desc:Related URI:
/ISAPI/System/Network/interface/<netCardID>/spectrumScan/capabilities?format=json-->true
</isSupportSpectrumScan>
<isSupportFRP>
<!--ro, opt, bool, whether the device supports FRP (Fast Reverse Proxy), desc:Related URI: /ISAPI/Syetem/Network/FRP?format=json-->true
</isSupportFRP>
<isSupport5GModule>
<!--ro, opt, bool, whether the device supports 5G module configuration, desc:Related URI: /ISAPI/System/Network/5GModule/capabilities?format=json-
>true
</isSupport5GModule>
<isSupportWirelessDialRoute>
<!--ro, opt, bool, whether the device supports configuring parameters of route forwarding rules of wireless dial-up, desc:Related URI:
/ISAPI/System/Network/WirelessDia/route/capabilities?format=json-->true
</isSupportWirelessDialRoute>
<isSupportNPlusOne>
<!--ro, opt, bool, whether the device supports N+1 protocol-->true
</isSupportNPlusOne>
<supportEnvironmentalStandards opt="HJ212">
<!--ro, opt, string, environmental monitoring standard, attr:opt{req, string}, desc:N/A-->true


<!--ro, opt, string, environmental monitoring standard, attr:opt{req, string}, desc:N/A-->true
</supportEnvironmentalStandards>
<isSupportIntranetSegment>
<!--ro, opt, bool, whether the device supports LAN segment configuration, desc:If this function is supported, this node will be returned and its
value is true; otherwise, this node will be returned and its value is true or not be returned. Related URI:
/ISAPI/System/Network/intranetSegment/capabilities?format=json-->true
</isSupportIntranetSegment>
<isSupportDHCPServer>
<!--ro, opt, bool, whether the device supports DHCP service configuration, desc:If this function is supported, this node will be returned and its
value is true; otherwise, this node will be returned and its value is true or not be returned. Related URI: /ISAPI/System/Network/DHCPServer/capabilities?
format=json-->true
</isSupportDHCPServer>
<isSupportClusterIntercom>
<!--ro, opt, bool, If this function is supported, this node will be returned and its value is true; otherwise, this node will be returned and its
value is true or not be returned., desc:If this function is supported, this node will be returned and its value is true; otherwise, this node will be
returned and its value is true or not be returned.-->true
</isSupportClusterIntercom>
<isSupportHydrologicMonitoring>
<!--ro, opt, bool, whether the device supports hydrologic monitoring data communication, desc:If this function is supported, this node will be
returned and its value is true; otherwise, this node will be returned and its value is true or not be returned. Related URI:
/ISAPI/System/Network/HydrologicMonitoring/capabilities?format=json-->true
</isSupportHydrologicMonitoring>
<isWirelessDialMutexWithWlanAndWifi>
<!--ro, opt, bool, whether the wireless dial-up is mutually exclusive with the WLAN hotspot and Wi-Fi, desc:Before a function is enabled, another
one must be disabled first.-->true
</isWirelessDialMutexWithWlanAndWifi>
<isSupportSpeechTranscription>
<!--ro, opt, bool, whether the device supports accessing the speech-to-text transcription platform, desc:If this function is supported, this node
will be returned and its value is true; otherwise, this node will be returned and its value is true or not be returned. Related URI:
/ISAPI/System/Network/speechTranscriptionPlatform/capabilities?format=json-->true
</isSupportSpeechTranscription>
<isSupportAsynPingTest>
<!--ro, opt, bool, whether the device supports asynchronous network detection, desc:Network detection means testing the network stability and packet
loss rate of the network using the ping command for knowing about the network condition. Related URI: /ISAPI/System/Network/asynPingTest/capabilities?
format=json.-->true
</isSupportAsynPingTest>
<isSupportBasebandCapture>
<!--ro, opt, bool, whether the device supports capturing packets of the baseband, desc:You can capture packets transmitted between the 4G module and
the base station using the ping command. Related URI: /ISAPI/System/Network/cellularNetwork/basebandCapture/capabilities?format=json.-->true
</isSupportBasebandCapture>
<isSupportCellularNetworkSpeedTest>
<!--ro, opt, bool, whether the device supports testing the connection speed between the device and the cellular network, desc:You can test the
connection speed of the network where the current device is. Related URI: /ISAPI/System/Network/cellularNetwork/speedTest/capabilities?format=json.-->true
</isSupportCellularNetworkSpeedTest>
<isSupportCellularNetworkCellInfo>
<!--ro, opt, bool, whether the device supports getting a cell's information of the cellular network, desc:You can get the information of the
cellular network where the device is. Related URI: /ISAPI/System/Network/cellularNetwork/cellInfo?format=json&ecurity=<security>&iv=<iv>.-->true
</isSupportCellularNetworkCellInfo>
<isSupportMultiBandFrequencyScanning>
<!--ro, opt, bool, whether the device supports scanning all frequency bands of the cellular network, desc:Related URI:
/ISAPI/System/Network/cellularNetwork/multiBandFrequencyScanning/capabilities?format=json-->true
</isSupportMultiBandFrequencyScanning>
<isSupportCellularNetworkLockBand>
<!--ro, opt, bool, whether the device accessing the locked frequency band of the cellular network, desc:Related URI:
/ISAPI/System/Network/cellularNetwork/lockBand/capabilities?format=json-->true
</isSupportCellularNetworkLockBand>
<isSupportRadioFrequencyFluctuation>
<!--ro, opt, bool, whether the device supports configuring RF parameters of the cellular network, desc:Related URI:
/ISAPI/System/Network/cellularNetwork/radioFrequencyFluctuation/capabilities?format=json-->true
</isSupportRadioFrequencyFluctuation>
<isSupportBasebandBlock>
<!--ro, opt, bool, whether the device supports the unauthorized list of the base station, desc:Related URI:
/ISAPI/System/Network/cellularNetwork/basebandBlock/capabilities?format=json-->true
</isSupportBasebandBlock>
<isSupportRFIDTagCheckTest>
<!--ro, opt, bool-->true
</isSupportRFIDTagCheckTest>
<isSupportQoSDSCPtoLoaclPriorityMapping>
<!--ro, opt, bool-->true
</isSupportQoSDSCPtoLoaclPriorityMapping>
<isSupportQoS802.1pto802.1pPriorityMapping>
<!--ro, opt, bool-->true
</isSupportQoS802.1pto802.1pPriorityMapping>
<isSupportLinkTestStart>
<!--ro, opt, bool-->true
</isSupportLinkTestStart>
<isSupportLinkTestResult>
<!--ro, opt, bool-->true
</isSupportLinkTestResult>
<isSupportNetworkModuleUpgrade>
<!--ro, opt, bool-->true
</isSupportNetworkModuleUpgrade>
<isSupportNetworkModuleVersionInfo>
<!--ro, opt, bool-->true
</isSupportNetworkModuleVersionInfo>
<isSupportFRPParams>
<!--ro, opt, bool-->true
</isSupportFRPParams>
</NetworkCap>
<IOCap>
<!--ro, opt, object, IO Capability, desc:Related URI: /ISAPI/System/IO/capabilities-->
<IOInputPortNums>
<!--ro, opt, int, number of local input ports of the device-->true
</IOInputPortNums>


<IOOutputPortNums>
<!--ro, opt, int, number of local output ports of the device-->true
</IOOutputPortNums>
<isSupportStrobeLamp>
<!--ro, opt, bool, whether the device supports configuring the output of the gate's light, desc:Related URI:
/ISAPI/System/IO/outputs/strobelampConf-->true
</isSupportStrobeLamp>
<SoftIOInputPortNums>
<!--ro, opt, int, number of soft input ports of the device, desc:This node depends on whether the URI /ISAPI/System/IO/softInputs/capabilities?
format=json is supported.-->true
</SoftIOInputPortNums>
<isSupportIOOutputAdvanceParameter>
<!--ro, opt, bool, whether the device supports configuring advanced parameters of the output port, desc:This node determines whether the URI
/ISAPI/System/IO/outputs/advanceParameter/capabilities?format=json is supported.-->true
</isSupportIOOutputAdvanceParameter>
<isSupportSetAllIOOutput>
<!--ro, opt, bool, whether the device supports configuring all output ports, desc:This node determines whether the PUT method of the URI
/ISAPI/System/IO/outputs is supported.-->true
</isSupportSetAllIOOutput>
<isSupportCombinationAlarm>
<!--ro, opt, bool, whether the device supports the combined alarm, desc:Related URI: /ISAPI/System/IO/inputs/capabilities. Related node:
CombinationAlarmCap.-->true
</isSupportCombinationAlarm>
<isSupportAlarmKeyParam>
<!--ro, opt, bool-->true
</isSupportAlarmKeyParam>
</IOCap>
<SerialCap>
<!--ro, opt, object, range of RS-485 serial port numbers supported by the device-->
<rs485PortNums>
<!--ro, opt, int, the maximum number of RS-485 serial ports supported by the device-->true
</rs485PortNums>
<supportRS232Config>
<!--ro, opt, bool, whether the device supports configuring parameters of RS-232 serial ports-->true
</supportRS232Config>
<rs422PortNums>
<!--ro, opt, int, the maximum number of RS-422 serial ports supported by the device-->true
</rs422PortNums>
<rs232PortNums>
<!--ro, opt, int, the maximum number of RS-232 serial ports supported by the device-->true
</rs232PortNums>
<rs485WorkMode opt="Led,CaptureTrigger">
<!--ro, opt, string, RS-485 working modes supported by the device, attr:opt{opt, string}, desc:Led (external LED screen, which is used for LED
display), CaptureTrigger (external device, which is used to trigger the transmission of the captured data)-->test
</rs485WorkMode>
<rs232SerialNumber opt="1,2,3">
<!--ro, opt, string, range of RS-232 serial port numbers supported by the device, attr:opt{opt, string}-->test
</rs232SerialNumber>
<rs485SerialNumber opt="4,5,6">
<!--ro, opt, string, range of RS-485 serial port numbers supported by the device, attr:opt{opt, string}-->test
</rs485SerialNumber>
<isSupportAuthenticationService>
<!--ro, opt, bool, whether the device supports the serial port authentication service-->true
</isSupportAuthenticationService>
<isSupportDeviceInfo>
<!--ro, opt, bool, whether the device supports configuring the information about the serial port device-->true
</isSupportDeviceInfo>
<isSupportSearchDeviceInfoRelations>
<!--ro, opt, bool, whether the device supports searching the linkage information of the serial port device-->true
</isSupportSearchDeviceInfoRelations>
</SerialCap>
<VideoCap>
<!--ro, opt, object, video encoding capability, desc:Related URI: /ISAPI/System/Video/capabilities-->
<videoInputPortNums>
<!--ro, opt, int, number of video input ports-->true
</videoInputPortNums>
<videoOutputPortNums>
<!--ro, opt, int, number of video output ports-->true
</videoOutputPortNums>
<menuNums>
<!--ro, opt, int, number of local menus that can be displayed-->true
</menuNums>
<externalChannelNum>
<!--ro, opt, bool, number of extended analog channels-->true
</externalChannelNum>
<isSupportHeatmap>
<!--ro, opt, bool, whether the device supports heat map-->true
</isSupportHeatmap>
<isSupportCounting>
<!--ro, opt, bool, whether the device supports people counting-->true
</isSupportCounting>
<countingType>
<!--ro, opt, string, human (people counting); object (counting), desc:human (people counting); object (counting)-->test
</countingType>
<isSupportPicture>
<!--ro, opt, bool, whether the device supports OSD picture overlay-->true
</isSupportPicture>
<isSupportPreviewSwitch>
<!--ro, opt, bool, whether the device supports switching live view-->true
</isSupportPreviewSwitch>
<isSupportMultiChannelCounting>
<!--ro, opt, bool, whether the device supports multichannel statistics-->true
</isSupportMultiChannelCounting>
<isSupportCountingCollection>


<isSupportCountingCollection>
<!--ro, opt, bool, whether the device supports people counting ANR-->true
</isSupportCountingCollection>
<isSupportHeatmapCollection>
<!--ro, opt, bool, whether the device supports heat map data ANR-->true
</isSupportHeatmapCollection>
<channelFlexible opt="name,online,linknum">
<!--ro, opt, string, This node is located after the node <isSupportHeatmapCollection>., attr:opt{opt, string}-->true
</channelFlexible>
<isSupportMixedChannel>
<!--ro, opt, bool, This node is located after the node <channelFlexible>.-->true
</isSupportMixedChannel>
<isSupportMixedChannelStatus>
<!--ro, opt, bool, This node is located after the node <isSupportMixedChannel>.-->true
</isSupportMixedChannelStatus>
<isSupportRecodStatus>
<!--ro, opt, bool, whether the device supports searching for the recording status-->true
</isSupportRecodStatus>
<isSupportPrivacyMask>
<!--ro, opt, bool, whether the device supports privacy mask-->true
</isSupportPrivacyMask>
<isSupportBinocularPreviewSwitch>
<!--ro, opt, bool, whether the device supports switching live view of the dual-lens camera-->true
</isSupportBinocularPreviewSwitch>
<isSupportCalibCheck>
<!--ro, opt, bool, whether the device supports calibration verification-->true
</isSupportCalibCheck>
<isSupportPIP>
<!--ro, opt, bool, whether the device supports PIP-->true
</isSupportPIP>
<isSupportFocusVideoMode>
<!--ro, opt, bool, whether the device supports the focus mode of the video-->true
</isSupportFocusVideoMode>
<isSupportExternalChannel>
<!--ro, opt, bool, whether the device supports extended analog channels-->true
</isSupportExternalChannel>
<isSupportCompressedTranscode>
<!--ro, opt, bool-->true
</isSupportCompressedTranscode>
<isSupportLocalStreamCfg>
<!--ro, opt, bool-->true
</isSupportLocalStreamCfg>
</VideoCap>
<AudioCap>
<!--ro, opt, object, audio encoding capability, desc:Related Uri: /ISAPI/System/Audio/capabilities-->
<audioInputNums>
<!--ro, req, int, number of audio inputs-->1
</audioInputNums>
<audioOutputNums>
<!--ro, req, int, number of audio outputs-->1
</audioOutputNums>
<mixAudioInSet>
<!--ro, opt, bool, [TBC]-->true
</mixAudioInSet>
<mixAudioOutSet>
<!--ro, opt, bool-->true
</mixAudioOutSet>
<isSupportAudioMixing>
<!--ro, opt, bool, whether the device supports audio mixing-->true
</isSupportAudioMixing>
<isSupportRemoveFrequencyPoint>
<!--ro, opt, bool, whether the device supports clearing the howling frequency point-->true
</isSupportRemoveFrequencyPoint>
<isSupportAudioInConfig>
<!--ro, opt, bool, whether the device supports configuring parameters of all audio inputs, desc:Related URI:
/ISAPI/System/Audio/AudioIn/capabilities-->true
</isSupportAudioInConfig>
<muteDuringPanTilt opt="MicIn">
<!--ro, opt, string, whether the device supports muting during motion, attr:opt{opt, string}, desc:Related URI:
/ISAPI/System/TwoWayAudio/channels/ID. Related Node: muteDuringPanTilt.-->true
</muteDuringPanTilt>
<isSupportAudioOutConfig>
<!--ro, opt, bool-->true
</isSupportAudioOutConfig>
<isSupportSAIP>
<!--ro, opt, bool-->true
</isSupportSAIP>
<SAIPChannelsNum>
<!--ro, opt, int, dep:and,{$.AudioCap.isSupportSAIP,eq,true}-->1
</SAIPChannelsNum>
<isSupportDataStorage>
<!--ro, opt, bool, whether the device supports uploading the audio file-->true
</isSupportDataStorage>
<isSupportDataRelease>
<!--ro, opt, bool-->true
</isSupportDataRelease>
<isSupportAudioPlan>
<!--ro, opt, bool-->true
</isSupportAudioPlan>
<isSupportAudioTask>
<!--ro, opt, bool-->true
</isSupportAudioTask>
<isSupportaudioCollection>
<!--ro, opt, bool-->true


</isSupportaudioCollection>
<isSupportWirelessPickUp>
<!--ro, opt, bool-->true
</isSupportWirelessPickUp>
<audioOutputBroadcastNums opt="1,2,3,4">
<!--ro, opt, int, attr:opt{opt, string}-->0
</audioOutputBroadcastNums>
<isSupportAudioOutMixing>
<!--ro, opt, bool-->true
</isSupportAudioOutMixing>
<isSupportRTSPAudio>
<!--ro, opt, bool, whether the device supports listening to the audio transmitted via RTSP in real time, desc:RTSP URI:
/ISAPI/System/Audio/AudioIn/channels/<audioID>-->true
</isSupportRTSPAudio>
<isSupportRTSPAudioPlaybackByFile>
<!--ro, opt, bool-->true
</isSupportRTSPAudioPlaybackByFile>
</AudioCap>
<isSupportHolidy>
<!--ro, opt, bool, This node is located after the node <AudioCap>.-->true
</isSupportHolidy>
<RebootConfigurationCap>
<!--ro, opt, object, capability of configuring parameters for rebooting the device, desc:Related URI: /ISAPI/System/reboot/capabilities. This node is
located before the node <isSupportSubscribeEvent> and after the node <isSupportHolidy>.-->
<Genetec>
<!--ro, opt, bool, whether to enable the Genetec protocol-->true
</Genetec>
<ONVIF>
<!--ro, opt, bool, whether to enable the ONVIF protocol-->true
</ONVIF>
<RTSP>
<!--ro, opt, bool, whether to enable the RTSP protocol-->true
</RTSP>
<HTTP>
<!--ro, opt, bool, whether to enable the HTTP protocol-->true
</HTTP>
<SADP>
<!--ro, opt, object, SADP (Search Active Devices Protocol, including the link layer and multicast discovery)-->
<ISDiscoveryMode>
<!--ro, opt, bool, mode of the SADP multicast discovery protocol-->true
</ISDiscoveryMode>
<PcapMode>
<!--ro, opt, bool, mode of the SADP link layer discovery protocol-->true
</PcapMode>
</SADP>
<IPCAddStatus>
<!--ro, opt, bool, IP address status-->true
</IPCAddStatus>
</RebootConfigurationCap>
<isSupportExternalDevice>
<!--ro, opt, bool, whether the device supports connecting to peripherals: true (support), desc:Related URI: /ISAPI/System/externalDevice/capabilities->true
</isSupportExternalDevice>
<isSupportSoundCfg>
<!--ro,
opt, bool, whether the device supports the sound configuration, desc:Related URI: /ISAPI/System/SoundCfg/capabilities-->true
</isSupportSoundCfg>
<isSupportSubscribeEvent>
<!--ro, opt, bool, whether the device supports subscribing to events, desc:Related URI: /ISAPI/Event/notification/subscribeEventCap-->true
</isSupportSubscribeEvent>
<isSupportSubscribeIOTInfo>
<!--ro, opt, bool, whether the device supports subscribing to the IoT information-->true
</isSupportSubscribeIOTInfo>
<isSupportDiagnosedData>
<!--ro, opt, bool, whether the device supports exporting the device diagnosis data, desc:true (support), this node is not returned (not support).
Related URI: /ISAPI/System/diagnosedData.-->true
</isSupportDiagnosedData>
<isSupportChangedUpload>
<!--ro, opt, bool, whether the device supports uploading changes-->true
</isSupportChangedUpload>
<isSupportGettingWorkingStatus>
<!--ro, opt, bool, whether the device supports getting the device status-->true
</isSupportGettingWorkingStatus>
<isSupportGettingChannelInfoByCondition>
<!--ro, opt, bool, whether the device supports getting the channel information by condition-->true
</isSupportGettingChannelInfoByCondition>
<isSupportDiagnosedDataParameter>
<!--ro, opt, bool, whether the device supports enabling or disabling exporting the diagnosis information-->true
</isSupportDiagnosedDataParameter>
<isSupportSimpleDevStatus>
<!--ro, opt, bool, whether the device supports getting the device's simple status, desc:Related URI: /ISAPI/System/workingstatus?format=json-->true
</isSupportSimpleDevStatus>
<isSupportFlexible>
<!--ro, opt, bool, whether the device supports the flexible combination configuration. Related URI: /ISAPI/System/Video/inputs/channels?format=json-
>true
</isSupportFlexible>
<isSupportPTZChannels>
<!--ro, opt, bool, whether the device supports returning the PTZ channel (it is distinguished from the video channel)-->true
</isSupportPTZChannels>
<isSupportMetadata>
<!--ro, opt, bool, whether the device supports metadata, desc:Related URI: /ISAPI/Streaming/channels/<ID>/metadata/capabilities-->true
</isSupportMetadata>
<isSupportTimeCap>
<!--ro, opt, bool, whether the device supports the time configuration, desc:Related URI: /ISAPI/System/time/capabilities-->true
</isSupportTimeCap>


</isSupportTimeCap>
<isSupportThermalStreamData>
<!--ro, opt, bool, whether the device supports uploading thermal imaging stream data in real time-->true
</isSupportThermalStreamData>
<isSupportShutdown>
<!--ro, opt, bool, whether the device supports the shutdown configuration, desc:Related URI: /ISAPI/System/shutdown?format=json-->true
</isSupportShutdown>
<isSupportConsumptionMode>
<!--ro, opt, bool, whether the device supports switching the consumption mode, desc:Related URI: /ISAPI/System/consumptionMode/capabilities?
format=json-->true
</isSupportConsumptionMode>
<isSupportManualPowerConsumption>
<!--ro, opt, bool, whether the device supports controlling the device consumption manually-->true
</isSupportManualPowerConsumption>
<isSupportPostUpdateFirmware>
<!--ro, opt, bool, whether the device supports upgrading firmware by POST method-->true
</isSupportPostUpdateFirmware>
<isSupportPostConfigData>
<!--ro, opt, bool, whether the device supports importing and exporting the configuration file by POST method-->true
</isSupportPostConfigData>
<isSupportUserLock>
<!--ro, opt, bool, whether the device supports locking the user, desc:Related URI: /ISAPI/System/userLock/config/capabilities?format=json-->true
</isSupportUserLock>
<isSupportModuleLock>
<!--ro, opt, bool, whether the device supports locking the module, desc:Related URI: /ISAPI/System/moduleLock-->true
</isSupportModuleLock>
<supportSmartOverlapChannles opt="1">
<!--ro, opt, bool, whether the device supports configuring the smart event stream, attr:opt{opt, string}, desc:If this function is supported, this
node and the corresponding channel ID will be returned; otherwise, this node will not be returned.-->true
</supportSmartOverlapChannles>
<isSupportNetworkCapture>
<!--ro, opt, bool, whether the device supports capturing network packets, desc:This node is used to determine whether the device supports capturing
communication packets transmitted between the device and the external. Related URI: /ISAPI/System/networkCapture/capabilities?format=json.-->true
</isSupportNetworkCapture>
<isSupportOperationRecord>
<!--ro, opt, bool, whether the device supports the device operation records, desc:The charging voltage and monthly flow can be recorded in the device
in real-time low-consumption mode and full-consumption mode. Related URI: /ISAPI/System/operationRecord/capabilities?format=json.-->true
</isSupportOperationRecord>
</SysCap>
<voicetalkNums>
<!--ro, opt, int, number of two-way audio channels-->2
</voicetalkNums>
<isSupportSnapshot>
<!--ro, opt, bool, whether the device supports capturing pictures-->true
</isSupportSnapshot>
<SecurityCap>
<!--ro, opt, object, encryption capability set-->
<supportUserNums>
<!--ro, opt, int, supported maximum number of users-->1
</supportUserNums>
<userBondIpNums>
<!--ro, opt, int, supported maximum number of IP addresses that can be bound-->1
</userBondIpNums>
<userBondMacNums>
<!--ro, opt, int, supported maximum number of MAC addresses that can be bound-->1
</userBondMacNums>
<isSupCertificate>
<!--ro, opt, bool, whether the device supports authentication-->true
</isSupCertificate>
<issupIllegalLoginLock>
<!--ro, opt, bool, whether the device supports locking login-->true
</issupIllegalLoginLock>
<isSupportOnlineUser>
<!--ro, opt, bool, whether the device supports the online user configuration-->true
</isSupportOnlineUser>
<isSupportAnonymous>
<!--ro, opt, bool, whether the device supports anonymous login-->true
</isSupportAnonymous>
<isSupportStreamEncryption>
<!--ro, opt, bool, whether the device supports stream encryption-->true
</isSupportStreamEncryption>
<securityVersion opt="1,2">
<!--ro, opt, string, encryption capability, attr:opt{opt, string}, desc:The encryption capability of each version consists of two parts: encryption
algorithm and the range of encrypted nodes. Currently 1 refers to AES128 encryption and 2 refers to AES256 encryption. The range of encrypted nodes is
described in each protocol.-->test
</securityVersion>
<keyIterateNum>
<!--ro, opt, int, iteration times, desc:The value is usually between 100 and 1000.-->100
</keyIterateNum>
<isSupportUserCheck>
<!--ro, opt, bool, whether the device supports verifying the login password when editing (editing/adding/deleting) user parameters, desc:This node
depends on the node <securityVersion>, which means that it is only valid for the versions that support encrypting the sensitive information.-->true
</isSupportUserCheck>
<isSupportGUIDFileDataExport>
<!--ro, opt, bool, whether the device supports exporting the device's GUID file-->true
</isSupportGUIDFileDataExport>
<isSupportSecurityQuestionConfig>
<!--ro, opt, bool, whether the device supports answering security questions-->true
</isSupportSecurityQuestionConfig>
<supportSecurityNode opt="wirelessServer,wirelessDial">
<!--ro, opt, string, additional node for supporting sensitive information encryption, attr:opt{opt, string}, desc:In the earlier version of the
solution for encrypting the sensitive information via ISAPI (i.e., the solution for transmitting plaintext via ISAPI), some URIs containing sensitive
information are left out. Now these URIs need to be encrypted for transmission. This capability node is added to be compatible with old devices.-->test
</supportSecurityNode>


</supportSecurityNode>
<isSupportGetOnlineUserListSC>
<!--ro, opt, bool, whether the device supports searching the online user list-->true
</isSupportGetOnlineUserListSC>
<SecurityLimits>
<!--ro, opt, object, capability of configuring security limit parameters-->
<LoginPasswordLenLimit min="1" max="16">
<!--ro, opt, string, length limit of the user's login password, attr:min{opt, string},max{opt, string}-->test
</LoginPasswordLenLimit>
<SecurityAnswerLenLimit min="1" max="128">
<!--ro, opt, string, length limit of the security question's answer, attr:min{opt, string},max{opt, string}-->test
</SecurityAnswerLenLimit>
</SecurityLimits>
<RSAKeyLength opt="512,1024,2048" def="2048">
<!--ro, opt, enum, HTTPS certificate length, subType:string, attr:opt{opt, string},def{opt, string}, desc:512, 1024, 2048-->2048
</RSAKeyLength>
<isSupportONVIFUserManagement>
<!--ro, opt, bool, whether the device supports ONVIF user management-->true
</isSupportONVIFUserManagement>
<WebCertificateCap>
<!--ro, opt, object, HTTP authentication capability-->
<CertificateType opt="basic,digest,digest/basic">
<!--ro, req, string, certificate type: basic (authentication), attr:opt{opt, string}-->test
</CertificateType>
<SecurityAlgorithm>
<!--ro, opt, object, dep:or,{$.DeviceCap.SecurityCap.WebCertificateCap.CertificateType,eq,degist},
{$.DeviceCap.SecurityCap.WebCertificateCap.CertificateType,eq,digest/basic}-->
<algorithmType opt="MD5,SHA256,MD5/SHA256">
<!--ro, opt, string, algorithm type, attr:opt{req, string}-->test
</algorithmType>
</SecurityAlgorithm>
</WebCertificateCap>
<isSupportConfigFileImport>
<!--ro, opt, bool, whether the device supports importing the configuration file-->true
</isSupportConfigFileImport>
<isSupportConfigFileExport>
<!--ro, opt, bool, whether the device supports exporting the configuration file-->true
</isSupportConfigFileExport>
<cfgFileSecretKeyLenLimit min="0" max="16">
<!--ro, opt, string, length limit of the configuration file's verification key, attr:min{opt, string},max{opt, string}-->0
</cfgFileSecretKeyLenLimit>
<supportIPCActivatePassword>
<!--ro, opt, bool, whether the device supports configuring the password for activating the network camera-->true
</supportIPCActivatePassword>
<isIrreversible>
<!--ro, opt, bool, whether the device supports irreversible password storage, desc:If this function is not supported, the plaintext password of the
user information will be stored in the device; otherwise, the password will be hashed for storage in the device.-->true
</isIrreversible>
<salt>
<!--ro, opt, string, the specific salt used by the user to log in-->test
</salt>
<isSupportOnvifInfo>
<!--ro, opt, bool, whether the device supports getting the ONVIF protocol information-->true
</isSupportOnvifInfo>
<isSupportUserNamePasswordCheckUpgrade>
<!--ro, opt, bool, whether the device supports upgrading the verification of the user name and password-->true
</isSupportUserNamePasswordCheckUpgrade>
<isSupportDeviceCertificatesManagement>
<!--ro, opt, bool, whether the device supports certificate management-->true
</isSupportDeviceCertificatesManagement>
<isSupportSIPCertificatesManagement>
<!--ro, opt, bool, whether the device supports SIP certificate management-->true
</isSupportSIPCertificatesManagement>
<isSupportDeviceSelfSignCertExport>
<!--ro, opt, bool, whether the device supports exporting the self-signed certificate-->true
</isSupportDeviceSelfSignCertExport>
<isSupportSecurityEmail>
<!--ro, opt, bool, whether the device supports configuring the security email-->true
</isSupportSecurityEmail>
<isSupportRTSPCertificate opt="true,false">
<!--ro, opt, bool, whether the device supports RTSP authentication, attr:opt{opt, string}-->true
</isSupportRTSPCertificate>
<isSupportPictureURlCertificate opt="true,false">
<!--ro, opt, bool, whether the device supports configuring parameters for picture URL authentication, attr:opt{opt, string}-->true
</isSupportPictureURlCertificate>
<isSupportGB35114Certificate>
<!--ro, opt, bool, N/A-->true
</isSupportGB35114Certificate>
<isSupportAuthenticationMode opt="uKey,private">
<!--ro, opt, enum, verification mode, subType:string, attr:opt{req, string}, desc:“uKey”, “private”-->private
</isSupportAuthenticationMode>
<isSupportUnloggedUserPermissionConfig opt="true,false">
<!--ro, opt, bool, whether the device supports configuring permission for users that have not logged in, attr:opt{opt, string}-->true
</isSupportUnloggedUserPermissionConfig>
<maxIllegalLoginTimes min="3" max="20" def="5">
<!--ro, opt, string, maximum failed illegal login attempts, attr:min{opt, string},max{opt, string},def{opt, string}, desc:This node is valid when the
value of the node <issupportIllegalLoginLock> is true and will be returned when the maximum failed attempts of illegally logging in to the device reach the
limit.-->1
</maxIllegalLoginTimes>
<SecurityAdvanced>
<!--ro, opt, object, advanced security configuration-->
<securityEnhanced>
<!--ro, opt, bool, whether the device supports security reinforcement-->true
</securityEnhanced>
<noOperationEnabled>


<noOperationEnabled>
<!--ro, req, bool, whether to enable the control timeout when there is no operation-->true
</noOperationEnabled>
<noOperationTime min="1" max="60" def="15">
<!--ro, req, int, control timeout when there is no operation, unit:分钟, attr:min{opt, string},max{opt, string},def{opt, string}-->1
</noOperationTime>
<isSupportDigestStatus>
<!--ro, opt, bool, digest status-->true
</isSupportDigestStatus>
</SecurityAdvanced>
<LoginLinkNum>
<!--ro, opt, object, number of users logging in at the same time-->
<maxLinkNum min="1" max="128" def="50">
<!--ro, req, int, number of controls logging in at the same time, attr:min{opt, string},max{opt, string},def{opt, string}-->64
</maxLinkNum>
</LoginLinkNum>
<isSupportCCClientCertificate>
<!--ro, opt, bool, whether the device supports the CC (Client Certificate) function-->true
</isSupportCCClientCertificate>
<passwordValidity min="0" max="365">
<!--ro, opt, string, range of the password validity period, attr:min{opt, string},max{opt, string}, desc:Unit: day. If this node is returned, it
indicates that the device supports configuring the password validity period, and only the administrator can edit the configuration.-->1
</passwordValidity>
<isSupportResetChannelPassword>
<!--ro, opt, bool, whether the device supports resetting the password of the channel-->true
</isSupportResetChannelPassword>
<DoubleVerificationCap>
<!--ro, opt, object, secondary authentication capability-->
<isSupportUsersConfig>
<!--ro, opt, bool, whether the device supports configuring users for secondary authentication-->true
</isSupportUsersConfig>
<isSupportUsersPermissionConfig>
<!--ro, opt, bool, whether the device supports configuring user permission for secondary authentication-->true
</isSupportUsersPermissionConfig>
</DoubleVerificationCap>
<isSupportUserSearch>
<!--ro, opt, bool, whether the device supports searching users-->true
</isSupportUserSearch>
<keypadPassword min="1" max="10">
<!--ro, opt, int, keypad password length, attr:min{req, int},max{req, int}, desc:When the password length of different user types is different, this
node only indicates the keypad password length of the administrator; otherwise, the keypad password length of all user types is the same and defined by the
value of this node.-->1
</keypadPassword>
<installerKeypadPassword min="1" max="10">
<!--ro, opt, int, keypad password length of the installer, attr:min{req, int},max{req, int}-->1
</installerKeypadPassword>
<operatorKeypadPassword min="1" max="10">
<!--ro, opt, int, keypad password length of the operator, attr:min{req, int},max{req, int}-->1
</operatorKeypadPassword>
<userOperateType opt="1,2,3">
<!--ro, opt, enum, user type: 1 (network user), subType:int, attr:opt{req, string}, desc:1 (network user), 2 (keypad user), 3 (network user and keypad
user)-->1
</userOperateType>
<isSptUserEnabled>
<!--ro, opt, bool, whether the device supports configuring parameters for enabling the user-->true
</isSptUserEnabled>
<isSptAdminCap>
<!--ro, opt, bool, whether the device supports getting the admin permission-->true
</isSptAdminCap>
<isSupportBackLogCfg>
<!--ro, opt, bool, whether the device supports configuring basic parameters of the background log-->true
</isSupportBackLogCfg>
<isSupportBackLogExport>
<!--ro, opt, bool, whether the device supports exporting the background log-->true
</isSupportBackLogExport>
<isSupportModifyInnerPassword opt="true,false">
<!--ro, opt, bool, whether the device supports editing the built-in password, attr:opt{req, string}, desc:The device's built-in passwords include the
database password, system account password, and so on.-->true
</isSupportModifyInnerPassword>
<isSupportEncryptCertificate>
<!--ro, opt, bool, whether the device supports certificate encryption, desc:/ISAPI/Security/deviceCertificate-->true
</isSupportEncryptCertificate>
<maxIllegalLoginLockTime min="1" max="120" def="30.00">
<!--ro, opt, int, lock time range, range:[1,120], unit:min, attr:min{req, int},max{req, int},def{req, int}-->1
</maxIllegalLoginLockTime>
<cloudSensitiveInfoEncryptType>
<!--ro, opt, string, encryption type of the cloud sensitive information, desc:The current device returns the value "2.1", which means that the method
of generating the key for encrypting the sensitive information is SHA256(calc_sha256(user, salt, SHA256(user+salt2+SHA256(user+salt+password)))+
AaBbCcDd1234!@#$).-->2.1
</cloudSensitiveInfoEncryptType>
<isSupportCertificateCustomID>
<!--ro, opt, bool, whether the device supports using the user's custom ID to configure the certificate-->true
</isSupportCertificateCustomID>
<isSupportResetLANPassword>
<!--ro, opt, bool, whether the device supports resetting the device's password in the LAN, desc:Related URI:
/ISAPI/Security/resetPassword/certification?format=json-->true
</isSupportResetLANPassword>
<isSupportPicHttpsCertificatesManagement>
<!--ro, opt, bool, whether the device supports managing the HTTPS certificate for pictures, desc:If this function is supported, this node will be
returned and its value is true; otherwise, this node will not be returned.-->true
</isSupportPicHttpsCertificatesManagement>
<isSupportAKSKImport>
<!--ro, opt, bool, whether the device supports importing AKSK, desc:If this function is supported, this node will be returned and its value is true;
otherwise, this node will not be returned.-->true


otherwise, this node will not be returned.-->true
</isSupportAKSKImport>
<isSupportAKSKExport>
<!--ro, opt, bool, whether the device supports exporting AKSK, desc:If this function is supported, this node will be returned and its value is true;
otherwise, this node will not be returned.-->true
</isSupportAKSKExport>
<isSupportAKSKReset>
<!--ro, opt, bool, whether the device supports resetting AKSK, desc:If this function is supported, this node will be returned and its value is true;
otherwise, this node will not be returned.-->true
</isSupportAKSKReset>
<ExportCertificateFile>
<!--ro, opt, object, whether the device supports exporting the certificate, desc:Related URI: POST
/ISAPI/Security/serverCertificate/exportCertificateFile-->
<type opt="GB35114">
<!--ro, req, enum, types of certificates that can be exported, subType:string, attr:opt{req, string}, desc:types of certificates that can be
exported-->GB35114
</type>
</ExportCertificateFile>
<isSupportGB351114FDWSFCertificate>
<!--ro, opt, bool, whether the device supports FDWSF certificate management, desc:If this function is supported, this node will be returned and its
value is true; otherwise, this node will not be returned. Related URIs: /ISAPI/Security/GB351114/FDWSFCertificate/capabilities?format=json, POST
/ISAPI/Security/GB351114/FDWSFCertificate?format=json, GET /ISAPI/Security/GB351114/FDWSFCertificate?format=json, and DELETE
/ISAPI/Security/GB351114/FDWSFCertificate?format=json.-->true
</isSupportGB351114FDWSFCertificate>
</SecurityCap>
<EventCap>
<!--ro, opt, object, event capability-->
<isSupportHDFull>
<!--ro, opt, bool, whether the device supports HDD full alarm-->true
</isSupportHDFull>
<isSupportHDError>
<!--ro, opt, bool, whether the device supports HDD error alarm-->true
</isSupportHDError>
<isSupportNicBroken>
<!--ro, opt, bool, whether the device supports the network disconnected event-->true
</isSupportNicBroken>
<isSupportIpConflict>
<!--ro, opt, bool, whether the device supports the IP address conflict event-->true
</isSupportIpConflict>
<isSupportIllAccess>
<!--ro, opt, bool, whether the device supports the illegal login event-->true
</isSupportIllAccess>
<isSupportViException>
<!--ro, opt, bool, whether the device supports video input exception (only for analog channels)-->true
</isSupportViException>
<isSupportViMismatch>
<!--ro, opt, bool, whether the device supports the event of video standard mismatch-->true
</isSupportViMismatch>
<isSupportRecordException>
<!--ro, opt, bool, whether the device supports the recording exception event-->true
</isSupportRecordException>
<isSupportRaidException>
<!--ro, opt, bool, whether the device supports the array exception event-->true
</isSupportRaidException>
<isSupportViResMismatch>
<!--ro, opt, bool, whether the device supports the event of video resolution mismatch-->true
</isSupportViResMismatch>
<isSupportPOCException>
<!--ro, opt, bool, whether the device supports the event of powering over coaxial exception-->true
</isSupportPOCException>
<isSupportSmartDetection>
<!--ro, opt, bool, whether the device supports the Smart event-->true
</isSupportSmartDetection>
<isSupportSpareException>
<!--ro, opt, bool, whether the device supports hot spare exception-->true
</isSupportSpareException>
<isSupportPoePowerException>
<!--ro, opt, bool, whether the device supports the POE exception event-->true
</isSupportPoePowerException>
<isSupportTriggerFocus>
<!--ro, opt, bool, whether the device supports defocus exception-->true
</isSupportTriggerFocus>
<isSupportMotionDetection>
<!--ro, opt, bool, whether the device supports motion detection-->true
</isSupportMotionDetection>
<isSupportVideoLoss>
<!--ro, opt, bool, whether the device supports video loss events-->true
</isSupportVideoLoss>
<isSupportTamperDetection>
<!--ro, opt, bool, whether the device supports tampering detection-->true
</isSupportTamperDetection>
<isSupportFireDetection>
<!--ro, opt, bool, whether the device supports fire detection events-->true
</isSupportFireDetection>
<isSupportRegionEntrance>
<!--ro, opt, bool, whether the device supports region entrance events-->true
</isSupportRegionEntrance>
<isSupportRegionExiting>
<!--ro, opt, bool, whether the device supports region exiting events-->true
</isSupportRegionExiting>
<isSupportLoitering>
<!--ro, opt, bool, whether the device supports loitering events-->true
</isSupportLoitering>
<isSupportGroup>


<!--ro, opt, bool, whether the device supports people gathering events-->true
</isSupportGroup>
<isSupportRapidMove>
<!--ro, opt, bool, whether the device supports fast moving events-->true
</isSupportRapidMove>
<isSupportParking>
<!--ro, opt, bool, whether the device supports parking detection events-->true
</isSupportParking>
<isSupportUnattendedBaggage>
<!--ro, opt, bool, whether the device supports unattended baggage events-->true
</isSupportUnattendedBaggage>
<isSupportAttendedBaggage>
<!--ro, opt, bool, whether the device supports object removal events-->true
</isSupportAttendedBaggage>
<isSupportHumanAttribute>
<!--ro, opt, bool, whether the device supports human body features-->true
</isSupportHumanAttribute>
<isSupportHumanRecognition>
<!--ro, opt, bool, whether the device supports target capture events-->true
</isSupportHumanRecognition>
<isSupportFaceContrast>
<!--ro, opt, bool, whether the device supports face picture comparison events-->true
</isSupportFaceContrast>
<isSupportFaceLib>
<!--ro, opt, bool, Front-end devices support linkage by face picture library., desc:Related URI: /ISAPI/Event/schedules/faceLib/<ID>/<FDID>-->true
</isSupportFaceLib>
<isSupportBlackListFaceContrast>
<!--ro, opt, bool, whether the device supports events of blocklist face picture comparison-->true
</isSupportBlackListFaceContrast>
<isSupportWhiteListFaceContrast>
<!--ro, opt, bool, whether the device supports events of allowlist face picture comparison-->true
</isSupportWhiteListFaceContrast>
<isSupportillegalParking>
<!--ro, opt, bool, whether the device supports illegal parking detection-->true
</isSupportillegalParking>
<isSupportPedestrian>
<!--ro, opt, bool, whether the device supports pedestrian detection-->true
</isSupportPedestrian>
<isSupportTrafficAccident>
<!--ro, opt, bool, whether the device supports traffic incident detection-->true
</isSupportTrafficAccident>
<isSupportConstruction>
<!--ro, opt, bool, whether the device supports construction detection-->true
</isSupportConstruction>
<isSupportRoadBlock>
<!--ro, opt, bool, whether the device supports roadblock detection-->true
</isSupportRoadBlock>
<isSupportAbandonedObject>
<!--ro, opt, bool, whether the device supports fallen object detection-->true
</isSupportAbandonedObject>
<isSupportParallelParking>
<!--ro, opt, bool, whether the device supports parallel parking detection-->true
</isSupportParallelParking>
<isSupportParkingState>
<!--ro, opt, bool, whether the device supports parking space status detection-->true
</isSupportParkingState>
<isSupportTrafficJam>
<!--ro, opt, bool, whether the device supports traffic jam detection (old version)-->true
</isSupportTrafficJam>
<isSupportCongestion>
<!--ro, opt, bool, whether the device supports traffic jam detection-->true
</isSupportCongestion>
<isSupportStudentsStoodUp>
<!--ro, opt, bool, whether the device supports the student standing up detection event-->true
</isSupportStudentsStoodUp>
<isSupportFramesPeopleCounting>
<!--ro, opt, bool, whether the device supports the regional people counting event-->true
</isSupportFramesPeopleCounting>
<isSupportFaceSnap>
<!--ro, opt, bool, whether the device supports face capture events-->true
</isSupportFaceSnap>
<isSupportPersonDensityDetection>
<!--ro, opt, bool, whether the device supports people density detection-->true
</isSupportPersonDensityDetection>
<HFPD>
<!--ro, opt, bool, whether the device supports frequently appeared person detection-->true
</HFPD>
<isSupportPersonQueueDetection>
<!--ro, opt, bool, whether the device supports queue detection events-->true
</isSupportPersonQueueDetection>
<isSupportVehicleStatistics>
<!--ro, opt, bool, whether the device supports vehicle statistics events-->true
</isSupportVehicleStatistics>
<isSupportFaceThermometry>
<!--ro, opt, bool, whether the device supports face temperature screening-->true
</isSupportFaceThermometry>
<isSupportSafetyHelmetDetection>
<!--ro, opt, bool, whether the device supports hard hat detection-->true
</isSupportSafetyHelmetDetection>
<isSupportPowerSupplyCabinet>
<!--ro, opt, bool, whether the device supports cabinet powering detection-->true
</isSupportPowerSupplyCabinet>
<isSupportSensorDetection>
<!--ro, opt, bool, whether the device supports sensor detection-->true


<!--ro, opt, bool, whether the device supports sensor detection-->true
</isSupportSensorDetection>
<isSupportSignAbnormal>
<!--ro, opt, bool, whether the device supports the physical sign exception detection-->true
</isSupportSignAbnormal>
<isSupportTeacherBehaviorDetect>
<!--ro, opt, bool, whether the device supports teacher's behavior detection-->true
</isSupportTeacherBehaviorDetect>
<isSupportCityManagement>
<!--ro, opt, bool, whether the device supports the city management function-->true
</isSupportCityManagement>
<isSupportMixedTargetDetection>
<!--ro, opt, bool, whether the device supports multi-target-type detection events-->true
</isSupportMixedTargetDetection>
<isSupportFaceSnapModeling>
<!--ro, opt, bool, whether the device supports face modeling events-->true
</isSupportFaceSnapModeling>
<isSupportIntersectionAnalysis>
<!--ro, opt, bool, whether the device supports the intersection analysis-->true
</isSupportIntersectionAnalysis>
<isSupportTriggerCapCheck>
<!--ro, opt, bool, whether the device supports verifying the capability of triggering linkage actions, desc:This node indicates that the capability
message returned by calling the URI GET /ISAPI/Event/triggersCap has been verified, and the event linkage actions can be displayed exactly according to the
capability.-->true
</isSupportTriggerCapCheck>
<isSupportLuma>
<!--ro, opt, bool, VQD brightness exception-->true
</isSupportLuma>
<isSupportChroma>
<!--ro, opt, bool, VQD image color cast-->true
</isSupportChroma>
<isSupportSnow>
<!--ro, opt, bool, VQD snow noise-->true
</isSupportSnow>
<isSupportStreak>
<!--ro, opt, bool, VQD stripe noise-->true
</isSupportStreak>
<isSupportFreeze>
<!--ro, opt, bool, VQD image freeze-->true
</isSupportFreeze>
<isSupportSigLose>
<!--ro, opt, bool, VQD signal loss-->true
</isSupportSigLose>
<isSupportClarity>
<!--ro, opt, bool, VQD resolution exception-->true
</isSupportClarity>
<isSupportJitter>
<!--ro, opt, bool, VQD image flutter-->true
</isSupportJitter>
<isSupportBlock>
<!--ro, opt, bool, VQD video tampering-->true
</isSupportBlock>
<isSupportFlowers>
<!--ro, opt, bool, VQD blurred image alarm-->true
</isSupportFlowers>
<isSupportNoise>
<!--ro, opt, bool, VQD blurred screen-->true
</isSupportNoise>
<isSupportGhost>
<!--ro, opt, bool, VQD image noise-->true
</isSupportGhost>
<isSupportPurple>
<!--ro, opt, bool, VQD purple fringing-->true
</isSupportPurple>
<isSupportICR>
<!--ro, opt, bool, VQD ICP-->true
</isSupportICR>
<isSupportProtectiveFilm>
<!--ro, opt, bool, VQD protective film unremoved-->true
</isSupportProtectiveFilm>
<isSupportVoltageInstable>
<!--ro, opt, bool, whether the device supports the voltage instable exception detection-->true
</isSupportVoltageInstable>
<isSupportCertificateRevocation>
<!--ro, opt, bool, whether the device supports the certificate expiry alarm-->true
</isSupportCertificateRevocation>
<isSupportSysStorFull>
<!--ro, opt, bool, whether the device supports the storage full alarm of the cluster system-->true
</isSupportSysStorFull>
<isSupportVersionAbnormal>
<!--ro, opt, bool, whether the device supports cluster version exception-->true
</isSupportVersionAbnormal>
<isSupportNodeOffline>
<!--ro, opt, bool, whether the device supports device offline detection-->true
</isSupportNodeOffline>
<isSupportRecordCycleAbnormal>
<!--ro, opt, bool, whether the device supports the event of insufficient recording period-->true
</isSupportRecordCycleAbnormal>
<isSupportIpcTransferAbnormal>
<!--ro, opt, bool, whether the device supports the event of network camera migration failure-->true
</isSupportIpcTransferAbnormal>
<isSupportDrivingBehaviorDetect>
<!--ro, opt, bool, whether the device supports driving behavior detection-->true
</isSupportDrivingBehaviorDetect>


<isSupportWasteGasDetection>
<!--ro, opt, bool, whether the device supports waste gas monitoring-->true
</isSupportWasteGasDetection>
<isSupportGreyScaleAlarm>
<!--ro, opt, bool, whether the device supports the gray scale alarm-->true
</isSupportGreyScaleAlarm>
<isSupportPTLocking>
<!--ro, opt, bool, whether the device supports the PT locking event-->true
</isSupportPTLocking>
<isSupportNoMaskDetection>
<!--ro, opt, bool, whether the device supports not wearing mask detection-->true
</isSupportNoMaskDetection>
<isSupportTMPA>
<!--ro, opt, bool, whether the device supports the warning linkage of face temperature screening-->true
</isSupportTMPA>
<RuleScheduleCap>
<!--ro, opt, object, capability of configuring the arming schedule by rule-->
<isSupportCityManagement>
<!--ro, opt, bool, whether the device supports configuring the arming schedule by rule for the city management event-->true
</isSupportCityManagement>
</RuleScheduleCap>
<RegionScheduleCap>
<!--ro, opt, object, capability of configuring the arming schedule by area-->
<isSupportPersonDensityDetection>
<!--ro, opt, bool, whether the device supports configuring the arming schedule by area for the people density detection-->true
</isSupportPersonDensityDetection>
<isSupportPersonQueueDetection>
<!--ro, opt, bool, whether the device supports configuring the arming schedule by area for the queue detection (area popularity analytics)-->true
</isSupportPersonQueueDetection>
</RegionScheduleCap>
<isSupportThermalCalibrationFileException>
<!--ro, opt, bool, whether the device supports the temperature calibration file exception-->true
</isSupportThermalCalibrationFileException>
<isSupportTemperatureIntervalMeasurement>
<!--ro, opt, bool, whether the device supports the temperature range detection-->true
</isSupportTemperatureIntervalMeasurement>
<isSupportThermalVehicleDetection>
<!--ro, opt, bool, whether the device supports thermal imaging vehicle detection-->true
</isSupportThermalVehicleDetection>
<isSupportWaterQualityDetection>
<!--ro, opt, bool, whether the device supports water quality detection-->true
</isSupportWaterQualityDetection>
<isSupportWaterLevelDetection>
<!--ro, opt, bool, whether the device supports water level detection-->true
</isSupportWaterLevelDetection>
<isSupportDeviceTemperatureAbnormal>
<!--ro, opt, bool, whether the device supports temperature exception detection-->true
</isSupportDeviceTemperatureAbnormal>
<isSupportObjectAccumulationDetection>
<!--ro, opt, bool, whether the device supports object accumulation detection-->true
</isSupportObjectAccumulationDetection>
<isSupportAppAbnormal>
<!--ro, opt, bool, whether the device supports the App exception alarm or event-->true
</isSupportAppAbnormal>
<isSupportLensTemperatureException>
<!--ro, opt, bool-->true
</isSupportLensTemperatureException>
<isSupportPTZFXYFinish>
<!--ro, opt, bool-->true
</isSupportPTZFXYFinish>
<isSupportNormalTemperatureAlarm>
<!--ro, opt, bool-->true
</isSupportNormalTemperatureAlarm>
<isSupportLowTemperatureAlarm>
<!--ro, opt, bool-->true
</isSupportLowTemperatureAlarm>
<isSupportLowCoolerLifeEvent>
<!--ro, opt, bool-->true
</isSupportLowCoolerLifeEvent>
<isSupportObstacleAvoidanceAlarm>
<!--ro, opt, bool-->true
</isSupportObstacleAvoidanceAlarm>
</EventCap>
<ITCCap>
<!--ro, opt, object, Related node and URIs: the node <isSupportVehicleDetection> in /ISAPI/ITC/capability and /ISAPI/ITC/capabilities.-->
<isSupportITC>
<!--ro, opt, bool, whether the device supports ITC-->true
</isSupportITC>
<isSupportIllegalDictionary>
<!--ro, opt, bool, whether the device supports the violation dictionary-->true
</isSupportIllegalDictionary>
<isSupportVehicleDetection>
<!--ro, opt, bool, whether the device supports vehicle detection-->true
</isSupportVehicleDetection>
<isSupportHVTVehicleDetection>
<!--ro, opt, bool, whether the device supports mixed-traffic vehicle detection-->true
</isSupportHVTVehicleDetection>
<isSupportlicencePlateAuditData>
<!--ro, opt, bool, whether the device supports importing or exporting the license plate blocklist and allowlist data-->true
</isSupportlicencePlateAuditData>
<isSupportSearchLPListAudit>
<!--ro, opt, bool, whether the device supports searching the license plate blocklist and allowlist-->true
</isSupportSearchLPListAudit>
<isSupportVehicleDetectionManualTrigger opt="false,true">


<isSupportVehicleDetectionManualTrigger opt="false,true">
<!--ro, opt, bool, whether the device supports manually triggering vehicle detection, attr:opt{opt, string}-->true
</isSupportVehicleDetectionManualTrigger>
<isSupportSyncSignalOutput>
<!--ro, opt, bool, whether the device supports configuring output parameters-->true
</isSupportSyncSignalOutput>
</ITCCap>
<ImageCap>
<!--ro, opt, object, capability of configuring image parameters-->
<isSupportRegionalExposure>
<!--ro, opt, bool, whether the device supports regional exposure-->true
</isSupportRegionalExposure>
<isSupportRegionalFocus>
<!--ro, opt, bool, whether the device supports regional focus-->true
</isSupportRegionalFocus>
</ImageCap>
<RacmCap>
<!--ro, opt, object, UI before picture search-->
<isSupportZeroChan>
<!--ro, opt, bool, whether the device supports channel-zero, desc:Related URI: /ISAPI/ContentMgmt/ZeroVideo/channels-->true
</isSupportZeroChan>
<inputProxyNums>
<!--ro, opt, int, supported number of digital channels, desc:Related URI: /ISAPI/ContentMgmt/InputProxy/channels/<ID>-->1
</inputProxyNums>
<eSATANums>
<!--ro, opt, int, supported number of eSATA interfaces-->1
</eSATANums>
<miniSASNums>
<!--ro, opt, int, supported number of miniSAS interfaces-->1
</miniSASNums>
<nasNums>
<!--ro, opt, int, supported number of NAS devices, desc:Related URI: /ISAPI/ContentMgmt/Storage/nas-->1
</nasNums>
<ipSanNums>
<!--ro, opt, int, supported number of IPSANs-->1
</ipSanNums>
<isSupportRaid>
<!--ro, opt, bool, whether the device supports RAID-->true
</isSupportRaid>
<isSupportExtHdCfg>
<!--ro, opt, bool, whether the device supports advanced HDD management-->true
</isSupportExtHdCfg>
<isSupportTransCode>
<!--ro, opt, bool, whether the device supports live view transcoding-->true
</isSupportTransCode>
<isSupportIpcImport>
<!--ro, opt, bool, whether the device supports importing the configuration file of the network camera, desc:Related URI:
/ISAPI/ContentMgmt/InputProxy/ipcConfig-->true
</isSupportIpcImport>
<NasMountType>
<!--ro, opt, object, NAS mounting type-->
<isNFSSupportAuthentication>
<!--ro, opt, bool, whether the device supports NFS authentication-->true
</isNFSSupportAuthentication>
<isCIFSSupportAuthentication>
<!--ro, opt, bool, whether the device supports CIFS authentication-->true
</isCIFSSupportAuthentication>
</NasMountType>
<isSupportIpcStreamType>
<!--ro, opt, bool, whether the device supports the stream type of the network camera-->true
</isSupportIpcStreamType>
<isSupportIOInputProxy>
<!--ro, opt, bool, whether the device supports dynamic input channels, desc:Related URI: /ISAPI/ContentMgmt/IOProxy/inputs-->true
</isSupportIOInputProxy>
<isSupportIOOutputProxy>
<!--ro, opt, bool, whether the device supports dynamic output channels, desc:Related URI: /ISAPI/ContentMgmt/IOProxy/outputs-->true
</isSupportIOOutputProxy>
<isSupportPTZRs485Proxy>
<!--ro, opt, bool, whether the device supports dynamic PTZ RS-485 channels, desc:Related URI: /ISAPI/ContentMgmt/PTZCtrlProxy/capabilities-->true
</isSupportPTZRs485Proxy>
<isSupportSrcIDSearch>
<!--ro, opt, bool, whether the device supports stream ID search-->true
</isSupportSrcIDSearch>
<isSupportReversePlayback>
<!--ro, opt, bool, whether the device supports reverse playback-->true
</isSupportReversePlayback>
<isSupportSMARTTest>
<!--ro, opt, bool, whether the device supports HDD detection, desc:Related URI: /ISAPI/ContentMgmt/Storage/hdd/SMARTTest/config-->true
</isSupportSMARTTest>
<isSupportDownloadByTime>
<!--ro, opt, bool, whether the device supports downloading by time, desc:Related URI: /ISAPI/ContentMgmt/download/capabilities-->true
</isSupportDownloadByTime>
<pictureSearchType
opt="AllEvent,CMR,MOTION,ALARM,EDR,ALARMANDMOTION,Command,pir,wlsensor,callhelp,facedetection,FieldDetection,scenechangedetection,LineDetection,
regionEntrance,regionExiting,loitering,group,rapidMove,parking,unattendedBaggage,attendedBaggage,vehicleDetection,manual,manualSnapShot,playSnapShot,safetyH
elmet,
personQueueCounting,personQueueTime,violentMotion,leavePosition,advReachHeight,peopleNumChange,mixedTargetDetection,illegalParking,pedestrian,construction,r
oadblock,
abandonedObject,trafficAccident,fogDetection,smokeDetection,personDensity,failDown,accessController,videoInterCom,GJD,Luminite,OPTEX,securityControlPanel,ge
tUp,toiletTarry,
playCellphone,vehicleMonitor,vibrationDetection,running,retention,spacingChange,yardTarry,keyPersonGetUp,sitQuietly,standUp,plateRecognition,smoking,onThePh
one,fatigueDriving,
notLookingStraightAhead,leaveThePost,seatBelt,sunglasses,identityAbnormal,ForwardCollisionWarning,LaneDepartureWarning,BlindSpotDetection,HeadwayMonitoringW
arning,


arning,
PedestrianCollisionWarning,SuddenSpeedUp,SuddenSpeedDown,SuddenLeftTurn,SuddenRightTurn,Turnover,NotYieldToPedestrian,unregisteredStreetVendor,stallOutsideS
hop,stallOccupyingRoad,
illegalHeap,illegalParkingofNonMotorVehicle,illegalOutdoorAdvertisement,packGarbage,stallUnderUmbrella,dustbinOverflow,exposeGarbage,hangClothingAlongStreet,allPic,ATMPanel,
ATMSurround,ATMFace,ATMSafetyCabin,loitering,smokeDetectAlarm">
<!--ro,
opt, string, picture search type, attr:opt{opt, string}-->test
</pictureSearchType>
<recordSearchType
opt="AllEvent,CMR,MOTION,ALARM,EDR,ALARMANDMOTION,Command,pir,wlsensor,callhelp,facedetection,FieldDetection,scenechangedetection,LineDetection,
regionEntrance,regionExiting,loitering,group,rapidMove,parking,unattendedBaggage,attendedBaggage,vehicleDetection,manual,manualSnapShot,playSnapShot,safetyH
elmet,
failDown,personDensityDetection,smokeDetection,vibrationDetection,unregisteredStreetVendor,stallOutsideShop,stallOccupyingRoad,illegalHeap,illegalParkingofN
on-MotorVehicle,
illegalOutdoorAdvertisement,packGarbage,stallUnderUmbrella,dustbinOverflow,exposeGarbage,hangClothingAlongStreet,ATMPanel,ATMSurround,ATMFace,ATMSafetyCabin
">
<!--ro, opt, string, video search type, attr:opt{opt, string}, desc:llEvent (all events), CMR (capture by schedule), MOTION (capture motion detection
pictures), ALARM (capture alarm pictures), EDR (capture alarm pictures or motion detection pictures), ALARMANDMOTION (capture alarm pictures and motion
detection pictures), Command,pir (pir alarm), wlsensor (wireless alarm), callhelp (panic alarm), facedetection (face detection), FieldDetection (intrusion
detection), scenechangedetection (scene change detection), LineDetection (line crossing detection)-->test
</recordSearchType>
<isSupportActivateIpc>
<!--ro, opt, bool, whether the device supports activating the network camera-->true
</isSupportActivateIpc>
<isSupportCheckIpcSecurity>
<!--ro, opt, object, device password detection-->
<isSupportCheckPassword>
<!--ro, opt, bool, whether the device supports password detection-->true
</isSupportCheckPassword>
</isSupportCheckIpcSecurity>
<isSupportMainAndSubRecord>
<!--ro, opt, bool, whether the device supports the main stream and sub-stream recording-->true
</isSupportMainAndSubRecord>
<isSupportSyncIPCPassword>
<!--ro, opt, bool, whether the device supports synchronizing the password of the network camera-->true
</isSupportSyncIPCPassword>
<isSupportTransferIPC>
<!--ro, opt, bool, whether the device supports transparent transmission of the network camera-->true
</isSupportTransferIPC>
<isSupportSmartSearch>
<!--ro, opt, bool, whether the device supports video dual-VCA, desc:Related URI: /ISAPI/ContentMgmt/SmartSearch/capabilities-->true
</isSupportSmartSearch>
<isSupportPOS>
<!--ro, opt, bool, whether the device supports POS-->true
</isSupportPOS>
<isSupportLinkNum>
<!--ro, opt, bool, whether the device supports getting the number of links, desc:Related URI: /ISAPI/ContentMgmt/InputProxy/channels/<ID>/linkNum-
>true
</isSupportLinkNum>
<isSupportPassBackBasicCfg>
<!--ro, opt, bool, whether the device supports configuring basic parameters of the CVR copy-back function, desc:Related URI:
/ISAPI/ContentMgmt/record/passback/basicCfg/capabilities-->true
</isSupportPassBackBasicCfg>
<PassBackTaskConfig>
<!--ro, opt, object, capability of managing tasks of the CVR copy-back function-->
<isSupportAddTask>
<!--ro, opt, bool, whether the device supports adding a task, desc:Related URI: /ISAPI/ContentMgmt/record/passback/addTask/capabilities-->true
</isSupportAddTask>
<isSupportSearchTask>
<!--ro, opt, bool, whether the device supports searching tasks, desc:Related URI: /ISAPI/ContentMgmt/record/passback/searchTask/capabilities-->true
</isSupportSearchTask>
<isSupportControlTask>
<!--ro, opt, bool, whether the device supports controlling the task, desc:Related URI: /ISAPI/ContentMgmt/record/passback/controlTask/capabilities-
>true
</isSupportControlTask>
<isSupportDeleteTask>
<!--ro, opt, bool, whether the device supports deleting the task, desc:Related URI: /ISAPI/ContentMgmt/record/passback/deleteTask/capabilities-
>true
</isSupportDeleteTask>
</PassBackTaskConfig>
<PassBackPlanConfig>
<!--ro, opt, object, capability of configuring the CVR copy-back schedule-->
<isSupportAddPlan>
<!--ro, opt, bool, whether the device supports adding a schedule, desc:Related URI: /ISAPI/ContentMgmt/record/passback/addPlan/capabilities-->true
</isSupportAddPlan>
<isSupportSearchPlan>
<!--ro, opt, bool, whether the device supports searching schedules, desc:Related URI: /ISAPI/ContentMgmt/record/passback/searchPlan/capabilities-
>true
</isSupportSearchPlan>
<isSupportDeletePlan>
<!--ro, opt, bool, whether the device supports deleting the schedule, desc:Related URI: /ISAPI/ContentMgmt/record/passback/deletePlan/capabilities-
>true
</isSupportDeletePlan>
</PassBackPlanConfig>
<IRAIDCap>
<!--ro, opt, object, network array capability-->
<isSupportIRAIDRapidConfiguration>
<!--ro, opt, bool, whether the device supports the rapid IRAID configuration, desc:Related URI:
/ISAPI/ContentMgmt/Storage/IRAID/RapidConfiguration/capabilities-->true
</isSupportIRAIDRapidConfiguration>
</IRAIDCap>
<isSupportStorageExtraInfo>
<!--ro, opt, bool, whether the device supports configuring additional storage information, desc:Related URI:
/ISAPI/ContentMgmt/Storage/ExtraInfo/capabilities-->true
</isSupportStorageExtraInfo>
<isSupportRecordStatus>


<isSupportRecordStatus>
<!--ro, opt, bool, whether the device supports getting the recording status, desc:Related URI: /ISAPI/ContentMgmt/channels/<ID>/record/capabilities-
>true
</isSupportRecordStatus>
<isSupportRacmChannelsCap>
<!--ro, opt, bool, whether the device supports the Rcam capability by channel, desc:Related URI: /ISAPI/ContentMgmt/channels/<ID>/capabilities-->true
</isSupportRacmChannelsCap>
<LockCap>
<!--ro, opt, object, Video Locking and Unlocking, desc:Related URI: /ISAPI/ContentMgmt/record/control/locks/capabilities-->
</LockCap>
<isSupportForamtAll>
<!--ro, opt, bool, whether the device supports formatting all HDDs, desc:Related URI: /ISAPI/ContentMgmt/Storage/hdd/format-->true
</isSupportForamtAll>
<isSupportExtendCabinetCfg>
<!--ro, opt, bool, whether the device supports configuring parameters of the extended cabinet. Related URI:
/ISAPI/ContentMgmt/Storage/ExtendCabinet/capabilities-->true
</isSupportExtendCabinetCfg>
<diskGroupNums>
<!--ro, opt, int, supported number of disk groups, desc:Related URI: /ISAPI/ContentMgmt/Storage/diskGroup-->1
</diskGroupNums>
<ExternalDevice>
<!--ro, opt, object, external device storage-->
<USB>
<!--ro, opt, object, USB information-->
<debugLogOutput>
<!--ro, opt, bool, whether to enable the debugging log, desc:Related URI: /ISAPI/ContentMgmt/Storage/externalDevice/USB?format=json-->true
</debugLogOutput>
<isSupportCapturePackage>
<!--ro, opt, bool, whether the device supports configuring capture and filter function of a USB, desc:Related URI:
/ISAPI/ContentMgmt/Storage/externalDevice/USB/capturePackage/capabilities?format=json-->true
</isSupportCapturePackage>
<isSupportStreamStorage>
<!--ro, opt, bool, whether the device supports saving stream to a USB, desc:Related URI:
/ISAPI/ContentMgmt/Storage/externalDevice/USB/streamStorage/capabilities?format=json-->true
</isSupportStreamStorage>
</USB>
</ExternalDevice>
<customProtocolNums>
<!--ro, opt, int, number of custom protocols connected via IPC-->1
</customProtocolNums>
<isSupportIPCTiming>
<!--ro, opt, bool, whether the device supports synchronizing the time of the network camera, desc:whether the device supports synchronizing the time
of the network camera-->true
</isSupportIPCTiming>
<isSupportLogConfig>
<!--ro, opt, bool, whether the device supports log configuration, desc:Related URI: /ISAPI/ContentMgmt/Storage/externalDevice/USB?format=json-->true
</isSupportLogConfig>
<SecurityLog>
<!--ro, opt, object-->
<isSupportSecurityLog>
<!--ro, opt, bool, whether the device supports the security log-->true
</isSupportSecurityLog>
<isSupportLogServer>
<!--ro, opt, bool, whether it supports security log server configuration-->true
</isSupportLogServer>
<isSupportLogServerTest>
<!--ro, opt, bool, whether it supports security log server test-->true
</isSupportLogServerTest>
<SecurityLogTypeList>
<!--ro, req, array, list of security log types, subType:object-->
<SecurityLogType>
<!--ro, opt, object, security log type-->
<primaryType>
<!--ro, req, string, main log type, desc:main log type-->test
</primaryType>
<secondaryType opt="all">
<!--ro, req, string, attr:opt{opt, string}-->test
</secondaryType>
</SecurityLogType>
</SecurityLogTypeList>
<isSupportLogServerList>
<!--ro, opt, bool-->true
</isSupportLogServerList>
</SecurityLog>
<isSupportGetBackupDevice>
<!--ro, opt, bool, whether the device supports getting the backup device, desc:Related URI: /ISAPI/ContentMgmt/Storage/backup/device?format=json-
>true
</isSupportGetBackupDevice>
<isSupportAutoBackup>
<!--ro, opt, bool, whether the device supports automatic backup, desc:Related URI: /ISAPI/ContentMgmt/Storage/backup/auto/capabilities?format=json-
>true
</isSupportAutoBackup>
<certificateValidationEnabled>
<!--ro, opt, bool-->true
</certificateValidationEnabled>
<defaultAdminPortEnabled>
<!--ro, opt, bool, whether to enable the default communication port, desc:whether to enable the default communication port-->true
</defaultAdminPortEnabled>
<isSupportLogDataPackage>
<!--ro, opt, bool, whether the device supports exporting the log files, desc:Related URI: /ISAPI/ContentMgmt/logSearch/dataPackage-->true
</isSupportLogDataPackage>
<logSearchTimeSpanNums>
<!--ro, opt, int, number of time periods for log search-->1
</logSearchTimeSpanNums>


</logSearchTimeSpanNums>
<CloudStorageServerCap>
<!--ro, opt, object, capability of configuring the cloud storage server-->
<isSupportCloudStorageParameter>
<!--ro, opt, bool, whether the device supports configuring the cloud storage parameters, desc:Related URI:
/ISAPI/ContentMgmt/Storage/cloudServer/capabilities?format=json-->true
</isSupportCloudStorageParameter>
<isSupportCloudStoragePool>
<!--ro, opt, bool, whether the device supports configuring the cloud storage pool, desc:Related URI:
/ISAPI/ContentMgmt/Storage/cloudServer/pool/capabilities?format=json-->true
</isSupportCloudStoragePool>
<supportChannelsNum>
<!--ro, opt, int, number of channels supported by the cloud storage-->1
</supportChannelsNum>
</CloudStorageServerCap>
<isSupportWebPrivatePlaybackByUTC>
<!--ro, opt, bool, whether it supports playback based on Web private protocol-->true
</isSupportWebPrivatePlaybackByUTC>
<isSupportFindCommonFileByUTC>
<!--ro, opt, bool, whether it supports extending the time zone for searching files-->true
</isSupportFindCommonFileByUTC>
<isSupportFindEventFileByUTC>
<!--ro, opt, bool-->true
</isSupportFindEventFileByUTC>
<isSupportSmartSearchRecordByUTC>
<!--ro, opt, bool, whether it supports VCA search by UTC time-->true
</isSupportSmartSearchRecordByUTC>
<isSupportMRDSearchByTimeZone>
<!--ro, opt, bool, whether it supports extending the time zone for searching files by calendar-->true
</isSupportMRDSearchByTimeZone>
<isSupportSearchRecordLabelByUTC>
<!--ro, opt, bool, whether it supports searching video tags by UTC time-->true
</isSupportSearchRecordLabelByUTC>
<isSupportSearchPictureByUTC>
<!--ro, opt, bool, whether it supports searching pictures by UTC time-->true
</isSupportSearchPictureByUTC>
<isSupportSmartSearchPictureByUTC>
<!--ro, opt, bool, whether it supports searching pictures with smart information by UTC time-->true
</isSupportSmartSearchPictureByUTC>
<isSupportFindLogByUTC>
<!--ro, opt, bool, whether it supports searching log by UTC time-->true
</isSupportFindLogByUTC>
<isSupportUploadRecordByUTC>
<!--ro, opt, bool, whether it supports uploading files to cloud storage by UTC time-->true
</isSupportUploadRecordByUTC>
<isSupportPlaybackByUTC>
<!--ro, opt, bool, whether it supports playback and locating by UTC time-->true
</isSupportPlaybackByUTC>
<isSupportFaceDetecttionAlarmByTimeZone>
<!--ro, opt, bool, whether the device supports getting the channel information by condition-->true
</isSupportFaceDetecttionAlarmByTimeZone>
<isSupportSourceModify>
<!--ro, opt, bool, Related URI: /ISAPI/ContentMgmt/InputProxy/sourceModify/capabilities, desc:Related URI:
/ISAPI/ContentMgmt/InputProxy/sourceModify/capabilities-->true
</isSupportSourceModify>
<isSupportCountingSearchByUTC>
<!--ro, opt, bool, whether it supports searching people counting results by UTC time-->true
</isSupportCountingSearchByUTC>
<isSupportCluster>
<!--ro, opt, bool, whether the device supports the cluster function, desc:Related URI: /ISAPI/ContentMgmt/Cluster-->true
</isSupportCluster>
<supportAIDTFSType opt="illegalParking,wrongdirection,crosslane,vehicleexist,lanechange,turnround,evidence">
<!--ro, opt, string, attr:opt{opt, string}-->test
</supportAIDTFSType>
<isSupportMisinfoStateSearch>
<!--ro, opt, bool, whether it supports searching by false alarm status-->true
</isSupportMisinfoStateSearch>
<isSupportOneKeyOperationStorageData>
<!--ro, opt, bool, whether it supports one-touch configuration for storage data, desc:Related URI: /ISAPI/ContentMgmt/Storage/oneKey/capabilities?
format=json-->true
</isSupportOneKeyOperationStorageData>
<eventRecordSearch>
<!--ro, opt, object, whether the device supports searching videos by event, desc:Related URI: /ISAPI/ContentMgmt/eventRecordSearch?format=json-->
<eventType opt="faceContrast,faceSnap,vehicleMatchResult,hawkResult">
<!--ro, opt, string, attr:opt{opt, string}-->test
</eventType>
<auxEventType opt="faceContrastFailure,faceContrastSuccess">
<!--ro, opt, string, search sub type of the event, attr:opt{opt, string}-->test
</auxEventType>
</eventRecordSearch>
<isSupportManualRecord>
<!--ro, opt, bool, whether the device supports manual recording, desc:Related URI: /ISAPI/ContentMgmt/record/control/manual/capabilities?format=json-
>true
</isSupportManualRecord>
<isSupportRemark>
<!--ro, opt, bool, whether it supports file remarks-->true
</isSupportRemark>
<FileUpload>
<!--ro, opt, object, auto-upload file-->
<enabled>
<!--ro, req, bool, whether it supports uploading the file-->true
</enabled>
</FileUpload>
<PoliceInfoUpload>


<!--ro, opt, object, auto-upload police information-->
<enabled>
<!--ro, req, bool, whether it supports uploading the police information-->true
</enabled>
</PoliceInfoUpload>
<PoliceInfo>
<!--ro, opt, object, police officer information-->
<policeID>
<!--ro, opt, bool, whether the device supports police ID-->true
</policeID>
<policeCode>
<!--ro, opt, bool, whether the device supports police number-->true
</policeCode>
<policeName>
<!--ro, opt, bool, whether the device supports police name-->true
</policeName>
<password>
<!--ro, opt, bool, whether the device supports police password-->true
</password>
<deviceID>
<!--ro, opt, bool, whether the device supports device ID-->true
</deviceID>
</PoliceInfo>
<isSupportAssignChannelID>
<!--ro, opt, bool, whether the device supports specifying the access channel No. when adding the network camera, desc:whether the device supports
specifying the access channel No. when adding the network camera-->true
</isSupportAssignChannelID>
<isSupportAssignStreamID>
<!--ro, opt, bool, whether it supports specifying stream ID of the channel when adding the network camera-->true
</isSupportAssignStreamID>
<PictureSearchSubTypeList>
<!--ro, opt, array, list of picture searching sub type, subType:object-->
<PictureSearchSubType>
<!--ro, opt, object, searched picture type-->
<mainType>
<!--ro, req, string, main event type of the searched picture-->test
</mainType>
<subType opt="all,motorVehicle,nonMotorVehicle,pedestrian">
<!--ro, req, string, sub type of each main event type, attr:opt{opt, string}-->test
</subType>
</PictureSearchSubType>
</PictureSearchSubTypeList>
<isSupportPlaybackStreamIDByUTC>
<!--ro, opt, bool, whether it supports playback by stream ID-->true
</isSupportPlaybackStreamIDByUTC>
<isSupportTimeLockStreamIDByUTC>
<!--ro, opt, bool, whether it supports UTC time for locking and unlocking the video segment by steam ID-->true
</isSupportTimeLockStreamIDByUTC>
<isSupportTimeSearch>
<!--ro, opt, bool, whether it supports searching for recording start and end time by channel, desc:Related URI: /ISAPI/ContentMgmt/time/search?
format=json-->true
</isSupportTimeSearch>
<behaviorEventPicSearch opt="allBehaviorEvent,running,group,violentMotion,failDown,playCellphone,peopleNumChange,leavePosition,retention,sleepOnduty">
<!--ro, opt, string, behavior analysis events whose pictures are supported to be searched, attr:opt{opt, string}-->test
</behaviorEventPicSearch>
<perimeterEventPicSearch opt="allPerimeterEvent,linedetection,fielddetection,regionEntrance,regionExiting,loitering">
<!--ro, opt, string, perimeter protection events whose pictures are supported to be searched, attr:opt{opt, string}-->test
</perimeterEventPicSearch>
<isSupportSourceStatus>
<!--ro, opt, bool, whether it supports getting source status-->true
</isSupportSourceStatus>
<isSupportSSDSMARTTest>
<!--ro, opt, bool, whether the device supports S.M.A.R.T. detection on SSD, desc:Related URI: /ISAPI/ContentMgmt/Storage/ssd/<ID>/SMARTTest/start-
>true
</isSupportSSDSMARTTest>
<MobileStorage>
<!--ro, opt, object, storage capability of the mobile HDD-->
<isSupportGetFileTime>
<!--ro, opt, bool, whether it supports getting the file time of the mobile HDD-->true
</isSupportGetFileTime>
</MobileStorage>
<isSupportGetChannelList>
<!--ro, opt, bool, whether it supports getting channels of HDD-->true
</isSupportGetChannelList>
<isSupportCascade>
<!--ro, opt, bool, whether it supports configuring parameters for NVR cascading topology-->true
</isSupportCascade>
<isSupportPictureInfo>
<!--ro, opt, bool, whether it supports picture search on the SD card of the capture camera-->true
</isSupportPictureInfo>
<isSupportCloudStorageModel>
<!--ro, opt, bool, whether the device supports configuring the cloud storage mode,
desc:/ISAPI/ContentMgmt/Storage/CloudStorageModel/<channelID>/capabilities?format=json-->true
</isSupportCloudStorageModel>
<isSupportCloudStorageModelList>
<!--ro, opt, bool, whether the device supports configuring cloud storage modes in a batch,
desc:/ISAPI/ContentMgmt/Storage/CloudStorageModel/<channelID>?format=json-->true
</isSupportCloudStorageModelList>
<isSupportRecordAudio>
<!--ro, opt, bool, whether the device supports recording the audio, desc:Only the video will be recorded and the video will not be recorded. Related
URI: /ISAPI/ContentMgmt/recordAudio/<audioID>/capabilities?format=json-->true
</isSupportRecordAudio>
<isSupportSearchAudio>
<!--ro, opt, bool, whether the device supports searching the audio, desc:Related URI: /ISAPI/ContentMgmt/recordAudio/search/capabilities?format=json-


<!--ro, opt, bool, whether the device supports searching the audio, desc:Related URI: /ISAPI/ContentMgmt/recordAudio/search/capabilities?format=json-
>true
</isSupportSearchAudio>
<isSupportAudioDailyDistribution>
<!--ro, opt, bool, whether it supports searching for audio file information by monthly calendar, desc:Related URI:
/ISAPI/ContentMgmt/recordAudio/<audioID>/searchDailyDistribution?format=json-->true
</isSupportAudioDailyDistribution>
<isSupportDownloadAudio>
<!--ro, opt, bool, whether the device supports downloading the audio by file name, desc:related URI:
/ISAPI/ContentMgmt/recordAudio/fileNameDownload/capabilities?format=json-->true
</isSupportDownloadAudio>
<isSupportDeleteAudio>
<!--ro, opt, bool, whether the device supports deleting the recorded audio file, desc:Related URI: /ISAPI/ContentMgmt/recordAudio/deleteFile?
format=json-->true
</isSupportDeleteAudio>
<isSupportSearchRemoteAlbum>
<!--ro, opt, bool, whether the device supports searching the remote album information, desc:Related URI: /ISAPI/ContentMgmt/searchRemoteAlbum?
format=json-->true
</isSupportSearchRemoteAlbum>
<isSupportStreamParam>
<!--ro, opt, bool-->true
</isSupportStreamParam>
</RacmCap>
<PTZCtrlCap>
<!--ro, opt, object, device's PTZ capability-->
<isSupportPatrols>
<!--ro, opt, bool, whether the device supports patrol-->true
</isSupportPatrols>
<isSupportCombinedPath>
<!--ro, opt, bool-->true
</isSupportCombinedPath>
<isSupportRailwayRobot>
<!--ro, opt, bool-->true
</isSupportRailwayRobot>
</PTZCtrlCap>
<SmartCap>
<!--ro, opt, object, /ISAPI/Smart/capabilities, desc:/ISAPI/Smart/capabilities-->
<isSupportROI>
<!--ro, opt, bool, whether the device supports ROI encoding configuration-->true
</isSupportROI>
<isSupportFaceDetect>
<!--ro, opt, bool, whether the device supports face detection-->true
</isSupportFaceDetect>
<isSupportIntelliTrace>
<!--ro, opt, bool, whether the device supports smart tracking-->true
</isSupportIntelliTrace>
<isSupportFieldDetection>
<!--ro, opt, bool, whether the device supports intrusion detection-->true
</isSupportFieldDetection>
<isSupportDefocusDetection>
<!--ro, opt, bool, whether the device supports defocus detection-->true
</isSupportDefocusDetection>
<isSupportAudioDetection>
<!--ro, opt, bool, whether the device supports audio detection-->true
</isSupportAudioDetection>
<isSupportSceneChangeDetection>
<!--ro, opt, bool, whether the device supports scene change detection-->true
</isSupportSceneChangeDetection>
<isSupportLineDetection>
<!--ro, opt, bool, whether the device supports line crossing detection-->true
</isSupportLineDetection>
<isSupportRegionEntrance>
<!--ro, opt, bool, whether the device supports region entrance detection-->true
</isSupportRegionEntrance>
<isSupportRegionExiting>
<!--ro, opt, bool, whether the device supports region exiting detection-->true
</isSupportRegionExiting>
<isSupportLoitering>
<!--ro, opt, bool, whether the device supports loitering detection-->true
</isSupportLoitering>
<isSupportGroup>
<!--ro, opt, bool, whether the device supports people gathering detection-->true
</isSupportGroup>
<isSupportRapidMove>
<!--ro, opt, bool, whether the device supports fast moving detection-->true
</isSupportRapidMove>
<isSupportParking>
<!--ro, opt, bool, whether the device supports parking detection-->true
</isSupportParking>
<isSupportUnattendedBaggage>
<!--ro, opt, bool, whether the device supports unattended baggage detection-->true
</isSupportUnattendedBaggage>
<isSupportAttendedBaggage>
<!--ro, opt, bool, whether the device supports object removal detection-->true
</isSupportAttendedBaggage>
<isSupportPeopleDetection>
<!--ro, opt, bool, whether the device supports human body detection-->true
</isSupportPeopleDetection>
<isSupportSmartCalibration>
<!--ro, opt, bool-->true
</isSupportSmartCalibration>
<isSupportStorageDetection>
<!--ro, opt, bool-->true
</isSupportStorageDetection>


<isSupportShipsDetection>
<!--ro, opt, bool, whether the device supports ship detection-->true
</isSupportShipsDetection>
<isSupportShield>
<!--ro, opt, bool-->true
</isSupportShield>
<isSupportAlgVersion>
<!--ro, opt, bool, whether the device supports algorithm version-->true
</isSupportAlgVersion>
<isSupportVideoOverlap>
<!--ro, opt, bool-->true
</isSupportVideoOverlap>
<isSupportParkingState>
<!--ro, opt, bool, whether the device supports parking status-->true
</isSupportParkingState>
<isSupportChannelResource>
<!--ro, opt, bool, whether the device supports channel resources-->true
</isSupportChannelResource>
<isSupportAnalysisUnitSwitch opt="true,false">
<!--ro, opt, bool, whether the device supports switching analysis unit, attr:opt{opt, string}-->true
</isSupportAnalysisUnitSwitch>
<isSupportHFPD>
<!--ro, opt, bool, whether the device supports frequently appeared person detection, desc:Related URI: /ISAPI/SDT/HFPD?format=json-->true
</isSupportHFPD>
<isSupportImageROI>
<!--ro, opt, bool, whether the device supports smartJpeg (image ROI)-->true
</isSupportImageROI>
<isSupportLFPD>
<!--ro, opt, bool, whether the device supports rarely appeared person detection, desc:Related URI: /ISAPI/SDT/LFPD?format=json-->true
</isSupportLFPD>
</SmartCap>
<isSupportEhome>
<!--ro, opt, bool, whether it supports ISUP functions: true (support),this node is not returned (not support)-->true
</isSupportEhome>
<isSupportStreamingEncrypt>
<!--ro, opt, bool, whether the device supports stream encryption-->true
</isSupportStreamingEncrypt>
<TestCap>
<!--ro, opt, object, test capability-->
<isSupportEmailTest>
<!--ro, opt, bool, whether the device supports email test-->true
</isSupportEmailTest>
</TestCap>
<ImageMiscCap>
<!--ro, opt, object, DPC capability-->
<isSupportDPC>
<!--ro, opt, bool, whether the device supports DPC-->true
</isSupportDPC>
</ImageMiscCap>
<PanoramaCap>
<!--ro, opt, object-->
<isSupportGeneratePanorama>
<!--ro, opt, bool-->true
</isSupportGeneratePanorama>
<isSupportPanoramaPosition3D>
<!--ro, opt, bool-->true
</isSupportPanoramaPosition3D>
<isSupportPreset>
<!--ro, opt, bool-->true
</isSupportPreset>
</PanoramaCap>
<ThermalCap>
<!--ro, opt, object, thermal capability, desc:Related URI: /ISAPI/Thermal/capabilities-->
<isSupportFireDetection>
<!--ro, opt, bool, whether the device supports fire detection, desc:Related URI: /ISAPI/Thermal/channels/<ID>/fireDetection/capabilities-->true
</isSupportFireDetection>
<isFireFocusZoomSupport>
<!--ro, opt, bool, whether supports visible light lens zooming, desc:Related URI: /ISAPI/Thermal/channels/<ID>/fireFocusZoom-->true
</isFireFocusZoomSupport>
<isSupportThermometry>
<!--ro, opt, bool, whether the device supports thermography, desc:Related URI: /ISAPI/Thermal/channels/<ID>/thermometry/<SID>/capabilities-->true
</isSupportThermometry>
<isSupportRealtimeThermometry>
<!--ro, opt, bool, whether supports uploading real-time temperature measurement data-->true
</isSupportRealtimeThermometry>
<isSupportThermIntell>
<!--ro, opt, bool, desc:Related URI: /ISAPI/Thermal/channels/<ID>/thermIntell/capabilities-->true
</isSupportThermIntell>
<isSupportNVR>
<!--ro, opt, bool-->true
</isSupportNVR>
<isSupportThermometrySchedule>
<!--ro, opt, bool-->true
</isSupportThermometrySchedule>
<isSupportTemperatureSchedule>
<!--ro, opt, bool-->true
</isSupportTemperatureSchedule>
<isSupportFireDetectionSchedule>
<!--ro, opt, bool-->true
</isSupportFireDetectionSchedule>
<isSupportPower>
<!--ro, opt, bool, whether supports power on/off capability, desc:Related URI: /ISAPI/Thermal/Power/capabilities-->true
</isSupportPower>
<isSupportRealtimeTempHumi>


<isSupportRealtimeTempHumi>
<!--ro, opt, bool, whether supports real-time detection of temperature and humidity, desc:Related URI: /ISAPI/Thermal/TempHumi/capabilities-->true
</isSupportRealtimeTempHumi>
<ManualThermCap>
<!--ro, opt, object-->
<manualThermRuleNum>
<!--ro, opt, int, if this node is not returned, it indicates manual temperature measurement is not supported, desc:Related URI:
/ISAPI/Thermal/manualThermometry/capabilities-->true
</manualThermRuleNum>
</ManualThermCap>
<isSupportManualThermBasic>
<!--ro, opt, bool, whether supports basic configuration of manual temperature measurement, desc:Related URI:
/ISAPI/Thermal/manualThermBasic/capabilities-->true
</isSupportManualThermBasic>
<isSupportFireShieldMask>
<!--ro, opt, bool, desc:Related URI: /ISAPI/Thermal/channels/<ID>/fireShieldMask/capabilities-->true
</isSupportFireShieldMask>
<isSupportSmokeShieldMask>
<!--ro, opt, bool, desc:Related URI: /ISAPI/Thermal/channels/<ID>/smokeShieldMask/capabilities-->true
</isSupportSmokeShieldMask>
<isSupportThermometryMode>
<!--ro, opt, bool, whether the device supports the configuration of temperature measurement mode, desc:Related URI:
/ISAPI/Thermal/channels/<ID>/thermometryMode/capabilities-->true
</isSupportThermometryMode>
<isSupportThermalPip>
<!--ro, opt, bool, whether the device supports the PIP configuration, desc:Related URI: /ISAPI/Thermal/channels/<ID>/pip/capabilities-->true
</isSupportThermalPip>
<isSupportThermalIntelRuleDisplay>
<!--ro, opt, bool, whether the device supports the PIP configuration, desc:Related URI: /ISAPI/Thermal/channels/<ID>/IntelRuleDisplay/capabilities-
>true
</isSupportThermalIntelRuleDisplay>
<AlgVersionInfo>
<!--ro, opt, object, whether supports getting the version information of thermal algorithms library, desc:Related URI: /ISAPI/Thermal/AlgVersion-->
<thermometryAlgName min="1" max="128">
<!--ro, opt, string, version information of temperature measurement algorithms library, attr:min{opt, string},max{opt, string}-->test
</thermometryAlgName>
<shipsAlgName min="1" max="128">
<!--ro, opt, string, version name of ship detection algorithms library, attr:min{opt, string},max{opt, string}-->test
</shipsAlgName>
<fireAlgName min="1" max="128">
<!--ro, opt, string, algorithm library version name of fire detection, attr:min{opt, int},max{opt, int}-->test
</fireAlgName>
<smokeAlgName min="1" max="128">
<!--ro, opt, string, algorithm library version name of smoke detection, attr:min{req, int},max{opt, int}-->test
</smokeAlgName>
<wasteGasAlgName min="1" max="128">
<!--ro, opt, string, algorithm library version name of waste gas detection, attr:min{opt, string},max{opt, string}-->test
</wasteGasAlgName>
<greyScaleAlarmAlgName min="1" max="128">
<!--ro, opt, string, algorithm library version name of greyscale alarm, attr:min{opt, string},max{opt, string}-->test
</greyScaleAlarmAlgName>
</AlgVersionInfo>
<isSupportFaceThermometry>
<!--ro, opt, bool, whether supports temperature screening configuration, desc:Related URI: /ISAPI/Thermal/channels/<ID>/faceThermometry/capabilities-
>true
</isSupportFaceThermometry>
<isSupportThermalBlackBody>
<!--ro, opt, bool, whether the device supports configuring black body parameters of thermal imaging, desc:Related URI:
/ISAPI/Thermal/channels/<ID>/blackBody/capabilities-->true
</isSupportThermalBlackBody>
<isSupportThermalStreamParam>
<!--ro, opt, bool, whether the device supports configuring stream parameters of thermal imaging, desc:Related URI:
/ISAPI/Thermal/channels/<ID>/streamParam/capabilities-->true
</isSupportThermalStreamParam>
<isSupportBodyTemperatureCompensation>
<!--ro, opt, bool, whether supports temperature compensation configuration, desc:Related URI:
/ISAPI/Thermal/channels/<ID>/bodyTemperatureCompensation/capabilities-->true
</isSupportBodyTemperatureCompensation>
<isSupportClickToThermometry>
<!--ro, opt, bool, whether the device supports click-to-thermometry, desc:Related URI: ISAPI/Thermal/channels/<ID>/clickToThermometry/initialization-
>true
</isSupportClickToThermometry>
<isSupportThermometryHistorySearch>
<!--ro, opt, bool-->true
</isSupportThermometryHistorySearch>
<isSupportThermometryShieldMask>
<!--ro, opt, bool, desc:Related URI: /ISAPI/Thermal/channels/<ID>/thermometryShieldMask/capabilities-->true
</isSupportThermometryShieldMask>
<isSupportTemperatureCorrection>
<!--ro, opt, bool, whether device supports temperature measurement correction, desc:Related URI:
/ISAPI/Thermal/channels/<ID>/CorrectionParam/capabilities-->true
</isSupportTemperatureCorrection>
<isSupportBurningPrevention>
<!--ro, opt, bool, whether device supports burning prevention, desc:Related URI: /ISAPI/Thermal/channels/<ID>/burningPrevention/capabilities-->true
</isSupportBurningPrevention>
<isSupportTemperatureCollection>
<!--ro, opt, bool, whether device supports temperature ANR-->true
</isSupportTemperatureCollection>
<isSupportJpegPicWithAppendData>
<!--ro, opt, bool, whether the device supports capturing pictures-->true
</isSupportJpegPicWithAppendData>
<isSupportRealTimethermometryForHTTP>
<!--ro, opt, bool, whether device supports real-time temperature measurement. If supports,it is returned and its value is true,if not support,it is
not returned-->true


not returned-->true
</isSupportRealTimethermometryForHTTP>
<isSupportthermometryOffLineCapture>
<!--ro, opt, bool, whether the device supports capturing pictures offline, desc:Related URI: /ISAPI/Thermal/channels/<ID>/thermometry/OffLineCapture?
format=json-->true
</isSupportthermometryOffLineCapture>
<isSupportShipsDetectionWithScene>
<!--ro, opt, bool, whether the device supports ship detection by scene, desc:Related URI: /ISAPI/Thermal/channels/<ID>/shipsDetection/capabilities?
format=json-->true
</isSupportShipsDetectionWithScene>
<isSupportWasteGasDetection>
<!--ro, opt, bool, whether the device supports waste gas monitoring-->true
</isSupportWasteGasDetection>
<isSupportGreyScaleAlarm>
<!--ro, opt, bool, whether the device supports the gray scale alarm-->true
</isSupportGreyScaleAlarm>
<isSupportFaceSnapThermometry>
<!--ro, opt, bool, whether device supports uploading captured face picture with temperature information-->true
</isSupportFaceSnapThermometry>
<isSupportThermalTemperatureCorrect>
<!--ro, opt, bool, whether device supports temperature calibration, desc:Related URI: /ISAPI/Thermal/channels/<ID>/temperatureCorrect?format=json-
>true
</isSupportThermalTemperatureCorrect>
<isSupportThermalVehicleDetection>
<!--ro, opt, bool, whether the device supports thermal imaging vehicle detection-->true
</isSupportThermalVehicleDetection>
<isSupportSensorParam>
<!--ro, opt, bool, Related URI: /ISAPI/Thermal/channels/<channelID>/thermometry/sensorParam/capabilities?format=json, desc:Related URI:
/ISAPI/Thermal/channels/<channelID>/thermometry/sensorParam/capabilities?format=json-->true
</isSupportSensorParam>
<isSupportThermalDataLinkInfo>
<!--ro, opt, bool-->true
</isSupportThermalDataLinkInfo>
<isSupportTemperatureCompensationCalib>
<!--ro, opt, bool-->true
</isSupportTemperatureCompensationCalib>
<isSupportWebDisplayPixelToPixelParam>
<!--ro, opt, bool, Related URI: /ISAPI/Thermal/channels/<channelID>/thermometry/pixelToPixelParam/capabilities, desc:Related URI:
/ISAPI/Thermal/channels/<channelID>/thermometry/pixelToPixelParam/capabilities-->true
</isSupportWebDisplayPixelToPixelParam>
<isSupportThermalInspection>
<!--ro, opt, bool-->true
</isSupportThermalInspection>
</ThermalCap>
<WLAlarmCap>
<!--ro, opt, object, wireless alarm capability-->
<isSupportTeleControl>
<!--ro, opt, bool, whether the device supports remote control-->true
</isSupportTeleControl>
<isSupportPIR>
<!--ro, opt, bool, whether the device supports PIR configuration-->true
</isSupportPIR>
<isSupportWLSensors>
<!--ro, opt, bool-->true
</isSupportWLSensors>
<isSupportCallHelp>
<!--ro, opt, bool, whether the device supports calling for help-->true
</isSupportCallHelp>
<WLSensorsNum>
<!--ro, opt, int-->1
</WLSensorsNum>
</WLAlarmCap>
<isSupportGIS>
<!--ro, opt, bool, whether the device supports GIS, desc:Related URI: /ISAPI/GIS/channels-->true
</isSupportGIS>
<isSupportCompass>
<!--ro, opt, bool, whether the device supports compass configuration, desc:Related URI: /ISAPI/Compass/channels/<ID>/capabilities-->true
</isSupportCompass>
<isSupportRoadInfoOverlays>
<!--ro, opt, bool, whether the device supports overlaying the lane information-->true
</isSupportRoadInfoOverlays>
<isSupportFaceCaptureStatistics>
<!--ro, opt, bool-->true
</isSupportFaceCaptureStatistics>
<isSupportElectronicsEnlarge>
<!--ro, opt, bool-->true
</isSupportElectronicsEnlarge>
<isSupportRemoveStorage>
<!--ro, opt, bool, whether the device supports remote storage-->true
</isSupportRemoveStorage>
<isSupportCloud>
<!--ro, opt, bool, whether the device supports cloud storage-->true
</isSupportCloud>
<isSupportRecordHost>
<!--ro, opt, bool, whether the device supports configuring the education sharing server, desc:Related URI: /ISAPI/RecordHost/capabilities-->true
</isSupportRecordHost>
<isSupportViewshedOverlay>
<!--ro, opt, bool-->true
</isSupportViewshedOverlay>
<isSupportGPSLabelTracking>
<!--ro, opt, bool-->true
</isSupportGPSLabelTracking>
<isSupportEagleEye>
<!--ro, opt, bool-->true
</isSupportEagleEye>


</isSupportEagleEye>
<isSupportPanorama>
<!--ro, opt, bool-->true
</isSupportPanorama>
<isSupportFirmwareVersionInfo>
<!--ro, opt, bool, whether the device supports displaying the firmware version information-->true
</isSupportFirmwareVersionInfo>
<isSupportExternalWirelessServer>
<!--ro, opt, bool, whether the device supports external wireless servers: true (support)-->true
</isSupportExternalWirelessServer>
<isSupportSetupCalibration>
<!--ro, opt, bool-->true
</isSupportSetupCalibration>
<isSupportGetmutexFuncErrMsg>
<!--ro, opt, bool-->true
</isSupportGetmutexFuncErrMsg>
<isSupportTokenAuthenticate>
<!--ro, opt, bool, whether the device supports token authentication-->true
</isSupportTokenAuthenticate>
<isSupportStreamDualVCA>
<!--ro, opt, bool-->true
</isSupportStreamDualVCA>
<isSupportLaserSpotManual>
<!--ro, opt, bool-->true
</isSupportLaserSpotManual>
<isSupportRTMP>
<!--ro, opt, bool, whether the device supports RTMP configuration, desc:Related URI: /ISAPI/Streaming/channels/<ID>/RTMPCfg/capabilities-->true
</isSupportRTMP>
<isSupportTraffic>
<!--ro, opt, bool, traffic service capability-->true
</isSupportTraffic>
<isSupportLaserSpotAdjustment>
<!--ro, opt, bool, Related URI: /ISAPI/Image/channels/<ID>/laserLight/laserSpotAdjustment/capabilities, desc:Related URI:
/ISAPI/Image/channels/<ID>/laserLight/laserSpotAdjustment/capabilities-->true
</isSupportLaserSpotAdjustment>
<VideoIntercomCap>
<!--ro, opt, object, Related URI: /ISAPI/VideoIntercom/capabilities, desc:Related URI: /ISAPI/VideoIntercom/capabilities-->
<isSupportSceneManage>
<!--ro, opt, bool-->true
</isSupportSceneManage>
<isSupportDeviceId>
<!--ro, opt, bool, whether the device supports device ID-->true
</isSupportDeviceId>
<isSupportOperationTime>
<!--ro, opt, bool-->true
</isSupportOperationTime>
<isSupportCallerInfo>
<!--ro, opt, bool-->true
</isSupportCallerInfo>
<isSupportCallSignal>
<!--ro, opt, bool-->true
</isSupportCallSignal>
<isSupportCallStatus>
<!--ro, opt, bool-->true
</isSupportCallStatus>
<isSupportCallElevator>
<!--ro, req, bool-->true
</isSupportCallElevator>
<isSupportRelatedDeviceAdress>
<!--ro, opt, bool-->true
</isSupportRelatedDeviceAdress>
<isSupportCardSectorCheck>
<!--ro, req, bool-->true
</isSupportCardSectorCheck>
<isSupportKeyCfg>
<!--ro, opt, bool-->true
</isSupportKeyCfg>
<isSupportWorkModeCfg>
<!--ro, opt, bool-->true
</isSupportWorkModeCfg>
<isSupportSystemSwitchCfg>
<!--ro, opt, bool-->true
</isSupportSystemSwitchCfg>
<isSupportPrivilegePasswordStatus>
<!--ro, req, bool-->true
</isSupportPrivilegePasswordStatus>
<isSupportSmartHomeRoomsCfg>
<!--ro, opt, bool-->true
</isSupportSmartHomeRoomsCfg>
<isSupportSmartHomeDevices>
<!--ro, req, bool-->true
</isSupportSmartHomeDevices>
<isSupportScenesCfg>
<!--ro, opt, bool-->true
</isSupportScenesCfg>
<isSupportNameModify>
<!--ro, opt, bool-->true
</isSupportNameModify>
<isSupportElevatorControlCfg>
<!--ro, opt, bool-->true
</isSupportElevatorControlCfg>
<isSupportPrivilegePassword>
<!--ro, opt, bool-->true
</isSupportPrivilegePassword>


</isSupportPrivilegePassword>
<isSupportSubModules>
<!--ro, opt, bool-->true
</isSupportSubModules>
<isSupportIssueCards>
<!--ro, opt, bool-->true
</isSupportIssueCards>
<isSupportSendCardCfg>
<!--ro, opt, bool-->true
</isSupportSendCardCfg>
<isSupportRingBackTone>
<!--ro, opt, bool-->true
</isSupportRingBackTone>
<isSupportCallPriority>
<!--ro, opt, bool-->true
</isSupportCallPriority>
<isSupportPhoneCfg>
<!--ro, opt, bool-->true
</isSupportPhoneCfg>
<isSupportWatchPoint>
<!--ro, opt, bool-->true
</isSupportWatchPoint>
<isSupportVoiceConfiguration>
<!--ro, opt, bool-->true
</isSupportVoiceConfiguration>
<isSupportSubModulesCfg>
<!--ro, opt, bool-->true
</isSupportSubModulesCfg>
<isSupportDisplayRegion>
<!--ro, opt, bool-->true
</isSupportDisplayRegion>
<isSupportUpdateData>
<!--ro, opt, bool-->true
</isSupportUpdateData>
<isSupportUpdateStrategy>
<!--ro, opt, bool-->true
</isSupportUpdateStrategy>
<isSupportMetaInfo>
<!--ro, opt, bool-->true
</isSupportMetaInfo>
<isSupportStreamAbility>
<!--ro, opt, bool-->true
</isSupportStreamAbility>
<platform opt="R0,R1">
<!--ro, opt, enum, Platform Type, subType:string, attr:opt{req, string}, desc:Platform Type-->R0
</platform>
<isSupportSecurityMode>
<!--ro, opt, bool-->true
</isSupportSecurityMode>
<isSupportDeviceCommunication>
<!--ro, opt, bool-->true
</isSupportDeviceCommunication>
<isSupportAutoSync>
<!--ro, opt, bool-->true
</isSupportAutoSync>
<isSupportDifferentKeystrokes>
<!--ro, opt, bool-->true
</isSupportDifferentKeystrokes>
<isSupportKeyCfgWeekPlan>
<!--ro, opt, bool-->true
</isSupportKeyCfgWeekPlan>
<isSupportKeyCfgHolidayPlan>
<!--ro, opt, bool-->true
</isSupportKeyCfgHolidayPlan>
<isSupportKeyCfgHolidayGroup>
<!--ro, opt, bool-->true
</isSupportKeyCfgHolidayGroup>
<isSupportKeyCfgPlanTemplate>
<!--ro, opt, bool-->true
</isSupportKeyCfgPlanTemplate>
<isSupportCallCfg>
<!--ro, opt, bool-->true
</isSupportCallCfg>
<isSupportAccessParams>
<!--ro, opt, bool-->true
</isSupportAccessParams>
<isSupportTransmitRequestEventConfirm>
<!--ro, opt, bool-->true
</isSupportTransmitRequestEventConfirm>
<isSupportIncomingCallLinkage>
<!--ro, opt, bool-->true
</isSupportIncomingCallLinkage>
<isSupportAdbControl>
<!--ro, opt, bool-->true
</isSupportAdbControl>
<isSupportProtocolFileManage>
<!--ro, req, bool-->true
</isSupportProtocolFileManage>
<isSupportStreamSwitch>
<!--ro, req, bool-->true
</isSupportStreamSwitch>
<isSupportKeywordAudioRecognition>
<!--ro, req, bool-->true
</isSupportKeywordAudioRecognition>


<isSupportOneWaySpeaking>
<!--ro, opt, bool-->true
</isSupportOneWaySpeaking>
<isSupportPositionInfo>
<!--ro, req, bool-->true
</isSupportPositionInfo>
<isSupportElevatorControlDisplay>
<!--ro, req, bool-->true
</isSupportElevatorControlDisplay>
<isSupportRingManage>
<!--ro, req, bool-->true
</isSupportRingManage>
<isSupportPasswordAuthentication>
<!--ro, req, bool-->true
</isSupportPasswordAuthentication>
<isSupportAlarmControlByPhone>
<!--ro, req, bool-->true
</isSupportAlarmControlByPhone>
<isSupportZoneCfgByScene>
<!--ro, req, bool-->true
</isSupportZoneCfgByScene>
<isSupportAppKeyConfiguration>
<!--ro, req, bool-->true
</isSupportAppKeyConfiguration>
<isSupportIntercomProtocolChange>
<!--ro, req, bool-->true
</isSupportIntercomProtocolChange>
<isSupportGetAnnouncementMessage>
<!--ro, req, bool-->true
</isSupportGetAnnouncementMessage>
<isSupportGetDeployInfo>
<!--ro, req, bool-->true
</isSupportGetDeployInfo>
<detectorType opt="panicButton,magneticContact,smokeDetector,activeInfraredDetector,passiveInfraredDetector,combustibleGasDetector,doorbell">
<!--ro, opt, string, attr:opt{req, string}-->test
</detectorType>
<isSupportBroadcastRealtime>
<!--ro, opt, bool-->true
</isSupportBroadcastRealtime>
<isSupportOrganizationNodes>
<!--ro, opt, bool-->true
</isSupportOrganizationNodes>
<isSupportCallForwarding>
<!--ro, opt, bool-->true
</isSupportCallForwarding>
<isSupportAudioPlayStatus>
<!--ro, opt, bool-->true
</isSupportAudioPlayStatus>
<isSupportDeviceIdAnalysisRuleCfg>
<!--ro, opt, bool-->true
</isSupportDeviceIdAnalysisRuleCfg>
<isSupportOperationTimeByChannel>
<!--ro, opt, bool-->true
</isSupportOperationTimeByChannel>
<isSupportCallAuthorization>
<!--ro, opt, bool-->true
</isSupportCallAuthorization>
<isSupportRecordControl>
<!--ro, opt, bool-->true
</isSupportRecordControl>
<isSupportTrusteeship>
<!--ro, opt, bool-->true
</isSupportTrusteeship>
<isSupportAnalogIndoorStation>
<!--ro, opt, bool-->true
</isSupportAnalogIndoorStation>
<isSupportImportPartitions>
<!--ro, opt, bool-->true
</isSupportImportPartitions>
<isSupportBroadcastPlan>
<!--ro, opt, bool-->true
</isSupportBroadcastPlan>
<isSupportBroadcastPlanSearch>
<!--ro, opt, bool, desc:related URI:-->true
</isSupportBroadcastPlanSearch>
<isSupportBroadcastPlanPause>
<!--ro, opt, bool-->true
</isSupportBroadcastPlanPause>
<isSupportBroadcastPlanResume>
<!--ro, opt, bool-->true
</isSupportBroadcastPlanResume>
<isSupportBroadcastPlanTest>
<!--ro, opt, bool-->true
</isSupportBroadcastPlanTest>
<isSupportBroadcastPlanEx>
<!--ro, opt, bool-->true
</isSupportBroadcastPlanEx>
<isSupportBroadcastPlanExSearch>
<!--ro, opt, bool, desc:related URI:-->true
</isSupportBroadcastPlanExSearch>
<isSupportBroadcastPlanModify>
<!--ro, opt, bool-->true
</isSupportBroadcastPlanModify>
<isSupportBroadcastPlanDelete>


<isSupportBroadcastPlanDelete>
<!--ro, opt, bool-->true
</isSupportBroadcastPlanDelete>
<isSupportAudioInPlayCfg>
<!--ro, opt, bool-->true
</isSupportAudioInPlayCfg>
<isSupportSearchWardBedInfo>
<!--ro, opt, bool-->true
</isSupportSearchWardBedInfo>
<isSupportPatient>
<!--ro, opt, bool-->true
</isSupportPatient>
<isSupportPatientTagInfo>
<!--ro, opt, bool-->true
</isSupportPatientTagInfo>
<isSupportPatientMessage>
<!--ro, opt, bool-->true
</isSupportPatientMessage>
<isSupportPatientReport>
<!--ro, opt, bool-->true
</isSupportPatientReport>
<isSupportOperation>
<!--ro, opt, bool-->true
</isSupportOperation>
<isSupportPatientExpenses>
<!--ro, opt, bool-->true
</isSupportPatientExpenses>
<isSupportIntroduction>
<!--ro, opt, bool-->true
</isSupportIntroduction>
<isSupportMedicalUpdate>
<!--ro, opt, bool-->true
</isSupportMedicalUpdate>
</VideoIntercomCap>
<SecurityCPCapabilities>
<!--ro, opt, object, Related URI: /ISAPI/SecurityCP/capabilities?format=json, desc:Related URI: /ISAPI/SecurityCP/capabilities?format=json-->true
</SecurityCPCapabilities>
<isSupportSafetyCabin>
<!--ro, opt, bool, Related URI: /ISAPI/SafetyCabin/capabilities, desc:Related URI: /ISAPI/SafetyCabin/capabilities-->true
</isSupportSafetyCabin>
<isSupportAcsUpdate>
<!--ro, opt, bool, Related URI: /ISAPI/System/AcsUpdate/capabilities, desc:Related URI: /ISAPI/System/AcsUpdate/capabilities-->true
</isSupportAcsUpdate>
<isSupportSecurityCP>
<!--ro, opt, bool-->true
</isSupportSecurityCP>
<isSupportPEA>
<!--ro, opt, bool-->true
</isSupportPEA>
<isSupportCurrentLock>
<!--ro, opt, bool-->true
</isSupportCurrentLock>
<isSupportGuardAgainstTheft>
<!--ro, opt, bool, Related URI: /ISAPI/System/guardAgainstTheft/capabilities, desc:Related URI: /ISAPI/System/guardAgainstTheft/capabilities-->true
</isSupportGuardAgainstTheft>
<isSupportPicInfoOverlap>
<!--ro, opt, bool-->true
</isSupportPicInfoOverlap>
<isSupportPlay>
<!--ro, opt, bool-->true
</isSupportPlay>
<isSupportPlayback>
<!--ro, opt, bool-->true
</isSupportPlayback>
<UHFRFIDReader>
<!--ro, opt, object-->
<isSupportBasicInformation>
<!--ro, opt, bool-->true
</isSupportBasicInformation>
<isSupportHardDiskStorageTest>
<!--ro, opt, bool-->true
</isSupportHardDiskStorageTest>
<isSupportCarReaderConfig>
<!--ro, opt, bool, Related URI: /ISAPI/Traffic/UHFRFIDReader/carReaderConfig/capabilities?format=json, desc:Related URI:
/ISAPI/Traffic/UHFRFIDReader/carReaderConfig/capabilities?format=json-->true
</isSupportCarReaderConfig>
</UHFRFIDReader>
<isSupportIntelligentStructureAnalysis>
<!--ro, opt, bool, whether the device supports intelligent structuralization analysis, desc:Related URI:
/ISAPI/Intelligent/structureAnalysis/capabilities-->true
</isSupportIntelligentStructureAnalysis>
<isSupportIntelligentAnalysisEngines>
<!--ro, opt, bool, whether the device supports configuring the intelligent engine, desc:Related URI: /ISAPI/Intelligent/analysisEngines/capabilities-
>true
</isSupportIntelligentAnalysisEngines>
<PreviewDisplayNum>
<!--ro, opt, int-->1
</PreviewDisplayNum>
<isSupportBoard opt="true,false">
<!--ro, opt, bool, attr:opt{opt, string}-->true
</isSupportBoard>
<ResourceSwitch>
<!--ro, opt, object-->
<workMode opt="4KPreview,educationRecord">


<!--ro, req, string, attr:opt{opt, string}-->test
</workMode>
</ResourceSwitch>
<isSupportCustomStream>
<!--ro, opt, bool, whether the device supports custom stream, desc:Related URI: /ISAPI/Streaming/channels/<ID>/customStream/capabilities-->true
</isSupportCustomStream>
<isSupportTriggerCapCheck>
<!--ro, opt, bool-->true
</isSupportTriggerCapCheck>
<isSupportChannelEventCap>
<!--ro, opt, bool, whether the device supports getting the event capability by channel, desc:Related URI: /ISAPI/Event/channels/<ID>/capabilities-->true
</isSupportChannelEventCap>
<SensorCap>
<!--ro, opt, object, capability of configuring sensor parameters, desc:Related URI: /ISAPI/System/Sensor/capabilities-->
<SensorNums>
<!--ro, opt, int, the maximum number of sensors that can be added-->1
</SensorNums>
<isSupportSensorPortConfiguration>
<!--ro, opt, bool-->true
</isSupportSensorPortConfiguration>
<isSupportSensorPortControl>
<!--ro, opt, bool-->true
</isSupportSensorPortControl>
<isSupportAcquireSensorStatus>
<!--ro, opt, bool, whether the device supports getting the real-time status of the sensor-->true
</isSupportAcquireSensorStatus>
<isSupportSearchSensorData>
<!--ro, opt, bool, whether the device supports searching the sensor data-->true
</isSupportSearchSensorData>
</SensorCap>
<isSupportEncryption>
<!--ro, opt, bool, stream encryption capability-->true
</isSupportEncryption>
<isSupportTrial>
<!--ro, opt, bool-->true
</isSupportTrial>
<isSupportSignInstrument>
<!--ro, opt, bool-->true
</isSupportSignInstrument>
<isSupportLocate>
<!--ro, opt, bool-->true
</isSupportLocate>
<isSupportVibration>
<!--ro, opt, bool-->true
</isSupportVibration>
<isSupportMixedTargetDetection>
<!--ro, opt, bool, whether the device supports multi-target-type detection events-->true
</isSupportMixedTargetDetection>
<SDCardCtrlCap>
<!--ro, opt, object-->
<isSupportIOCtrl>
<!--ro, opt, bool-->true
</isSupportIOCtrl>
<isSupportReadCardStatus>
<!--ro, opt, bool-->true
</isSupportReadCardStatus>
<isSupportStartUpdate>
<!--ro, opt, bool-->true
</isSupportStartUpdate>
<isSupportEndUpdate>
<!--ro, opt, bool-->true
</isSupportEndUpdate>
<isSupportPowerCtrl>
<!--ro, opt, bool-->true
</isSupportPowerCtrl>
</SDCardCtrlCap>
<isSupportMutiChannelCalibration>
<!--ro, opt, bool-->true
</isSupportMutiChannelCalibration>
<isSupportElevatorFloorCalibration>
<!--ro, opt, bool-->true
</isSupportElevatorFloorCalibration>
<isSupportPictureCaptureComparision>
<!--ro, opt, bool-->true
</isSupportPictureCaptureComparision>
<isSupportGPSCalibratation>
<!--ro, opt, bool-->true
</isSupportGPSCalibratation>
<isSupportCityManagement>
<!--ro, opt, bool-->true
</isSupportCityManagement>
<isSupportBVCorrect>
<!--ro, opt, bool-->true
</isSupportBVCorrect>
<isSupportSteamingCodingModeSwitch>
<!--ro, opt, bool, Related URI: /ISAPI/System/streamingCoding/mode/capabilities?format=json, desc:Related URI:
/ISAPI/System/streamingCoding/mode/capabilities?format=json-->true
</isSupportSteamingCodingModeSwitch>
<supportImageChannel opt="1,2,3,4">
<!--ro, opt, string, whether the device supports the image channel configuration, attr:opt{req, string}, desc:whether the device supports the image
channel configuration-->test
</supportImageChannel>
<isSupportPanoramaCalibration>
<!--ro, opt, bool-->true


<!--ro, opt, bool-->true
</isSupportPanoramaCalibration>
<isSupportPanoramaMode>
<!--ro, opt, bool-->true
</isSupportPanoramaMode>
<supportSnapshotChannel opt="1">
<!--ro, opt, string, attr:opt{opt, string}-->test
</supportSnapshotChannel>
<isSupportPanoramaCorrections>
<!--ro, opt, bool-->true
</isSupportPanoramaCorrections>
<isSupportActiveMulticast>
<!--ro, opt, bool-->true
</isSupportActiveMulticast>
<isSupportChannelEventListCap>
<!--ro, opt, bool-->true
</isSupportChannelEventListCap>
<VCAResourceChannelsCap>
<!--ro, opt, object-->
<ChannelsList>
<!--ro, opt, array, subType:object-->
<channelsID>
<!--ro, req, int, No. of channels supported by the device-->1
</channelsID>
</ChannelsList>
</VCAResourceChannelsCap>
<isSupportTimerVCAResource>
<!--ro, opt, bool-->true
</isSupportTimerVCAResource>
<MixedTargetDetection>
<!--ro, opt, object-->
<isSupportFaceRecognition>
<!--ro, opt, bool, whether the device supports facial recognition-->true
</isSupportFaceRecognition>
<isSupportHumanRecognition>
<!--ro, opt, bool, whether the device supports human body recognition-->true
</isSupportHumanRecognition>
<isSupportVehicleRecognition>
<!--ro, opt, bool, whether the device supports vehicle recognition-->true
</isSupportVehicleRecognition>
</MixedTargetDetection>
<isSupportDiscoveryMode>
<!--ro, opt, bool, Related URI: /ISAPI/System/discoveryMode/capabilities, desc:Related URI: /ISAPI/System/discoveryMode/capabilities-->true
</isSupportDiscoveryMode>
<isSupportDumpData>
<!--ro, opt, bool, whether the device supports exporting the Dump file-->true
</isSupportDumpData>
<isSupportCameraAccessConfiguration>
<!--ro, opt, bool, whether the device supports the camera access configuration, desc:Related URI: /ISAPI/System/cameraAccess/configuration/capabilities?
format=json-->true
</isSupportCameraAccessConfiguration>
<isSupportIntelligentSearch>
<!--ro, opt, bool, whether the device supports intelligent search, desc:Related URI: /ISAPI/SDT/Management/IntelligentSearch/capabilities?format=json-
>true
</isSupportIntelligentSearch>
<isSupportAutoMaintenance>
<!--ro, opt, bool, whether the device supports automatic maintenance, desc:Related URI: /ISAPI/System/autoMaintenance/capabilities?format=json-->true
</isSupportAutoMaintenance>
<isSupportRtspOverHTTPS>
<!--ro, opt, bool-->true
</isSupportRtspOverHTTPS>
<isSupportIntersectionAnalysis>
<!--ro, opt, bool, whether the device supports the intersection analysis, desc:Related URI:
/ISAPI/Intelligent/channels/<ID>/intersectionAnalysis/capabilities?format=json-->true
</isSupportIntersectionAnalysis>
<isSupportAudioInteract>
<!--ro, opt, bool, Related URI: /ISAPI/Streaming/interact/capabilities?format=json, desc:Related URI: /ISAPI/Streaming/interact/capabilities?
format=json-->true
</isSupportAudioInteract>
<isSupportChannelFullEventListCap>
<!--ro, opt, bool-->true
</isSupportChannelFullEventListCap>
<isSupportAUXInfoCap>
<!--ro, opt, bool-->true
</isSupportAUXInfoCap>
<supportPanoramaChannel opt="2">
<!--ro, opt, string, attr:opt{opt, string}-->test
</supportPanoramaChannel>
<regionClip>
<!--ro, opt, object-->
<channels opt="101">
<!--ro, opt, string, attr:opt{opt, string}-->test
</channels>
</regionClip>
<AIDEventSupport
opt="abandonedObject,pedestrian,congestion,roadBlock,construction,trafficAccident,fogDetection,wrongDirection,illegalParking,SSharpDriving,lowSpeed,dragRaci
ng,obstacle,vehNoYieldPedest,illegalMannedVeh,illegalMannedNonMotorVeh,umbrellaTentInstall,nonMotorVehOnVehLane,wearingNoHelmet,pedestRedLightRunning,pedest
OnNonMotorVehLane,pedestOnVehLane,conflagration,smoke">
<!--ro, opt, string, attr:opt{opt, string}-->test
</AIDEventSupport>
<TFSEventSupport opt="illegalParking
,wrongDirection,crossLane,laneChange,vehicleExist,turnRound,parallelParking,notKeepDistance,notSlowZebraCrossing,overtakeRightSide,lowSpeed,dragRacing,chang
eLaneContinuously,SSharpDriving,largeVehicleOccupyLine,jamCrossLine,obstacle,blackSmokeVehicle,turnRightStop,occupyDedicatedLane,notDriveInDedicatedLane,TFS
_nonZipperMerge">


_nonZipperMerge">
<!--ro, opt, string, attr:opt{opt, string}-->test
</TFSEventSupport>
<isVehicleStatisticsSupport>
<!--ro, opt, bool, whether the device supports configuring parameters for traffic data collection-->true
</isVehicleStatisticsSupport>
<isSupportElevatorFloorName>
<!--ro, opt, bool-->true
</isSupportElevatorFloorName>
<isSupportVehicleFaceRecognition>
<!--ro, opt, bool-->true
</isSupportVehicleFaceRecognition>
<VQDEventSupport opt="luma,chroma,snow,streak,freeze,sigLose,clarity,jitter,block,flowers,noise,ghost,purple,ICR,protectiveFilm">
<!--ro, opt, string, VQD event list, attr:opt{opt, string}, desc:VQD event list-->test
</VQDEventSupport>
<IOTCap>
<!--ro, opt, object-->
<supportChannelNum opt="1">
<!--ro, opt, int, attr:opt{opt, string}-->1
</supportChannelNum>
<startChannelNo>
<!--ro, opt, int-->1
</startChannelNo>
<isSupportlinkageChannelsSearch>
<!--ro, opt, bool-->true
</isSupportlinkageChannelsSearch>
<isSupportIOTChannelCap>
<!--ro, opt, bool-->true
</isSupportIOTChannelCap>
<satusSearchTaskCap>
<!--ro, opt, object-->
<maxResults>
<!--ro, opt, int-->1
</maxResults>
<filterType opt="all,online,offline,updateFailed">
<!--ro, opt, enum, filtering type, subType:string, attr:opt{req, string}, desc:filtering type-->all
</filterType>
<deviceStatus opt="calling,noCall,medicationChangePrompt,alarming,offline,free">
<!--ro, opt, string, range:[0,32], attr:opt{req, string}-->calling
</deviceStatus>
<logicRelationship opt="and,or">
<!--ro, opt, string, range:[0,16], attr:opt{req, string}-->and
</logicRelationship>
<alarmType opt="SOS,toilet">
<!--ro, opt, string, range:[0,16], attr:opt{req, string}-->test
</alarmType>
<callWaitingType opt="normal,cisit">
<!--ro, opt, string, Alarm Type, attr:opt{req, string}, desc:Alarm Type-->test
</callWaitingType>
</satusSearchTaskCap>
<channelConfigList>
<!--ro, opt, object-->
<channelConfig>
<!--ro, opt, object-->
<unitType>
<!--ro, opt, enum, unit type, subType:string-->outdoor
</unitType>
<floorNumber min="0" max="10">
<!--ro, opt, int, floor number, attr:min{req, int},max{req, int}-->0
</floorNumber>
<roomNumber min="0" max="10">
<!--ro, opt, int, room number, attr:min{req, int},max{req, int}-->0
</roomNumber>
<isSupportSlaveDevice>
<!--ro, opt, bool, whether the device supports sub-devices-->true
</isSupportSlaveDevice>
<isSupportZeroFloorNumber>
<!--ro, opt, bool-->true
</isSupportZeroFloorNumber>
<periodNumber min="0" max="10">
<!--ro, opt, int, community number, attr:min{req, int},max{req, int}-->0
</periodNumber>
<buildingNumber min="0" max="10">
<!--ro, opt, int, building number, attr:min{req, int},max{req, int}-->0
</buildingNumber>
<unitNumber min="0" max="10">
<!--ro, opt, int, unit number, attr:min{req, int},max{req, int}-->0
</unitNumber>
<deviceIndex min="1" max="15">
<!--ro, opt, string, attr:min{req, int},max{req, int}-->test
</deviceIndex>
<industryType opt="builidings,prison,medicalTreatment,broadcasting,general">
<!--ro, opt, string, range:[0,32], attr:opt{req, string}-->test
</industryType>
<priority min="1" max="100">
<!--ro, opt, int, attr:min{req, int},max{req, int}-->0
</priority>
<transportType opt="unicast,multicast">
<!--ro, opt, string, unicast, multicast, attr:opt{req, string}, desc:unicast, multicast-->test
</transportType>
<audioVolume min="0" max="15">
<!--ro, opt, int, attr:min{req, int},max{req, int}-->0
</audioVolume>
<callForwardingEnabled>
<!--ro, opt, bool, true (enable), false (disable). The default value is false., desc:true (enable), false (disable). The default value is false.-


<!--ro, opt, bool, true (enable), false (disable). The default value is false., desc:true (enable), false (disable). The default value is false.-
>true
</callForwardingEnabled>
<callForwardingType opt="unconditional,busy,noReply,noReachable,calling">
<!--ro, opt, string, range:[0,32], attr:opt{req, string}-->test
</callForwardingType>
<isSupportCallTerminalNumbe>
<!--ro, opt, bool-->true
</isSupportCallTerminalNumbe>
<customCommunicationName min="0" max="128">
<!--ro, opt, string, range:[0,128], attr:min{req, int},max{req, int}-->test
</customCommunicationName>
<isSupportMoreFeatures>
<!--ro, opt, bool-->true
</isSupportMoreFeatures>
<isNotSupportRegPassword>
<!--ro, opt, bool-->true
</isNotSupportRegPassword>
<mappingRoomNumber min="0" max="5">
<!--ro, opt, int, attr:min{req, int},max{req, int}-->0
</mappingRoomNumber>
<IOTProtocolType opt="CodeMaster,GJD,HIKVISION,Luminite,OPTEX,SIA-CID,logisticsScanningGun,Adam,Arteco,ISUP,Ezviz">
<!--ro, opt, enum, IOT protocol type, subType:string, attr:opt{req, string}-->CodeMaster
</IOTProtocolType>
<deviceID min="0" max="64">
<!--ro, opt, string, attr:min{req, int},max{req, int}-->test
</deviceID>
<ISUPkey min="1" max="32">
<!--ro, opt, string, attr:min{req, int},max{req, int}-->test
</ISUPkey>
</channelConfig>
</channelConfigList>
<isSupportConfigTemplate>
<!--ro, opt, bool-->true
</isSupportConfigTemplate>
<isSupportConfigReport>
<!--ro, opt, bool-->true
</isSupportConfigReport>
<unitType opt="outdoor,indoor,manage,fence,terminal,netAudio">
<!--ro, opt, string, terminal, netAudio (network sound box), range:[0,32], attr:opt{req, string}, desc:terminal, netAudio (network sound box)-->test
</unitType>
<serialNumber min="1" max="32">
<!--ro, opt, string, range:[0,32], attr:min{req, int},max{req, int}-->test
</serialNumber>
<isSupportAsyncStatus>
<!--ro, opt, bool-->true
</isSupportAsyncStatus>
<isSupportAddIOTChannelList>
<!--ro, opt, bool-->true
</isSupportAddIOTChannelList>
<isSupportSearchMoreIOTSource>
<!--ro, opt, bool-->true
</isSupportSearchMoreIOTSource>
<channelConfigReportMode>
<!--ro, opt, enum, subType:string-->cover
</channelConfigReportMode>
</IOTCap>
<isSupportLCDScreen>
<!--ro, opt, bool-->true
</isSupportLCDScreen>
<isSupportBluetooth>
<!--ro, opt, bool, whether the device supports bluetooth, desc:Related URI: /ISAPI/System/Bluetooth/capabilities-->true
</isSupportBluetooth>
<isSupportNetScreen>
<!--ro, opt, bool, Related URI: /ISAPI/System/netScreens/capabilities?format=json, desc:Related URI: /ISAPI/System/netScreens/capabilities?format=json-
>true
</isSupportNetScreen>
<isSupportLocation>
<!--ro, opt, bool, whether the device supports getting the device location information, desc:Related URI: /ISAPI/System/location?format=json-->true
</isSupportLocation>
<isSupportDebugInfoExport>
<!--ro, opt, bool, whether the device supports exporting the debugging information, desc:Related URI: /ISAPI/System/debugInfoExport/capabilities?
format=json-->true
</isSupportDebugInfoExport>
<isSupportIoTGateway>
<!--ro, opt, bool, whether the device supports IoT gateway functions, desc:Related URI: /ISAPI/System/IoTGateway/capabilities?format=json-->true
</isSupportIoTGateway>
<isSupportImageCap>
<!--ro, opt, bool, whether the device supports configuring image parameters-->true
</isSupportImageCap>
<isSupportLogToUSB opt="true,false">
<!--ro, opt, bool, whether the device supports exporting logs via USB, attr:opt{opt, string}, desc:Related URI:
/ISAPI/System/exportLogToUSB/capabilities?format=json-->true
</isSupportLogToUSB>
<isSupportWiresharkToUSB opt="true,false">
<!--ro, opt, bool, attr:opt{opt, string}-->true
</isSupportWiresharkToUSB>
<CDBurningStreamEncryptionChannels opt="1,2">
<!--ro, opt, string, attr:opt{opt, string}-->true
</CDBurningStreamEncryptionChannels>
<isSupportOCR>
<!--ro, opt, bool, whether the device supports OCR detection, desc:Related URI: /ISAPI/Intelligent/channels/<ID>/OCR/capabilities?format=json-->true
</isSupportOCR>
<isSupportInstallationAngleCalibration>


<isSupportInstallationAngleCalibration>
<!--ro, opt, bool, Related URI: /ISAPI/System/installationAngleCalibration/channels/<ID>/capabilities, desc:Related URI:
/ISAPI/System/installationAngleCalibration/channels/<ID>/capabilities-->true
</isSupportInstallationAngleCalibration>
<isSupportZeroBiasCalibration>
<!--ro, opt, bool-->true
</isSupportZeroBiasCalibration>
<isSupportCalibrationFile>
<!--ro, opt, bool, whether the device importing the calibration file, desc:Related URI: /ISAPI/System/configurationData-->true
</isSupportCalibrationFile>
<isSupportDisplayTrajectory>
<!--ro, opt, bool-->true
</isSupportDisplayTrajectory>
<maximumSuperPositionTime opt="5,10,20,30">
<!--ro, opt, string, Trajectory Display Duration Limit, attr:opt{opt, string}-->true
</maximumSuperPositionTime>
<isSupportUnitConfig>
<!--ro, opt, bool, whether the device supports the unit configuration, desc:Related URI: /ISAPI/System/unitConfig/capabilities?format=json-->true
</isSupportUnitConfig>
<isSupportShipsDetectionWithScene>
<!--ro, opt, bool, whether the device supports ship detection by scene-->true
</isSupportShipsDetectionWithScene>
<isSupportPictureServer>
<!--ro, opt, bool, whether the device supports configuring the picture storage server, desc:Related URI: /ISAPI/System/PictureServer/capabilities?
format=json-->true
</isSupportPictureServer>
<isSupportEmmcInfo>
<!--ro, opt, bool-->true
</isSupportEmmcInfo>
<isSupportVehicleIllegalType opt="1,2...29">
<!--ro, opt, string, attr:opt{opt, string}-->test
</isSupportVehicleIllegalType>
<isSupportRFIDChannels>
<!--ro, opt, bool-->true
</isSupportRFIDChannels>
<isSupportRfidCollection>
<!--ro, opt, bool-->true
</isSupportRfidCollection>
<DevInfoSearch opt="tiltAngle">
<!--ro, opt, string, whether the device supports searching the device information, attr:opt{opt, string}, desc:Related URI:
/ISAPI/System/workingstatus/devInfoSearch?format=json-->test
</DevInfoSearch>
<isSupportAIOpenPlatform>
<!--ro, opt, bool, Related URI: /ISAPI/Intelligent/AIOpenPlatform/capabilities?format=json, desc:Related URI:
/ISAPI/Intelligent/AIOpenPlatform/capabilities?format=json-->true
</isSupportAIOpenPlatform>
<isSupportPictureDownloadError>
<!--ro, opt, bool, whether the device supports uploading the exception that downloading the picture failed, desc:eventType: pictureDownloadError-->true
</isSupportPictureDownloadError>
<isSupportStudentBehavior>
<!--ro, opt, bool, eventType: studentBehavior, desc:eventType: studentBehavior-->true
</isSupportStudentBehavior>
<guideEventSupport opt="linkageCapture">
<!--ro, opt, string, Related URI: /ISAPI/System/guideConfig/<guideEvent>/capabilities?format=json, attr:opt{opt, string}, desc:Related URI:
/ISAPI/System/guideConfig/<guideEvent>/capabilities?format=json-->test
</guideEventSupport>
<supportRemoteCtrl opt="up,down,left,right,enter,menu,num,power,esc,edit,F1,.prev,rec,play,stop,notSupport">
<!--ro, opt, string, Related URI: /ISAPI/System/remoteCtrl/XXX, attr:opt{opt, string}, desc:Related URI: /ISAPI/System/remoteCtrl/XXX-->test
</supportRemoteCtrl>
<isSupportSSDFileSystemUpgrade>
<!--ro, opt, bool-->true
</isSupportSSDFileSystemUpgrade>
<isSupportSSDFileSystemFormat>
<!--ro, opt, bool, whether the device supports formatting SSD, desc:Related URI: /ISAPI/System/SSDFileSystem/format?format=json-->true
</isSupportSSDFileSystemFormat>
<FaceCounting>
<!--ro, opt, object-->
<ChannelsList>
<!--ro, opt, array, subType:object-->
<channelsID>
<!--ro, req, int, No. of channels supported by the device-->1
</channelsID>
</ChannelsList>
</FaceCounting>
<isSupportCluster>
<!--ro, opt, bool, Related URI:, desc:/ISAPI/ContentMgmt/Cluster/capabilities-->true
</isSupportCluster>
<DeviceConfigurationSupport opt="time,network,accessProtocol,recordSchedule,channel,customProtocol">
<!--ro, opt, string, Related URI: /ISAPI/System/deviceConfiguration, attr:opt{opt, string}, desc:Related URI: /ISAPI/System/deviceConfiguration-->test
</DeviceConfigurationSupport>
<behaviorEventSupport opt="getUp,toiletTarry,playCellphone">
<!--ro, opt, string, behavior analysis event types, attr:opt{opt, string}-->test
</behaviorEventSupport>
<isSupportBVCorrectPassthrough>
<!--ro, opt, bool, Related URI: /ISAPI/System/BVCorrect/Passthrough/channels/<ID>/capabilities?format=json, desc:Related URI:
/ISAPI/System/BVCorrect/Passthrough/channels/<ID>/capabilities?format=json-->true
</isSupportBVCorrectPassthrough>
<VehiclePositionControl>
<!--ro, opt, object, whether the device supports vehicle position arming-->
<license min="0" max="16">
<!--ro, req, string, attr:min{opt, string},max{opt, string}-->test
</license>
<intervalTime min="0" max="65535" def="1">
<!--ro, req, int, uploading interval, unit:s, attr:min{opt, string},max{opt, string},def{opt, string}-->1


</intervalTime>
</VehiclePositionControl>
<supportGISEvent opt="AID,TPS,ANPR,mixedTargetDetection">
<!--ro, opt, string, attr:opt{opt, string}-->test
</supportGISEvent>
<isSupportGPSPTZCalibratation>
<!--ro, opt, bool, whether the device supports GPS PTZ calibration, desc:Related URI: /ISAPI/System/GPSPTZCalibratation/channels/<ID>/points?
format=json-->true
</isSupportGPSPTZCalibratation>
<isSupportRadar>
<!--ro, opt, bool, whether the device supports radar functions, desc:Related URI: /ISAPI/Radar/capabilities?format=json-->true
</isSupportRadar>
<isSupportISUPHttpPassthrough>
<!--ro, opt, bool-->true
</isSupportISUPHttpPassthrough>
<isSupportMaterialListQuery>
<!--ro, opt, bool-->true
</isSupportMaterialListQuery>
<isSupportDebugLogAsync>
<!--ro, opt, bool, whether the device supports exporting the debugging log asynchronously-->true
</isSupportDebugLogAsync>
<isSupportAlgorithmsInfo>
<!--ro, opt, bool, whether the device supports getting the algorithm version of the device-->true
</isSupportAlgorithmsInfo>
<isSupportSecurityChecking>
<!--ro, opt, bool-->true
</isSupportSecurityChecking>
<isSupportSecurityCheckException>
<!--ro, opt, bool-->true
</isSupportSecurityCheckException>
<isSupportPictureManage>
<!--ro, opt, bool, Related URI: /ISAPI/System/isSupportPictureManage/capabilities?format=json, desc:Related URI:
/ISAPI/System/isSupportPictureManage/capabilities?format=json-->true
</isSupportPictureManage>
<isSupportAutoSwitch>
<!--ro, opt, bool, Related URI: /ISAPI/System/autoSwitch/capabilities?format=json, desc:Related URI: /ISAPI/System/autoSwitch/capabilities?format=json-
>true
</isSupportAutoSwitch>
<SHMCap>
<!--ro, opt, object, SHM alarm-->
<isSupportHighHDTemperature>
<!--ro, opt, bool, whether the device supports HDD high temperature detection, desc:eventType: highHDTemperature-->true
</isSupportHighHDTemperature>
<isSupportLowHDTemperature>
<!--ro, opt, bool, whether the device supports HDD low temperature detection, desc:eventType: lowHDTemperature-->true
</isSupportLowHDTemperature>
<isSupportHDImpact>
<!--ro, opt, bool, whether the device supports HDD impact detection, desc:eventType: hdImpact-->true
</isSupportHDImpact>
<isSupportHDBadBlock>
<!--ro, opt, bool, whether the device supports HDD bad sector detection, desc:eventType: hdBadBlock-->true
</isSupportHDBadBlock>
<isSupportSevereHDFailure>
<!--ro, opt, bool, whether the device supports HDD major fault detection, desc:eventType: severeHDFailure-->true
</isSupportSevereHDFailure>
</SHMCap>
<isSupportLinkStatusEvent>
<!--ro, opt, bool, whether the device supports uploading the information about the network connection status of the device, desc:eventType: linkEvent-
>true
</isSupportLinkStatusEvent>
<isSupportVideoDealStatus>
<!--ro, opt, bool-->true
</isSupportVideoDealStatus>
<isSupportAudioDealStatus>
<!--ro, opt, bool-->true
</isSupportAudioDealStatus>
<isSupportNetPackLossStatus>
<!--ro, opt, bool-->true
</isSupportNetPackLossStatus>
<isSupportVideoConferenceStatus>
<!--ro, opt, bool-->true
</isSupportVideoConferenceStatus>
<isSupportDataPrealarm>
<!--ro, opt, bool-->true
</isSupportDataPrealarm>
<isSupportClearCache>
<!--ro, opt, bool, whether the device supports clearing the cache, desc:Related URI: /ISAPI/System/clearCache?format=json-->true
</isSupportClearCache>
<isSupportIntelligentMode>
<!--ro, opt, bool, whether the device supports switching the intelligent mode, desc:Related URI: /ISAPI/System/IntelligentMode?format=json-->true
</isSupportIntelligentMode>
<isSupportFaceTemperatureMeasurementEvent>
<!--ro, opt, bool, whether the device supports the skin-surface temperature measurement event, desc:eventType: FaceTemperatureMeasurementEvent-->true
</isSupportFaceTemperatureMeasurementEvent>
<isSupportQRCodeEvent>
<!--ro, opt, bool, whether the device supports the QR code event, desc:eventType: QRCodeEvent-->true
</isSupportQRCodeEvent>
<isSupportVisitorEvent>
<!--ro, opt, bool, whether the device supports the visitor event, desc:eventType: VisitorEvent-->true
</isSupportVisitorEvent>
<isSupportEmployeeAuthEvent>
<!--ro, opt, bool, whether the device supports the employee authorization event, desc:eventType: EmployeeAuthEvent-->true
</isSupportEmployeeAuthEvent>
<isSupportVisitorInfoSearchEvent>


<isSupportVisitorInfoSearchEvent>
<!--ro, opt, bool, whether the device supports the visitor information search event, desc:eventType: VisitorInfoSearchEvent-->true
</isSupportVisitorInfoSearchEvent>
<isSupportConsumptionEvent>
<!--ro, opt, bool, whether the device supports the transaction record event, desc:eventType: ConsumptionEvent-->true
</isSupportConsumptionEvent>
<isSupportTransactionRecordEvent>
<!--ro, opt, bool, whether the device supports the transaction record event, desc:eventType: TransactionRecordEvent-->true
</isSupportTransactionRecordEvent>
<isSupportFaceContrastResultDisplay>
<!--ro, opt, bool, whether the device supports displaying the face picture comparison result, desc:Related URI:
/ISAPI/Intelligent/faceContrast/resultDisplay/capabilities?format=json-->true
</isSupportFaceContrastResultDisplay>
<isSupportSnapshotAsync>
<!--ro, opt, bool, whether the device supports capturing pictures asynchronously (the picture URL will be returned), desc:Related URI:
/ISAPI/Streaming/channels/<ID>/picture/async?format=json-->true
</isSupportSnapshotAsync>
<isSupportLogExportByUSB>
<!--ro, opt, bool-->true
</isSupportLogExportByUSB>
<isSupportShellCmd>
<!--ro, opt, bool-->true
</isSupportShellCmd>
<faceMonitor opt="dailyFaceMonitor,dailyFaceTracking,VCAFaceMonitor,VCAFaceTracking,manualFaceMonitor,advanceConfiguration,">
<!--ro, opt, bool, whether the device supports face arming, attr:opt{opt, string}, desc:Related URI: /ISAPI/Intelligent/channels/<ID>/dailyFaceMonitor?
format=json-->true
</faceMonitor>
<isSupportRelatedVCAResource>
<!--ro, opt, bool-->true
</isSupportRelatedVCAResource>
<isSupportVehicleMonitor>
<!--ro, opt, bool, Related URI: /ISAPI/Traffic/channels/<ID>/vehicleMonitor/capabilities?format=json, desc:Related URI:
/ISAPI/Traffic/channels/<ID>/vehicleMonitor/capabilities?format=json-->true
</isSupportVehicleMonitor>
<isSupportManualVehicleMonitor>
<!--ro, opt, bool, whether the device supports arming and tracking vehicles, desc:Related URI:
/ISAPI/Traffic/channels/<ID>/vehicleMonitor/manual/capabilitis?format=json-->true
</isSupportManualVehicleMonitor>
<isSupportDailyVehicleMonitor>
<!--ro, opt, bool, Related URI: /ISAPI/Traffic/channels/<ID>/vehicleDetect/capabilities, desc:Related URI:
/ISAPI/Traffic/channels/<ID>/vehicleDetect/capabilities-->true
</isSupportDailyVehicleMonitor>
<isSupportInputProxyDeviceInfo>
<!--ro, opt, bool, Related URI:, desc:Related URI:-->true
</isSupportInputProxyDeviceInfo>
<isSupportAccessControlCap>
<!--ro, opt, bool, access control capability, desc:Related URI: /ISAPI/AccessControl/capabilities-->true
</isSupportAccessControlCap>
<isSupportDebugLog>
<!--ro, opt, bool, whether the device supports exporting the debugging log, desc:Related URI: /ISAPI/System/debugLog?format=json-->true
</isSupportDebugLog>
<isSupportFaceAppear>
<!--ro, opt, bool-->true
</isSupportFaceAppear>
<isSupportFaceDisappear>
<!--ro, opt, bool-->true
</isSupportFaceDisappear>
<isSupportTeacherBehavior>
<!--ro, opt, bool, whether the device supports the teacher behavior analysis event, desc:eventType: teacherBehavior-->true
</isSupportTeacherBehavior>
<isSupportHeadRiseRate>
<!--ro, opt, bool-->true
</isSupportHeadRiseRate>
<isSupportIPCUpgrade>
<!--ro, opt, bool, Related URI: /ISAPI/System/IPCUpgrade/<ID>?format=json, desc:Related URI: /ISAPI/System/IPCUpgrade/<ID>?format=json-->true
</isSupportIPCUpgrade>
<isSupportFaceLibRebuildEvent>
<!--ro, opt, bool-->true
</isSupportFaceLibRebuildEvent>
<isSupportCalibrationStream>
<!--ro, opt, bool-->true
</isSupportCalibrationStream>
<isSupportChannelOccupy>
<!--ro, opt, bool-->true
</isSupportChannelOccupy>
<isSupportOffDuty>
<!--ro, opt, bool-->true
</isSupportOffDuty>
<isSupportNoCertificate>
<!--ro, opt, bool-->true
</isSupportNoCertificate>
<isSupportSmokeAlarm>
<!--ro, opt, bool, whether the device supports the smoke alarm, desc:eventType: smokeAlarm-->true
</isSupportSmokeAlarm>
<isSupportBatteryCarDisobey>
<!--ro, opt, bool-->true
</isSupportBatteryCarDisobey>
<isSupportNoFireExtinguisherRecog>
<!--ro, opt, bool-->true
</isSupportNoFireExtinguisherRecog>
<isSupportIndoorPasswayBlock>
<!--ro, opt, bool-->true
</isSupportIndoorPasswayBlock>
<isSupportFireSmartFireDetect>


<!--ro, opt, bool, whether the device supports fire detection, desc:eventType: fireSmartFireDetect-->true
</isSupportFireSmartFireDetect>
<isSupportDetectorRunningStatus>
<!--ro, opt, bool, whether the device supports getting the detector running status, desc:eventType: detectorRunningStatus-->true
</isSupportDetectorRunningStatus>
<isSupportDetectorOperationStatus>
<!--ro, opt, bool, whether the device supports getting the detector operation status, desc:eventType: detectorOperationStatus-->true
</isSupportDetectorOperationStatus>
<isSupportDetectorTemperatureAlarm opt="highTemperature,riseTemperature,flame">
<!--ro, opt, bool, whether the device supports the detector temperature alarm, attr:opt{req, string}-->true
</isSupportDetectorTemperatureAlarm>
<isSupportDetectorShelterAlarm>
<!--ro, opt, bool-->true
</isSupportDetectorShelterAlarm>
<isSupportDetectorMotionAlarm>
<!--ro, opt, bool-->true
</isSupportDetectorMotionAlarm>
<isSupportDetectorTamperAlarm>
<!--ro, opt, bool-->true
</isSupportDetectorTamperAlarm>
<isSupportDetectorEmergencyAlarm>
<!--ro, opt, bool-->true
</isSupportDetectorEmergencyAlarm>
<isSupportDetectorSmokeAlarm>
<!--ro, opt, bool-->true
</isSupportDetectorSmokeAlarm>
<isSupportDetectorCombustibleGasAlarm>
<!--ro, opt, bool-->true
</isSupportDetectorCombustibleGasAlarm>
<isSupportFireControlData>
<!--ro, opt, bool-->true
</isSupportFireControlData>
<isSupportFireNoRegulation>
<!--ro, opt, bool-->true
</isSupportFireNoRegulation>
<isSupportSmokeFireRecognize>
<!--ro, opt, bool-->true
</isSupportSmokeFireRecognize>
<isSupportClientProxyWEB>
<!--ro, opt, bool-->true
</isSupportClientProxyWEB>
<WEBLocation>
<!--ro, opt, string, range:[1,32]-->local
</WEBLocation>
<isSupportWEBLocalPlug>
<!--ro, opt, bool-->true
</isSupportWEBLocalPlug>
<deviceId>
<!--ro, opt, string, range:[1,32]-->test
</deviceId>
<isSupportTimeZone>
<!--ro, opt, bool, whether the device supports configuring the DST (Daylight Saving Time), desc:Related URI: /ISAPI/System/time/timeZone-->true
</isSupportTimeZone>
<isSptHealthDetection>
<!--ro, opt, bool, whether the device supports health monitoring, desc:Related URI: /ISAPI/System/healthDetection-->true
</isSptHealthDetection>
<isSptDiagnosis>
<!--ro, opt, bool, whether the device supports diagnosis, desc:Related URI: /ISAPI/System/diagnosis-->true
</isSptDiagnosis>
<isSptSerialLogCfg>
<!--ro, opt, bool, whether the device supports configuring parameters of serial port log redirection, desc:Related URI: /ISAPI/System/serialLogCfg?
format=json-->true
</isSptSerialLogCfg>
<isSptFileExport>
<!--ro, opt, bool, whether the device supports exporting the device file, desc:Related URI: /ISAPI/System/fileExport?format=json-->true
</isSptFileExport>
<isSptCertificationStandard>
<!--ro, opt, bool-->true
</isSptCertificationStandard>
<isSptKeypadLock>
<!--ro, opt, bool, whether the device supports locking the keypad, desc:Related URI: /ISAPI/System/keypadLock/config-->true
</isSptKeypadLock>
<isSupportVibrationDetection>
<!--ro, opt, bool, whether the device supports the vibration detection, desc:Related URI: /ISAPI/System/channels/<ID>/vibrationDetection?format=json-
>true
</isSupportVibrationDetection>
<isSupportSmokingDetectAlarm>
<!--ro, opt, bool, whether the device supports the smoking alarm, desc:whether the device supports the smoking alarm-->true
</isSupportSmokingDetectAlarm>
<isSupportRadarChannels>
<!--ro, opt, bool, whether the device supports getting the radar channel, desc:Related URI: /ISAPI/System/RadarChannels?format=json-->true
</isSupportRadarChannels>
<radarIPDForm>
<!--ro, opt, enum, subType:string-->single
</radarIPDForm>
<isSupportRadarFieldDetection>
<!--ro, opt, bool, Related URI: /ISAPI/Smart/RadarChannels/<radarChannelID>/radarFieldDetection/capabilities?format=json, desc:Related URI:
/ISAPI/Smart/RadarChannels/<radarChannelID>/radarFieldDetection/capabilities?format=json-->true
</isSupportRadarFieldDetection>
<isSupportRadarLineDetection>
<!--ro, opt, bool, Related URI: /ISAPI/Smart/RadarChannels/<radarChannelID>/radarLineDetection/capabilities?format=json, desc:Related URI:
/ISAPI/Smart/RadarChannels/<radarChannelID>/radarLineDetection/capabilities?format=json-->true
</isSupportRadarLineDetection>
<mixedTargetDetectionWebNoDisplay>


<mixedTargetDetectionWebNoDisplay>
<!--ro, opt, bool-->true
</mixedTargetDetectionWebNoDisplay>
<isSupportRemovePlaybackRecord>
<!--ro, opt, bool-->true
</isSupportRemovePlaybackRecord>
<isSupportAudioUpload>
<!--ro, opt, bool, whether the device supports uploading the audio file, desc:Related URI: /ISAPI/System/Audio/audioUpload?format=json-->true
</isSupportAudioUpload>
<VCAResourceList>
<!--ro, opt, array, subType:object-->
<VCAResource>
<!--ro, opt, object-->
<VCAResourceType>
<!--ro, opt, string, VCA Resource Type-->test
</VCAResourceType>
<ChannleVCAResourceList>
<!--ro, opt, array, subType:object-->
<ChannleVCAResource>
<!--ro, opt, object-->
<channel>
<!--ro, opt, int-->1
</channel>
<channleVCAResourceType>
<!--ro, opt, string-->test
</channleVCAResourceType>
</ChannleVCAResource>
</ChannleVCAResourceList>
</VCAResource>
</VCAResourceList>
<isSupportSlotInsertion>
<!--ro, opt, bool-->true
</isSupportSlotInsertion>
<isSupportNetworkLoop>
<!--ro, opt, bool-->true
</isSupportNetworkLoop>
<isSupportApOnOffLine>
<!--ro, opt, bool-->true
</isSupportApOnOffLine>
<isSupportAbnormalWANPort>
<!--ro, opt, bool-->true
</isSupportAbnormalWANPort>
<isSupportAPException>
<!--ro, opt, bool-->true
</isSupportAPException>
<isSupportACException>
<!--ro, opt, bool-->true
</isSupportACException>
<isSupportCartridgeCapacity>
<!--ro, opt, bool-->true
</isSupportCartridgeCapacity>
<isSupportCDCakeBoxCapacity>
<!--ro, opt, bool-->true
</isSupportCDCakeBoxCapacity>
<isSupportSleep>
<!--ro, opt, bool, /ISAPI/System/sleep/capabilities?format=json, desc:/ISAPI/System/sleep/capabilities?format=json-->true
</isSupportSleep>
<isSupportContainerDetection>
<!--ro, opt, bool-->true
</isSupportContainerDetection>
<isSupportRadarVideoDetection>
<!--ro, opt, bool, Related URI: /ISAPI/Intelligent/channels/<ID>/radarVideoDetection/capabilities?format=json, desc:Related URI:
/ISAPI/Intelligent/channels/<ID>/radarVideoDetection/capabilities?format=json-->true
</isSupportRadarVideoDetection>
<isSupportRadarVideoDetectionRealtime>
<!--ro, opt, bool, Related URI: /ISAPI/Intelligent/channels/<ID>/radarVideoDetection/capabilities?format=json, desc:Related URI:
/ISAPI/Intelligent/channels/<ID>/radarVideoDetection/capabilities?format=json-->true
</isSupportRadarVideoDetectionRealtime>
<isSupportBatteryStatusUpload>
<!--ro, opt, bool, eventType: batteryStatus, desc:eventType: batteryStatus-->true
</isSupportBatteryStatusUpload>
<isSupportPowerConsumptionStatusUpload>
<!--ro, opt, bool-->true
</isSupportPowerConsumptionStatusUpload>
<isSupportOnlineUpgradeTask>
<!--ro, opt, bool-->true
</isSupportOnlineUpgradeTask>
<isSupportPersonArmingTrack>
<!--ro, opt, bool, Related URI: /ISAPI/Intelligent/channels/<ID>/personArmingTrack/capabilities?format=json, desc:Related URI:
/ISAPI/Intelligent/channels/<ID>/personArmingTrack/capabilities?format=json-->true
</isSupportPersonArmingTrack>
<isSupportManualPersonArmingTrack>
<!--ro, opt, bool, whether the device supports manual person arming, desc:Related URI: /ISAPI/Intelligent/channels/<ID>/manualPersonArmingTrack?
format=json-->true
</isSupportManualPersonArmingTrack>
<isSupportGPSVerification>
<!--ro, opt, bool, Related URI: /ISAPI/System/GPSVerification/channels/<ID>/points?format=json, desc:Related URI:
/ISAPI/System/GPSVerification/channels/<ID>/points?format=json-->true
</isSupportGPSVerification>
<isSupportHBDLib>
<!--ro, opt, bool, whether the device supports the human body library, desc:Related URI: /ISAPI/Intelligent/HBDLib/capabilities?format=json-->true
</isSupportHBDLib>
<isSupportDisinfectionInfo>
<!--ro, opt, bool-->true


<!--ro, opt, bool-->true
</isSupportDisinfectionInfo>
<isSupportTempQueryDelete>
<!--ro, opt, bool-->true
</isSupportTempQueryDelete>
<isSupportMobilePayment>
<!--ro, opt, bool-->true
</isSupportMobilePayment>
<isSupportFileSearch>
<!--ro, opt, bool, whether the device supports searching files, desc:Related URI: /ISAPI/System/fileSearch?format=json-->true
</isSupportFileSearch>
<isSupportFileExportAsync>
<!--ro, opt, bool, whether the device supports exporting files asynchronously, desc:Related URI: /ISAPI/System/fileExport/async?format=json-->true
</isSupportFileExportAsync>
<isSupportSSDFileSystemCapacity>
<!--ro, opt, bool, Related URI: /ISAPI/System/SSDFileSystem/capacity?format=json, desc:Related URI: /ISAPI/System/SSDFileSystem/capacity?format=json-
>true
</isSupportSSDFileSystemCapacity>
<isSupport4GSafetyHelmetInfo>
<!--ro, opt, bool, whether the device supports the hard hat event, desc:eventType: 4GSafetyHelmetInfo-->true
</isSupport4GSafetyHelmetInfo>
<isSupportICCID>
<!--ro, opt, bool, whether the device getting the ICCID information, desc:Related URI: /ISAPI/System/deviceInfo/ICCID?format=json-->true
</isSupportICCID>
<isSupportFireEscapeDetection>
<!--ro, opt, bool, Related URI: /ISAPI/Intelligent/channels/<ID>/fireEscapeDetection/capabilities?format=json, desc:Related URI:
/ISAPI/Intelligent/channels/<ID>/fireEscapeDetection/capabilities?format=json-->true
</isSupportFireEscapeDetection>
<isSupportTakingElevatorDetection>
<!--ro, opt, bool, Related URI: /ISAPI/Intelligent/channels/<ID>/takingElevatorDetection/capabilities?format=json, desc:Related URI:
/ISAPI/Intelligent/channels/<ID>/takingElevatorDetection/capabilities?format=json-->true
</isSupportTakingElevatorDetection>
<isSupportVehicleMatchResult>
<!--ro, opt, bool, whether the device supports license plate comparison, desc:Related URI:
/ISAPI/Intelligent/channels/<ID>/licensePlateContrast/capabilities?format=json-->true
</isSupportVehicleMatchResult>
<isSupportDataAware>
<!--ro, opt, bool, Related URI: /ISAPI/System/dataAware/capabilities?format=json, desc:Related URI: /ISAPI/System/dataAware/capabilities?format=json-
>true
</isSupportDataAware>
<isSupportAbnormalReboot>
<!--ro, opt, bool-->true
</isSupportAbnormalReboot>
<isSupportVehicleThermometry>
<!--ro, opt, bool, Related URI: /ISAPI/Traffic/channels/<ID>/vehicleDetect/thermometry/capabilities?format=json, desc:Related URI:
/ISAPI/Traffic/channels/<ID>/vehicleDetect/thermometry/capabilities?format=json-->true
</isSupportVehicleThermometry>
<AssociationScenesList>
<!--ro, opt, array, subType:object-->
<AssociationScenes>
<!--ro, req, object-->
<channelID>
<!--ro, req, int-->1
</channelID>
<isSupportScene>
<!--ro, opt, bool, whether the device supports the scene configuration, desc:whether the device supports the scene configuration-->true
</isSupportScene>
</AssociationScenes>
</AssociationScenesList>
<supportRelationVideoEvent opt="PIR,cityManagement,roadMaint">
<!--ro, opt, string, attr:opt{req, string}-->test
</supportRelationVideoEvent>
<isSupportVCAResourceList>
<!--ro, opt, bool, whether the device supports configuring intelligent resources in a batch, desc:Related URI:
/ISAPI/System/Video/inputs/channels/VCAResourceList?format=json-->true
</isSupportVCAResourceList>
<isSupportConvergenceCloud>
<!--ro, opt, bool-->true
</isSupportConvergenceCloud>
<isSupportInterconnection>
<!--ro, opt, bool-->true
</isSupportInterconnection>
<isSupportHPVehicleStatus>
<!--ro, opt, bool-->true
</isSupportHPVehicleStatus>
<isSupportHPWorkingStatus>
<!--ro, opt, bool-->true
</isSupportHPWorkingStatus>
<isSupportHPPeopleDetection>
<!--ro, opt, bool-->true
</isSupportHPPeopleDetection>
<isSupportHPVehicleDoorDetection>
<!--ro, opt, bool-->true
</isSupportHPVehicleDoorDetection>
<isSupportRoadMaint>
<!--ro, opt, bool-->true
</isSupportRoadMaint>
<isSupportDockStationInfo>
<!--ro, opt, bool-->true
</isSupportDockStationInfo>
<isSupportBodyCameraManualForensics>
<!--ro, opt, bool-->true
</isSupportBodyCameraManualForensics>
<isSupportBodyCameraLogin>
<!--ro, opt, bool-->true


<!--ro, opt, bool-->true
</isSupportBodyCameraLogin>
<isSupportBodyCameraRunStatus>
<!--ro, opt, bool-->true
</isSupportBodyCameraRunStatus>
<isSupportBodyCameraSignIn>
<!--ro, opt, bool-->true
</isSupportBodyCameraSignIn>
<isSupportAlertDistribution>
<!--ro, opt, bool-->true
</isSupportAlertDistribution>
<isSupportImageCapture>
<!--ro, opt, bool-->true
</isSupportImageCapture>
<isSupportScheduledRecordUpload>
<!--ro, opt, bool-->true
</isSupportScheduledRecordUpload>
<isSupportTargetPatternCollect>
<!--ro, opt, bool-->true
</isSupportTargetPatternCollect>
<isSupportAudioAnalysis>
<!--ro, opt, bool, whether the device supports the audio analysis event, desc:eventType: audioAnalysis. If this event is not supported, this node will
not be returned.-->true
</isSupportAudioAnalysis>
<isSupportDebuggingDataExport>
<!--ro, opt, bool-->true
</isSupportDebuggingDataExport>
<isSupportInternalParaAdjust>
<!--ro, opt, bool-->true
</isSupportInternalParaAdjust>
<isSupportManualImageCapture>
<!--ro, opt, bool-->true
</isSupportManualImageCapture>
<characteristicCode min="1" max="128">
<!--ro, opt, string, device attribute code, range:[1,128], attr:min{opt, string},max{opt, string}, desc:Related URI:
/ISAPI/System/deviceInfo/characteristicCode?format=json-->test
</characteristicCode>
<isSupportSIMCardStatus>
<!--ro, opt, bool, whether the device supports getting the SIM card status information, desc:Related URI: /ISAPI/System/SIMCardStatus?format=json-->true
</isSupportSIMCardStatus>
<OpenPlatformCap>
<!--ro, opt, object, detailed HEOP capability supported by the device-->
<isSupportOpenPlatform>
<!--ro, req, bool, whether the device supports Embedded Open Platform-->true
</isSupportOpenPlatform>
<maxAPPNum>
<!--ro, req, int-->0
</maxAPPNum>
</OpenPlatformCap>
<isSupportLogException>
<!--ro, opt, bool, whether the device supports the log exception alarm, desc:eventType: logException-->true
</isSupportLogException>
<isSupportReID>
<!--ro, opt, bool, whether the device supports ReID, desc:Related URI: /ISAPI/Intelligent/channels/<ID>/ReID?format=json-->true
</isSupportReID>
<isSupportMEF>
<!--ro, opt, bool, Related URI: /ISAPI/System/Network/MEF/<ID>?format=json, desc:Related URI: /ISAPI/System/Network/MEF/<ID>?format=json-->true
</isSupportMEF>
<manualEvent opt="fielddetection,linedetection,ANPR,faceCapture,mixedTargetDetection,studentsStoodUp,headRiseRate,teacherBehavior">
<!--ro, opt, string, Related URI: /ISAPI/Intelligent/channels/<ID>/manualEvent/<eventType>?format=json, attr:opt{req, string}, desc:Related URI:
/ISAPI/Intelligent/channels/<ID>/manualEvent/<eventType>?format=json-->test
</manualEvent>
<isSupportAppCfg>
<!--ro, opt, bool, whether the device supports application management, desc:/ISAPI/System/app/capabilities?format=json-->true
</isSupportAppCfg>
<isSupportCleanUp>
<!--ro, opt, bool, /ISAPI/System/cleanup?format=json, desc:/ISAPI/System/cleanup?format=json-->true
</isSupportCleanUp>
<isSupportEndUserCheckMsg opt="sleep,reboot,factoryReset,cleanup,parentPickUpQuery,schoolAttendanceQuery,screenShare,screenMirror">
<!--ro, opt, bool, eventType: endUserCheckMsg, attr:opt{req, string}, desc:eventType: endUserCheckMsg-->true
</isSupportEndUserCheckMsg>
<isSupportScreenConfig>
<!--ro, opt, bool, whether the device supports configuring screen parameters, desc:/ISAPI/System/screenConfig/capabilities?format=json-->true
</isSupportScreenConfig>
<isSupportTemperatureMonitor>
<!--ro, opt, bool, /ISAPI/System/temperatureMonitor/capabilities?format=json, desc:/ISAPI/System/temperatureMonitor/capabilities?format=json-->true
</isSupportTemperatureMonitor>
<isSupportObjectServer>
<!--ro, opt, bool, whether the device supports the object storage service, desc:/ISAPI/System/objectServer/capabilities?format=json-->true
</isSupportObjectServer>
<isSupportCDsStatus>
<!--ro, opt, bool-->true
</isSupportCDsStatus>
<isSupportCoalGangueDetection>
<!--ro, opt, bool-->true
</isSupportCoalGangueDetection>
<isSupportVacantSeatRate>
<!--ro, opt, bool-->true
</isSupportVacantSeatRate>
<isSupportObjectsThrownDetection>
<!--ro, opt, bool-->true
</isSupportObjectsThrownDetection>
<isSupportBVCorrectDataSearch>
<!--ro, opt, bool-->true


<!--ro, opt, bool-->true
</isSupportBVCorrectDataSearch>
<isSupportSlagTruckWashingDetection>
<!--ro, opt, bool, eventType: slagTruckWashingDetection, desc:eventType: slagTruckWashingDetection-->true
</isSupportSlagTruckWashingDetection>
<isSupportWOL>
<!--ro, opt, bool-->true
</isSupportWOL>
<isSupportPersonQueueTimingStatistics>
<!--ro, opt, bool, eventType: isSupportPersonQueueTimingStatistics, desc:eventType: isSupportPersonQueueTimingStatistics-->true
</isSupportPersonQueueTimingStatistics>
<isSupportLensParamFile>
<!--ro, opt, bool-->true
</isSupportLensParamFile>
<isSupportVehiclePassingInParkingLot>
<!--ro, opt, bool, eventType: vehiclePassingInParkingLot, desc:eventType: vehiclePassingInParkingLot-->true
</isSupportVehiclePassingInParkingLot>
<isSupportPowerOutput>
<!--ro, opt, bool-->true
</isSupportPowerOutput>
<isSupportIPCUpgradeByFTP>
<!--ro, opt, bool, Related URI: /ISAPI/System/IPCUpgrade/<channelID>/FTP?format=json&security=<security>&iv=<iv>, desc:Related URI:
/ISAPI/System/IPCUpgrade/<channelID>/FTP?format=json&security=<security>&iv=<iv>-->true
</isSupportIPCUpgradeByFTP>
<isSupportMethaneConcentrationException>
<!--ro, opt, bool, eventType: methaneConcentrationException, desc:eventType: methaneConcentrationException-->true
</isSupportMethaneConcentrationException>
<isSupportMethaneLightIntensityException>
<!--ro, opt, bool, eventType: methaneLightIntensityException, desc:eventType: methaneLightIntensityException-->true
</isSupportMethaneLightIntensityException>
<isSupportLocalButtonPermission>
<!--ro, opt, bool, Related URI: /ISAPI/System/localButtonPermission/capabilities?format=json, desc:Related URI:
/ISAPI/System/localButtonPermission/capabilities?format=json-->true
</isSupportLocalButtonPermission>
<isSupportLocalButtonRecord>
<!--ro, opt, bool-->true
</isSupportLocalButtonRecord>
<isSupportLocalButtonSnapshot>
<!--ro, opt, bool-->true
</isSupportLocalButtonSnapshot>
<isSupportVoiceTalkEvent>
<!--ro, opt, bool-->true
</isSupportVoiceTalkEvent>
<isSupportPowerSupply>
<!--ro, opt, bool, Related URI: /ISAPI/System/powerSupply/capabilities?format=json, desc:Related URI: /ISAPI/System/powerSupply/capabilities?
format=json-->true
</isSupportPowerSupply>
<isSupportbarrierGateStatus>
<!--ro, opt, bool, eventType: barrierGateStatus, desc:eventType: barrierGateStatus-->true
</isSupportbarrierGateStatus>
<DeployCap>
<!--ro, opt, object-->
<deployID opt="1,2">
<!--ro, opt, enum, subType:int, attr:opt{req, string}-->0
</deployID>
</DeployCap>
<isSupportSignalControllerStatus>
<!--ro, opt, bool-->true
</isSupportSignalControllerStatus>
<isSupportSignalControllerFault>
<!--ro, opt, bool-->true
</isSupportSignalControllerFault>
<isSupportNTPConfig>
<!--ro, opt, bool, whether the device supports configuring NTP parameters, desc:/ISAPI/System/time/ntp/capabilities?format=json-->true
</isSupportNTPConfig>
<isSupportConsumptionQuery>
<!--ro, opt, bool-->true
</isSupportConsumptionQuery>
<StreamingCodingRegionPositionCap>
<!--ro, opt, object, /ISAPI/System/streamingCoding/channels/<channelID>/regionPosition,
desc:/ISAPI/System/streamingCoding/channels/<channelID>/regionPosition-->
<ChannelsList>
<!--ro, opt, array, subType:object-->
<channelsID>
<!--ro, req, int, No. of channels supported by the device-->1
</channelsID>
</ChannelsList>
</StreamingCodingRegionPositionCap>
<isSupportLowPowerPlan>
<!--ro, opt, bool, Related URI: /ISAPI/System/consumptionMode/lowPowerPlan/capablities?format=json, desc:Related URI:
/ISAPI/System/consumptionMode/lowPowerPlan/capablities?format=json-->true
</isSupportLowPowerPlan>
<isSupportPlateQuaAlarm>
<!--ro, opt, bool-->true
</isSupportPlateQuaAlarm>
<isSupportWiegand>
<!--ro, opt, bool, whether the device supports the Wiegand protocol, desc:Related URI: /ISAPI/System/Wiegand/<wiegandID>/capabilities?format=json-->true
</isSupportWiegand>
<zoomFocusWebDisplay opt="ROI,roadTrafficDetection,SMD,mixedTargetDetection,faceCapture">
<!--ro, opt, string, attr:opt{req, string}-->ROI
</zoomFocusWebDisplay>
<isSupportInternalParamsAdjustment>
<!--ro, opt, bool, true (support), false or this node is not returned (not support) Related URI:
/ISAPI/System/internalParameters/regionAdjustment/capabilities?format=json, desc:true (support), false or this node is not returned (not support) Related


URI: /ISAPI/System/internalParameters/regionAdjustment/capabilities?format=json-->true
</isSupportInternalParamsAdjustment>
<isSupportDiagnosticReport>
<!--ro, opt, bool, true (support), false or this node is not returned (not support) Related URI: /ISAPI/System/diagnosticReport/capabilities?
format=json, desc:true (support), false or this node is not returned (not support) Related URI: /ISAPI/System/diagnosticReport/capabilities?format=json-
>true
</isSupportDiagnosticReport>
<isSupportWaterQualitySearch>
<!--ro, opt, bool, true (support), false or this node is not returned (not support) Related URI: /ISAPI/Event/waterQualityDetection/search?format=json,
desc:true (support), false or this node is not returned (not support) Related URI: /ISAPI/Event/waterQualityDetection/search?format=json-->true
</isSupportWaterQualitySearch>
<isSupportExhaustDetection>
<!--ro, opt, bool, true (support), false or this node is not returned (not support) Related URI:
/ISAPI/Event/exhaustDetection/channels/<channelID>/capabilities?format=json, desc:true (support), false or this node is not returned (not support) Related
URI: /ISAPI/Event/exhaustDetection/channels/<channelID>/capabilities?format=json-->true
</isSupportExhaustDetection>
<isSupportTPMSecretKey>
<!--ro, opt, bool, true (support), false or this node is not returned (not support) Related URI: /ISAPI/Streaming/encryption/TPMSecretKeyList?
format=json&security=<security>&iv=<iv>, desc:true (support), false or this node is not returned (not support) Related URI:
/ISAPI/Streaming/encryption/TPMSecretKeyList?format=json&security=<security>&iv=<iv>-->true
</isSupportTPMSecretKey>
<isSupportWeatherStation>
<!--ro, opt, bool-->true
</isSupportWeatherStation>
<isSupportRoadVisibilityAnalysis>
<!--ro, opt, bool-->true
</isSupportRoadVisibilityAnalysis>
<isSupportRoadWeatherAnalysis>
<!--ro, opt, bool-->true
</isSupportRoadWeatherAnalysis>
<isSupportRoadVisibilityAbnormal>
<!--ro, opt, bool-->true
</isSupportRoadVisibilityAbnormal>
<isSupportRoadWeatherAbnormal>
<!--ro, opt, bool-->true
</isSupportRoadWeatherAbnormal>
<isSupportChannelsTimeSync>
<!--ro, opt, bool, Related URI: /ISAPI/System/time/channelsTimeSync/capabilities?format=json, desc:Related URI:
/ISAPI/System/time/channelsTimeSync/capabilities?format=json-->true
</isSupportChannelsTimeSync>
<isSupport433Sensor>
<!--ro, opt, bool, Related URI:
/ISAPI/System/Sensor/433sensor/433wirelessTransfer/capabilities?format=json, /ISAPI/System/Sensor/433sensor/capabilities?format=json,
/ISAPI/System/Sensor/433sensor/sensorDetection/capabilities?format=json, /ISAPI/System/Sensor/433sensor/sensorPicOverlay/capabilities?format=json, and
/ISAPI/System/Sensor/433sensor/rfParamTemplate/capabilities?format=json,
desc:Related URI:
/ISAPI/System/Sensor/433sensor/433wirelessTransfer/capabilities?format=json, /ISAPI/System/Sensor/433sensor/capabilities?format=json,
/ISAPI/System/Sensor/433sensor/sensorDetection/capabilities?format=json, /ISAPI/System/Sensor/433sensor/sensorPicOverlay/capabilities?format=json, and
/ISAPI/System/Sensor/433sensor/rfParamTemplate/capabilities?format=json-->true
</isSupport433Sensor>
<isSupportSignalSource>
<!--ro, opt, bool, whether the device supports configuring signal source parameters, desc:/ISAPI/System/signalSource/capabilities?format=json-->true
</isSupportSignalSource>
<isSupportUSBConfig>
<!--ro, opt, bool, whether the device supports configuring USB parameters, desc:/ISAPI/System/USBConfig/capabilities?format=json-->true
</isSupportUSBConfig>
<isSupportStandbyStrategy>
<!--ro, opt, bool, whether the device supports configuring standby strategy parameters, desc:/ISAPI/System/standbyStrategy/capabilities?format=json-
>true
</isSupportStandbyStrategy>
<isSupportWakeupStrategy>
<!--ro, opt, bool, whether the device supports configuring wakeup strategy parameters, desc:/ISAPI/System/wakeupStrategy/capabilities?format=json-->true
</isSupportWakeupStrategy>
<isSupportSeachMutexFunction>
<!--ro, opt, bool-->true
</isSupportSeachMutexFunction>
<isSupportMultiDeviceID>
<!--ro, opt, bool-->true
</isSupportMultiDeviceID>
<isNotSupportMultiDeviceIDCustomName>
<!--ro, opt, bool-->true
</isNotSupportMultiDeviceIDCustomName>
<isSupportMixedSecurityChecking>
<!--ro, opt, bool-->true
</isSupportMixedSecurityChecking>
<isSupportVisiblePackageEvent>
<!--ro, opt, bool-->true
</isSupportVisiblePackageEvent>
<isSupportBarCodeEvent>
<!--ro, opt, bool-->true
</isSupportBarCodeEvent>
<isSupportGaugeReading>
<!--ro, opt, bool-->true
</isSupportGaugeReading>
<isSupportUncertificateCompareEvent>
<!--ro, opt, bool-->true
</isSupportUncertificateCompareEvent>
<isSupportAudioDiacritical>
<!--ro, opt, bool-->true
</isSupportAudioDiacritical>
<isSupportMEFReportSearch>
<!--ro, opt, bool-->true
</isSupportMEFReportSearch>
<isSupportBroadcastTriggerEvent>


<isSupportBroadcastTriggerEvent>
<!--ro, opt, bool, /ISAPI/VideoIntercom/broadcastTriggerConfirm?format=json, desc:/ISAPI/VideoIntercom/broadcastTriggerConfirm?format=json-->true
</isSupportBroadcastTriggerEvent>
<isSupportFishingShipDetection>
<!--ro, opt, bool, /ISAPI/Thermal/channels/<channelID>/fishingShipDetection/<SID>?format=json,
desc:/ISAPI/Thermal/channels/<channelID>/fishingShipDetection/<SID>?format=json-->true
</isSupportFishingShipDetection>
<isSupportHPVehicleLoadingRate>
<!--ro, opt, bool, /ISAPI/Intelligent/channels/<channelID>/HPDetection/capabilities?format=json,
desc:/ISAPI/Intelligent/channels/<channelID>/HPDetection/capabilities?format=json-->true
</isSupportHPVehicleLoadingRate>
<isSupportVideoBarrierGateDetection>
<!--ro, opt, bool, /ISAPI/Traffic/ContentMgmt/videoBarrierGate/capabilities?format=json, desc:/ISAPI/Traffic/ContentMgmt/videoBarrierGate/capabilities?
format=json-->true
</isSupportVideoBarrierGateDetection>
<isSupportLogicalResource>
<!--ro, opt, bool, /ISAPI/System/LogicalResource/capabilities?format=json, desc:/ISAPI/System/LogicalResource/capabilities?format=json-->true
</isSupportLogicalResource>
<isSupportSlagTruckCoverPlate>
<!--ro, opt, bool, /ISAPI/Event/channels/<channelID>/slagTruckCoverPlate/capabilities?format=json,
desc:/ISAPI/Event/channels/<channelID>/slagTruckCoverPlate/capabilities?format=json-->true
</isSupportSlagTruckCoverPlate>
<isSupportTrainDetection>
<!--ro, opt, bool, whether the device supports train detection, desc:If train detection is not supported, this node will not be returned. Related event:
eventType: trainDetection.-->true
</isSupportTrainDetection>
<isNotSupportVideoOverlays>
<!--ro, opt, bool-->true
</isNotSupportVideoOverlays>
<isSupportScheduledCaptureTask>
<!--ro, opt, bool, whether the device supports scheduled capturing tasks, desc:Related URI: /ISAPI/Sytem/Video/scheduledCapture/capabilities-->true
</isSupportScheduledCaptureTask>
<isSupportGuideCfg>
<!--ro, opt, bool, whether the device supports the wizard configuration, desc:whether the device supports the wizard configuration-->true
</isSupportGuideCfg>
<isSupportCameraGroupPeopleCounting>
<!--ro, opt, bool, /ISAPI/Intelligent/counting/cameraGroup/capabilities?format=json, desc:/ISAPI/Intelligent/counting/cameraGroup/capabilities?
format=json-->true
</isSupportCameraGroupPeopleCounting>
<isSupportAngleDeviationDetection>
<!--ro, opt, bool-->true
</isSupportAngleDeviationDetection>
<isSupportCityCode>
<!--ro, opt, bool-->true
</isSupportCityCode>
<isSupportAlcoholDetectionResult>
<!--ro, opt, bool-->true
</isSupportAlcoholDetectionResult>
<isSupportAlcoholDetectionRodBind>
<!--ro, opt, bool-->true
</isSupportAlcoholDetectionRodBind>
<isSupportAlcoholDetectionRodBindQuery>
<!--ro, opt, bool-->true
</isSupportAlcoholDetectionRodBindQuery>
<isSupportAlcoholDetectionRodUnbind>
<!--ro, opt, bool-->true
</isSupportAlcoholDetectionRodUnbind>
<isSupportAbnormalDriving>
<!--ro, opt, bool-->true
</isSupportAbnormalDriving>
<isSupportEmanationsEvent>
<!--ro, opt, bool-->true
</isSupportEmanationsEvent>
<isSupportClientUpdatePackage>
<!--ro, opt, bool-->true
</isSupportClientUpdatePackage>
<isSupportDeviceStatusUploadStrategy>
<!--ro, opt, bool-->true
</isSupportDeviceStatusUploadStrategy>
<isSupportDialIndicatorReading>
<!--ro, opt, bool-->true
</isSupportDialIndicatorReading>
<isNotSupportAudioVideoCompress>
<!--ro, opt, bool-->true
</isNotSupportAudioVideoCompress>
<isSupportUPLCExceptionEvent>
<!--ro, opt, bool, whether the device supports the event of liquid chromatograph system exception, desc:eventType: UPLCException-->true
</isSupportUPLCExceptionEvent>
<isSupportUrgentTurn>
<!--ro, opt, bool, whether the device supports the sharp turn event, desc:eventType: urgentTurn-->true
</isSupportUrgentTurn>
<isSupportUrgentBrake>
<!--ro, opt, bool, whether the device supports the sudden brake event, desc:eventType: urgentBrake-->true
</isSupportUrgentBrake>
<isSupportUrgentAcceleration>
<!--ro, opt, bool, whether the device supports the rapid acceleration event, desc:eventType: urgentAcceleration-->true
</isSupportUrgentAcceleration>
<isSupportVehiclePanicButton>
<!--ro, opt, bool, whether the device supports the alarm/event of mobile emergency button, desc:eventType: vehiclePanicButton-->true
</isSupportVehiclePanicButton>
<isSupportOverSpeed>
<!--ro, opt, bool, whether the device supports the vehicle speeding alarm/event, desc:eventType: overSpeed-->true
</isSupportOverSpeed>
<isSupportAbnormalAcceleration>


<!--ro, opt, bool, eventType: abnormalAcceleration, desc:eventType: abnormalAcceleration-->true
</isSupportAbnormalAcceleration>
<isSupportRollover>
<!--ro, opt, bool, whether the device supports the vehicle turnover alarm/event, desc:eventType: rollover-->true
</isSupportRollover>
<isSupportCollision>
<!--ro, opt, bool, whether the device supports the vehicle collision alarm/event, desc:eventType: collision-->true
</isSupportCollision>
<isSupportVehicleOBUInfo>
<!--ro, opt, bool, whether the device supports uploading the vehicle OBU information, desc:eventType: vehicleOBUInfo-->true
</isSupportVehicleOBUInfo>
<isSupportPowerUpPicture>
<!--ro, opt, bool, whether the device supports importing and exporting pictures displayed during startup,
desc:/ISAPI/System/powerUpPicture/capabilities?format=json-->true
</isSupportPowerUpPicture>
<isSupportPowerUpPictureCfg>
<!--ro, opt, bool, whether the device supports configuring parameters of pictures displayed during startup,
desc:/ISAPI/System/powerUpPictureCfg/capabilities?format=json-->true
</isSupportPowerUpPictureCfg>
<isSupportAlgoPackageScheduling>
<!--ro, opt, bool, whether the device supports algorithm package scheduling, desc:Related URIs: /ISAPI/System/AlgoPackageScheduling/capabilities?
format=json and /ISAPI/System/AlgoPackageScheduling/task/capabilities?format=json-->true
</isSupportAlgoPackageScheduling>
<isSupportVoiceTalkRequestingAlarm>
<!--ro, opt, bool, whether the device supports the two-way audio request alarm, desc:eventType: voiceTalkRequestingAlarm-->true
</isSupportVoiceTalkRequestingAlarm>
<isSupportSetupStructure>
<!--ro, opt, bool, whether the device supports configuring construction structure parameters, desc:/ISAPI/System/setupStructure?format=json-->true
</isSupportSetupStructure>
<isSupportPassNumInfoEvent>
<!--ro, opt, bool, whether the device supports uploading the number of people passed, desc:eventType: passNumInfoEvent-->true
</isSupportPassNumInfoEvent>
<isShowClientRemote>
<!--ro, opt, bool, whether the device supports displaying remote configuration on the client,
desc:1. If this node is not returned or it is returned and its value is true, it indicates that the device supports this function.
2. If this node is returned and its value is false, it indicates that the device does not support this function.
iVMS-4200 client software supports remote configuration by default. However, there are still some devices that do not support remote configuration via iVMS4200
and they can only be configured remotely via the web browser. The capability determined by this node is used to control whether to display the remote
configuration on iVMS-4200 client software.-->true
</isShowClientRemote>
<isSupportUserManualQRCode>
<!--ro, opt, bool, whether the device supports getting the QR code of the user manual, desc:/ISAPI/System/userManualQRCode/capabilities?format=json-
>true
</isSupportUserManualQRCode>
<isSupportUnclosedFrontPanel>
<!--ro, opt, bool, whether the device supports uploading the event of the front panel not closed, desc:Related URI: /ISAPI/Trial/roompara/capabilities中
unclosedFrontPanelEnabled. Related event: unclosedFrontPanel-->true
</isSupportUnclosedFrontPanel>
<isSupportVehicleWeight>
<!--ro, opt, bool, whether the device supports configuring parameters for vehicle weight and axle detection,
desc:/ISAPI/Traffic/channels/<channelID>/vehicleWeight?format=json-->true
</isSupportVehicleWeight>
<isSupportSecurityPanicEvent>
<!--ro, opt, bool, whether the device supports emergency events of security inspection, desc:eventType: securityPanicEvent-->true
</isSupportSecurityPanicEvent>
<isSupportTrafficLightMalfunction>
<!--ro, opt, bool, whether the device supports the event of detecting faults of traffic lights, desc:eventType: trafficLightMalfunction-->true
</isSupportTrafficLightMalfunction>
<isSupportTOFShelterAlarm>
<!--ro, opt, bool, whether the device supports TOF tampering alarm, desc:/ISAPI/Event/channels/<channelID>/TOFShelterAlarm/capabilities?format=json-
>true
</isSupportTOFShelterAlarm>
<isSupportSetMealQuery>
<!--ro, opt, bool, whether the device supports uploading the event of searching set meals, desc:eventType: SetMealQuery-->true
</isSupportSetMealQuery>
<isSupportMultiScreenControlAlarm>
<!--ro, opt, bool, whether the device supports uploading the multi-screen controller alarm, desc:eventType: multiScreenControlAlarm-->true
</isSupportMultiScreenControlAlarm>
<isSupportKeyFrameLoss>
<!--ro, opt, bool, whether the device supports uploading the event of key frame loss, desc:Related URI: /ISAPI/Event/keyFrameLoss/capabilities?
format=json. Related event: eventType: keyFrameLoss.-->true
</isSupportKeyFrameLoss>
<isSupportWorkStatusCfg>
<!--ro, opt, bool, whether the device supports working status configuration, desc:/ISAPI/System/WorkStatusCfg?format=json-->true
</isSupportWorkStatusCfg>
<isSupportHealthInfoSyncQuery>
<!--ro, opt, bool, whether the device supports the event of searching the health information, desc:HealthInfoSyncQuery-->true
</isSupportHealthInfoSyncQuery>
<isSupportVisitorPictureSearchEvent>
<!--ro, opt, bool, whether the device supports the event of searching profiles of visitors, desc:VisitorPictureSearchEvent-->true
</isSupportVisitorPictureSearchEvent>
<isSupportEZVIZParameterTest>
<!--ro, opt, bool, whether the device supports testing EZ parameters, desc:whether the device supports testing EZVIZ parameters-->true
</isSupportEZVIZParameterTest>
<isSupportUnattendedPackageEvent>
<!--ro, opt, bool-->true
</isSupportUnattendedPackageEvent>
<isSupportPackageFragmentEvent>
<!--ro, opt, bool, whether the device supports the event of uploading package fragment data, desc:packageFragmentEvent-->true
</isSupportPackageFragmentEvent>
<isSupportPackageBarcodeMismatchEvent>
<!--ro, opt, bool-->true
</isSupportPackageBarcodeMismatchEvent>
<isSupportCheckingModeSwitchEvent>


<isSupportCheckingModeSwitchEvent>
<!--ro, opt, bool, whether the device supports the event of switching the image checking mode, desc:checkingModeSwitchEvent-->true
</isSupportCheckingModeSwitchEvent>
<FaceSnapPrivacyMask>
<!--ro, opt, object, whether the device supports privacy mask on faces, desc:Based on face picture comparison, all faces will be masked to prorect the
privacy. Related URI: /ISAPI/Intelligent/channels/<channelID>/faceSnap/privacyMask/capabilities?format=json-->
<ChannelsList>
<!--ro, opt, array, subType:object-->
<channelsID>
<!--ro, req, int, No. of channels supported by the device-->1
</channelsID>
</ChannelsList>
</FaceSnapPrivacyMask>
<FaceContrastPrivacyMask>
<!--ro, opt, object, whether the device supports privacy mask on faces of key persons, desc:Based on face picture comparison, the faces of key persons
will be masked to protect the privacy. Related URI: /ISAPI/Intelligent/channels/<channelID>/faceContrast/privacyMask/capabilities?format=json-->
<ChannelsList>
<!--ro, opt, array, subType:object-->
<channelsID>
<!--ro, req, int, No. of channels supported by the device-->1
</channelsID>
</ChannelsList>
</FaceContrastPrivacyMask>
<isSupportHumanBodyComparison>
<!--ro, opt, bool, whether the device supports human body comparison events, desc:Related Node: eventType:humanBodyComparison. Related URI:
/ISAPI/Event/channels/<channelID>/humanBodyComparison/capabilities?format=json-->true
</isSupportHumanBodyComparison>
<isSupportMedicalInfoSearchEvent>
<!--ro, opt, bool, whether the device supports the event of searching the medical information, desc:medicalInfoSearchEvent-->true
</isSupportMedicalInfoSearchEvent>
<isSupportConsumptionStatusQuery>
<!--ro, opt, bool, whether the device supports uploading the request for searching the consumption status, desc:eventType:ConsumptionStatusQuery-->true
</isSupportConsumptionStatusQuery>
<isSupportShipChannelAbnormal>
<!--ro, opt, bool-->true
</isSupportShipChannelAbnormal>
<isSupportDepositRetrieveEvent>
<!--ro, opt, bool-->true
</isSupportDepositRetrieveEvent>
<isSupportDepositTimeoutEvent>
<!--ro, opt, bool-->true
</isSupportDepositTimeoutEvent>
<isSupportCabinetStatusEvent>
<!--ro, opt, bool-->true
</isSupportCabinetStatusEvent>
<isSupportCabinetAuthorityExpired>
<!--ro, opt, bool-->true
</isSupportCabinetAuthorityExpired>
<isSupportT1Test>
<!--ro, opt, bool-->true
</isSupportT1Test>
<isSupportDrivingDirectionAtIntersection>
<!--ro, opt, bool-->true
</isSupportDrivingDirectionAtIntersection>
<isSupportPlaceSceneExecuteStatus>
<!--ro, opt, bool-->true
</isSupportPlaceSceneExecuteStatus>
<isSupportSceneRecordingCtrl>
<!--ro, opt, bool-->true
</isSupportSceneRecordingCtrl>
<isSupportStreamRecordStatus>
<!--ro, opt, bool-->true
</isSupportStreamRecordStatus>
<isSupportManualSnapPicture>
<!--ro, opt, bool-->true
</isSupportManualSnapPicture>
<isSupportVerificationResultEvent>
<!--ro, opt, bool-->true
</isSupportVerificationResultEvent>
<OTAP>
<!--ro, opt, object-->
<isSupportOTAPModel>
<!--ro, opt, bool-->true
</isSupportOTAPModel>
</OTAP>
<isSupportForeignObjectInRoadDetection>
<!--ro, opt, bool-->true
</isSupportForeignObjectInRoadDetection>
<isSupportUPLCMethodOperatingStatus>
<!--ro, opt, bool-->true
</isSupportUPLCMethodOperatingStatus>
<isSupportMaterialScanTaskStatus>
<!--ro, opt, bool-->true
</isSupportMaterialScanTaskStatus>
<isSupportSearchInputProxy>
<!--ro, opt, bool-->true
</isSupportSearchInputProxy>
<isSupportPostureDetection>
<!--ro, opt, bool-->true
</isSupportPostureDetection>
<isSupportFans>
<!--ro, opt, bool-->true
</isSupportFans>
<pickUpCalibration>


<pickUpCalibration>
<!--ro, opt, object-->
<ChannelsList>
<!--ro, opt, array, subType:object-->
<channelsID>
<!--ro, req, int, No. of channels supported by the device-->1
</channelsID>
</ChannelsList>
</pickUpCalibration>
<isSupportSerialLogUpload>
<!--ro, opt, bool-->true
</isSupportSerialLogUpload>
<isSupportLiquidDetectionEvent>
<!--ro, opt, bool-->true
</isSupportLiquidDetectionEvent>
<isSupportETCRSU>
<!--ro, opt, bool-->true
</isSupportETCRSU>
<isSupportVideoCodeConvertTool>
<!--ro, opt, bool-->true
</isSupportVideoCodeConvertTool>
<supportQuickConfigType opt="icr,dayNightGate,syncSignalOutput">
<!--ro, opt, string, attr:opt{opt, string}-->syncSignalOutput
</supportQuickConfigType>
<isSupportVisualLocation>
<!--ro, opt, bool-->true
</isSupportVisualLocation>
<isSupportVideoAccessAbnormal>
<!--ro, opt, bool-->true
</isSupportVideoAccessAbnormal>
<isSupportSubSystemAbnormal>
<!--ro, opt, bool-->true
</isSupportSubSystemAbnormal>
<isSupportSearchFileList>
<!--ro, opt, bool-->true
</isSupportSearchFileList>
<isSupportDistanceDetectionEvent>
<!--ro, opt, bool-->true
</isSupportDistanceDetectionEvent>
<isSupportMeetingQueryEvent>
<!--ro, opt, bool-->true
</isSupportMeetingQueryEvent>
<isSupportMeetingLockEvent>
<!--ro, opt, bool-->true
</isSupportMeetingLockEvent>
<isSupportMeetingAddEvent>
<!--ro, opt, bool-->true
</isSupportMeetingAddEvent>
<isSupportMeetingModifyEvent>
<!--ro, opt, bool-->true
</isSupportMeetingModifyEvent>
<isSupportMeetingCancelEvent>
<!--ro, opt, bool-->true
</isSupportMeetingCancelEvent>
<isSupportMeetingElementQueryEvent>
<!--ro, opt, bool-->true
</isSupportMeetingElementQueryEvent>
<isSupportScreenBindIPCEvent>
<!--ro, opt, bool-->true
</isSupportScreenBindIPCEvent>
<isSupportSensorDetection>
<!--ro, opt, bool-->true
</isSupportSensorDetection>
<isSupportClearLogCache>
<!--ro, opt, bool-->true
</isSupportClearLogCache>
<isSupportRoadOccupyDetection>
<!--ro, opt, bool-->true
</isSupportRoadOccupyDetection>
<isSupportMeetingRoomSignInEvent>
<!--ro, opt, bool-->true
</isSupportMeetingRoomSignInEvent>
<isSupportMeetingRoomSignOutEvent>
<!--ro, opt, bool-->true
</isSupportMeetingRoomSignOutEvent>
<isSupportTimeTypeSTD>
<!--ro, opt, bool-->true
</isSupportTimeTypeSTD>
<isSupportScanner>
<!--ro, opt, bool-->true
</isSupportScanner>
<isSupportRegionTargetNumberCounting>
<!--ro, opt, bool-->true
</isSupportRegionTargetNumberCounting>
<depthMapMaintainMode>
<!--ro, opt, object-->
<ChannelsList>
<!--ro, opt, array, subType:object-->
<channelID>
<!--ro, req, int, No. of channels supported by the device-->1
</channelID>
</ChannelsList>
</depthMapMaintainMode>
<isSupportExportPipCalibrationFile>
<!--ro, opt, bool-->true


<!--ro, opt, bool-->true
</isSupportExportPipCalibrationFile>
<isSupportCourseUploadInfo>
<!--ro, opt, bool-->true
</isSupportCourseUploadInfo>
<isSupportPresetSwitchingInformation>
<!--ro, opt, bool-->true
</isSupportPresetSwitchingInformation>
<isSupportCabinetChargingQuery>
<!--ro, opt, bool-->true
</isSupportCabinetChargingQuery>
<isSupportSearchVoltageAndPowerConsumptionReport>
<!--ro, opt, bool-->true
</isSupportSearchVoltageAndPowerConsumptionReport>
<isSupportDeviceDrop>
<!--ro, opt, bool-->true
</isSupportDeviceDrop>
<isSupportDeviceNotMoved>
<!--ro, opt, bool-->true
</isSupportDeviceNotMoved>
<isSupportWalkWrongWayOnEscalator>
<!--ro, opt, bool-->true
</isSupportWalkWrongWayOnEscalator>
<isSupportFallOnEscalator>
<!--ro, opt, bool-->true
</isSupportFallOnEscalator>
<isSupportCarryLargeLuggageOnEscalator>
<!--ro, opt, bool-->true
</isSupportCarryLargeLuggageOnEscalator>
<isSupportPushStrollerOnEscalator>
<!--ro, opt, bool-->true
</isSupportPushStrollerOnEscalator>
<isSupportTeachingSpeechDetection>
<!--ro, opt, bool-->true
</isSupportTeachingSpeechDetection>
<updatefirmwareType opt="warningScreenFirmware,warningScreenFont,warningScreenVoice">
<!--ro, opt, string, RS-485 working modes supported by the device, attr:opt{opt, string}-->warningScreenFirmware
</updatefirmwareType>
<isSupportPaymentQRCodeQuery>
<!--ro, opt, bool-->true
</isSupportPaymentQRCodeQuery>
<isSupportTopUpEvent>
<!--ro, opt, bool-->true
</isSupportTopUpEvent>
<isSupportTopUpRequest>
<!--ro, opt, bool-->true
</isSupportTopUpRequest>
<isSupportTopUpStatusQuery>
<!--ro, opt, bool-->true
</isSupportTopUpStatusQuery>
<isSupportLogOffRefundRequest>
<!--ro, opt, bool-->true
</isSupportLogOffRefundRequest>
<isSupportLogOffRefundStatusQuery>
<!--ro, opt, bool-->true
</isSupportLogOffRefundStatusQuery>
<isSupportAuthenticationTimeoutEvent>
<!--ro, opt, bool-->true
</isSupportAuthenticationTimeoutEvent>
<isSupportCertificateCapture>
<!--ro, opt, bool-->true
</isSupportCertificateCapture>
<isSupportDeviceBatchActivation>
<!--ro, opt, bool-->true
</isSupportDeviceBatchActivation>
<isSupportPlaceEnvironmentMonitoringRule>
<!--ro, opt, bool-->true
</isSupportPlaceEnvironmentMonitoringRule>
<isSupportEngineResource>
<!--ro, opt, bool-->true
</isSupportEngineResource>
<isSupportPTModulePowerCfg>
<!--ro, opt, bool-->true
</isSupportPTModulePowerCfg>
<isSupportGetBoxDoorDetectionCfg>
<!--ro, opt, bool-->true
</isSupportGetBoxDoorDetectionCfg>
<isSupportModifyBoxDoorDetectionCfg>
<!--ro, opt, bool-->true
</isSupportModifyBoxDoorDetectionCfg>
<isSupportSmartBoxStatus>
<!--ro, opt, bool-->true
</isSupportSmartBoxStatus>
<isSupportBatteryStatusCtrl>
<!--ro, opt, bool-->true
</isSupportBatteryStatusCtrl>
<isSupportCooler>
<!--ro, opt, bool-->true
</isSupportCooler>
<isSupportBoxDoorDetectionCfg>
<!--ro, opt, bool-->true
</isSupportBoxDoorDetectionCfg>
<isSupportBoxDoorStatus>
<!--ro, opt, bool-->true


<!--ro, opt, bool-->true
</isSupportBoxDoorStatus>
<isSupportLightningProtectionStatus>
<!--ro, opt, bool-->true
</isSupportLightningProtectionStatus>
<isSupportDeviceVisualLocalizationDetectionEvent>
<!--ro, opt, bool-->true
</isSupportDeviceVisualLocalizationDetectionEvent>
<isSupportDeviceVisualLocalizationAnalysisEvent>
<!--ro, opt, bool-->true
</isSupportDeviceVisualLocalizationAnalysisEvent>
<isSupportGetPowerPortWorkParamList>
<!--ro, opt, bool-->true
</isSupportGetPowerPortWorkParamList>
<isSupportUsersLoginNotification>
<!--ro, opt, bool-->true
</isSupportUsersLoginNotification>
<isSupportLiquidLevelDetectorInfo>
<!--ro, opt, bool-->true
</isSupportLiquidLevelDetectorInfo>
<isSupportWaterPressureDetectorInfo>
<!--ro, opt, bool-->true
</isSupportWaterPressureDetectorInfo>
<isSupportEncryptionFileUpgradeMgr>
<!--ro, opt, bool-->true
</isSupportEncryptionFileUpgradeMgr>
<isSupportInformedConsentTextParam>
<!--ro, opt, bool-->true
</isSupportInformedConsentTextParam>
<isSupportSendConsolePassword>
<!--ro, opt, bool-->true
</isSupportSendConsolePassword>
<isSupportAutoLaserRanging>
<!--ro, opt, bool-->true
</isSupportAutoLaserRanging>
<isSupportDelayedReboot>
<!--ro, opt, bool-->true
</isSupportDelayedReboot>
<isSupportFalseAlarmMaterialLibMgr>
<!--ro, opt, bool-->true
</isSupportFalseAlarmMaterialLibMgr>
<isSupportGetServerRandom>
<!--ro, opt, bool-->true
</isSupportGetServerRandom>
<isSupportSendTelnetTestCmd>
<!--ro, opt, bool-->true
</isSupportSendTelnetTestCmd>
<isSupportTelnetTestCmdStatus>
<!--ro, opt, bool-->true
</isSupportTelnetTestCmdStatus>
<isSupportImportUSBKeyAuthInfo>
<!--ro, opt, bool-->true
</isSupportImportUSBKeyAuthInfo>
<isSupportSendSupervisionRecordCollection>
<!--ro, opt, bool-->true
</isSupportSendSupervisionRecordCollection>
<isSupportStopPersonnelOperationGuidance>
<!--ro, opt, bool-->true
</isSupportStopPersonnelOperationGuidance>
<isSupportRequestPersonnelOperationGuidance>
<!--ro, opt, bool-->true
</isSupportRequestPersonnelOperationGuidance>
<isSupportSearchPersonnelOperationSupervisionTask>
<!--ro, opt, bool-->true
</isSupportSearchPersonnelOperationSupervisionTask>
<isSupportDeletePersonnelOperationSupervisionTask>
<!--ro, opt, bool-->true
</isSupportDeletePersonnelOperationSupervisionTask>
<isSupportAddPersonnelOperationSupervisionTask>
<!--ro, opt, bool-->true
</isSupportAddPersonnelOperationSupervisionTask>
<isSupportStopPersonnelOperationHelp>
<!--ro, opt, bool-->true
</isSupportStopPersonnelOperationHelp>
<isSupportRequestPersonnelOperationHelp>
<!--ro, opt, bool-->true
</isSupportRequestPersonnelOperationHelp>
<isSupportUserLoginStatusChangeEvent>
<!--ro, opt, bool-->true
</isSupportUserLoginStatusChangeEvent>
<isSupportObstacleAvoidance>
<!--ro, opt, bool-->true
</isSupportObstacleAvoidance>
</DeviceCap>
21.5.11 Import the configuration files securely
Request URL
PUT /ISAPI/System/configurationData?security=<security>&iv=<iv>&secretkey=<secretkey>


Query Parameter
Parameter Name Parameter Type Description
security
string
iv
secretkey
string
string
Request Message
None
Response Message
<?xml version="1.0" encoding="UTF-8"?>
<ResponseStatus xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--ro, req, object, response message, attr:version{ro, req, string, protocolVersion}-->
<requestURL>
<!--ro, req, string, request URL-->null
</requestURL>
<statusCode>
<!--ro, req, enum, status code, subType:int, desc:0 (OK), 1 (OK), 2 (Device Busy), 3 (Device Error), 4 (Invalid Operation), 5 (Invalid XML Format), 6
(Invalid XML Content), 7 (Reboot Required)-->0
</statusCode>
<statusString>
<!--ro, req, enum, status description, subType:string, desc:"OK" (succeeded), "Device Busy", "Device Error", "Invalid Operation", "Invalid XML Format",
"Invalid XML Content", "Reboot" (reboot device)-->OK
</statusString>
<subStatusCode>
<!--ro, req, string, sub status code, desc:error reason description in detail-->OK
</subStatusCode>
</ResponseStatus>
-
-
-
21.6 Accessing via Protocol
21.6.1 Get device protocol capability
Request URL
GET /ISAPI/Security/adminAccesses/capabilities
Query Parameter
None
Request Message
None
Response Message


<?xml version="1.0" encoding="UTF-8"?>
<AdminAccessProtocolList xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--ro, req, array, subType:object, attr:version{req, string, protocolVersion}-->
<AdminAccessProtocol>
<!--ro, req, object-->
<id>
<!--ro, req, string, ID-->test
</id>
<enabled opt="true,false">
<!--ro, opt, bool, whether to enable the function, attr:opt{req, string}-->true
</enabled>
<protocol opt="HTTP,HTTPS,SDK,RTSP,DEV_MANAGE,WebSocket,WebSocketS,SDK_OVER_TLS,MATRIX_GATEWAY,IOT,GB35114,104Proto,SRTP,ModbusTCP">
<!--ro, req, string, HTTPS, attr:opt{req, string}-->GB35114
</protocol>
<redirectToHttps opt="true,false">
<!--ro, opt, bool, attr:opt{req, string}-->true
</redirectToHttps>
<streamOverTls opt="true,false">
<!--ro, opt, bool, this node is valid when the protocol type is "SDK_OVER_TLS", attr:opt{req, string}-->true
</streamOverTls>
<portNo min="1" max="65535" default="8443">
<!--ro, req, int, range:[1,65535], attr:min{req, int},max{req, int},default{opt, int}-->1
</portNo>
<TLS1_1Enable opt="true,false">
<!--ro, opt, bool, attr:opt{req, string}-->true
</TLS1_1Enable>
<TLS1_2Enable opt="true,false">
<!--ro, opt, bool, attr:opt{req, string}-->true
</TLS1_2Enable>
<TLS1_3Enable opt="true,false">
<!--ro, opt, bool, attr:opt{req, string}-->true
</TLS1_3Enable>
<TLS1_1SecurityPrompt opt="Only when the video output mode is Panorama, the device supports the VCA functions except Monitoring">
<!--ro, opt, string, attr:opt{req, string}-->Only when the video output mode is Panorama, the device supports the VCA functions except Monitoring
</TLS1_1SecurityPrompt>
<connectTime min="1" max="999" def="10">
<!--ro, opt, int, range:[1,999], step:1, unit:min, attr:min{req, int},max{req, int},def{req, int}-->10
</connectTime>
</AdminAccessProtocol>
</AdminAccessProtocolList>
21.6.2 Get the security parameters of a single access protocol
Request URL
GET /ISAPI/Security/adminAccesses/<indexID>
Query Parameter
Parameter Name Parameter Type Description
indexID
string
Request Message
None
Response Message
-


<?xml version="1.0" encoding="UTF-8"?>
<AdminAccessProtocol xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--ro, req, object, attr:version{req, string, protocolVersion}-->
<id>
<!--ro, req, string, ID-->1
</id>
<enabled>
<!--ro, opt, bool, "true,false"-->true
</enabled>
<protocol>
<!--ro, req, enum, protocol type, subType:string, desc:protocol type-->HTTP
</protocol>
<redirectToHttps>
<!--ro, opt, bool, whether to enable HTTPS redirection, desc:this node is valid when the protocol type is "HTTPS"-->true
</redirectToHttps>
<streamOverTls>
<!--ro, opt, bool, whether to enable encryption of stream, desc:this node is valid when the protocol type is "SDK_OVER_TLS"-->true
</streamOverTls>
<portNo>
<!--ro, req, int, Port No., range:[1,65535], desc:Port No.-->80
</portNo>
<TLS1_1Enable>
<!--ro, opt, bool, dep:and,{$.AdminAccessProtocolList.AdminAccessProtocol.protocol,eq,HTTPS},
{$.AdminAccessProtocolList.AdminAccessProtocol.protocol,eq,WebSocket},{$.AdminAccessProtocolList.AdminAccessProtocol.protocol,eq,WebSocketS},
{$.AdminAccessProtocolList.AdminAccessProtocol.protocol,eq,SDK_OVER_TLS}-->true
</TLS1_1Enable>
<TLS1_2Enable>
<!--ro, opt, bool, dep:and,{$.AdminAccessProtocolList.AdminAccessProtocol.protocol,eq,HTTPS},
{$.AdminAccessProtocolList.AdminAccessProtocol.protocol,eq,WebSocket},{$.AdminAccessProtocolList.AdminAccessProtocol.protocol,eq,WebSocketS},
{$.AdminAccessProtocolList.AdminAccessProtocol.protocol,eq,SDK_OVER_TLS}-->true
</TLS1_2Enable>
<TLS1_3Enable>
<!--ro, opt, bool, dep:and,{$.AdminAccessProtocolList.AdminAccessProtocol.protocol,eq,HTTPS},
{$.AdminAccessProtocolList.AdminAccessProtocol.protocol,eq,WebSocket},{$.AdminAccessProtocolList.AdminAccessProtocol.protocol,eq,WebSocketS},
{$.AdminAccessProtocolList.AdminAccessProtocol.protocol,eq,SDK_OVER_TLS}-->true
</TLS1_3Enable>
</AdminAccessProtocol>
21.6.3 Set the parameters of a specific protocol that supported by device
Request URL
PUT /ISAPI/Security/adminAccesses/<indexID>
Query Parameter
Parameter Name Parameter Type Description
indexID
string
Request Message
-


<?xml version="1.0" encoding="UTF-8"?>
<AdminAccessProtocol xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--req, object, attr:version{req, string, protocolVersion}-->
<id>
<!--req, string, ID-->1
</id>
<enabled>
<!--opt, bool, whether to enable the function-->true
</enabled>
<protocol>
<!--req, enum, protocol type, subType:string, desc:protocol type-->HTTP
</protocol>
<redirectToHttps>
<!--opt, bool, whether to automatically go to HTTPS when connecting to HTTP port and HTTPS is enabled, desc:whether to automatically go to HTTPS when
connecting to HTTP port and HTTPS is enabled-->true
</redirectToHttps>
<streamOverTls>
<!--opt, bool, whether to enable encryption of stream, desc:whether to enable encryption of stream-->true
</streamOverTls>
<portNo>
<!--req, int, port No., range:[1,65535], desc:port No.-->80
</portNo>
<TLS1_1Enable>
<!--opt, bool, dep:and,{$.AdminAccessProtocolList.AdminAccessProtocol.protocol,eq,HTTPS},
{$.AdminAccessProtocolList.AdminAccessProtocol.protocol,eq,WebSocket},{$.AdminAccessProtocolList.AdminAccessProtocol.protocol,eq,WebSocketS},
{$.AdminAccessProtocolList.AdminAccessProtocol.protocol,eq,SDK_OVER_TLS}-->true
</TLS1_1Enable>
<TLS1_2Enable>
<!--opt, bool, dep:and,{$.AdminAccessProtocolList.AdminAccessProtocol.protocol,eq,HTTPS},
{$.AdminAccessProtocolList.AdminAccessProtocol.protocol,eq,WebSocket},{$.AdminAccessProtocolList.AdminAccessProtocol.protocol,eq,WebSocketS},
{$.AdminAccessProtocolList.AdminAccessProtocol.protocol,eq,SDK_OVER_TLS}-->true
</TLS1_2Enable>
<TLS1_3Enable>
<!--opt, bool, dep:and,{$.AdminAccessProtocolList.AdminAccessProtocol.protocol,eq,HTTPS},
{$.AdminAccessProtocolList.AdminAccessProtocol.protocol,eq,WebSocket},{$.AdminAccessProtocolList.AdminAccessProtocol.protocol,eq,WebSocketS},
{$.AdminAccessProtocolList.AdminAccessProtocol.protocol,eq,SDK_OVER_TLS}-->true
</TLS1_3Enable>
</AdminAccessProtocol>
Response Message
<?xml version="1.0" encoding="UTF-8"?>
<ResponseStatus xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--ro, req, object, response message, attr:version{ro, req, string, protocolVersion}-->
<requestURL>
<!--ro, req, string, request URL-->null
</requestURL>
<statusCode>
<!--ro, req, enum, status code, subType:int, desc:0 (OK), 1 (OK), 2 (Device Busy), 3 (Device Error), 4 (Invalid Operation), 5 (Invalid XML Format), 6
(Invalid XML Content), 7 (Reboot Required)-->0
</statusCode>
<statusString>
<!--ro, req, enum, status information, subType:string, desc:"OK" (succeeded), "Device Busy", "Device Error", "Invalid Operation", "Invalid XML Format",
"Invalid XML Content", "Reboot" (reboot device)-->OK
</statusString>
<subStatusCode>
<!--ro, req, string, sub status code, which describes the error in details, desc:sub status code, which describes the error in details-->OK
</subStatusCode>
</ResponseStatus>
21.7 EZVIZ Access Management
21.7.1 Get EZ parameters
Request URL
GET /ISAPI/System/Network/EZVIZ?security=<security>&iv=<iv>
Query Parameter
Parameter Name Parameter Type Description
security
string
iv
Request Message
None
string
-
-


Response Message
<?xml version="1.0" encoding="UTF-8"?>
<EZVIZ xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--ro, req, object, attr:version{opt, string, protocolVersion}-->
<enabled>
<!--ro, req, bool-->false
</enabled>
<registerStatus>
<!--ro, opt, bool, registration status-->true
</registerStatus>
<redirect>
<!--ro, opt, bool, whether to allow the device to redirect the server address, desc:whether to allow the device to redirect the server address-->true
</redirect>
<serverAddress>
<!--ro, opt, object-->
<addressingFormatType>
<!--ro, req, enum, whether to allow the device to redirect the server address, subType:string, desc:"ipaddress" (IP address), "hostname" (domain
name)-->ipaddress
</addressingFormatType>
<hostName>
<!--ro, opt, string, host domain name-->test
</hostName>
<ipAddress>
<!--ro, opt, string, IPv4 address-->172.6.64.7
</ipAddress>
<ipv6Address>
<!--ro, opt, string, IPv6 address-->1080:0:0:0:8:800:200C:417A
</ipv6Address>
</serverAddress>
<verificationCode>
<!--ro, opt, string, verification code, desc:verification code-->123456789TESTtest
</verificationCode>
<offlineStatus>
<!--ro, opt, enum, device offline status, subType:string, desc:"secretKeyInvalid" (invalid verification code)-->secretKeyInvalid
</offlineStatus>
<enabledTiming>
<!--ro, opt, bool, whether to enable timing: true-yes,false-no (default), desc:whether to enable Hik-Connect timing: true-yes,false-no (default); this
node is valid only when the value of parameter <platformType> in XML_Time is "EZVIZ" (related URI: /ISAPI/System/time)-->true
</enabledTiming>
<version>
<!--ro, opt, string, version information, desc:version information-->test
</version>
<operateCode>
<!--ro, opt, string, operation code for binding device, desc:operation code for binding device-->test
</operateCode>
<netWork>
<!--ro, opt, enum, 0-null;1-automatic;2-wired network priority;3-wired network(by default),4-3G/4G/GPRS, subType:int, desc:0-null; 1-automatic; 2-wired
network priority; 3-wired network (by default), 4-3G/4G/GPRS-->3
</netWork>
<convergenceCloudEnabled>
<!--ro, opt, bool-->false
</convergenceCloudEnabled>
<streamEncrypteEnabled>
<!--ro, opt, bool, whether to enable stream encryption, desc:whether to enable stream encryption-->true
</streamEncrypteEnabled>
<bindStatus>
<!--ro, opt, enum, Guarding Vision account binding status of the current device, subType:string, desc:"bind"-bound, "unbind"-unbound-->bind
</bindStatus>
<upISAPIStatus>
<!--ro, opt, enum, read-only,status of uplink transmitting ISAPI message: "open","close", subType:string, desc:status of uplink transmitting ISAPI
message-->open
</upISAPIStatus>
<offlineCode>
<!--ro, opt, string-->0xFFFFFFFF
</offlineCode>
<periodicTestEnabled>
<!--ro, opt, bool, whether to enable periodic test, desc:after this function is enabled, the host will send a Test event to the EZ platform every
configured interval for checking whether the link is valid for interaction-->true
</periodicTestEnabled>
<periodicTestTime>
<!--ro, opt, int, periodic test interval,unit: second,range: [10,86400], range:[10,86400], desc:unit: second-->10
</periodicTestTime>
<networkPriorityEnabled>
<!--ro, opt, bool-->true
</networkPriorityEnabled>
<NetworkPriorityList>
<!--ro, opt, object, dep:and,{$.EZVIZ.networkPriorityEnabled,eq,true}-->
<NetworkPriority>
<!--ro, opt, object, Network Priority-->
<networkType>
<!--ro, opt, enum, subType:int-->1
</networkType>
<priority>
<!--ro, opt, int, priority, range:[1,10], desc:priority-->1
</priority>
</NetworkPriority>
</NetworkPriorityList>
<protocolVersion>
<!--ro, opt, enum, protocol version, subType:string, desc:protocol version-->v2.0
</protocolVersion>


</protocolVersion>
</EZVIZ>
21.7.2 Set Hik-Connect parameters
Request URL
PUT /ISAPI/System/Network/EZVIZ?security=<security>&iv=<iv>
Query Parameter
Parameter Name Parameter Type Description
security
string
iv
Request Message
<?xml version="1.0" encoding="UTF-8"?>
<EZVIZ xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--req, object, attr:version{opt, string, protocolVersion}-->
<enabled>
<!--req, bool, whether to enable the function-->false
</enabled>
<registerStatus>
<!--ro, opt, bool, version information, format: ""Vx.x.xbuildYYMMDD-->true
</registerStatus>
<redirect>
<!--opt, bool, whether to allow the device to redirect the server address, desc:whether to allow the device to redirect the server address-->true
</redirect>
<serverAddress>
<!--opt, object, server address-->
<addressingFormatType>
<!--req, enum, "ipaddress,hostname", subType:string, desc:"ipaddress,hostname"-->ipaddress
</addressingFormatType>
<hostName>
<!--opt, string-->test
</hostName>
<ipAddress>
<!--opt, string, IPv4 address-->172.6.64.7
</ipAddress>
<ipv6Address>
<!--opt, string, IPv6 address-->1080:0:0:0:8:800:200C:417A
</ipv6Address>
</serverAddress>
<verificationCode>
<!--opt, string, verification code, desc:Only the "admin" user can edit the verification code using the control. The verification code will be displayed
for other users. If this node is returned, setting verification code is supported-->test
</verificationCode>
<offlineStatus>
<!--ro, opt, enum, read-only,it is valid when registerStatus values "false",device offline status: "secretKeyInvalid"-invalid verification
code,"netUnreachable"-network is unreachable,"blocklist"-blocklist,"unknown"-unknown error, subType:string, desc:read-only,it is valid when registerStatus
values "false",device offline status: "secretKeyInvalid"-invalid verification code,"netUnreachable"-network is unreachable,"blocklist"-blocklist,"unknown"unknown
error-->secretKeyInvalid
</offlineStatus>
<enabledTiming>
<!--opt, bool, it is valid when registerStatus values "false", device offline status: "secretKeyInvalid"-invalid verification code, "netUnreachable"network
is unreachable, "blocklist"-blocklist,"unknown"-unknown error, desc:whether to enable Hik-Connect timing: true-yes,false-no (default); this node is
valid only when the value of parameter <platformType> in XML_Time is "EZVIZ" (related URI: /ISAPI/System/time)-->true
</enabledTiming>
<version>
<!--opt, string, version information, desc:read-only,version information,format: ""Vx.x.xbuildYYMMDD-->test
</version>
<operateCode>
<!--opt, string, version information, format: ""Vx.x.xbuildYYMMDD, desc:operation code for binding device-->test
</operateCode>
<netWork>
<!--opt, enum, operation code for binding device, subType:int, desc:0-null;1-automatic;2-wired network priority;3-wired network(by default),43G/4G/GPRS-->3
</netWork>
<convergenceCloudEnabled>
<!--opt,
bool-->false
</convergenceCloudEnabled>
<streamEncrypteEnabled>
<!--opt, bool, 0-null; 1-automatic; 2-wired network priority; 3-wired network(by default), 4-3G/4G/GPRS, desc:whether to enable stream encryption,trueyes
(default),false-no-->true
</streamEncrypteEnabled>
<upISAPIStatus>
<!--ro, opt, enum, whether to enable stream encryption, true-yes (default), false-no, subType:string, desc:status of uplink transmitting ISAPI message:
"open", "close”-->open
</upISAPIStatus>
<bindStatus>
<!--ro, opt, enum, read-only,Guarding Vision account binding status of the current device: "bind"-bound,"unbind"-unbound. When "bind" is returned,you
can unbind the device from Guarding Vision account by calling the URI /ISAPI/System/Network/EZVIZ/unbind, subType:string, desc:Guarding Vision account
binding status of the current device: "bind"-bound, "unbind"-unbound. When "bind" is returned, you can unbind the device from Guarding Vision account by
string
-
-


calling the URI /ISAPI/System/Network/EZVIZ/unbind-->bind
</bindStatus>
<periodicTestEnabled>
<!--opt, bool, whether to enable periodic test. After this function is enabled,the host will send a Test event to the EZVIZ platform every configured
interval for checking whether the link is valid for interaction, desc:After this function is enabled, the host will send a Test event to the EZVIZ platform
every configured interval for checking whether the link is valid for interaction-->true
</periodicTestEnabled>
<periodicTestTime>
<!--opt, int, whether to enable periodic test, range:[10,86400], desc:periodic test interval,unit: second,range: [10,86400]-->10
</periodicTestTime>
<networkPriorityEnabled>
<!--opt, bool-->true
</networkPriorityEnabled>
<NetworkPriorityList>
<!--opt, object, dep:and,{$.EZVIZ.networkPriorityEnabled,eq,true}-->
<NetworkPriority>
<!--opt, object-->
<networkType>
<!--opt, enum, subType:int-->1
</networkType>
<priority>
<!--opt, int, priority, range:[1,10]-->1
</priority>
</NetworkPriority>
</NetworkPriorityList>
<protocolVersion>
<!--opt, enum, protocol version, subType:string-->v2.0
</protocolVersion>
<streamEncryptionPassword>
<!--opt, string, range:[8,16]-->test
</streamEncryptionPassword>
</EZVIZ>
Response Message
<?xml version="1.0" encoding="UTF-8"?>
<ResponseStatus xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--ro, req, object, response message, attr:version{ro, req, string, protocolVersion}-->
<requestURL>
<!--ro, req, string, request URL-->null
</requestURL>
<statusCode>
<!--ro, req, enum, status code, subType:int, desc:0 (OK), 1 (OK), 2 (Device Busy), 3 (Device Error), 4 (Invalid Operation), 5 (Invalid XML Format), 6
(Invalid XML Content), 7 (Reboot Required)-->0
</statusCode>
<statusString>
<!--ro, req, enum, status description, subType:string, desc:“OK” (succeeded), “Device Busy”, “Device Error”, “Invalid Operation”, “Invalid XML Format”,
“Invalid XML Content”, “Reboot” (reboot device)-->OK
</statusString>
<subStatusCode>
<!--ro, req, string, error reason description in detail, desc:error reason description in detail-->OK
</subStatusCode>
</ResponseStatus>
21.7.3 Get the capability of configuring EZ access service
Request URL
GET /ISAPI/System/Network/EZVIZ/capabilities
Query Parameter
None
Request Message
None
Response Message
<?xml version="1.0" encoding="UTF-8"?>
<EZVIZ xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--ro, req, object, verificationCode: only admin users are allowed to edit the verification code, attr:version{opt, string, protocolVersion}-->
<enabled opt="true,false">
<!--ro, req, bool, whether to enable the function, attr:opt{opt, string}, desc:whether to enable the function-->false
</enabled>
<registerStatus opt="true,false">
<!--ro, opt, bool, registration status, attr:opt{opt, string}-->true
</registerStatus>
<redirect opt="true,false">
<!--ro, opt, bool, attr:opt{opt, string}-->true
</redirect>
<serverAddress>
<!--ro, opt, object, server address-->


<!--ro, opt, object, server address-->
<addressingFormatType opt="ipaddress,hostname">
<!--ro, req, enum, address type, subType:string, attr:opt{req, string}, desc:"ipaddress, hostname"-->ipaddress
</addressingFormatType>
<hostName min="1" max="128">
<!--ro, opt, string, domain name, attr:min{opt, string},max{opt, string}-->www.baidu.com
</hostName>
<ipAddress min="null" max="null">
<!--ro, opt, string, IPv4 address, attr:min{opt, string},max{opt, string}-->172.6.64.7
</ipAddress>
<ipv6Address min="null" max="null">
<!--ro, opt, string, IPv6 address, attr:min{opt, string},max{opt, string}-->1080:0:0:0:8:800:200C:417A
</ipv6Address>
</serverAddress>
<verificationCode min="null" max="null">
<!--ro, opt, string, verification code, attr:min{opt, string},max{opt, string}-->test
</verificationCode>
<offlineStatus opt="secretKeyInvalid,networkError,notInAllowList,unknown">
<!--ro, opt, string, device offline status, attr:opt{opt, string}, desc:"secretKeyInvalid"-invalid verification code-->test
</offlineStatus>
<netWork opt="1,2,3,4">
<!--ro, opt, enum, network type, subType:int, attr:opt{req, string}, desc:0 (make no sense), 1 (automatic), 2(wired network preferred), 3 (wired
network), 4 (3G/4G/GPRS)-->3
</netWork>
<streamEncrypteEnabled opt="true,false">
<!--ro, opt, bool, whether to enable stream encryption, attr:opt{opt, string}, desc:whether to enable stream encryption-->true
</streamEncrypteEnabled>
<bindStatus opt="bind,unbind,unknown">
<!--ro, opt, enum, subType:string, attr:opt{req, string}-->bind
</bindStatus>
<isSupportEZVIZQRCode>
<!--ro, opt, bool, whether the device supports getting the EZ QR code, desc:whether the device supports getting the EZVIZ QR code (related URI-->true
</isSupportEZVIZQRCode>
<isSupportUpISAPI>
<!--ro, opt, bool, whether the device supports uplink transmitting ISAPI message-->true
</isSupportUpISAPI>
<isSupportDownISAPI>
<!--ro, opt, bool, whether the device supports downlink transmitting ISAPI message-->true
</isSupportDownISAPI>
<convergenceCloudEnabled opt="true,false">
<!--ro, opt, bool, attr:opt{opt, string}-->false
</convergenceCloudEnabled>
<offlineCode min="0" max="16">
<!--ro, opt, string, attr:min{opt, string},max{opt, string}-->0xFFFFFFFF
</offlineCode>
<isSupportEZVIZCloud>
<!--ro, opt, bool, Related URI: /ISAPI/System/Network/EZVIZ/QRCode?format=json, desc:Related URI: /ISAPI/System/Network/EZVIZ/QRCode?format=json-->true
</isSupportEZVIZCloud>
<periodicTestEnabled opt="true,false">
<!--ro, opt, bool, whether to enable periodic test, attr:opt{req, string}, desc:after this function is enabled, the host will send a Test event to the
EZ platform every configured interval for checking whether the link is valid for interaction-->true
</periodicTestEnabled>
<periodicTestTime min="10" max="86400">
<!--ro, opt, int, periodic test interval, attr:min{req, int},max{req, int}, desc:unit: second-->5
</periodicTestTime>
<CloudStorage>
<!--ro, opt, object, this node is valid when the value of wordVoiceEnabled is true, desc:this node is valid when the value of wordVoiceEnabled is true-
>
<isSupportRecordsSubscribe>
<!--ro, opt, bool-->true
</isSupportRecordsSubscribe>
<isSupportChannelRecordsSubscribe>
<!--ro, opt, bool, ., desc:.-->true
</isSupportChannelRecordsSubscribe>
<isSupportRecordsSubscribeStatistics>
<!--ro, opt, bool-->true
</isSupportRecordsSubscribeStatistics>
</CloudStorage>
<physicalAccessVerification opt="1,2,3,4">
<!--ro, opt, enum, subType:string, attr:opt{req, string}-->1
</physicalAccessVerification>
<userToken min="0" max="16">
<!--ro, opt, string, attr:min{req, int},max{req, int}-->test
</userToken>
<isSupportUserTokenUpdate opt="true,false">
<!--ro, opt, bool, attr:opt{req, string}-->true
</isSupportUserTokenUpdate>
<networkPriorityEnabled opt="true,false">
<!--ro, opt, bool, attr:opt{req, string}-->true
</networkPriorityEnabled>
<NetworkPriorityList size="5">
<!--ro, opt, object, attr:size{req, int}-->
<NetworkPriority>
<!--ro, opt, object, Network Priority-->
<networkType opt="1,2,3,4,5">
<!--ro, opt, enum, network type, subType:int, attr:opt{req, string}, desc:network type-->1
</networkType>
<priority min="1" max="10">
<!--ro, opt, int, priority, range:[1,10], attr:min{req, int},max{req, int}, desc:priority-->1
</priority>
</NetworkPriority>
</NetworkPriorityList>
<protocolVersion opt="v2.0,v3.0" def="v2.0">
<!--ro, opt, enum, protocol version, subType:string, attr:opt{req, string},def{req, string}, desc:protocol version-->v2.0


</protocolVersion>
<physicalAccessUserToken min="0" max="16">
<!--ro, opt, string, attr:min{req, int},max{req, int}-->test
</physicalAccessUserToken>
<streamEncryptionPassword min="8" max="16">
<!--ro, opt, string, range:[8,16], attr:min{req, int},max{req, int}-->test
</streamEncryptionPassword>
<isSupportAccessUserTokenCfgList>
<!--ro, opt, bool-->true
</isSupportAccessUserTokenCfgList>
</EZVIZ>
21.8 ISUP Access Management
21.8.1 Set the EHome server access parameters
Request URL
PUT /ISAPI/System/Network/Ehome?security=<security>&iv=<iv>&centerID=<centerID>
Query Parameter
Parameter Name Parameter Type Description
security
string
iv
centerID
Request Message
string
string
-
-
-


<?xml version="1.0" encoding="UTF-8"?>
<Ehome xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--opt, object, attr:version{req, string, protocolVersion}-->
<enabled>
<!--opt, bool-->false
</enabled>
<addressingFormatType>
<!--req, enum, address type, subType:string, desc:"ipaddress", "hostname"-->ipaddress
</addressingFormatType>
<hostName>
<!--opt, string, host name,this node is valid only when <addressingFormatType> is "hostname", range:[1,128]-->time.windows.com
</hostName>
<ipAddress>
<!--opt, string, IPv4 address, range:[1,16], desc:IPv4 address-->192.168.1.112
</ipAddress>
<ipv6Address>
<!--opt, string, IPv6 address, range:[1,128], desc:IPv6 address-->1030::C9B4:FF12:48AA:1A2B
</ipv6Address>
<portNo>
<!--opt, int, port No., range:[1,65535], desc:port No.-->74
</portNo>
<deviceID>
<!--req, string, port No., range:[1,64]-->test1234
</deviceID>
<registerStatus>
<!--ro, opt, bool, device ID-->true
</registerStatus>
<ServerAddressList>
<!--ro, opt, array, list of servers, subType:object-->
<ServerAddress>
<!--ro, opt, object, server information-->
<id>
<!--ro, req, enum, server type, subType:string, desc:server type-->alarm
</id>
<ipAddress>
<!--ro, req, string, server IP address, range:[1,16]-->192.168.1.113
</ipAddress>
<portNo>
<!--ro, req, int, server port No., range:[1,65535]-->76
</portNo>
</ServerAddress>
</ServerAddressList>
<key>
<!--ro, opt, string, secret key, which is used for registration via ISUP5.0 and OTAP, range:[1,64], dep:and,{$.Ehome.protocolVersion,eq,OTAP},
{$.Ehome.protocolVersion,eq,v5.0}-->test
</key>
<version>
<!--ro, opt, string, version number, range:[1,64]-->2.3.0.4
</version>
<voiceDeviceType>
<!--opt, enum, two-way audio device type, subType:string, desc:"bluetooth" (bluetooth device), "client", "local"-->bluetooth
</voiceDeviceType>
<protocolVersion>
<!--opt, enum, protocol version No., subType:string, desc:if this node is set to "v2.6", "v4.0" or "v5.0", the device will firstly use this protocol to
register. If this node is not returned, the protocol version will be determined by <version>-->v5.0
</protocolVersion>
<netWork>
<!--opt, enum, 0-make no sense,1-automatic,2-wired network preferred,3-wired network,4-3G/4G/GPRS, subType:string, desc:0-make no sense,1-automatic,2wired
network preferred,3-wired network,4-3G/4G/GPRS-->1
</netWork>
</Ehome>
Response Message
<?xml version="1.0" encoding="UTF-8"?>
<ResponseStatus xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--ro, req, object, response message, attr:version{ro, req, string, protocolVersion}-->
<requestURL>
<!--ro, req, string, request URL-->null
</requestURL>
<statusCode>
<!--ro, req, enum, status code, subType:int, desc:0 (OK), 1 (OK), 2 (Device Busy), 3 (Device Error), 4 (Invalid Operation), 5 (Invalid XML Format), 6
(Invalid XML Content), 7 (Reboot Required)-->0
</statusCode>
<statusString>
<!--ro, req, enum, status information, subType:string, desc:"OK" (succeeded), "Device Busy", "Device Error", "Invalid Operation", "Invalid XML Format",
"Invalid XML Content", "Reboot" (reboot device)-->OK
</statusString>
<subStatusCode>
<!--ro, req, string, read-only,describe the error reason in detail, desc:sub status code, which describes the error in details-->OK
</subStatusCode>
</ResponseStatus>
21.8.2 Get the configuration capability of accessing servers via ISUP (EHome)


Request URL
GET /ISAPI/System/Network/Ehome/capabilities
Query Parameter
None
Request Message
None
Response Message


<?xml version="1.0" encoding="UTF-8"?>
<Ehome xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--ro, req, object, configuration capability of accessing servers via ISUP, attr:version{req, string, protocolVersion}, desc:0-make no sense, 1automatic,
2-wired network preferred, 3-wired network, 4-3G/4G/GPRS-->
<enabled opt="true,false">
<!--ro, opt, bool, whether to enable, attr:opt{req, string}, desc:whether to enable-->false
</enabled>
<id min="1" max="1">
<!--ro, opt, string, ISUP center ID, attr:min{req, int},max{req, int}-->test
</id>
<addressingFormatType opt="ipaddress,hostname">
<!--ro, req, string, address type, attr:opt{req, string}-->ipaddress
</addressingFormatType>
<GPRSAddressingFormatType opt="ipaddress">
<!--ro, opt, string, GPRS address type. If this node is not returned, the address type will be determined by addressingFormatType which indicates that
the address types configured by different networks do not need to be distinguished, attr:opt{req, string}-->ipaddress
</GPRSAddressingFormatType>
<hostName min="1" max="128">
<!--ro, opt, string, host name, attr:min{req, int},max{req, int}-->time.windows.com
</hostName>
<ipAddress min="1" max="16">
<!--ro, opt, string, IPv4 address, attr:min{req, int},max{req, int}-->192.168.1.112
</ipAddress>
<ipv6Address min="1" max="128">
<!--ro, opt, string, IPv6 address, attr:min{req, int},max{req, int}-->1030::C9B4:FF12:48AA:1A2B
</ipv6Address>
<portNo min="1" max="65535">
<!--ro, opt, int, port No., attr:min{req, int},max{req, int}-->74
</portNo>
<deviceID min="1" max="64">
<!--ro, req, string, attr:min{req, int},max{req, int}-->test1234
</deviceID>
<registerStatus opt="true,false">
<!--ro, opt, bool, registration status, attr:opt{req, string}-->true
</registerStatus>
<ServerAddressList>
<!--ro, opt, array, list of servers, subType:object-->
<ServerAddress>
<!--ro, opt, object, server information-->
<id>
<!--ro, req, enum, server type, subType:string, desc:ISUP center ID-->alarm
</id>
<ipAddress>
<!--ro, req, string, server IP address-->192.168.1.113
</ipAddress>
<portNo>
<!--ro, req, int, server port No.-->76
</portNo>
</ServerAddress>
</ServerAddressList>
<key min="1" max="64">
<!--ro, opt, string, secret key, which is used for registration via ISUP5.0 and OTAP, dep:and,{$.Ehome.protocolVersion,eq,OTAP},
{$.Ehome.protocolVersion,eq,v5.0}, attr:min{req, int},max{req, int}-->test
</key>
<version min="1" max="64">
<!--ro, opt, string, version, attr:min{req, int},max{req, int}-->test
</version>
<voiceDeviceType opt="bluetooth,client,local">
<!--ro, opt, string, two-way audio device type: "bluetooth"-bluetooth device, "client", "local", attr:opt{req, string}-->test
</voiceDeviceType>
<protocolVersion opt="v2.0,v2.6,v4.0,v5.0,OTAP">
<!--ro, opt, string, protocol version, attr:opt{req, string}-->v5.0
</protocolVersion>
<netWork opt="0,1,2,3,4,5,6">
<!--ro, opt, int, network type, attr:opt{req, string}-->1
</netWork>
<pictureServerID min="1" max="64">
<!--ro, opt, int, linked picture storage server ID (related URI: /ISAPI/System/PictureServer), attr:min{req, int},max{req, int}-->1
</pictureServerID>
<ISUPID min="1" max="64">
<!--ro, opt, int, ISUP multi-platform ID, attr:min{req, int},max{req, int}-->1
</ISUPID>
<isSupportTest>
<!--ro, opt, bool, whether it supports server test via ISUP (EHome)-->true
</isSupportTest>
<periodicTestEnabled opt="true,false">
<!--ro, opt, bool, whether to enable periodic test, attr:opt{req, string}, desc:when it is enabled, the host will send a Test event to the server every
configured interval for checking whether the connection is normal (similar to heartbeat detection)-->true
</periodicTestEnabled>
<periodicTestTime min="10" max="86400">
<!--ro, opt, int, periodic test interval,unit: second. This node is valid when <periodicTestEnabled> is true, attr:min{req, int},max{req, int},
desc:periodic test interval,unit: second. This node is valid when <periodicTestEnabled> is true-->50
</periodicTestTime>
<isSupportMulticenterTest>
<!--ro, opt, bool-->true
</isSupportMulticenterTest>
</Ehome>


21.8.3 Get the ISUP server access parameters
Request URL
GET /ISAPI/System/Network/Ehome?security=<security>&iv=<iv>&centerID=<centerID>
Query Parameter
Parameter Name Parameter Type Description
security
string
iv
centerID
string
string
Request Message
None
Response Message
<?xml version="1.0" encoding="UTF-8"?>
<Ehome xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--ro, opt, object, attr:version{req, string, protocolVersion}-->
<enabled>
<!--ro, opt, bool, desc:by default, it is disabled-->false
</enabled>
<addressingFormatType>
<!--ro, req, enum, address type, subType:string, desc:"ipaddress"-IP address, "hostname"-host name-->ipaddress
</addressingFormatType>
<hostName>
<!--ro, opt, string, host name,this node is valid only when <addressingFormatType> is "hostname”, range:[1,128]-->time.windows.com
</hostName>
<ipAddress>
<!--ro, opt, string, IPv4 address, range:[1,16], desc:IPv4 address-->192.168.1.112
</ipAddress>
<ipv6Address>
<!--ro, opt, string, IPv6 address, range:[1,128], desc:IPv6 address-->1030::C9B4:FF12:48AA:1A2B
</ipv6Address>
<portNo>
<!--ro, opt, int, port No., range:[1,65535], desc:port No.-->74
</portNo>
<deviceID>
<!--ro, req, string, ISUP device serial No., range:[1,64]-->test1234
</deviceID>
<registerStatus>
<!--ro, opt, bool, ro,registration status-->true
</registerStatus>
<ServerAddressList>
<!--ro, opt, array, server information list, subType:object-->
<ServerAddress>
<!--ro, opt, object, server information-->
<id>
<!--ro, req, enum, server type, subType:string, desc:ID-->alarm
</id>
<ipAddress>
<!--ro, req, string, server IP address, range:[1,16]-->192.168.1.113
</ipAddress>
<portNo>
<!--ro, req, int, server port No., range:[1,65535]-->76
</portNo>
</ServerAddress>
</ServerAddressList>
<key>
<!--ro, opt, string, encryption key of ISUP version 5.0,which is required for ISUP version 50, range:[1,64], dep:and,{$.Ehome.protocolVersion,eq,OTAP},
{$.Ehome.protocolVersion,eq,v5.0}-->test
</key>
<version>
<!--ro, opt, string, version No., range:[1,64]-->2.3.0.4
</version>
<voiceDeviceType>
<!--ro, opt, enum, two-way audio device type, subType:string, desc:"bluetooth"-bluetooth device,"client","local”-->bluetooth
</voiceDeviceType>
<protocolVersion>
<!--ro, opt, enum, ISUP version No., subType:string, desc:If this node is not returned,the protocol version will be determined by <version>: v2.0, v2.6,
v4.0, v5.0, OTAP;-->v5.0
</protocolVersion>
<netWork>
<!--ro, opt, enum, Network, subType:string, desc:0-make no sense,1-automatic,2-wired network preferred,3-wired network,4-3G/4G/GPRS-->1
</netWork>
</Ehome>
-
-
-


21.9 Picture Storage Protocol Access Management
21.9.1 Set the picture storage server parameters
Request URL
PUT /ISAPI/System/PictureServer?format=json&security=<security>&iv=<iv>
Query Parameter
Parameter Name Parameter Type Description
security
enum
iv
Request Message
{
"PictureServerInformation": {
/*req, object, picture server information*/
"pictureServerType": "cloudStorage",
/*req, enum, picture server type, subType:string, desc:"tomact", "VRB", "cloudStorage", "KMS". When the value is null, it indicates that the servers
are all closed*/
"addressingFormatType": "ipaddress",
/*req, enum, address type of the picture storage server, subType:string, desc:"ipaddress" (IP address), "hostname" (domain name)*/
"hostName": "pc3-netsdk",
/*opt, string, domain name of the picture storage server*/
"ipv4Address": "10.17.133.46",
/*opt, string, IPv4 server address of the picture storage server*/
"ipv6Address": "2001:A304:6101:1::E0:F726:4E58",
/*opt, string, IPv6 server address of the picture storage server*/
"portNo": 1024,
/*req, int, picture storage server port, range:[1024,65535]*/
"underlyingProtocol": "http",
/*opt, enum, communication protocol, subType:string, desc:“http”, “https”*/
"cloudStorage": {
/*opt, object, configuration of cloud storage server parameters, dep:and,{$.PictureServerInformation.pictureServerType,eq,cloudStorage}*/
"cloudManageHttpPort": 6120,
/*opt, int, HTTP port No. for central management of the cloud storage server, which can be used for downloading the URLs of pictures and
intelligent structuralization data, range:[1024,65535]*/
"cloudTransDataPort": 9001,
/*opt, int, data transmission port No. of the cloud storage server, range:[1024,65535]*/
"cloudCmdPort": 6011,
/*opt, int, signaling port No. of the cloud storage server, range:[1024,65535]*/
"cloudHeartBeatPort": 9999,
/*opt, int, heartbeat port No. of the cloud storage server, range:[1024,65535]*/
"cloudStorageHttpPort": 8083,
/*opt, int, HTTP port No. of the cloud storage server, range:[1024,65535]*/
"cloudUsername": "username",
/*opt, string, user name of the cloud storage server, range:[0,32]*/
"cloudPassword": "12345",
/*opt, string, user name of the cloud storage server*/
"cloudPoolId": 1,
/*opt, int, cloud storage pool ID (int format), range:[1,4294967295], desc:by default, it is 1 if there is no configured device*/
"clouldProtocolVersion": "V2.0",
/*req, string, protocol version of the cloud storage server, range:[0,32]*/
"clouldAccessKey": "test",
/*opt, string, access key of the cloud storage server, range:[0,64], dep:and,
{$.PictureServerInformation.cloudStorage.clouldProtocolVersion,eq,V2.0}*/
"clouldSecretKey": "test",
/*opt, string, secret key of the cloud storage server, range:[0,64], dep:and,
{$.PictureServerInformation.cloudStorage.clouldProtocolVersion,eq,V2.0}*/
"resourceID": "test"
/*opt, string, source pool ID (string format), range:[1,256], dep:and,{$.PictureServerInformation.cloudStorage.clouldProtocolVersion,eq,V2.0},
desc:both resourceID and cloudPoolId can be used to configure the cloud storage pool ID. But different from cloudPoolId, the value of resourceID can be in
string format. When both resourceID and cloudPoolId are configured, cloudPoolId has priority over resourceID. If this node is not supported, you can
configure the pool ID via cloudPoolId.*/
}
}
}
Response Message
string
-
-


{
"requestURL": "test",
/*ro, opt, string, URI*/
"statusCode": "test",
/*ro, opt, string, status code*/
"statusString": "test",
/*ro, opt, string, status description*/
"subStatusCode": "test",
/*ro, opt, string, sub status code*/
"errorCode": 1,
/*ro, req, int, error code*/
"errorMsg": "ok"
/*ro, req, string, error message*/
}
21.9.2 Get the configuration capability of the picture storage server
Request URL
GET /ISAPI/System/PictureServer/capabilities?format=json
Query Parameter
None
Request Message
None
Response Message
{
"PictureServerInformation": {
/*ro, opt, object, picture server information*/
"pictureServerType": {
/*ro, opt, object, picture server type*/
"@opt": "tomcat,VRB,cloudStorage,KMS,null",
/*ro, opt, string, optional value*/
"#text": "cloudStorage"
/*ro, req, string, picture server type*/
},
"addressingFormatType": {
/*ro, opt, object, address type of the picture storage server*/
"@opt": "ipaddress,hostname",
/*ro, opt, string, optional value*/
"#text": "ipaddress"
/*ro, req, string, address type of the picture storage server*/
},
"hostName": {
/*ro, opt, object, domain name of the picture storage server*/
"@min": 0,
/*ro, opt, int, minimum value*/
"@max": 64,
/*ro, opt, int, maximum value*/
"#text": "pc3-netsdk"
/*ro, opt, string, domain name of the picture storage server*/
},
"ipv4Address": {
/*ro, opt, object, IPv4 server address of the picture storage server*/
"@min": 0,
/*ro, opt, int, minimum value*/
"@max": 64,
/*ro, opt, int, maximum value*/
"#text": "10.17.133.46"
/*ro, opt, string, IPv4 server address of the picture storage server*/
},
"ipv6Address": {
/*ro, opt, object, IPv6 server address of the picture storage server*/
"@min": 0,
/*ro, opt, int, minimum value*/
"@max": 128,
/*ro, opt, int, maximum value*/
"#text": "2001:A304:6101:1::E0:F726:4E58"
/*ro, opt, string, IPv6 server address of the picture storage server*/
},
"portNo": {
/*ro, opt, object, picture storage server port*/
"@min": 1024,
/*ro, opt, int, minimum value*/
"@max": 65535,
/*ro, opt, int, maximum value*/
"#text": 8000
/*ro, req, int, picture storage server port*/
},
"underlyProtocol": {
/*ro, opt, object, Communication Protocol*/
"@opt": "http,https"


/*ro, opt, string, Communication Protocol*/
},
"cloudStorage": {
/*ro, opt, object, configuration of cloud storage server parameters*/
"cloudManageHttpPort": {
/*ro, opt, object, HTTP port No. for central management of the cloud storage server*/
"@min": 1024,
/*ro, opt, int, minimum value*/
"@max": 65535,
/*ro, opt, int, maximum value*/
"#text": 8009
/*ro, opt, int, HTTP port No. for central management of the cloud storage server*/
},
"cloudTransDataPort": {
/*ro, opt, object, data transmission port No. of the cloud storage server*/
"@min": 1024,
/*ro, opt, int, minimum value*/
"@max": 65535,
/*ro, opt, int, maximum value*/
"#text": 9001
/*ro, opt, int, data transmission port No. of the cloud storage server*/
},
"cloudCmdPort": {
/*ro, opt, object, signaling port No. of the cloud storage server*/
"@min": 1024,
/*ro, opt, int, minimum value*/
"@max": 65535,
/*ro, opt, int, maximum value*/
"#text": 8008
/*ro, opt, int, signaling port No. of the cloud storage server*/
},
"cloudHeartBeatPort": {
/*ro, opt, object, heartbeat port No. of the cloud storage server*/
"@min": 1024,
/*ro, opt, int, minimum value*/
"@max": 65535,
/*ro, opt, int, maximum value*/
"#text": 9999
/*ro, opt, int, heartbeat port No. of the cloud storage server*/
},
"cloudStorageHttpPort": {
/*ro, opt, object, HTTP port No. of the cloud storage server*/
"@min": 1024,
/*ro, opt, int, minimum value*/
"@max": 65535,
/*ro, opt, int, maximum value*/
"#text": 8083
/*ro, opt, int, HTTP port No. of the cloud storage server*/
},
"cloudUsername": {
/*ro, opt, object, user name of the cloud storage server*/
"@min": 0,
/*ro, opt, int, minimum value*/
"@max": 32,
/*ro, opt, int, maximum value*/
"#text": "username"
/*ro, opt, string, user name of the cloud storage server*/
},
"cloudPassword": {
/*ro, opt, object, user name of the cloud storage server*/
"@min": 0,
/*ro, opt, int, minimum value*/
"@max": 32,
/*ro, opt, int, maximum value*/
"#text": "12345"
/*ro, opt, string, user name of the cloud storage server*/
},
"cloudPoolId": {
/*ro, opt, object, cloud storage pool ID (int format)*/
"@min": 1,
/*ro, opt, int, minimum value*/
"@max": 4294967295,
/*ro, opt, float, maximum value*/
"#text": 1
/*ro, opt, int, cloud storage pool ID*/
},
"clouldProtocolVersion": {
/*ro, opt, object, protocol version of the cloud storage server*/
"@min": 0,
/*ro, opt, int, minimum value*/
"@max": 32,
/*ro, opt, int, maximum value*/
"#text": "V2.0"
/*ro, req, string, protocol version of the cloud storage server*/
},
"clouldAccessKey": {
/*ro, opt, object, access key of the cloud storage server*/
"@min": 0,
/*ro, opt, int, minimum value*/
"@max": 64
/*ro, opt, int, maximum value*/
},
"clouldSecretKey": {
/*ro, opt, object, secret key of the cloud storage server*/


/*ro, opt, object, secret key of the cloud storage server*/
"@min": 0,
/*ro, opt, int, minimum value*/
"@max": 64
/*ro, opt, int, maximum value*/
},
"resourceID": {
/*ro, opt, object, cloud storage pool ID (string format), dep:and,{$.PictureServerInformation.cloudStorage.clouldProtocolVersion,eq,V2.0},
desc:both resourceID and cloudPoolId can be used to configure the cloud storage pool ID. But different from cloudPoolId, the value of resourceID can be in
string format. When both resourceID and cloudPoolId are configured, cloudPoolId has priority over resourceID. If this node is not supported, you can
configure the pool ID via cloudPoolId.*/
"@min": 1,
/*ro, opt, int, the minimum length of the value*/
"@max": 256
/*ro, opt, int, the maximum length of the value*/
}
},
"pictureServerID": {
/*ro, opt, object, picture storage server ID*/
"@min": 1,
/*ro, opt, int, minimum value*/
"@max": 2,
/*ro, opt, int, maximum value*/
"#text": 1
/*ro, opt, int, picture storage server ID: /ISAPI/System/PictureServer*/
}
}
}
21.9.3 Get the parameters of the picture storage server
Request URL
GET /ISAPI/System/PictureServer?format=json&security=<security>&iv=<iv>
Query Parameter
Parameter Name Parameter Type Description
security
enum
iv
Request Message
None
Response Message
string
-
-


{
"PictureServerInformation": {
/*ro, req, object, picture server information*/
"pictureServerType": "cloudStorage",
/*ro, req, enum, picture server type, subType:string, desc:"tomact", "VRB", "cloudStorage", "KMS". When the value is null, it indicates that the
servers are all closed*/
"addressingFormatType": "ipaddress",
/*ro, req, enum, address type of the picture storage server, subType:string, desc:"ipaddress" (IP address), "hostname" (domain name)*/
"hostName": "pc3-netsdk",
/*ro, opt, string, domain name of the picture storage server*/
"ipv4Address": "10.17.133.46",
/*ro, opt, string, IPv4 server address of the picture storage server*/
"ipv6Address": "2001:A304:6101:1::E0:F726:4E58",
/*ro, opt, string, IPv6 server address of the picture storage server*/
"portNo": 1024,
/*ro, req, int, picture storage server port, range:[1024,65535]*/
"underlyingProtocol": "http",
/*ro, opt, enum, communication protocol, subType:string, desc:“http”, “https”*/
"cloudStorage": {
/*ro, opt, object, configuration of cloud storage server parameters, dep:and,{$.PictureServerInformation.pictureServerType,eq,cloudStorage}*/
"cloudManageHttpPort": 6120,
/*ro, opt, int, HTTP port No. for central management of the cloud storage server, which can be used for downloading the URLs of pictures and
intelligent structuralization data, range:[1024,65535]*/
"cloudTransDataPort": 9001,
/*ro, opt, int, data transmission port No. of the cloud storage server, range:[1024,65535]*/
"cloudCmdPort": 6011,
/*ro, opt, int, signaling port No. of the cloud storage server, range:[1024,65535]*/
"cloudHeartBeatPort": 9999,
/*ro, opt, int, heartbeat port No. of the cloud storage server, range:[1024,65535]*/
"cloudStorageHttpPort": 8083,
/*ro, opt, int, HTTP port No. of the cloud storage server, range:[1024,65535]*/
"cloudUsername": "username",
/*ro, opt, string, user name of the cloud storage server, range:[0,32]*/
"cloudPassword": "12345",
/*ro, opt, string, user name of the cloud storage server*/
"cloudPoolId": 1,
/*ro, opt, int, cloud storage pool ID (int format), range:[1,4294967295], desc:by default, it is 1 if there is no configured device*/
"clouldProtocolVersion": "V2.0",
/*ro, req, string, protocol version of the cloud storage server, range:[0,32]*/
"clouldAccessKey": "test",
/*ro, opt, string, access key of the cloud storage server, range:[0,64], dep:and,
{$.PictureServerInformation.cloudStorage.clouldProtocolVersion,eq,V2.0}*/
"clouldSecretKey": "test",
/*ro, opt, string, secret key of the cloud storage server, range:[0,64], dep:and,
{$.PictureServerInformation.cloudStorage.clouldProtocolVersion,eq,V2.0}*/
"resourceID": "test"
/*ro, opt, string, cloud storage pool ID (string format), range:[1,256], dep:and,
{$.PictureServerInformation.cloudStorage.clouldProtocolVersion,eq,V2.0}, desc:both resourceID and cloudPoolId can be used to configure the cloud storage
pool ID. But different from cloudPoolId, the value of resourceID can be in string format. When both resourceID and cloudPoolId are configured, cloudPoolId
has priority over resourceID. If this node is not supported, you can configure the pool ID via cloudPoolId.*/
}
}
}
21.10 HTTP Listening Management
21.10.1 Set the parameters of a listening host
Request URL
PUT /ISAPI/Event/notification/httpHosts/<hostID>?security=<security>&iv=<iv>
Query Parameter
Parameter Name Parameter Type Description
hostID
string
security
iv
Request Message
<?xml version="1.0" encoding="UTF-8"?>
<HttpHostNotification xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--req, object, listening host, attr:version{req, string, protocolVersion}-->
<id>
<!--req, string, listening host ID, range:[1,10]-->test
</id>
<url>
<!--req, string, URL-->test
string
string
-
-
-


<!--req, string, URL-->test
</url>
<protocolType>
<!--req, enum, protocol type, subType:string, desc:"HTTP", "HTTPS", "EHome" (ISUP)-->HTTP
</protocolType>
<parameterFormatType>
<!--req, enum, parameter format type, subType:string, desc:“JSON”, “XML”-->JSON
</parameterFormatType>
<addressingFormatType>
<!--req, enum, address type, subType:string, desc:“hostname”, “ipaddress”-->hostname
</addressingFormatType>
<hostName>
<!--opt, string, host name-->test
</hostName>
<ipAddress>
<!--opt, string, IP address-->test
</ipAddress>
<ipv6Address>
<!--opt, string, IPv6 Address-->test
</ipv6Address>
<portNo>
<!--opt, int, port number-->1
</portNo>
<userName>
<!--opt, string, user name-->test
</userName>
<password>
<!--opt, string, password-->test
</password>
<httpAuthenticationMethod>
<!--req, enum, authentication method, subType:string, desc:“MD5digest” (MD5), “none”, “base64”-->MD5digest
</httpAuthenticationMethod>
<ANPR>
<!--opt, object, ANPR-->
<detectionUpLoadPicturesType>
<!--opt, enum, uploaded pictures type, subType:string, desc:“all”, “licensePlatePicture”, “detectionPicture” (detected picture)-->all
</detectionUpLoadPicturesType>
</ANPR>
<Extensions>
<!--opt, object, range-->
<intervalBetweenEvents>
<!--opt, int, event interval-->1
</intervalBetweenEvents>
</Extensions>
<uploadImagesDataType>
<!--opt, enum, picture data type, subType:string, desc:the default data type is binary. for cloud storage, only “URL” is supported. “URL”, “binary”-
>URL
</uploadImagesDataType>
<httpBroken>
<!--opt, bool, whether to enable the automatic network replenishment, desc:if the ANR function is enabled, it will be applied to all events-->true
</httpBroken>
<SubscribeEvent>
<!--opt, object, picture uploading modes of all events which contain pictures-->
<heartbeat>
<!--opt, int, Heartbeat Interval Time-->30
</heartbeat>
<eventMode>
<!--req, enum, event mode, subType:string, desc:“all” (all alarms need to be reported), “list” (only listed alarms need to be reported)-->all
</eventMode>
<EventList>
<!--opt, array, event list, subType:object-->
<Event>
<!--opt, object, channel information linked to event-->
<type>
<!--req, enum, event type, subType:string, desc:see details in event types: “ADAS” (advanced driving assistance system), “ADASAlarm” (advanced
driving assistance alarm), “AID” (traffic incident detection), “ANPR” (automatic number plate recognition), “AccessControllerEvent”, “CDsStatus”, “DBD”
(driving behavior detection) “GPSUpload”, “HFPD” (frequently appeared person), “IO” (I/O Alarm), “IOTD”, “LES”, “LFPD” (low frequency person detection),
“PALMismatch”, “PIR”, “PeopleCounting”, “PeopleNumChange”, “Standup” (standing up detection), “TMA” (thermometry alarm), “TMPA” (temperature measurement
pre-alarm), “VMD” (motion detection), “abnormalAcceleration”, “abnormalDriving”, “advReachHeight”, ”alarmResult”, “attendance”, “attendedBaggage”,
“audioAbnormal”, “audioexception”, “behaviorResult” (behavior analysis), “blindSpotDetection” (blind spot detection alarm), “cardMatch”, “changedStatus”,
“collision”, “containerDetection”, “crowdSituationAnalysis”, “databaseException”, “defocus” (defocus detection), “diskUnformat” (disk unformatted),
“diskerror”, “diskfull”, “driverConditionMonitor” (driver status monitoring alarm); “emergencyAlarm", “faceCapture”, “faceSnapModeling”, “facedetection”,
“failDown” (People Falling Down), “faultAlarm”, “fielddetection” (intrusion detection), “fireDetection”, “fireEscapeDetection”, “flowOverrun”,
“framesPeopleCounting”, “getUp” (getting up detection), “group” (people gathering), “hdBadBlock”(HDD bad sector detection event), “hdImpact” (HDD impact
detection event), “heatmap” (heat map alarm), “highHDTemperature” (HDD high temperature detection event), “highTempAlarm” (HDD high temperature alarm),
“hotSpare” (hot spare exception), “illaccess” (invalid access), “ipcTransferAbnormal”, “ipconflict” (IP address conflicts), “keyPersonGetUp” (key person
getting up detection), “leavePosition” (absence detection), “linedetection” (line crossing detection), “listSyncException” (list synchronization exception),
“loitering” (loitering detection), “lowHDTemperature” (HDD low temperature detection event), “mixedTargetDetection” (multi-target-type detection),
“modelError”, “nicbroken” (network disconnected), “nodeOffline” (node disconnected), “nonPoliceIntrusion”, “overSpeed” (overspeed alarm), “overtimeTarry”
(staying overtime detection), “parking” (parking detection), “peopleNumChange”, “peopleNumCounting”, “personAbnormalAlarm” (person ID exception alarm),
“personDensityDetection”, “personQueueCounting”, “personQueueDetection”, “personQueueRealTime” (real-time data of people queuing-up detection),
“personQueueTime” (waiting time detection), “playCellphone” (playing mobile phone detection), “pocException” (video exception), “poe” (POE power exception),
“policeAbsent”, “radarAlarm”, “radarFieldDetection”, “radarLineDetection”, “radarPerimeterRule” (radar rule data), “radarTargetDetection”,
“radarVideoDetection” (radar-assisted target detection), “raidException”, “rapidMove”, “reachHeight” (climbing detection), “recordCycleAbnormal”
(insufficient recording period), “recordException”, “regionEntrance”, “regionExiting”, “retention” (people overstay detection), “rollover”, “running”
(people running), “safetyHelmetDetection” (hard hat detection), “scenechangedetection”, “sensorAlarm” (angular acceleration alarm), “severeHDFailure” (HDD
major fault detection), “shelteralarm” (video tampering alarm), “shipsDetection”, “sitQuietly” (sitting detection), “smokeAndFireDetection”,
“smokeDetection”, “softIO”, “spacingChange” (distance exception), “sysStorFull” (storaging full alarm of cluster system), “takingElevatorDetection”
(elevator electric moped detection), “targetCapture”, “temperature” (temperature difference alarm), “thermometry” (temperature alarm),
“thirdPartyException”, “toiletTarry” (in-toilet overtime detection), “tollCodeInfo” (QR code information report), “tossing” (thrown object detection),
“unattendedBaggage”, “vehicleMatchResult” (uploading list alarms), “vehicleRcogResult”, “versionAbnormal” (cluster version exception), “videoException”,
“videoloss”, “violationAlarm”, “violentMotion” (violent motion detection), “yardTarry” (playground overstay detection), “AccessControllerEvent”,
“IDCardInfoEvent”, “FaceTemperatureMeasurementEvent” , “QRCodeEvent” (QR code event of access control), “CertificateCaptureEvent” (person ID capture
comparison event), “UncertificateCompareEvent”, “ConsumptionAndTransactionRecordEvent”, “ConsumptionEvent”, “TransactionRecordEvent”, “SetMealQuery”


(searching consumption set meals), “ConsumptionStatusQuery” (searching the consumption status), “humanBodyComparison”-->mixedTargetDetection
</type>
<minorAlarm>
<!--opt, string, alarm sub type, desc:see details in macro definition of uploaded events. “IDCardInfoEvent” is required when the type of event is
"AccessControllerEvent"-->0x400,0x401,0x402,0x403
</minorAlarm>
<minorException>
<!--opt, string, exception sub type, desc:see details in macro definition of uploaded events. “IDCardInfoEvent” is required when the type of event
is "AccessControllerEvent"-->0x400,0x401,0x402,0x403
</minorException>
<minorOperation>
<!--opt, string, operation sub type, desc:see details in macro definition of uploaded events. “IDCardInfoEvent” is required when the type of event
is "AccessControllerEvent"-->0x400,0x401,0x402,0x403
</minorOperation>
<minorEvent>
<!--opt, string, event sub type, desc:see details in macro definition of uploaded events. “IDCardInfoEvent” is required when the type of event is
"AccessControllerEvent"-->0x01,0x02,0x03,0x04
</minorEvent>
<pictureURLType>
<!--opt, enum, alarm picture format of the specified event, subType:string, desc:“binary”, “localURL”, “cloudStorageURL”, “EZVIZURL”-->binary
</pictureURLType>
<channels>
<!--opt, string, listen to the events on the specified channel No. list, desc:if all channels are being listened to, the node shall not be
applied. if some channels are being listened to, the channel No. shall be listed and separated by commas-->1,2,3,4
</channels>
</Event>
</EventList>
<channels>
<!--opt, string, listen to the specified channel No. list, desc:if all channels are being listened to, the node shall not be applied. if some channels
are being listened to, the channel No. shall be listed and separated by commas-->1,2,3,4
</channels>
<pictureURLType>
<!--opt, enum, alarm picture format, subType:string, desc:the node indicates the picture types of all events which contain pictures to be uploaded. if
the node is applied, the pictureURLType of the Event will not take effect. if the node is not applied, the pictures reported from the device by default
mode: the default data type of uploaded pictures captured from front-end devices is binary. the default data type of uploaded pictures reported from storage
devices is local URL of the device. “binary”, “localURL”, “cloudStorageURL”, “EZVIZURL”-->binary
</pictureURLType>
<ChangedUploadSub>
<!--opt, object, subscribe to messages-->
<interval>
<!--opt, int, the lifecycle of arm GUID, desc:if GUID is not reconnected in the internal, a new GUID will be generated since the device start a new
arm period-->5
</interval>
<StatusSub>
<!--opt, object, sub status-->
<all>
<!--opt, bool, subscribe to all?-->true
</all>
<channel>
<!--opt, bool, subscribe to channel status, desc:reporting is not required if all is true-->true
</channel>
<hd>
<!--opt, bool, subscribe to HDD status, desc:reporting is not required if all is true-->true
</hd>
<capability>
<!--opt, bool, subscribe to changing status of capability set, desc:reporting is not required if all is true-->true
</capability>
</StatusSub>
</ChangedUploadSub>
</SubscribeEvent>
<PackingSpaceRecognition>
<!--opt, object, current control parameters of event listened by parking space detector on the security control panel, desc:related event:
PackingSpaceRecognition-->
<upLoadPicturesType>
<!--req, enum, uploaded picture type, subType:string, desc:“all”, “picturesTypes” (upload specified types of pictures), “notUpload” (not upload
pictures)-->all
</upLoadPicturesType>
<PicturesTypes>
<!--opt, array, specified list of uploaded picture type, subType:object, dep:and,
{$.HttpHostNotification.PackingSpaceRecognition.upLoadPicturesType,eq,picturesTypes}-->
<picturesType>
<!--opt, enum, Uploaded Picture Type, subType:string, desc:“backgroundImage” (captured background picture), “plateImage” (license plate close-up)-
>backgroundImage
</picturesType>
</PicturesTypes>
</PackingSpaceRecognition>
</HttpHostNotification>
Response Message


<?xml version="1.0" encoding="UTF-8"?>
<ResponseStatus xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--ro, req, object, response message, attr:version{ro, req, string, protocolVersion}-->
<requestURL>
<!--ro, req, string, request URL-->null
</requestURL>
<statusCode>
<!--ro, req, enum, status code, subType:int, desc:0 (OK), 1 (OK), 2 (Device Busy), 3 (Device Error), 4 (Invalid Operation), 5 (Invalid XML Format), 6
(Invalid XML Content), 7 (Reboot Required)-->0
</statusCode>
<statusString>
<!--ro, req, enum, status description, subType:string, desc:“OK” (succeeded), “Device Busy”, “Device Error”, “Invalid Operation”, “Invalid XML Format”,
“Invalid XML Content”, “Reboot” (reboot device)-->OK
</statusString>
<subStatusCode>
<!--ro, req, string, sub status code, desc:sub status code-->OK
</subStatusCode>
</ResponseStatus>
21.10.2 Get parameters of all listening hosts
Request URL
GET /ISAPI/Event/notification/httpHosts?security=<security>&iv=<iv>
Query Parameter
Parameter Name Parameter Type Description
security
string
iv
string
Request Message
None
Response Message
<?xml version="1.0" encoding="UTF-8"?>
<HttpHostNotificationList xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--ro, req, array, listening host list, subType:object, attr:version{req, string, protocolVersion}-->
<HttpHostNotification>
<!--ro, opt, object, listening host-->
<id>
<!--ro, req, string, subscribe to ID, range:[1,10]-->test
</id>
<url>
<!--ro, req, string, URL-->test
</url>
<protocolType>
<!--ro, req, enum, protocol type, subType:string, desc:"HTTP", "HTTPS", "EHome" (ISUP)-->HTTP
</protocolType>
<parameterFormatType>
<!--ro, req, enum, parameter format type, subType:string, desc:“JSON”, “XML”-->JSON
</parameterFormatType>
<addressingFormatType>
<!--ro, req, enum, address type, subType:string, desc:“hostname”, “ipaddress”-->hostname
</addressingFormatType>
<hostName>
<!--ro, opt, string, host name-->test
</hostName>
<ipAddress>
<!--ro, opt, string, IP address-->test
</ipAddress>
<ipv6Address>
<!--ro, opt, string, IPv6 Address-->test
</ipv6Address>
<portNo>
<!--ro, opt, int, port number-->1
</portNo>
<userName>
<!--ro, opt, string, user name-->test
</userName>
<password>
<!--ro, opt, string, password-->test
</password>
<httpAuthenticationMethod>
<!--ro, req, enum, authentication method, subType:string, desc:“MD5digest” (MD5), “none”, “base64”-->MD5digest
</httpAuthenticationMethod>
<ANPR>
<!--ro, opt, object, ANPR-->
<detectionUpLoadPicturesType>
-
-


<detectionUpLoadPicturesType>
<!--ro, opt, enum, uploaded pictures type, subType:string, desc:“all”, “licensePlatePicture”, “detectionPicture” (detected picture)-->all
</detectionUpLoadPicturesType>
</ANPR>
<Extensions>
<!--ro, opt, object, range-->
<intervalBetweenEvents>
<!--ro, opt, int, event interval-->1
</intervalBetweenEvents>
</Extensions>
<uploadImagesDataType>
<!--ro, opt, enum, picture data type, subType:string, desc:the default data type is binary. for cloud storage, only “URL” is supported. “URL”,
“binary”-->URL
</uploadImagesDataType>
<httpBroken>
<!--ro, opt, bool, whether to enable the automatic network replenishment, desc:if the ANR function is enabled, it will be applied to all events-->true
</httpBroken>
<SubscribeEvent>
<!--ro, opt, object, picture uploading modes of all events which contain pictures-->
<heartbeat>
<!--ro, opt, int, heartbeat interval time-->30
</heartbeat>
<eventMode>
<!--ro, req, enum, event mode, subType:string, desc:“all” (all alarms need to be reported), “list” (only listed alarms need to be reported)-->all
</eventMode>
<EventList>
<!--ro, opt, array, event list, subType:object-->
<Event>
<!--ro, opt, object, channel information linked to event-->
<type>
<!--ro, req, enum, event type, subType:string, desc:see details in event types: “ADAS” (advanced driving assistance system), “ADASAlarm”
(advanced driving assistance alarm), “AID” (traffic incident detection), “ANPR” (automatic number plate recognition), “AccessControllerEvent”, “CDsStatus”,
“DBD” (driving behavior detection) “GPSUpload”, “HFPD” (frequently appeared person), “IO” (I/O Alarm), “IOTD”, “LES”, “LFPD” (low frequency person
detection), “PALMismatch”, “PIR”, “PeopleCounting”, “PeopleNumChange”, “Standup” (standing up detection), “TMA” (thermometry alarm), “TMPA” (temperature
measurement pre-alarm), “VMD” (motion detection), “abnormalAcceleration”, “abnormalDriving”, “advReachHeight”, ”alarmResult”, “attendance”,
“attendedBaggage”, “audioAbnormal”, “audioexception”, “behaviorResult” (behavior analysis), “blindSpotDetection” (blind spot detection alarm), “cardMatch”,
“changedStatus”, “collision”, “containerDetection”, “crowdSituationAnalysis”, “databaseException”, “defocus” (defocus detection), “diskUnformat” (disk
unformatted), “diskerror”, “diskfull”, “driverConditionMonitor” (driver status monitoring alarm); “emergencyAlarm", “faceCapture”, “faceSnapModeling”,
“facedetection”, “failDown” (People Falling Down), “faultAlarm”, “fielddetection” (intrusion detection), “fireDetection”, “fireEscapeDetection”,
“flowOverrun”, “framesPeopleCounting”, “getUp” (getting up detection), “group” (people gathering), “hdBadBlock”(HDD bad sector detection event), “hdImpact”
(HDD impact detection event), “heatmap” (heat map alarm), “highHDTemperature” (HDD high temperature detection event), “highTempAlarm” (HDD high temperature
alarm), “hotSpare” (hot spare exception), “illaccess” (invalid access), “ipcTransferAbnormal”, “ipconflict” (IP address conflicts), “keyPersonGetUp” (key
person getting up detection), “leavePosition” (absence detection), “linedetection” (line crossing detection), “listSyncException” (list synchronization
exception), “loitering” (loitering detection), “lowHDTemperature” (HDD low temperature detection event), “mixedTargetDetection” (multi-target-type
detection), “modelError”, “nicbroken” (network disconnected), “nodeOffline” (node disconnected), “nonPoliceIntrusion”, “overSpeed” (overspeed alarm),
“overtimeTarry” (staying overtime detection), “parking” (parking detection), “peopleNumChange”, “peopleNumCounting”, “personAbnormalAlarm” (person ID
exception alarm), “personDensityDetection”, “personQueueCounting”, “personQueueDetection”, “personQueueRealTime” (real-time data of people queuing-up
detection), “personQueueTime” (waiting time detection), “playCellphone” (playing mobile phone detection), “pocException” (video exception), “poe” (POE power
exception), “policeAbsent”, “radarAlarm”, “radarFieldDetection”, “radarLineDetection”, “radarPerimeterRule” (radar rule data), “radarTargetDetection”,
“radarVideoDetection” (radar-assisted target detection), “raidException”, “rapidMove”, “reachHeight” (climbing detection), “recordCycleAbnormal”
(insufficient recording period), “recordException”, “regionEntrance”, “regionExiting”, “retention” (people overstay detection), “rollover”, “running”
(people running), “safetyHelmetDetection” (hard hat detection), “scenechangedetection”, “sensorAlarm” (angular acceleration alarm), “severeHDFailure” (HDD
major fault detection), “shelteralarm” (video tampering alarm), “shipsDetection”, “sitQuietly” (sitting detection), “smokeAndFireDetection”,
“smokeDetection”, “softIO”, “spacingChange” (distance exception), “sysStorFull” (storaging full alarm of cluster system), “takingElevatorDetection”
(elevator electric moped detection), “targetCapture”, “temperature” (temperature difference alarm), “thermometry” (temperature alarm),
“thirdPartyException”, “toiletTarry” (in-toilet overtime detection), “tollCodeInfo” (QR code information report), “tossing” (thrown object detection),
“unattendedBaggage”, “vehicleMatchResult” (uploading list alarms), “vehicleRcogResult”, “versionAbnormal” (cluster version exception), “videoException”,
“videoloss”, “violationAlarm”, “violentMotion” (violent motion detection), “yardTarry” (playground overstay detection), “AccessControllerEvent”,
“IDCardInfoEvent”, “FaceTemperatureMeasurementEvent” , “QRCodeEvent” (QR code event of access control), “CertificateCaptureEvent” (person ID capture
comparison event), “UncertificateCompareEvent”, “ConsumptionAndTransactionRecordEvent”, “ConsumptionEvent”, “TransactionRecordEvent”, “SetMealQuery”
(searching consumption set meals), “ConsumptionStatusQuery” (searching the consumption status), “humanBodyComparison”-->mixedTargetDetection
</type>
<minorAlarm>
<!--ro, opt, string, alarm sub type, desc:see details in macro definition of uploaded events. “IDCardInfoEvent” is required when the type of
event is "AccessControllerEvent"-->0x400,0x401,0x402,0x403
</minorAlarm>
<minorException>
<!--ro, opt, string, exception sub type, desc:see details in macro definition of uploaded events. “IDCardInfoEvent” is required when the type of
event is "AccessControllerEvent"-->0x400,0x401,0x402,0x403
</minorException>
<minorOperation>
<!--ro, opt, string, operation sub type, desc:see details in macro definition of uploaded events. “IDCardInfoEvent” is required when the type of
event is "AccessControllerEvent"-->0x400,0x401,0x402,0x403
</minorOperation>
<minorEvent>
<!--ro, opt, string, event sub type, desc:see details in macro definition of uploaded events. “IDCardInfoEvent” is required when the type of
event is "AccessControllerEvent"-->0x01,0x02,0x03,0x04
</minorEvent>
<pictureURLType>
<!--ro, opt, enum, alarm picture format of the specified event, subType:string, desc:alarm picture format of the specified event-->binary
</pictureURLType>
<channels>
<!--ro, opt, string, listen to the events on the specified channel No. list, desc:if all channels are being listened to, the node shall not be
applied. if some channels are being listened to, the channel No. shall be listed and separated by commas-->1,2,3,4
</channels>
</Event>
</EventList>
<channels>
<!--ro, opt, string, listen to the specified channel No. list, desc:if all channels are being listened to, the node shall not be applied. if some
channels are being listened to, the channel No. shall be listed and separated by commas-->1,2,3,4
</channels>
<pictureURLType>
<!--ro, opt, enum, alarm picture format, subType:string, desc:the node indicates the picture types of all events which contain pictures to be
uploaded. if the node is applied, the pictureURLType of the Event will not take effect. if the node is not applied, the pictures reported from the device by


uploaded. if the node is applied, the pictureURLType of the Event will not take effect. if the node is not applied, the pictures reported from the device by
default mode: the default data type of uploaded pictures captured from front-end devices is binary. the default data type of uploaded pictures reported from
storage devices is local URL of the device.-->binary
</pictureURLType>
<ChangedUploadSub>
<!--ro, opt, object, subscribe to messages-->
<interval>
<!--ro, opt, int, the lifecycle of arm GUID, desc:if GUID is not reconnected in the internal, a new GUID will be generated since the device start
a new arm period-->5
</interval>
<StatusSub>
<!--ro, opt, object, sub status-->
<all>
<!--ro, opt, bool, subscribe to all?-->true
</all>
<channel>
<!--ro, opt, bool, subscribe to channel status, desc:reporting is not required if all is true-->true
</channel>
<hd>
<!--ro, opt, bool, subscribe to HDD status, desc:reporting is not required if all is true-->true
</hd>
<capability>
<!--ro, opt, bool, subscribe to changing status of capability set, desc:reporting is not required if all is true-->true
</capability>
</StatusSub>
</ChangedUploadSub>
</SubscribeEvent>
<PackingSpaceRecognition>
<!--ro, req, object, current control parameters of event listened by parking space detector on the security control panel, desc:related event:
PackingSpaceRecognition-->
<upLoadPicturesType>
<!--ro, opt, enum, uploaded picture type, subType:string, desc:“all”, “picturesTypes” (upload specified types of pictures), “notUpload” (not upload
pictures)-->all
</upLoadPicturesType>
<PicturesTypes>
<!--ro, opt, array, specified list of uploaded picture type, subType:object, dep:and,
{$.HttpHostNotificationList[*].HttpHostNotification.PackingSpaceRecognition.upLoadPicturesType,eq,picturesTypes}-->
<picturesType>
<!--ro, opt, enum, uploaded picture type, subType:string, desc:“backgroundImage” (captured background picture), “plateImage” (license plate closeup)-->backgroundImage
</picturesType>
</PicturesTypes>
</PackingSpaceRecognition>
</HttpHostNotification>
</HttpHostNotificationList>
21.10.3
Set IP address of receiving server(s)
Request URL
PUT /ISAPI/Event/notification/httpHosts?security=<security>&iv=<iv>
Query Parameter
Parameter Name Parameter Type Description
security
string
iv
Request Message
<?xml version="1.0" encoding="UTF-8"?>
<HttpHostNotificationList xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--req, array, listening host list, subType:object, attr:version{req, string, protocolVersion}-->
<HttpHostNotification>
<!--opt, object, listening host-->
<id>
<!--req, string, ID-->test
</id>
<url>
<!--req, string, URL-->test
</url>
<protocolType>
<!--req, enum, protocol type, subType:string, desc:"HTTP", "HTTPS", "EHome"-->HTTP
</protocolType>
<parameterFormatType>
<!--req, enum, parameter format type, subType:string, desc:"JSON", "XML"-->JSON
</parameterFormatType>
<addressingFormatType>
<!--req, enum, address types, subType:string, desc:"hostname" (host name), "ipaddress" (ip address)-->hostname
</addressingFormatType>
<hostName>
<!--opt, string, host name-->test
</hostName>
<ipAddress>
string
-
-


<!--opt, string, IP address-->test
</ipAddress>
<ipv6Address>
<!--opt, string, IPv6 address-->test
</ipv6Address>
<portNo>
<!--opt, int, port No.-->1
</portNo>
<userName>
<!--opt, string, user name-->test
</userName>
<password>
<!--opt, string, password-->test
</password>
<httpAuthenticationMethod>
<!--req, enum, authentication method, subType:string, desc:"MD5digest" (MD5), "none"-->MD5digest
</httpAuthenticationMethod>
<ANPR>
<!--opt, object, ANPR-->
<detectionUpLoadPicturesType>
<!--opt, enum, uploaded pictures type, subType:string, desc:uploaded pictures type-->all
</detectionUpLoadPicturesType>
</ANPR>
<Extensions>
<!--opt, object, range-->
<intervalBetweenEvents>
<!--opt, int, event interval-->1
</intervalBetweenEvents>
</Extensions>
<uploadImagesDataType>
<!--opt, enum, picture data type, subType:string, desc:picture data type-->URL
</uploadImagesDataType>
<httpBroken>
<!--opt, bool, whether to enable the automatic network replenishment, desc:if the ANR function is enabled, it will be applied to all events-->true
</httpBroken>
<SubscribeEvent>
<!--opt, object, picture uploading modes of all events which contain pictures-->
<heartbeat>
<!--opt, int, heartbeat interval-->30
</heartbeat>
<eventMode>
<!--req, enum, event mode, subType:string, desc:event mode-->all
</eventMode>
<EventList>
<!--opt, array, event list, subType:object-->
<Event>
<!--opt, object, channel information linked to event-->
<type>
<!--req, enum, event type, subType:string, desc:event type-->mixedTargetDetection
</type>
<minorAlarm>
<!--opt, string, minor alarm type, desc:see details in macro definition of uploaded events. "IDCardInfoEvent" is required when the type of event
is "AccessControllerEvent"-->0x400,0x401,0x402,0x403
</minorAlarm>
<minorException>
<!--opt, string, minor exception type, desc:see details in macro definition of uploaded events. "IDCardInfoEvent" is required when the type of
event is "AccessControllerEvent"-->0x400,0x401,0x402,0x403
</minorException>
<minorOperation>
<!--opt, string, minor operation type, desc:see details in macro definition of uploaded events. "IDCardInfoEvent" is required when the type of
event is "AccessControllerEvent"-->0x400,0x401,0x402,0x403
</minorOperation>
<minorEvent>
<!--opt, string, minor event type, desc:see details in macro definition of uploaded events. "IDCardInfoEvent" is required when the type of event
is "AccessControllerEvent"-->0x01,0x02,0x03,0x04
</minorEvent>
<pictureURLType>
<!--opt, enum, alarm picture format, subType:string, desc:alarm picture format of the specified event-->binary
</pictureURLType>
<channels>
<!--opt, string, channel No.-->1,2,3,4
</channels>
</Event>
</EventList>
<channels>
<!--opt, string, listen to the specified channel No. list, desc:listen to the specified channel No. list-->1,2,3,4
</channels>
<pictureURLType>
<!--opt, enum, alarm picture format, subType:string, desc:"binary" (binary), "localURL" (device local URL), "cloudStorageURL" (cloud storage URL)-
>binary
</pictureURLType>
<ChangedUploadSub>
<!--opt, object, subscribe to messages-->
<interval>
<!--opt, int, the lifecycle of arm GUID, desc:if GUID is not reconnected in the internal, a new GUID will be generated since the device starts a
new arm period-->5
</interval>
<StatusSub>
<!--opt, object, sub status-->
<all>
<!--opt, bool, whether to subscribe to all-->true
</all>
<channel>
<!--opt, bool, status of subscribed channels, desc:reporting is not required if all is true-->true


<!--opt, bool, status of subscribed channels, desc:reporting is not required if all is true-->true
</channel>
<hd>
<!--opt, bool, subscribe to HDD status, desc:reporting is not required if all is true-->true
</hd>
<capability>
<!--opt, bool, subscribe to changing status of capability set, desc:reporting is not required if all is true-->true
</capability>
</StatusSub>
</ChangedUploadSub>
</SubscribeEvent>
<PackingSpaceRecognition>
<!--opt, object, current control parameters of event listened by parking space detector on the security control panel, desc:related event:
PackingSpaceRecognition-->
<upLoadPicturesType>
<!--req, enum, uploaded picture type, subType:string, desc:uploaded picture type-->all
</upLoadPicturesType>
<PicturesTypes>
<!--opt, array, specified list of uploaded picture types, subType:object, dep:and,
{$.HttpHostNotificationList[*].HttpHostNotification.PackingSpaceRecognition.upLoadPicturesType,eq,picturesTypes}-->
<picturesType>
<!--opt, enum, uploaded picture type, subType:string, desc:"backgroundImage" (captured background picture), "plateImage" (license plate close-up)->backgroundImage
</picturesType>
</PicturesTypes>
</PackingSpaceRecognition>
</HttpHostNotification>
</HttpHostNotificationList>
Response
Message
<?xml version="1.0" encoding="UTF-8"?>
<ResponseStatus xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--ro, req, object, response message, attr:version{ro, req, string, protocolVersion}-->
<requestURL>
<!--ro, req, string, request URL-->null
</requestURL>
<statusCode>
<!--ro, req, enum, status code, subType:int, desc:0 (OK), 1 (OK), 2 (Device Busy), 3 (Device Error), 4 (Invalid Operation), 5 (Invalid XML Format), 6
(Invalid XML Content), 7 (Reboot Required)-->0
</statusCode>
<statusString>
<!--ro, req, enum, status description, subType:string, desc:"OK" (succeeded), "Device Busy", "Device Error", "Invalid Operation", "Invalid XML Format",
"Invalid XML Content", "Reboot" (reboot device)-->OK
</statusString>
<subStatusCode>
<!--ro, req, string, sub status code, which describes the error in details, desc:sub status code, which describes the error in details-->OK
</subStatusCode>
</ResponseStatus>
21.10.4 Get the parameters of a listening host
Request URL
GET /ISAPI/Event/notification/httpHosts/<hostID>?security=<security>&iv=<iv>
Query Parameter
Parameter Name Parameter Type Description
hostID
string
security
iv
string
string
Request Message
None
Response Message
<?xml version="1.0" encoding="UTF-8"?>
<HttpHostNotification xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--ro, req, object, listening host, attr:version{req, string, protocolVersion}-->
<id>
<!--ro, req, string, listening host ID, range:[1,10]-->test
</id>
<url>
<!--ro, req, string, URL-->test
</url>
-
-
-


<protocolType>
<!--ro, req, enum, protocol type, subType:string, desc:"HTTP", "HTTPS", "EHome"-->HTTP
</protocolType>
<parameterFormatType>
<!--ro, req, enum, parameter format type, subType:string, desc:“JSON”, “XML”-->JSON
</parameterFormatType>
<addressingFormatType>
<!--ro, req, enum, address type, subType:string, desc:“hostname”, “ipaddress”-->hostname
</addressingFormatType>
<hostName>
<!--ro, opt, string, host name-->test
</hostName>
<ipAddress>
<!--ro, opt, string, IP address-->test
</ipAddress>
<ipv6Address>
<!--ro, opt, string, IPv6 address-->test
</ipv6Address>
<portNo>
<!--ro, opt, int, port number-->1
</portNo>
<userName>
<!--ro, opt, string, user name-->test
</userName>
<httpAuthenticationMethod>
<!--ro, req, enum, authentication method, subType:string, desc:“MD5digest” (MD5), “none”, “base64”-->MD5digest
</httpAuthenticationMethod>
<ANPR>
<!--ro, opt, object, ANPR-->
<detectionUpLoadPicturesType>
<!--ro, opt, enum, uploaded pictures type, subType:string, desc:“all”, “licensePlatePicture”, “detectionPicture” (detected picture)-->all
</detectionUpLoadPicturesType>
</ANPR>
<Extensions>
<!--ro, opt, object, range-->
<intervalBetweenEvents>
<!--ro, opt, int, event interval-->1
</intervalBetweenEvents>
</Extensions>
<uploadImagesDataType>
<!--ro, opt, enum, picture data type, subType:string, desc:the default data type is binary. for cloud storage, only “URL” is supported. “URL”, “binary”->URL
</uploadImagesDataType>
<httpBroken>
<!--ro,
opt, bool, whether to enable the automatic network replenishment, desc:if the ANR function is enabled, it will be applied to all events-->true
</httpBroken>
<SubscribeEvent>
<!--ro, opt, object, picture uploading modes of all events which contain pictures-->
<heartbeat>
<!--ro, opt, int, heartbeat interval time-->30
</heartbeat>
<eventMode>
<!--ro, req, enum, event mode, subType:string, desc:“all” (all alarms need to be reported), “list” (only listed alarms need to be reported)-->all
</eventMode>
<EventList>
<!--ro, opt, array, event list, subType:object-->
<Event>
<!--ro, opt, object, channel information linked to event-->
<type>
<!--ro, req, enum, event type, subType:string, desc:see details in event types: “ADAS” (advanced driving assistance system), “ADASAlarm” (advanced
driving assistance alarm), “AID” (traffic incident detection), “ANPR” (automatic number plate recognition), “AccessControllerEvent”, “CDsStatus”, “DBD”
(driving behavior detection) “GPSUpload”, “HFPD” (frequently appeared person), “IO” (I/O Alarm), “IOTD”, “LES”, “LFPD” (low frequency person detection),
“PALMismatch”, “PIR”, “PeopleCounting”, “PeopleNumChange”, “Standup” (standing up detection), “TMA” (thermometry alarm), “TMPA” (temperature measurement
pre-alarm), “VMD” (motion detection), “abnormalAcceleration”, “abnormalDriving”, “advReachHeight”, ”alarmResult”, “attendance”, “attendedBaggage”,
“audioAbnormal”, “audioexception”, “behaviorResult” (behavior analysis), “blindSpotDetection” (blind spot detection alarm), “cardMatch”, “changedStatus”,
“collision”, “containerDetection”, “crowdSituationAnalysis”, “databaseException”, “defocus” (defocus detection), “diskUnformat” (disk unformatted),
“diskerror”, “diskfull”, “driverConditionMonitor” (driver status monitoring alarm); “emergencyAlarm", “faceCapture”, “faceSnapModeling”, “facedetection”,
“failDown” (People Falling Down), “faultAlarm”, “fielddetection” (intrusion detection), “fireDetection”, “fireEscapeDetection”, “flowOverrun”,
“framesPeopleCounting”, “getUp” (getting up detection), “group” (people gathering), “hdBadBlock”(HDD bad sector detection event), “hdImpact” (HDD impact
detection event), “heatmap” (heat map alarm), “highHDTemperature” (HDD high temperature detection event), “highTempAlarm” (HDD high temperature alarm),
“hotSpare” (hot spare exception), “illaccess” (invalid access), “ipcTransferAbnormal”, “ipconflict” (IP address conflicts), “keyPersonGetUp” (key person
getting up detection), “leavePosition” (absence detection), “linedetection” (line crossing detection), “listSyncException” (list synchronization exception),
“loitering” (loitering detection), “lowHDTemperature” (HDD low temperature detection event), “mixedTargetDetection” (multi-target-type detection),
“modelError”, “nicbroken” (network disconnected), “nodeOffline” (node disconnected), “nonPoliceIntrusion”, “overSpeed” (overspeed alarm), “overtimeTarry”
(staying overtime detection), “parking” (parking detection), “peopleNumChange”, “peopleNumCounting”, “personAbnormalAlarm” (person ID exception alarm),
“personDensityDetection”, “personQueueCounting”, “personQueueDetection”, “personQueueRealTime” (real-time data of people queuing-up detection),
“personQueueTime” (waiting time detection), “playCellphone” (playing mobile phone detection), “pocException” (video exception), “poe” (POE power exception),
“policeAbsent”, “radarAlarm”, “radarFieldDetection”, “radarLineDetection”, “radarPerimeterRule” (radar rule data), “radarTargetDetection”,
“radarVideoDetection” (radar-assisted target detection), “raidException”, “rapidMove”, “reachHeight” (climbing detection), “recordCycleAbnormal”
(insufficient recording period), “recordException”, “regionEntrance”, “regionExiting”, “retention” (people overstay detection), “rollover”, “running”
(people running), “safetyHelmetDetection” (hard hat detection), “scenechangedetection”, “sensorAlarm” (angular acceleration alarm), “severeHDFailure” (HDD
major fault detection), “shelteralarm” (video tampering alarm), “shipsDetection”, “sitQuietly” (sitting detection), “smokeAndFireDetection”,
“smokeDetection”, “softIO”, “spacingChange” (distance exception), “sysStorFull” (storaging full alarm of cluster system), “takingElevatorDetection”
(elevator electric moped detection), “targetCapture”, “temperature” (temperature difference alarm), “thermometry” (temperature alarm),
“thirdPartyException”, “toiletTarry” (in-toilet overtime detection), “tollCodeInfo” (QR code information report), “tossing” (thrown object detection),
“unattendedBaggage”, “vehicleMatchResult” (uploading list alarms), “vehicleRcogResult”, “versionAbnormal” (cluster version exception), “videoException”,
“videoloss”, “violationAlarm”, “violentMotion” (violent motion detection), “yardTarry” (playground overstay detection), “AccessControllerEvent”,
“IDCardInfoEvent”, “FaceTemperatureMeasurementEvent” , “QRCodeEvent” (QR code event of access control), “CertificateCaptureEvent” (person ID capture
comparison event), “UncertificateCompareEvent”, “ConsumptionAndTransactionRecordEvent”, “ConsumptionEvent”, “TransactionRecordEvent”, “SetMealQuery”
(searching consumption set meals), “ConsumptionStatusQuery” (searching the consumption status), “humanBodyComparison”-->mixedTargetDetection
</type>
<minorAlarm>
<!--ro, opt, string, alarm sub type, desc:see details in macro definition of uploaded events. “IDCardInfoEvent” is required when the type of event
is "AccessControllerEvent"-->0x400,0x401,0x402,0x403


is "AccessControllerEvent"-->0x400,0x401,0x402,0x403
</minorAlarm>
<minorException>
<!--ro, opt, string, exception sub type, desc:see details in macro definition of uploaded events. “IDCardInfoEvent” is required when the type of
event is "AccessControllerEvent"-->0x400,0x401,0x402,0x403
</minorException>
<minorOperation>
<!--ro, opt, string, operation sub type, desc:see details in macro definition of uploaded events. “IDCardInfoEvent” is required when the type of
event is "AccessControllerEvent"-->0x400,0x401,0x402,0x403
</minorOperation>
<minorEvent>
<!--ro, opt, string, event sub type, desc:see details in macro definition of uploaded events. “IDCardInfoEvent” is required when the type of event
is "AccessControllerEvent"-->0x01,0x02,0x03,0x04
</minorEvent>
<pictureURLType>
<!--ro, opt, enum, alarm picture format of the specified event, subType:string, desc:alarm picture format of the specified event-->binary
</pictureURLType>
<channels>
<!--ro, opt, string, listen to the events on the specified channel No. list, desc:if all channels are being listened to, the node shall not be
applied. if some channels are being listened to, the channel No. shall be listed and separated by commas-->1,2,3,4
</channels>
</Event>
</EventList>
<channels>
<!--ro, opt, string, listen to the specified channel No. list, desc:if all channels are being listened to, the node shall not be applied. if some
channels are being listened to, the channel No. shall be listed and separated by commas-->1,2,3,4
</channels>
<pictureURLType>
<!--ro, opt, enum, alarm picture format, subType:string, desc:the node indicates the picture types of all events which contain pictures to be
uploaded. if the node is applied, the pictureURLType of the Event will not take effect. if the node is not applied, the pictures reported from the device by
default mode: the default data type of uploaded pictures captured from front-end devices is binary. the default data type of uploaded pictures reported from
storage devices is local URL of the device.-->binary
</pictureURLType>
<ChangedUploadSub>
<!--ro, opt, object, subscribe to messages-->
<interval>
<!--ro, opt, int, the lifecycle of arm GUID, desc:if GUID is not reconnected in the internal, a new GUID will be generated since the device start a
new arm period-->5
</interval>
<StatusSub>
<!--ro, opt, object, sub status-->
<all>
<!--ro, opt, bool, subscribe to all?-->true
</all>
<channel>
<!--ro, opt, bool, subscribe to channel status, desc:reporting is not required if all is true-->true
</channel>
<hd>
<!--ro, opt, bool, subscribe to HDD status, desc:reporting is not required if all is true-->true
</hd>
<capability>
<!--ro, opt, bool, subscribe to changing status of capability set, desc:reporting is not required if all is true-->true
</capability>
</StatusSub>
</ChangedUploadSub>
</SubscribeEvent>
<PackingSpaceRecognition>
<!--ro, opt, object, current control parameters of event listened by parking space detector on the security control panel, desc:related event:
PackingSpaceRecognition-->
<upLoadPicturesType>
<!--ro, req, enum, uploaded picture type, subType:string, desc:“all”, “picturesTypes” (upload specified types of pictures), “notUpload” (not upload
pictures)-->all
</upLoadPicturesType>
<PicturesTypes>
<!--ro, opt, array, specified list of uploaded picture type, subType:object, dep:and,
{$.HttpHostNotification.PackingSpaceRecognition.upLoadPicturesType,eq,picturesTypes}-->
<picturesType>
<!--ro, opt, enum, uploaded picture type, subType:string, desc:“backgroundImage” (captured background picture), “plateImage” (license plate closeup)-->backgroundImage
</picturesType>
</PicturesTypes>
</PackingSpaceRecognition>
</HttpHostNotification>
21.10.5
Set the parameters of a listening host
Request URL
PUT /ISAPI/Event/notification/httpHosts/<hostID>?security=<security>&iv=<iv>
Query Parameter


Parameter Name Parameter Type Description
hostID
string
security
iv
Request Message
<?xml version="1.0" encoding="UTF-8"?>
<HttpHostNotification xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--req, object, listening host, attr:version{req, string, protocolVersion}-->
<id>
<!--req, string, listening host ID, range:[1,10]-->test
</id>
<url>
<!--req, string, URL-->test
</url>
<protocolType>
<!--req, enum, protocol type, subType:string, desc:"HTTP", "HTTPS", "EHome" (ISUP)-->HTTP
</protocolType>
<parameterFormatType>
<!--req, enum, parameter format type, subType:string, desc:“JSON”, “XML”-->JSON
</parameterFormatType>
<addressingFormatType>
<!--req, enum, address type, subType:string, desc:“hostname”, “ipaddress”-->hostname
</addressingFormatType>
<hostName>
<!--opt, string, host name-->test
</hostName>
<ipAddress>
<!--opt, string, IP address-->test
</ipAddress>
<ipv6Address>
<!--opt, string, IPv6 Address-->test
</ipv6Address>
<portNo>
<!--opt, int, port number-->1
</portNo>
<userName>
<!--opt, string, user name-->test
</userName>
<password>
<!--opt, string, password-->test
</password>
<httpAuthenticationMethod>
<!--req, enum, authentication method, subType:string, desc:“MD5digest” (MD5), “none”, “base64”-->MD5digest
</httpAuthenticationMethod>
<ANPR>
<!--opt, object, ANPR-->
<detectionUpLoadPicturesType>
<!--opt, enum, uploaded pictures type, subType:string, desc:“all”, “licensePlatePicture”, “detectionPicture” (detected picture)-->all
</detectionUpLoadPicturesType>
</ANPR>
<Extensions>
<!--opt, object, range-->
<intervalBetweenEvents>
<!--opt, int, event interval-->1
</intervalBetweenEvents>
</Extensions>
<uploadImagesDataType>
<!--opt, enum, picture data type, subType:string, desc:the default data type is binary. for cloud storage, only “URL” is supported. “URL”, “binary”-
>URL
</uploadImagesDataType>
<httpBroken>
<!--opt, bool, whether to enable the automatic network replenishment, desc:if the ANR function is enabled, it will be applied to all events-->true
</httpBroken>
<SubscribeEvent>
<!--opt, object, picture uploading modes of all events which contain pictures-->
<heartbeat>
<!--opt, int, Heartbeat Interval Time-->30
</heartbeat>
<eventMode>
<!--req, enum, event mode, subType:string, desc:“all” (all alarms need to be reported), “list” (only listed alarms need to be reported)-->all
</eventMode>
<EventList>
<!--opt, array, event list, subType:object-->
<Event>
<!--opt, object, channel information linked to event-->
<type>
<!--req, enum, event type, subType:string, desc:see details in event types: “ADAS” (advanced driving assistance system), “ADASAlarm” (advanced
driving assistance alarm), “AID” (traffic incident detection), “ANPR” (automatic number plate recognition), “AccessControllerEvent”, “CDsStatus”, “DBD”
(driving behavior detection) “GPSUpload”, “HFPD” (frequently appeared person), “IO” (I/O Alarm), “IOTD”, “LES”, “LFPD” (low frequency person detection),
“PALMismatch”, “PIR”, “PeopleCounting”, “PeopleNumChange”, “Standup” (standing up detection), “TMA” (thermometry alarm), “TMPA” (temperature measurement
pre-alarm), “VMD” (motion detection), “abnormalAcceleration”, “abnormalDriving”, “advReachHeight”, ”alarmResult”, “attendance”, “attendedBaggage”,
“audioAbnormal”, “audioexception”, “behaviorResult” (behavior analysis), “blindSpotDetection” (blind spot detection alarm), “cardMatch”, “changedStatus”,
“collision”, “containerDetection”, “crowdSituationAnalysis”, “databaseException”, “defocus” (defocus detection), “diskUnformat” (disk unformatted),
string
string
-
-
-


“collision”, “containerDetection”, “crowdSituationAnalysis”, “databaseException”, “defocus” (defocus detection), “diskUnformat” (disk unformatted),
“diskerror”, “diskfull”, “driverConditionMonitor” (driver status monitoring alarm); “emergencyAlarm", “faceCapture”, “faceSnapModeling”, “facedetection”,
“failDown” (People Falling Down), “faultAlarm”, “fielddetection” (intrusion detection), “fireDetection”, “fireEscapeDetection”, “flowOverrun”,
“framesPeopleCounting”, “getUp” (getting up detection), “group” (people gathering), “hdBadBlock”(HDD bad sector detection event), “hdImpact” (HDD impact
detection event), “heatmap” (heat map alarm), “highHDTemperature” (HDD high temperature detection event), “highTempAlarm” (HDD high temperature alarm),
“hotSpare” (hot spare exception), “illaccess” (invalid access), “ipcTransferAbnormal”, “ipconflict” (IP address conflicts), “keyPersonGetUp” (key person
getting up detection), “leavePosition” (absence detection), “linedetection” (line crossing detection), “listSyncException” (list synchronization exception),
“loitering” (loitering detection), “lowHDTemperature” (HDD low temperature detection event), “mixedTargetDetection” (multi-target-type detection),
“modelError”, “nicbroken” (network disconnected), “nodeOffline” (node disconnected), “nonPoliceIntrusion”, “overSpeed” (overspeed alarm), “overtimeTarry”
(staying overtime detection), “parking” (parking detection), “peopleNumChange”, “peopleNumCounting”, “personAbnormalAlarm” (person ID exception alarm),
“personDensityDetection”, “personQueueCounting”, “personQueueDetection”, “personQueueRealTime” (real-time data of people queuing-up detection),
“personQueueTime” (waiting time detection), “playCellphone” (playing mobile phone detection), “pocException” (video exception), “poe” (POE power exception),
“policeAbsent”, “radarAlarm”, “radarFieldDetection”, “radarLineDetection”, “radarPerimeterRule” (radar rule data), “radarTargetDetection”,
“radarVideoDetection” (radar-assisted target detection), “raidException”, “rapidMove”, “reachHeight” (climbing detection), “recordCycleAbnormal”
(insufficient recording period), “recordException”, “regionEntrance”, “regionExiting”, “retention” (people overstay detection), “rollover”, “running”
(people running), “safetyHelmetDetection” (hard hat detection), “scenechangedetection”, “sensorAlarm” (angular acceleration alarm), “severeHDFailure” (HDD
major fault detection), “shelteralarm” (video tampering alarm), “shipsDetection”, “sitQuietly” (sitting detection), “smokeAndFireDetection”,
“smokeDetection”, “softIO”, “spacingChange” (distance exception), “sysStorFull” (storaging full alarm of cluster system), “takingElevatorDetection”
(elevator electric moped detection), “targetCapture”, “temperature” (temperature difference alarm), “thermometry” (temperature alarm),
“thirdPartyException”, “toiletTarry” (in-toilet overtime detection), “tollCodeInfo” (QR code information report), “tossing” (thrown object detection),
“unattendedBaggage”, “vehicleMatchResult” (uploading list alarms), “vehicleRcogResult”, “versionAbnormal” (cluster version exception), “videoException”,
“videoloss”, “violationAlarm”, “violentMotion” (violent motion detection), “yardTarry” (playground overstay detection), “AccessControllerEvent”,
“IDCardInfoEvent”, “FaceTemperatureMeasurementEvent” , “QRCodeEvent” (QR code event of access control), “CertificateCaptureEvent” (person ID capture
comparison event), “UncertificateCompareEvent”, “ConsumptionAndTransactionRecordEvent”, “ConsumptionEvent”, “TransactionRecordEvent”, “SetMealQuery”
(searching consumption set meals), “ConsumptionStatusQuery” (searching the consumption status), “humanBodyComparison”-->mixedTargetDetection
</type>
<minorAlarm>
<!--opt, string, alarm sub type, desc:see details in macro definition of uploaded events. “IDCardInfoEvent” is required when the type of event is
"AccessControllerEvent"-->0x400,0x401,0x402,0x403
</minorAlarm>
<minorException>
<!--opt, string, exception sub type, desc:see details in macro definition of uploaded events. “IDCardInfoEvent” is required when the type of event
is "AccessControllerEvent"-->0x400,0x401,0x402,0x403
</minorException>
<minorOperation>
<!--opt, string, operation sub type, desc:see details in macro definition of uploaded events. “IDCardInfoEvent” is required when the type of event
is "AccessControllerEvent"-->0x400,0x401,0x402,0x403
</minorOperation>
<minorEvent>
<!--opt, string, event sub type, desc:see details in macro definition of uploaded events. “IDCardInfoEvent” is required when the type of event is
"AccessControllerEvent"-->0x01,0x02,0x03,0x04
</minorEvent>
<pictureURLType>
<!--opt, enum, alarm picture format of the specified event, subType:string, desc:“binary”, “localURL”, “cloudStorageURL”, “EZVIZURL”-->binary
</pictureURLType>
<channels>
<!--opt, string, listen to the events on the specified channel No. list, desc:if all channels are being listened to, the node shall not be
applied. if some channels are being listened to, the channel No. shall be listed and separated by commas-->1,2,3,4
</channels>
</Event>
</EventList>
<channels>
<!--opt, string, listen to the specified channel No. list, desc:if all channels are being listened to, the node shall not be applied. if some channels
are being listened to, the channel No. shall be listed and separated by commas-->1,2,3,4
</channels>
<pictureURLType>
<!--opt, enum, alarm picture format, subType:string, desc:the node indicates the picture types of all events which contain pictures to be uploaded. if
the node is applied, the pictureURLType of the Event will not take effect. if the node is not applied, the pictures reported from the device by default
mode: the default data type of uploaded pictures captured from front-end devices is binary. the default data type of uploaded pictures reported from storage
devices is local URL of the device. “binary”, “localURL”, “cloudStorageURL”, “EZVIZURL”-->binary
</pictureURLType>
<ChangedUploadSub>
<!--opt, object, subscribe to messages-->
<interval>
<!--opt, int, the lifecycle of arm GUID, desc:if GUID is not reconnected in the internal, a new GUID will be generated since the device start a new
arm period-->5
</interval>
<StatusSub>
<!--opt, object, sub status-->
<all>
<!--opt, bool, subscribe to all?-->true
</all>
<channel>
<!--opt, bool, subscribe to channel status, desc:reporting is not required if all is true-->true
</channel>
<hd>
<!--opt, bool, subscribe to HDD status, desc:reporting is not required if all is true-->true
</hd>
<capability>
<!--opt, bool, subscribe to changing status of capability set, desc:reporting is not required if all is true-->true
</capability>
</StatusSub>
</ChangedUploadSub>
</SubscribeEvent>
<PackingSpaceRecognition>
<!--opt, object, current control parameters of event listened by parking space detector on the security control panel, desc:related event:
PackingSpaceRecognition-->
<upLoadPicturesType>
<!--req, enum, uploaded picture type, subType:string, desc:“all”, “picturesTypes” (upload specified types of pictures), “notUpload” (not upload
pictures)-->all
</upLoadPicturesType>
<PicturesTypes>
<!--opt, array, specified list of uploaded picture type, subType:object, dep:and,
{$.HttpHostNotification.PackingSpaceRecognition.upLoadPicturesType,eq,picturesTypes}-->


{$.HttpHostNotification.PackingSpaceRecognition.upLoadPicturesType,eq,picturesTypes}-->
<picturesType>
<!--opt, enum, Uploaded Picture Type, subType:string, desc:“backgroundImage” (captured background picture), “plateImage” (license plate close-up)-
>backgroundImage
</picturesType>
</PicturesTypes>
</PackingSpaceRecognition>
</HttpHostNotification>
Response Message
<?xml version="1.0" encoding="UTF-8"?>
<ResponseStatus xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--ro, req, object, response message, attr:version{ro, req, string, protocolVersion}-->
<requestURL>
<!--ro, req, string, request URL-->null
</requestURL>
<statusCode>
<!--ro, req, enum, status code, subType:int, desc:0 (OK), 1 (OK), 2 (Device Busy), 3 (Device Error), 4 (Invalid Operation), 5 (Invalid XML Format), 6
(Invalid XML Content), 7 (Reboot Required)-->0
</statusCode>
<statusString>
<!--ro, req, enum, status description, subType:string, desc:“OK” (succeeded), “Device Busy”, “Device Error”, “Invalid Operation”, “Invalid XML Format”,
“Invalid XML Content”, “Reboot” (reboot device)-->OK
</statusString>
<subStatusCode>
<!--ro, req, string, sub status code, desc:sub status code-->OK
</subStatusCode>
</ResponseStatus>
21.10.6 Get the parameters of a listening host
Request URL
GET /ISAPI/Event/notification/httpHosts/<hostID>?security=<security>&iv=<iv>
Query Parameter
Parameter Name Parameter Type Description
hostID
string
security
iv
string
string
Request Message
None
Response Message
<?xml version="1.0" encoding="UTF-8"?>
<HttpHostNotification xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--ro, req, object, listening host, attr:version{req, string, protocolVersion}-->
<id>
<!--ro, req, string, listening host ID, range:[1,10]-->test
</id>
<url>
<!--ro, req, string, URL-->test
</url>
<protocolType>
<!--ro, req, enum, protocol type, subType:string, desc:"HTTP", "HTTPS", "EHome"-->HTTP
</protocolType>
<parameterFormatType>
<!--ro, req, enum, parameter format type, subType:string, desc:“JSON”, “XML”-->JSON
</parameterFormatType>
<addressingFormatType>
<!--ro, req, enum, address type, subType:string, desc:“hostname”, “ipaddress”-->hostname
</addressingFormatType>
<hostName>
<!--ro, opt, string, host name-->test
</hostName>
<ipAddress>
<!--ro, opt, string, IP address-->test
</ipAddress>
<ipv6Address>
<!--ro, opt, string, IPv6 address-->test
</ipv6Address>
<portNo>
<!--ro, opt, int, port number-->1
</portNo>
-
-
-


</portNo>
<userName>
<!--ro, opt, string, user name-->test
</userName>
<httpAuthenticationMethod>
<!--ro, req, enum, authentication method, subType:string, desc:“MD5digest” (MD5), “none”, “base64”-->MD5digest
</httpAuthenticationMethod>
<ANPR>
<!--ro, opt, object, ANPR-->
<detectionUpLoadPicturesType>
<!--ro, opt, enum, uploaded pictures type, subType:string, desc:“all”, “licensePlatePicture”, “detectionPicture” (detected picture)-->all
</detectionUpLoadPicturesType>
</ANPR>
<Extensions>
<!--ro, opt, object, range-->
<intervalBetweenEvents>
<!--ro, opt, int, event interval-->1
</intervalBetweenEvents>
</Extensions>
<uploadImagesDataType>
<!--ro, opt, enum, picture data type, subType:string, desc:the default data type is binary. for cloud storage, only “URL” is supported. “URL”, “binary”->URL
</uploadImagesDataType>
<httpBroken>
<!--ro,
opt, bool, whether to enable the automatic network replenishment, desc:if the ANR function is enabled, it will be applied to all events-->true
</httpBroken>
<SubscribeEvent>
<!--ro, opt, object, picture uploading modes of all events which contain pictures-->
<heartbeat>
<!--ro, opt, int, heartbeat interval time-->30
</heartbeat>
<eventMode>
<!--ro, req, enum, event mode, subType:string, desc:“all” (all alarms need to be reported), “list” (only listed alarms need to be reported)-->all
</eventMode>
<EventList>
<!--ro, opt, array, event list, subType:object-->
<Event>
<!--ro, opt, object, channel information linked to event-->
<type>
<!--ro, req, enum, event type, subType:string, desc:see details in event types: “ADAS” (advanced driving assistance system), “ADASAlarm” (advanced
driving assistance alarm), “AID” (traffic incident detection), “ANPR” (automatic number plate recognition), “AccessControllerEvent”, “CDsStatus”, “DBD”
(driving behavior detection) “GPSUpload”, “HFPD” (frequently appeared person), “IO” (I/O Alarm), “IOTD”, “LES”, “LFPD” (low frequency person detection),
“PALMismatch”, “PIR”, “PeopleCounting”, “PeopleNumChange”, “Standup” (standing up detection), “TMA” (thermometry alarm), “TMPA” (temperature measurement
pre-alarm), “VMD” (motion detection), “abnormalAcceleration”, “abnormalDriving”, “advReachHeight”, ”alarmResult”, “attendance”, “attendedBaggage”,
“audioAbnormal”, “audioexception”, “behaviorResult” (behavior analysis), “blindSpotDetection” (blind spot detection alarm), “cardMatch”, “changedStatus”,
“collision”, “containerDetection”, “crowdSituationAnalysis”, “databaseException”, “defocus” (defocus detection), “diskUnformat” (disk unformatted),
“diskerror”, “diskfull”, “driverConditionMonitor” (driver status monitoring alarm); “emergencyAlarm", “faceCapture”, “faceSnapModeling”, “facedetection”,
“failDown” (People Falling Down), “faultAlarm”, “fielddetection” (intrusion detection), “fireDetection”, “fireEscapeDetection”, “flowOverrun”,
“framesPeopleCounting”, “getUp” (getting up detection), “group” (people gathering), “hdBadBlock”(HDD bad sector detection event), “hdImpact” (HDD impact
detection event), “heatmap” (heat map alarm), “highHDTemperature” (HDD high temperature detection event), “highTempAlarm” (HDD high temperature alarm),
“hotSpare” (hot spare exception), “illaccess” (invalid access), “ipcTransferAbnormal”, “ipconflict” (IP address conflicts), “keyPersonGetUp” (key person
getting up detection), “leavePosition” (absence detection), “linedetection” (line crossing detection), “listSyncException” (list synchronization exception),
“loitering” (loitering detection), “lowHDTemperature” (HDD low temperature detection event), “mixedTargetDetection” (multi-target-type detection),
“modelError”, “nicbroken” (network disconnected), “nodeOffline” (node disconnected), “nonPoliceIntrusion”, “overSpeed” (overspeed alarm), “overtimeTarry”
(staying overtime detection), “parking” (parking detection), “peopleNumChange”, “peopleNumCounting”, “personAbnormalAlarm” (person ID exception alarm),
“personDensityDetection”, “personQueueCounting”, “personQueueDetection”, “personQueueRealTime” (real-time data of people queuing-up detection),
“personQueueTime” (waiting time detection), “playCellphone” (playing mobile phone detection), “pocException” (video exception), “poe” (POE power exception),
“policeAbsent”, “radarAlarm”, “radarFieldDetection”, “radarLineDetection”, “radarPerimeterRule” (radar rule data), “radarTargetDetection”,
“radarVideoDetection” (radar-assisted target detection), “raidException”, “rapidMove”, “reachHeight” (climbing detection), “recordCycleAbnormal”
(insufficient recording period), “recordException”, “regionEntrance”, “regionExiting”, “retention” (people overstay detection), “rollover”, “running”
(people running), “safetyHelmetDetection” (hard hat detection), “scenechangedetection”, “sensorAlarm” (angular acceleration alarm), “severeHDFailure” (HDD
major fault detection), “shelteralarm” (video tampering alarm), “shipsDetection”, “sitQuietly” (sitting detection), “smokeAndFireDetection”,
“smokeDetection”, “softIO”, “spacingChange” (distance exception), “sysStorFull” (storaging full alarm of cluster system), “takingElevatorDetection”
(elevator electric moped detection), “targetCapture”, “temperature” (temperature difference alarm), “thermometry” (temperature alarm),
“thirdPartyException”, “toiletTarry” (in-toilet overtime detection), “tollCodeInfo” (QR code information report), “tossing” (thrown object detection),
“unattendedBaggage”, “vehicleMatchResult” (uploading list alarms), “vehicleRcogResult”, “versionAbnormal” (cluster version exception), “videoException”,
“videoloss”, “violationAlarm”, “violentMotion” (violent motion detection), “yardTarry” (playground overstay detection), “AccessControllerEvent”,
“IDCardInfoEvent”, “FaceTemperatureMeasurementEvent” , “QRCodeEvent” (QR code event of access control), “CertificateCaptureEvent” (person ID capture
comparison event), “UncertificateCompareEvent”, “ConsumptionAndTransactionRecordEvent”, “ConsumptionEvent”, “TransactionRecordEvent”, “SetMealQuery”
(searching consumption set meals), “ConsumptionStatusQuery” (searching the consumption status), “humanBodyComparison”-->mixedTargetDetection
</type>
<minorAlarm>
<!--ro, opt, string, alarm sub type, desc:see details in macro definition of uploaded events. “IDCardInfoEvent” is required when the type of event
is "AccessControllerEvent"-->0x400,0x401,0x402,0x403
</minorAlarm>
<minorException>
<!--ro, opt, string, exception sub type, desc:see details in macro definition of uploaded events. “IDCardInfoEvent” is required when the type of
event is "AccessControllerEvent"-->0x400,0x401,0x402,0x403
</minorException>
<minorOperation>
<!--ro, opt, string, operation sub type, desc:see details in macro definition of uploaded events. “IDCardInfoEvent” is required when the type of
event is "AccessControllerEvent"-->0x400,0x401,0x402,0x403
</minorOperation>
<minorEvent>
<!--ro, opt, string, event sub type, desc:see details in macro definition of uploaded events. “IDCardInfoEvent” is required when the type of event
is "AccessControllerEvent"-->0x01,0x02,0x03,0x04
</minorEvent>
<pictureURLType>
<!--ro, opt, enum, alarm picture format of the specified event, subType:string, desc:alarm picture format of the specified event-->binary
</pictureURLType>
<channels>
<!--ro, opt, string, listen to the events on the specified channel No. list, desc:if all channels are being listened to, the node shall not be
applied. if some channels are being listened to, the channel No. shall be listed and separated by commas-->1,2,3,4
</channels>


</channels>
</Event>
</EventList>
<channels>
<!--ro, opt, string, listen to the specified channel No. list, desc:if all channels are being listened to, the node shall not be applied. if some
channels are being listened to, the channel No. shall be listed and separated by commas-->1,2,3,4
</channels>
<pictureURLType>
<!--ro, opt, enum, alarm picture format, subType:string, desc:the node indicates the picture types of all events which contain pictures to be
uploaded. if the node is applied, the pictureURLType of the Event will not take effect. if the node is not applied, the pictures reported from the device by
default mode: the default data type of uploaded pictures captured from front-end devices is binary. the default data type of uploaded pictures reported from
storage devices is local URL of the device.-->binary
</pictureURLType>
<ChangedUploadSub>
<!--ro, opt, object, subscribe to messages-->
<interval>
<!--ro, opt, int, the lifecycle of arm GUID, desc:if GUID is not reconnected in the internal, a new GUID will be generated since the device start a
new arm period-->5
</interval>
<StatusSub>
<!--ro, opt, object, sub status-->
<all>
<!--ro, opt, bool, subscribe to all?-->true
</all>
<channel>
<!--ro, opt, bool, subscribe to channel status, desc:reporting is not required if all is true-->true
</channel>
<hd>
<!--ro, opt, bool, subscribe to HDD status, desc:reporting is not required if all is true-->true
</hd>
<capability>
<!--ro, opt, bool, subscribe to changing status of capability set, desc:reporting is not required if all is true-->true
</capability>
</StatusSub>
</ChangedUploadSub>
</SubscribeEvent>
<PackingSpaceRecognition>
<!--ro, opt, object, current control parameters of event listened by parking space detector on the security control panel, desc:related event:
PackingSpaceRecognition-->
<upLoadPicturesType>
<!--ro, req, enum, uploaded picture type, subType:string, desc:“all”, “picturesTypes” (upload specified types of pictures), “notUpload” (not upload
pictures)-->all
</upLoadPicturesType>
<PicturesTypes>
<!--ro, opt, array, specified list of uploaded picture type, subType:object, dep:and,
{$.HttpHostNotification.PackingSpaceRecognition.upLoadPicturesType,eq,picturesTypes}-->
<picturesType>
<!--ro, opt, enum, uploaded picture type, subType:string, desc:“backgroundImage” (captured background picture), “plateImage” (license plate closeup)-->backgroundImage
</picturesType>
</PicturesTypes>
</PackingSpaceRecognition>
</HttpHostNotification>
21.10.7
Set IP address of receiving server(s)
Request URL
PUT /ISAPI/Event/notification/httpHosts?security=<security>&iv=<iv>
Query Parameter
Parameter Name Parameter Type Description
security
string
iv
Request Message
<?xml version="1.0" encoding="UTF-8"?>
<HttpHostNotificationList xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--req, array, listening host list, subType:object, attr:version{req, string, protocolVersion}-->
<HttpHostNotification>
<!--opt, object, listening host-->
<id>
<!--req, string, ID-->test
</id>
<url>
<!--req, string, URL-->test
</url>
<protocolType>
<!--req, enum, protocol type, subType:string, desc:"HTTP", "HTTPS", "EHome"-->HTTP
</protocolType>
<parameterFormatType>
<!--req, enum, parameter format type, subType:string, desc:"JSON", "XML"-->JSON
string
-
-


</parameterFormatType>
<addressingFormatType>
<!--req, enum, address types, subType:string, desc:"hostname" (host name), "ipaddress" (ip address)-->hostname
</addressingFormatType>
<hostName>
<!--opt, string, host name-->test
</hostName>
<ipAddress>
<!--opt, string, IP address-->test
</ipAddress>
<ipv6Address>
<!--opt, string, IPv6 address-->test
</ipv6Address>
<portNo>
<!--opt, int, port No.-->1
</portNo>
<userName>
<!--opt, string, user name-->test
</userName>
<password>
<!--opt, string, password-->test
</password>
<httpAuthenticationMethod>
<!--req, enum, authentication method, subType:string, desc:"MD5digest" (MD5), "none"-->MD5digest
</httpAuthenticationMethod>
<ANPR>
<!--opt, object, ANPR-->
<detectionUpLoadPicturesType>
<!--opt, enum, uploaded pictures type, subType:string, desc:uploaded pictures type-->all
</detectionUpLoadPicturesType>
</ANPR>
<Extensions>
<!--opt, object, range-->
<intervalBetweenEvents>
<!--opt, int, event interval-->1
</intervalBetweenEvents>
</Extensions>
<uploadImagesDataType>
<!--opt, enum, picture data type, subType:string, desc:picture data type-->URL
</uploadImagesDataType>
<httpBroken>
<!--opt, bool, whether to enable the automatic network replenishment, desc:if the ANR function is enabled, it will be applied to all events-->true
</httpBroken>
<SubscribeEvent>
<!--opt, object, picture uploading modes of all events which contain pictures-->
<heartbeat>
<!--opt, int, heartbeat interval-->30
</heartbeat>
<eventMode>
<!--req, enum, event mode, subType:string, desc:event mode-->all
</eventMode>
<EventList>
<!--opt, array, event list, subType:object-->
<Event>
<!--opt, object, channel information linked to event-->
<type>
<!--req, enum, event type, subType:string, desc:event type-->mixedTargetDetection
</type>
<minorAlarm>
<!--opt, string, minor alarm type, desc:see details in macro definition of uploaded events. "IDCardInfoEvent" is required when the type of event
is "AccessControllerEvent"-->0x400,0x401,0x402,0x403
</minorAlarm>
<minorException>
<!--opt, string, minor exception type, desc:see details in macro definition of uploaded events. "IDCardInfoEvent" is required when the type of
event is "AccessControllerEvent"-->0x400,0x401,0x402,0x403
</minorException>
<minorOperation>
<!--opt, string, minor operation type, desc:see details in macro definition of uploaded events. "IDCardInfoEvent" is required when the type of
event is "AccessControllerEvent"-->0x400,0x401,0x402,0x403
</minorOperation>
<minorEvent>
<!--opt, string, minor event type, desc:see details in macro definition of uploaded events. "IDCardInfoEvent" is required when the type of event
is "AccessControllerEvent"-->0x01,0x02,0x03,0x04
</minorEvent>
<pictureURLType>
<!--opt, enum, alarm picture format, subType:string, desc:alarm picture format of the specified event-->binary
</pictureURLType>
<channels>
<!--opt, string, channel No.-->1,2,3,4
</channels>
</Event>
</EventList>
<channels>
<!--opt, string, listen to the specified channel No. list, desc:listen to the specified channel No. list-->1,2,3,4
</channels>
<pictureURLType>
<!--opt, enum, alarm picture format, subType:string, desc:"binary" (binary), "localURL" (device local URL), "cloudStorageURL" (cloud storage URL)-
>binary
</pictureURLType>
<ChangedUploadSub>
<!--opt, object, subscribe to messages-->
<interval>
<!--opt, int, the lifecycle of arm GUID, desc:if GUID is not reconnected in the internal, a new GUID will be generated since the device starts a
new arm period-->5


new arm period-->5
</interval>
<StatusSub>
<!--opt, object, sub status-->
<all>
<!--opt, bool, whether to subscribe to all-->true
</all>
<channel>
<!--opt, bool, status of subscribed channels, desc:reporting is not required if all is true-->true
</channel>
<hd>
<!--opt, bool, subscribe to HDD status, desc:reporting is not required if all is true-->true
</hd>
<capability>
<!--opt, bool, subscribe to changing status of capability set, desc:reporting is not required if all is true-->true
</capability>
</StatusSub>
</ChangedUploadSub>
</SubscribeEvent>
<PackingSpaceRecognition>
<!--opt, object, current control parameters of event listened by parking space detector on the security control panel, desc:related event:
PackingSpaceRecognition-->
<upLoadPicturesType>
<!--req, enum, uploaded picture type, subType:string, desc:uploaded picture type-->all
</upLoadPicturesType>
<PicturesTypes>
<!--opt, array, specified list of uploaded picture types, subType:object, dep:and,
{$.HttpHostNotificationList[*].HttpHostNotification.PackingSpaceRecognition.upLoadPicturesType,eq,picturesTypes}-->
<picturesType>
<!--opt, enum, uploaded picture type, subType:string, desc:"backgroundImage" (captured background picture), "plateImage" (license plate close-up)->backgroundImage
</picturesType>
</PicturesTypes>
</PackingSpaceRecognition>
</HttpHostNotification>
</HttpHostNotificationList>
Response
Message
<?xml version="1.0" encoding="UTF-8"?>
<ResponseStatus xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--ro, req, object, response message, attr:version{ro, req, string, protocolVersion}-->
<requestURL>
<!--ro, req, string, request URL-->null
</requestURL>
<statusCode>
<!--ro, req, enum, status code, subType:int, desc:0 (OK), 1 (OK), 2 (Device Busy), 3 (Device Error), 4 (Invalid Operation), 5 (Invalid XML Format), 6
(Invalid XML Content), 7 (Reboot Required)-->0
</statusCode>
<statusString>
<!--ro, req, enum, status description, subType:string, desc:"OK" (succeeded), "Device Busy", "Device Error", "Invalid Operation", "Invalid XML Format",
"Invalid XML Content", "Reboot" (reboot device)-->OK
</statusString>
<subStatusCode>
<!--ro, req, string, sub status code, which describes the error in details, desc:sub status code, which describes the error in details-->OK
</subStatusCode>
</ResponseStatus>
21.10.8 Get parameters of all listening hosts
Request URL
GET /ISAPI/Event/notification/httpHosts?security=<security>&iv=<iv>
Query Parameter
Parameter Name Parameter Type Description
security
string
iv
string
Request Message
None
Response Message
<?xml version="1.0" encoding="UTF-8"?>
<HttpHostNotificationList xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--ro, req, array, listening host list, subType:object, attr:version{req, string, protocolVersion}-->
<HttpHostNotification>
-
-


<HttpHostNotification>
<!--ro, opt, object, listening host-->
<id>
<!--ro, req, string, subscribe to ID, range:[1,10]-->test
</id>
<url>
<!--ro, req, string, URL-->test
</url>
<protocolType>
<!--ro, req, enum, protocol type, subType:string, desc:"HTTP", "HTTPS", "EHome" (ISUP)-->HTTP
</protocolType>
<parameterFormatType>
<!--ro, req, enum, parameter format type, subType:string, desc:“JSON”, “XML”-->JSON
</parameterFormatType>
<addressingFormatType>
<!--ro, req, enum, address type, subType:string, desc:“hostname”, “ipaddress”-->hostname
</addressingFormatType>
<hostName>
<!--ro, opt, string, host name-->test
</hostName>
<ipAddress>
<!--ro, opt, string, IP address-->test
</ipAddress>
<ipv6Address>
<!--ro, opt, string, IPv6 Address-->test
</ipv6Address>
<portNo>
<!--ro, opt, int, port number-->1
</portNo>
<userName>
<!--ro, opt, string, user name-->test
</userName>
<password>
<!--ro, opt, string, password-->test
</password>
<httpAuthenticationMethod>
<!--ro, req, enum, authentication method, subType:string, desc:“MD5digest” (MD5), “none”, “base64”-->MD5digest
</httpAuthenticationMethod>
<ANPR>
<!--ro, opt, object, ANPR-->
<detectionUpLoadPicturesType>
<!--ro, opt, enum, uploaded pictures type, subType:string, desc:“all”, “licensePlatePicture”, “detectionPicture” (detected picture)-->all
</detectionUpLoadPicturesType>
</ANPR>
<Extensions>
<!--ro, opt, object, range-->
<intervalBetweenEvents>
<!--ro, opt, int, event interval-->1
</intervalBetweenEvents>
</Extensions>
<uploadImagesDataType>
<!--ro, opt, enum, picture data type, subType:string, desc:the default data type is binary. for cloud storage, only “URL” is supported. “URL”,
“binary”-->URL
</uploadImagesDataType>
<httpBroken>
<!--ro, opt, bool, whether to enable the automatic network replenishment, desc:if the ANR function is enabled, it will be applied to all events-->true
</httpBroken>
<SubscribeEvent>
<!--ro, opt, object, picture uploading modes of all events which contain pictures-->
<heartbeat>
<!--ro, opt, int, heartbeat interval time-->30
</heartbeat>
<eventMode>
<!--ro, req, enum, event mode, subType:string, desc:“all” (all alarms need to be reported), “list” (only listed alarms need to be reported)-->all
</eventMode>
<EventList>
<!--ro, opt, array, event list, subType:object-->
<Event>
<!--ro, opt, object, channel information linked to event-->
<type>
<!--ro, req, enum, event type, subType:string, desc:see details in event types: “ADAS” (advanced driving assistance system), “ADASAlarm”
(advanced driving assistance alarm), “AID” (traffic incident detection), “ANPR” (automatic number plate recognition), “AccessControllerEvent”, “CDsStatus”,
“DBD” (driving behavior detection) “GPSUpload”, “HFPD” (frequently appeared person), “IO” (I/O Alarm), “IOTD”, “LES”, “LFPD” (low frequency person
detection), “PALMismatch”, “PIR”, “PeopleCounting”, “PeopleNumChange”, “Standup” (standing up detection), “TMA” (thermometry alarm), “TMPA” (temperature
measurement pre-alarm), “VMD” (motion detection), “abnormalAcceleration”, “abnormalDriving”, “advReachHeight”, ”alarmResult”, “attendance”,
“attendedBaggage”, “audioAbnormal”, “audioexception”, “behaviorResult” (behavior analysis), “blindSpotDetection” (blind spot detection alarm), “cardMatch”,
“changedStatus”, “collision”, “containerDetection”, “crowdSituationAnalysis”, “databaseException”, “defocus” (defocus detection), “diskUnformat” (disk
unformatted), “diskerror”, “diskfull”, “driverConditionMonitor” (driver status monitoring alarm); “emergencyAlarm", “faceCapture”, “faceSnapModeling”,
“facedetection”, “failDown” (People Falling Down), “faultAlarm”, “fielddetection” (intrusion detection), “fireDetection”, “fireEscapeDetection”,
“flowOverrun”, “framesPeopleCounting”, “getUp” (getting up detection), “group” (people gathering), “hdBadBlock”(HDD bad sector detection event), “hdImpact”
(HDD impact detection event), “heatmap” (heat map alarm), “highHDTemperature” (HDD high temperature detection event), “highTempAlarm” (HDD high temperature
alarm), “hotSpare” (hot spare exception), “illaccess” (invalid access), “ipcTransferAbnormal”, “ipconflict” (IP address conflicts), “keyPersonGetUp” (key
person getting up detection), “leavePosition” (absence detection), “linedetection” (line crossing detection), “listSyncException” (list synchronization
exception), “loitering” (loitering detection), “lowHDTemperature” (HDD low temperature detection event), “mixedTargetDetection” (multi-target-type
detection), “modelError”, “nicbroken” (network disconnected), “nodeOffline” (node disconnected), “nonPoliceIntrusion”, “overSpeed” (overspeed alarm),
“overtimeTarry” (staying overtime detection), “parking” (parking detection), “peopleNumChange”, “peopleNumCounting”, “personAbnormalAlarm” (person ID
exception alarm), “personDensityDetection”, “personQueueCounting”, “personQueueDetection”, “personQueueRealTime” (real-time data of people queuing-up
detection), “personQueueTime” (waiting time detection), “playCellphone” (playing mobile phone detection), “pocException” (video exception), “poe” (POE power
exception), “policeAbsent”, “radarAlarm”, “radarFieldDetection”, “radarLineDetection”, “radarPerimeterRule” (radar rule data), “radarTargetDetection”,
“radarVideoDetection” (radar-assisted target detection), “raidException”, “rapidMove”, “reachHeight” (climbing detection), “recordCycleAbnormal”
(insufficient recording period), “recordException”, “regionEntrance”, “regionExiting”, “retention” (people overstay detection), “rollover”, “running”
(people running), “safetyHelmetDetection” (hard hat detection), “scenechangedetection”, “sensorAlarm” (angular acceleration alarm), “severeHDFailure” (HDD
major fault detection), “shelteralarm” (video tampering alarm), “shipsDetection”, “sitQuietly” (sitting detection), “smokeAndFireDetection”,
“smokeDetection”, “softIO”, “spacingChange” (distance exception), “sysStorFull” (storaging full alarm of cluster system), “takingElevatorDetection”


“smokeDetection”, “softIO”, “spacingChange” (distance exception), “sysStorFull” (storaging full alarm of cluster system), “takingElevatorDetection”
(elevator electric moped detection), “targetCapture”, “temperature” (temperature difference alarm), “thermometry” (temperature alarm),
“thirdPartyException”, “toiletTarry” (in-toilet overtime detection), “tollCodeInfo” (QR code information report), “tossing” (thrown object detection),
“unattendedBaggage”, “vehicleMatchResult” (uploading list alarms), “vehicleRcogResult”, “versionAbnormal” (cluster version exception), “videoException”,
“videoloss”, “violationAlarm”, “violentMotion” (violent motion detection), “yardTarry” (playground overstay detection), “AccessControllerEvent”,
“IDCardInfoEvent”, “FaceTemperatureMeasurementEvent” , “QRCodeEvent” (QR code event of access control), “CertificateCaptureEvent” (person ID capture
comparison event), “UncertificateCompareEvent”, “ConsumptionAndTransactionRecordEvent”, “ConsumptionEvent”, “TransactionRecordEvent”, “SetMealQuery”
(searching consumption set meals), “ConsumptionStatusQuery” (searching the consumption status), “humanBodyComparison”-->mixedTargetDetection
</type>
<minorAlarm>
<!--ro, opt, string, alarm sub type, desc:see details in macro definition of uploaded events. “IDCardInfoEvent” is required when the type of
event is "AccessControllerEvent"-->0x400,0x401,0x402,0x403
</minorAlarm>
<minorException>
<!--ro, opt, string, exception sub type, desc:see details in macro definition of uploaded events. “IDCardInfoEvent” is required when the type of
event is "AccessControllerEvent"-->0x400,0x401,0x402,0x403
</minorException>
<minorOperation>
<!--ro, opt, string, operation sub type, desc:see details in macro definition of uploaded events. “IDCardInfoEvent” is required when the type of
event is "AccessControllerEvent"-->0x400,0x401,0x402,0x403
</minorOperation>
<minorEvent>
<!--ro, opt, string, event sub type, desc:see details in macro definition of uploaded events. “IDCardInfoEvent” is required when the type of
event is "AccessControllerEvent"-->0x01,0x02,0x03,0x04
</minorEvent>
<pictureURLType>
<!--ro, opt, enum, alarm picture format of the specified event, subType:string, desc:alarm picture format of the specified event-->binary
</pictureURLType>
<channels>
<!--ro, opt, string, listen to the events on the specified channel No. list, desc:if all channels are being listened to, the node shall not be
applied. if some channels are being listened to, the channel No. shall be listed and separated by commas-->1,2,3,4
</channels>
</Event>
</EventList>
<channels>
<!--ro, opt, string, listen to the specified channel No. list, desc:if all channels are being listened to, the node shall not be applied. if some
channels are being listened to, the channel No. shall be listed and separated by commas-->1,2,3,4
</channels>
<pictureURLType>
<!--ro, opt, enum, alarm picture format, subType:string, desc:the node indicates the picture types of all events which contain pictures to be
uploaded. if the node is applied, the pictureURLType of the Event will not take effect. if the node is not applied, the pictures reported from the device by
default mode: the default data type of uploaded pictures captured from front-end devices is binary. the default data type of uploaded pictures reported from
storage devices is local URL of the device.-->binary
</pictureURLType>
<ChangedUploadSub>
<!--ro, opt, object, subscribe to messages-->
<interval>
<!--ro, opt, int, the lifecycle of arm GUID, desc:if GUID is not reconnected in the internal, a new GUID will be generated since the device start
a new arm period-->5
</interval>
<StatusSub>
<!--ro, opt, object, sub status-->
<all>
<!--ro, opt, bool, subscribe to all?-->true
</all>
<channel>
<!--ro, opt, bool, subscribe to channel status, desc:reporting is not required if all is true-->true
</channel>
<hd>
<!--ro, opt, bool, subscribe to HDD status, desc:reporting is not required if all is true-->true
</hd>
<capability>
<!--ro, opt, bool, subscribe to changing status of capability set, desc:reporting is not required if all is true-->true
</capability>
</StatusSub>
</ChangedUploadSub>
</SubscribeEvent>
<PackingSpaceRecognition>
<!--ro, req, object, current control parameters of event listened by parking space detector on the security control panel, desc:related event:
PackingSpaceRecognition-->
<upLoadPicturesType>
<!--ro, opt, enum, uploaded picture type, subType:string, desc:“all”, “picturesTypes” (upload specified types of pictures), “notUpload” (not upload
pictures)-->all
</upLoadPicturesType>
<PicturesTypes>
<!--ro, opt, array, specified list of uploaded picture type, subType:object, dep:and,
{$.HttpHostNotificationList[*].HttpHostNotification.PackingSpaceRecognition.upLoadPicturesType,eq,picturesTypes}-->
<picturesType>
<!--ro, opt, enum, uploaded picture type, subType:string, desc:“backgroundImage” (captured background picture), “plateImage” (license plate closeup)-->backgroundImage
</picturesType>
</PicturesTypes>
</PackingSpaceRecognition>
</HttpHostNotification>
</HttpHostNotificationList>
21.10.9
Get the capabilities of listening hosts parameters
Request URL
GET /ISAPI/Event/notification/httpHosts/capabilities


Query Parameter
None
Request Message
None
Response Message
<?xml version="1.0" encoding="UTF-8"?>
<HttpHostNotificationCap xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--ro, req, object, capabilities of subscribing to event types and event channels, attr:version{req, string, protocolVersion}-->
<hostNumber>
<!--ro, req, int, the number of listening hosts-->0
</hostNumber>
<urlLen max="10">
<!--ro, req, string, URL length, attr:max{req, int}-->test
</urlLen>
<url>
<!--ro, opt, string, URL-->test
</url>
<protocolType opt="HTTP,HTTPS,EHome">
<!--ro, req, enum, protocol type, subType:string, attr:opt{req, string}, desc:"HTTP", "HTTPS", "EHome"-->HTTP
</protocolType>
<parameterFormatType opt="XML,querystring,JSON">
<!--ro, req, enum, alarm parameter format type, subType:string, attr:opt{req, string}, desc:“xml" (XML format), “querystring”, "json" (JSON format)-
>XML
</parameterFormatType>
<addressingFormatType opt="ipaddress,hostname">
<!--ro, req, enum, address format type, subType:string, attr:opt{req, string}, desc:"ipaddress", "hostname"-->ipaddress
</addressingFormatType>
<hostName min="1" max="64">
<!--ro, opt, string, domain name, attr:min{req, int},max{req, int}, desc:it is valid when addressingFormatType is hostname-->test
</hostName>
<ipAddress opt="ipv4,ipv6">
<!--ro, opt, string, IP address, attr:opt{req, string}, desc:it is valid when addressingFormatType is ipaddress-->test
</ipAddress>
<portNo min="0" max="10">
<!--ro, opt, int, port number, range:[0,65535], attr:min{req, int},max{req, int}-->1
</portNo>
<userNameLen min="0" max="10">
<!--ro, opt, int, user name length, attr:min{req, int},max{req, int}-->1
</userNameLen>
<passwordLen min="0" max="10">
<!--ro, opt, int, password length, attr:min{req, int},max{req, int}-->1
</passwordLen>
<httpAuthenticationMethod opt="MD5digest,none,base64">
<!--ro, req, enum, HTTP authentication method, subType:string, attr:opt{req, string}, desc:“MD5digest” (MD5), “none”, “base64”-->MD5digest
</httpAuthenticationMethod>
<ANPR>
<!--ro, opt, object, ANPR-->
<detectionUpLoadPicturesType opt="test">
<!--ro, opt, string, uploaded pictures type, attr:opt{req, string}-->test
</detectionUpLoadPicturesType>
<alarmHttpPushProtocol opt="baseline,custom">
<!--ro, opt, string, alarm HTTP push protocol, attr:opt{req, string}-->baseline
</alarmHttpPushProtocol>
</ANPR>
<HttpHostUploadCtrl>
<!--ro, opt, object, the capability of reporting alarms-->
<postDataTypes>
<!--ro, opt, string, checkpoint data dictionary-->test
</postDataTypes>
<epoliceDataTypes>
<!--ro, opt, string, intersection violation data dictionary-->test
</epoliceDataTypes>
<eventDataTypes>
<!--ro, opt, string, event data dictionary-->test
</eventDataTypes>
<evidenceDataTypes>
<!--ro, opt, string, enforcement data dictionary-->test
</evidenceDataTypes>
<uploadInterval min="1" max="2000">
<!--ro, req, int, the default upload interval is 50 (1~2000ms), attr:min{req, int},max{req, int}-->0
</uploadInterval>
<uploadTimeout min="1" max="6000">
<!--ro, req, int, the default timeout duration is 5000 (1~6000ms), attr:min{req, int},max{req, int}-->0
</uploadTimeout>
<noPlateUploadEnabled opt="true,false">
<!--ro, req, bool, whether to upload no license plate data, attr:opt{req, string}-->true
</noPlateUploadEnabled>
<historyEnabled opt="true,false">
<!--ro, req, bool, whether to upload history data, attr:opt{req, string}-->true
</historyEnabled>
<uploadTimePlan>
<!--ro, opt, object, upload event schedule-->
<enabled opt="true,false">
<!--ro, req, bool, whether to enable the function, attr:opt{req, string}-->true
</enabled>
<timeList>


<timeList>
<!--ro, opt, object, time list-->
<timeSpan>
<!--ro, opt, object, time-->
<timeId min="0" max="1">
<!--ro, req, int, time No., attr:min{req, int},max{req, int}-->0
</timeId>
<startHour min="0" max="23">
<!--ro, opt, int, start hour, attr:min{req, int},max{req, int}-->0
</startHour>
<startMinute min="0" max="59">
<!--ro, opt, int, start minute, attr:min{req, int},max{req, int}-->0
</startMinute>
<endHour min="0" max="23">
<!--ro, opt, int, end hour, attr:min{req, int},max{req, int}-->0
</endHour>
<endMinute min="0" max="59">
<!--ro, opt, int, end minute, attr:min{req, int},max{req, int}-->0
</endMinute>
</timeSpan>
</timeList>
</uploadTimePlan>
</HttpHostUploadCtrl>
<Extensions>
<!--ro, opt, object, expand-->
<intervalBetweenEvents min="0" max="10">
<!--ro, opt, int, event interval, attr:min{req, int},max{req, int}-->0
</intervalBetweenEvents>
</Extensions>
<uploadImagesDataType opt="URL,binary">
<!--ro, opt, enum, uploaded picture type, subType:string, attr:opt{req, string}, desc:the default data type is binary. for cloud storage, only “URL” is
supported. “URL”, “binary”-->URL
</uploadImagesDataType>
<httpBroken opt="true,false" def="true">
<!--ro, opt, bool, whether to enable the automatic network replenishment, attr:opt{req, string},def{req, string}-->true
</httpBroken>
<SubscribeEventCap>
<!--ro, opt, string, subscribe to changing status of capability set-->test
<heartbeat min="0" max="10">
<!--ro, opt, int, heartbeat interval time, unit:s, attr:min{req, int},max{req, int}-->1
</heartbeat>
<channelMode opt="all,list">
<!--ro, opt, enum, channel mode, subType:string, attr:opt{req, string}, desc:if channelMode and eventMode return all, the device does not support
subscribing to event types and event channels. “all” (the device does not support subscribing to event channels separately, “list” (the device support
subscribing to event channels separately)-->all
</channelMode>
<eventMode opt="all,list">
<!--ro, opt, enum, event mode, subType:string, attr:opt{req, string}, desc:“all” (subscribe to all channels and events on the device), “list”
(subscribe to all channels and events on the device-->all
</eventMode>
<EventList>
<!--ro, opt, object, event list-->
<Event>
<!--ro, opt, string, event subscription information-->test
<type>
<!--ro, req, enum, see details in event type list, subType:string, desc:“AccessControllerEvent”, "IDCardInfoEvent”,
“FaceTemperatureMeasurementEvent, “QRCodeEvent”, “CertificateCaptureEvent”, “UncertificateCompareEvent”, “ConsumptionAndTransactionRecordEvent”,
“ConsumptionEvent”, “TransactionRecordEvent”, “HealthInfoSyncQuery”, “SetMealQuery”, “ConsumptionStatusQuery”, “humanBodyComparison”-->AccessControllerEvent
</type>
<minorAlarm opt="0x400,0x401,0x402,0x403">
<!--ro, opt, string, alarm sub type, attr:opt{req, string}, desc:“IDCardInfoEvent” is required when the type of event is "AccessControllerEvent"-
>0x400,0x401
</minorAlarm>
<minorException opt="0x400,0x401,0x402,0x403">
<!--ro, opt, string, exception sub type, attr:opt{req, string}, desc:“IDCardInfoEvent” is required when the type of event is
"AccessControllerEvent"-->0x400,0x401
</minorException>
<minorOperation opt="0x400,0x401,0x402,0x403">
<!--ro, opt, string, operation sub type, attr:opt{req, string}, desc:“IDCardInfoEvent” is required when the type of event is
"AccessControllerEvent"-->0x400,0x401
</minorOperation>
<minorEvent opt="0x01,0x02,0x03,0x04">
<!--ro, opt, string, event sub type, attr:opt{req, string}, desc:“IDCardInfoEvent” is required when the type of event is "AccessControllerEvent"-
>0x400,0x401
</minorEvent>
<pictureURLType opt="binary,localURL,cloudStorageURL,EZVIZURL" def="cloudStorageURL">
<!--ro, opt, enum, alarm picture format, subType:string, attr:opt{req, string},def{req, string}, desc:alarm picture format-->cloudStorageURL
</pictureURLType>
</Event>
</EventList>
<pictureURLType opt="binary,localURL,cloudStorageURL,EZVIZURL" def="cloudStorageURL">
<!--ro, opt, enum, picture uploading modes of all events which contain pictures, subType:string, attr:opt{req, string},def{req, string}, desc:if the
node is applied, the pictureURLType of the Event will not take effect. if the node is not applied, the pictures reported from the device by default mode:
the default data type of uploaded pictures captured from front-end devices is binary. the default data type of uploaded pictures reported from storage
devices is local URL of the device.-->cloudStorageURL
</pictureURLType>
<ChangedUploadSub>
<!--ro, opt, int, upload changes-->0
<interval>
<!--ro, opt, int, the lifecycle of arm GUID, desc:5 minute (default). if GUID is not reconnected in the internal, a new GUID will be generated since
the device start a new arm period-->1
</interval>
<StatusSub>
<!--ro, opt, bool, subscribe to status-->true


<!--ro, opt, bool, subscribe to status-->true
<all>
<!--ro, opt, bool, whether to subscribe to all-->true
</all>
<channel>
<!--ro, opt, bool, subscribe to channel status, desc:reporting is not required if all is true-->true
</channel>
<hd>
<!--ro, opt, bool, subscribe to HDD status, desc:reporting is not required if all is true-->true
</hd>
<capability>
<!--ro, opt, bool, subscribe to changing status of capability set, desc:reporting is not required if all is true-->true
</capability>
</StatusSub>
</ChangedUploadSub>
</SubscribeEventCap>
<PackingSpaceRecognition>
<!--ro, opt, object, current control parameters of event listened by parking space detector on the security control panel, desc:related event:
PackingSpaceRecognition. if it is not supported by the device, all pictures will be uploaded by default-->
<upLoadPicturesType opt="all,picturesTypes,notUpload" def="all">
<!--ro, req, enum, uploaded picture type, subType:string, attr:opt{req, string},def{req, string}, desc:“all”, “picturesTypes” (upload specified types
of pictures), “notUpload” (not upload pictures)-->all
</upLoadPicturesType>
<PicturesTypes size="2">
<!--ro, opt, array, specified list of uploaded picture types, subType:object, dep:and,
{$.HttpHostNotificationList[*].HttpHostNotification.PackingSpaceRecognition.upLoadPicturesType,eq,picturesTypes}, attr:size{req, int}-->
<picturesType opt="backgroundImage,plateImage">
<!--ro, opt, enum, Uploaded Picture Type, subType:string, attr:opt{req, string}, desc:“backgroundImage” (captured background picture), “plateImage”
(license plate close-up)-->backgroundImage
</picturesType>
</PicturesTypes>
</PackingSpaceRecognition>
</HttpHostNotificationCap>
21.10.10 Delete receiving server(s)
Request URL
DELETE /ISAPI/Event/notification/httpHosts
Query Parameter
None
Request Message
None
Response Message
<?xml version="1.0" encoding="UTF-8"?>
<ResponseStatus xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--ro, req, object, response message, attr:version{ro, req, string, protocolVersion}-->
<requestURL>
<!--ro, req, string, request URL-->null
</requestURL>
<statusCode>
<!--ro, req, enum, status code, subType:int, desc:0 (OK), 1 (OK), 2 (Device Busy), 3 (Device Error), 4 (Invalid Operation), 5 (Invalid XML Format), 6
(Invalid XML Content), 7 (Reboot Required)-->0
</statusCode>
<statusString>
<!--ro, req, enum, status information, subType:string, desc:"OK" (succeeded), "Device Busy", "Device Error", "Invalid Operation", "Invalid XML Format",
"Invalid XML Content", "Reboot" (reboot device)-->OK
</statusString>
<subStatusCode>
<!--ro, req, string, sub status code, which describes the error in details, desc:sub status code, which describes the error in details-->OK
</subStatusCode>
</ResponseStatus>
21.10.11 Delete a HTTP listening server
Request URL
DELETE /ISAPI/Event/notification/httpHosts/<hostID>
Query Parameter
Parameter Name Parameter Type Description
hostID
string
Request Message
-


None
Response Message
<?xml version="1.0" encoding="UTF-8"?>
<ResponseStatus xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--ro, req, object, response message, attr:version{ro, req, string, protocolVersion}-->
<requestURL>
<!--ro, req, string, request URL-->null
</requestURL>
<statusCode>
<!--ro, req, enum, status code, subType:int, desc:0-OK, 1-OK, 2-Device Busy, 3-Device Error, 4-Invalid Operation, 5-Invalid XML Format, 6-Invalid XML
Content, 7-Reboot Required-->0
</statusCode>
<statusString>
<!--ro, req, enum, status description, subType:string, desc:“OK” (succeeded), “Device Busy”, “Device Error”, “Invalid Operation”, “Invalid XML Format”,
“Invalid XML Content”, “Reboot” (reboot device)-->OK
</statusString>
<subStatusCode>
<!--ro, req, string, sub status code, desc:sub status code-->OK
</subStatusCode>
</ResponseStatus>
21.11 Protocol Certificate
21.11.1 Generate the signature request information of device certificate
Request URL
PUT /ISAPI/Security/serverCertificate/certSignReq?platformNo=<platformNo>&type=<type>&security=
<security>&iv=<iv>
Query Parameter
Parameter Name Parameter Type Description
platformNo
string
type
security
iv
Request Message
enum
string
string
-
-
-
-


<?xml version="1.0" encoding="UTF-8"?>
<CertificateReq xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--req, object, attr:version{req, string, protocolVersion}-->
<id>
<!--req, string-->test
</id>
<SubjectDN>
<!--req, object-->
<countryName>
<!--req, string-->test
</countryName>
<stateOrProvinceName>
<!--opt, string-->test
</stateOrProvinceName>
<localityName>
<!--opt, string-->test
</localityName>
<organizationName>
<!--opt, string-->test
</organizationName>
<organizationUnitName>
<!--opt, string-->test
</organizationUnitName>
<commonName>
<!--req, string-->test
</commonName>
<countyOrDistrict>
<!--opt, string, range:[1,2]-->test
</countyOrDistrict>
<email>
<!--opt, string-->test
</email>
</SubjectDN>
<version>
<!--opt, string-->test
</version>
<keyAlgorithm>
<!--opt, string-->test
</keyAlgorithm>
<passwd>
<!--opt, string-->test
</passwd>
<RSAKeyLength>
<!--opt, int-->1
</RSAKeyLength>
</CertificateReq>
Response Message
<?xml version="1.0" encoding="UTF-8"?>
<ResponseStatus xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--ro, req, object, response message, attr:version{ro, req, string, protocolVersion}-->
<requestURL>
<!--ro, req, string, request URL-->null
</requestURL>
<statusCode>
<!--ro, req, enum, status code, subType:int, desc:0 (OK), 1 (OK), 2 (Device Busy), 3 (Device Error), 4 (Invalid Operation), 5 (Invalid XML Format), 6
(Invalid XML Content), 7 (Reboot Required)-->0
</statusCode>
<statusString>
<!--ro, req, enum, status information, subType:string, desc:"OK" (succeeded), "Device Busy", "Device Error", "Invalid Operation", "Invalid XML Format",
"Invalid XML Content", "Reboot" (reboot device)-->OK
</statusString>
<subStatusCode>
<!--ro, req, string, sub status code, which describes the error in details, desc:sub status code, which describes the error in details-->OK
</subStatusCode>
</ResponseStatus>
21.11.2 Delete signature request of device certificate
Request URL
DELETE /ISAPI/Security/serverCertificate/certSignReq?type=<type>
Query Parameter
Parameter Name Parameter Type Description
type
enum
Request Message
-


None
Response Message
<?xml version="1.0" encoding="UTF-8"?>
<ResponseStatus xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--ro, req, object, response message, attr:version{ro, req, string, protocolVersion}-->
<requestURL>
<!--ro, req, string, request URL-->null
</requestURL>
<statusCode>
<!--ro, req, enum, status code, subType:int, desc:0 (OK), 1 (OK), 2 (Device Busy), 3 (Device Error), 4 (Invalid Operation), 5 (Invalid XML Format), 6
(Invalid XML Content), 7 (Reboot Required)-->0
</statusCode>
<statusString>
<!--ro, req, enum, status information, subType:string, desc:"OK" (succeeded), "Device Busy", "Device Error", "Invalid Operation", "Invalid XML Format",
"Invalid XML Content", "Reboot" (reboot device)-->OK
</statusString>
<subStatusCode>
<!--ro, req, string, sub status code, which describes the error in details, desc:sub status code, which describes the error in details-->OK
</subStatusCode>
</ResponseStatus>
21.11.3 Get the signature request information of device certificate
Request URL
GET /ISAPI/Security/serverCertificate/certSignReq?platformNo=<platformNo>&type=<type>&security=
<security>&iv=<iv>
Query Parameter
Parameter Name Parameter Type Description
platformNo
string
type
security
iv
Request Message
None
Response Message
enum
string
string
-
-
-
-


<?xml version="1.0" encoding="UTF-8"?>
<CertificateReqInfo xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--ro, req, object, attr:version{req, string, protocolVersion}-->
<id>
<!--ro, req, string, certificate No., desc:it starts from 1-->test
</id>
<SubjectDN>
<!--ro, req, object, isapi:DN-->
<countryName>
<!--ro, req, string-->test
</countryName>
<stateOrProvinceName>
<!--ro, opt, string-->test
</stateOrProvinceName>
<localityName>
<!--ro, opt, string, city name-->test
</localityName>
<organizationName>
<!--ro, opt, string-->test
</organizationName>
<organizationUnitName>
<!--ro, opt, string-->test
</organizationUnitName>
<commonName>
<!--ro, req, string-->test
</commonName>
<email>
<!--ro, opt, string-->test
</email>
<countyOrDistrict>
<!--ro, opt, string, range:[1,2]-->test
</countyOrDistrict>
</SubjectDN>
<version>
<!--ro, opt, string-->test
</version>
<keyAlgorithm>
<!--ro, opt, string-->test
</keyAlgorithm>
<passwd>
<!--ro, opt, string, private key of the certificate-->test
</passwd>
<RSAKeyLength>
<!--ro, opt, int-->1
</RSAKeyLength>
</CertificateReqInfo>
21.12 Upgrade Management
21.12.1 Upgrade devices
Request URL
POST /ISAPI/System/updateFirmware?type=<type>&moduleAddress=<moduleAddress>&id=<indexID>
Query Parameter
Parameter Name Parameter Type Description
type
string
moduleAddress
indexID
Request Message
None
Response Message
string
string
-
-
-


<?xml version="1.0" encoding="UTF-8"?>
<ResponseStatus xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--ro, req, object, response message, attr:version{ro, req, string, protocolVersion}-->
<requestURL>
<!--ro, req, string, request URL-->null
</requestURL>
<statusCode>
<!--ro, req, enum, status code, subType:int, desc:0 (OK), 1 (OK), 2 (Device Busy), 3 (Device Error), 4 (Invalid Operation), 5 (Invalid XML Format), 6
(Invalid XML Content), 7 (Reboot Required)-->0
</statusCode>
<statusString>
<!--ro, req, enum, status information, subType:string, desc:"OK" (succeeded), "Device Busy", "Device Error", "Invalid Operation", "Invalid XML Format",
"Invalid XML Content", "Reboot" (reboot device)-->OK
</statusString>
<subStatusCode>
<!--ro, req, string, sub status code, which describes the error in details, desc:sub status code, which describes the error in details-->OK
</subStatusCode>
</ResponseStatus>
statusCode statusString subStatusCode
Device Error theDeviceIsOffline
3
3
3
3
errorCode description
0x30008007 The device is offline
Device Error deviceIsForwardedByTheRepeater 0x30008008 Device is forwarded by the repeater
Device Error lowBattery
0x30008009 Low battery
Device Error theSignalIsUnstable
21.12.2 Get the device upgrade progress
Request URL
GET /ISAPI/System/upgradeStatus?format=json
Query Parameter
None
Request Message
None
Response Message
{
"requestURL": "/ISAPI/Streaming/channels/1",
/*ro, opt, string, request URL*/
"statusCode": "test",
/*ro, req, string, status code*/
"statusString": "test",
/*ro, req, string, status description*/
"subStatusCode": "test",
/*ro, req, string, sub status code*/
"errorCode": 1,
/*ro, opt, int, This field is required when the value of statusCode is not 1, and it corresponds to subStatusCode.*/
"errorMsg": "ok",
/*ro, opt, string, This field is required when the value of statusCode is not 1. Detailed error description of a certain parameter can be provided*/
"upgrading": "TRUE",
/*ro, opt, string, whether the device is upgrading: “TRUE" (upgrading), "FALSE" (not in upgrading)*/
"percent": 22,
/*ro, opt, int, upgrade progress (% complete)*/
"idList": [
/*ro, opt, array, ID list, subType:object*/
{
"id": "test",
/*ro, req, string, analysis unit ID*/
"percent": 22,
/*ro, opt, int, upgrade progress (% complete)*/
"status": "test"
/*ro, opt, string, "backingUp" (backing up upgrade)*/
}
]
}
21.12.3 Get the capabilities of peripheral module upgrade
Request URL
0x3000800A The signal is unstable


GET /ISAPI/System/AcsUpdate/capabilities
Query Parameter
None
Request Message
None
Response Message
<?xml version="1.0" encoding="UTF-8"?>
<AcsUpdate xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--ro, req, object, capabilities of peripheral module upgrade, attr:version{req, string, protocolVersion}-->
<type
opt="cardReader,FPModule,securityModule,extendModule,channelController,IRModule,lampModule,elevatorController,FPAlgorithmProgram,uboot,keypad,wirelessRecv,w
iredZone,sirenIndoor,sirenOutdoor,sirenAudio,repeater,bluetoothModule,single,wallSwitch,smartPlug,detector,transmitter,remoteCtrl,subModule,dispModule,netRe
ader,lockControlBoard,networkZoneModule,userInterfaceBoard,subPermissionController,electricLock,heatingModule,RS485Module,QRCodeModule">
<!--ro, opt, enum, upgrade type (peripheral type), subType:string, attr:opt{req, string}, desc:"cardReader" (485 card reader), "FPModule" (fingerprint
module), "securityModule" (security module), "extendModule" (I/O extended module), "channelController" (lane controller), "IRModule" (infrared module),
"lampModule" (indicator module), "elevatorController" (sub elevator controller), "FPAlgorithmProgram" (fingerprint algorithm programma of card reader),
"uboot" (uboot upgrade), "keypad" (keypad), "wirelessRecv" (wireless receiver module), "wiredZone" (wired zone module), "sirenIndoor" (indoor siren),
"sirenOutdoor" (outdoor siren), "sirenAudio" (siren two-way audio), "repeater" (repeater), "bluetoothModule" (bluetooth module), "single" (single output
module), "wallSwitch" (wall mounted switch), "smartPlug" (smart plug), "detector" (detector), "transmitter" (transmitter peripheral), "remoteCtrl" (keyfob),
"subModule" (sub module), "dispModule" (display module), "netReader" (network card reader), "faceModule" (face module), "touchScreenModule" (touch screen
module), "temperatureModule" (temperature measurement module), "lockControlBoard" (lock control board), "networkZoneModule" (network zone module),
"userInterfaceBoard" (interface board), "subPermissionController" (sub permission controller), "electricLock" (electric lock), "heatingModule" (heating
module), "RS485Module" (RS-485 module), "QRCodeModule" (QR code module)-->cardReader
</type>
<cardReaderNo min="1" max="10" opt="1,4">
<!--ro, opt, int, card reader No. range, it is valid when the returned value of type consists cardReader, attr:min{opt, int, step:1},max{opt, int,
step:1},opt{opt, string}-->1
</cardReaderNo>
<FPModuleNo min="1" max="10">
<!--ro, opt, int, fingerprint module No. range, it is valid when the returned value of type consists FPModule, attr:min{req, int},max{req, int}-->1
</FPModuleNo>
<securityModuleNo min="1" max="10">
<!--ro, opt, int, security module No. range, it is valid when the returned value of type consists securityModule, attr:min{req, int},max{req, int}-->1
</securityModuleNo>
<extendModuleNo min="1" max="10">
<!--ro, opt, int, No. range of I/O extended module, it is valid when the returned value of type consists extendModule, attr:min{req, int},max{req, int}->1
</extendModuleNo>
<channelControllerNo
min="1" max="10">
<!--ro, opt, int, lane controller No. range, it is valid when the returned value of type consists channelController, attr:min{req, int},max{req, int}-
>1
</channelControllerNo>
<IRModuleNo min="1" max="10">
<!--ro, opt, int, infrared module No. range, it is valid when the returned value of type consists IRModule, attr:min{req, int},max{req, int}-->1
</IRModuleNo>
<lampModuleNo min="1" max="10">
<!--ro, opt, int, indicator module No. range, it is valid when the returned value of type consists lampModule, attr:min{req, int},max{req, int}-->1
</lampModuleNo>
<elevatorControllerNo min="1" max="10">
<!--ro, opt, int, sub elevator controller No. range, it is valid when the returned value of type consists elevatorController, attr:min{req,
int},max{req, int}-->1
</elevatorControllerNo>
<FPAlgorithmProgramNo min="1" max="10">
<!--ro, opt, int, No. range of fingerprint algorithm programma of card reader, it is valid when the returned value of type consists FPAlgorithmProgram,
attr:min{req, int},max{req, int}-->1
</FPAlgorithmProgramNo>
<faceModuleNo min="1" max="10">
<!--ro, opt, int, face module No. range, it is valid when the returned value of type consists faceModule, attr:min{req, int},max{req, int}-->1
</faceModuleNo>
<touchScreenModuleNo min="1" max="10">
<!--ro, opt, int, touch screen module No. range, it is valid when the returned value of type consists touchScreenModule, attr:min{req, int},max{req,
int}-->1
</touchScreenModuleNo>
<temperatureModuleNo min="1" max="10">
<!--ro, opt, int, No. range of temperature measurement module, it is valid when the returned value of type consists temperatureModule, attr:min{req,
int},max{req, int}-->1
</temperatureModuleNo>
<keypadAddress opt="1,3,5">
<!--ro, opt, int, keypad address range, it is valid when the returned value of type consists keypad, attr:opt{req, string}-->1
</keypadAddress>
<wirelessRecvAddress opt="1,3,5">
<!--ro, opt, int, No. range of wireless receiver module, it is valid when the returned value of type consists wirelessRecv, attr:opt{req, string}-->1
</wirelessRecvAddress>
<wiredZoneAddress opt="1,3,5">
<!--ro, opt, int, No. range of wired zone module, it is valid when the returned value of type consists wiredZone, attr:opt{req, string}-->1
</wiredZoneAddress>
<sirenIndoorNo opt="1,3,5">
<!--ro, opt, int, indoor siren No. range, it is valid when the returned value of type consists sirenIndoor, attr:opt{req, string}-->1
</sirenIndoorNo>
<sirenOutdoorNo opt="1,3,5">
<!--ro, opt, int, outdoor siren No. range, it is valid when the returned value of type consists sirenOutdoor, attr:opt{req, string}-->1
</sirenOutdoorNo>
<repeaterNo opt="1,3,5">
<!--ro, opt, int, repeater No. range, it is valid when the returned value of type consists repeater, attr:opt{req, string}-->1


</repeaterNo>
<subModuleNo opt="1,3,5">
<!--ro, opt, int, sub module No. range, it is valid when the returned value of type consists subModule, attr:opt{req, string}-->1
</subModuleNo>
<dispModuleNo opt="1,3,5">
<!--ro, opt, int, display module No. range, it is valid when the returned value of type consists dispModule, attr:opt{req, string}-->1
</dispModuleNo>
<single opt="1,3,5">
<!--ro, opt, int, No. range of single output module, it is valid when the returned value of type consists single, attr:opt{req, string}-->1
</single>
<wallSwitch opt="1,3,5">
<!--ro, opt, int, No. range of wall mounted switch, it is valid when the returned value of type consists wallSwitch, attr:opt{req, string}-->1
</wallSwitch>
<smartPlug opt="1,3,5">
<!--ro, opt, int, smart plug No. range, it is valid when the returned value of type consists smartPlug, attr:opt{req, string}-->1
</smartPlug>
<zoneNo opt="1,3,5">
<!--ro, opt, int, zone No. range, it is valid when the returned value of type consists detector, attr:opt{req, string}, desc:get the detector via the
zone No.-->1
</zoneNo>
<transmitterNo opt="1,3,5">
<!--ro, opt, int, transmitter No. range, it is valid when the returned value of type consists transmitter, attr:opt{req, string}-->1
</transmitterNo>
<remoteCtrlNo opt="1,3,5">
<!--ro, opt, int, keyfob No. range, it is valid when the returned value of type consists remoteCtrl, attr:opt{req, string}-->1
</remoteCtrlNo>
<netReaderNo min="1" max="10">
<!--ro, opt, int, No. range of network card reader, it is valid when the returned value of type consists netReader, attr:min{req, int},max{req, int}-->1
</netReaderNo>
<lockControlBoardLNo opt="1,2,3,4,5,6,7,8">
<!--ro, opt, int, attr:opt{req, string}-->1
</lockControlBoardLNo>
<lockControlBoardRNo opt="1,2,3,4,5,6,7,8">
<!--ro, opt, int, attr:opt{req, string}-->1
</lockControlBoardRNo>
<networkZoneModuleNo opt="1,3,5">
<!--ro, opt, int, No. range of network zone module, it is valid when the returned value of type consists networkZoneModule, attr:opt{req, string}-->1
</networkZoneModuleNo>
<userInterfaceBoardNo opt="0,1">
<!--ro, opt, enum, interface board No. range, it is valid when the returned value of type consists userInterfaceBoard, subType:string, attr:opt{req,
string}-->0
</userInterfaceBoardNo>
<electricLockNo opt="1,3,5">
<!--ro, opt, int, electric lock No. range, it is valid when the returned value of type consists electricLock, attr:opt{req, string}-->1
</electricLockNo>
<heatingModuleNo opt="1,3,5">
<!--ro, opt, int, heating module No. range, it is valid when the returned value of type consists heatingModule, attr:opt{req, string}, desc:the heating
module starts to work to increase the device temperature when the devices runs under low temperature-->1
</heatingModuleNo>
<RS485ModuleNo opt="1,3,5">
<!--ro, opt, int, RS-485 module No. range, it is valid when the returned value of type consists RS485Module, step:1, attr:opt{req, string}-->1
</RS485ModuleNo>
<sirenAudioNo opt="1,3,5">
<!--ro, opt, int, siren (two-way audio) No. range, it is valid when the returned value of type consists sirenAudio, attr:opt{req, string}-->1
</sirenAudioNo>
<QRCodeModuleNo min="1" max="10">
<!--ro, opt, int, No. range of QR code module, it is valid when the returned value of type consists QRCodeModule, attr:min{req, int},max{req, int}-->1
</QRCodeModuleNo>
</AcsUpdate>
21.12.4 Get the device upgrading status and progress
Request URL
GET /ISAPI/System/upgradeStatus?type=<Type>
Query Parameter
Parameter Name Parameter Type Description
Type
string
Request Message
None
Response Message
-


<?xml version="1.0" encoding="UTF-8"?>
<upgradeStatus xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--ro, req, object, upgrade status and result, attr:version{req, string, protocolVersion}-->
<upgrading>
<!--ro, req, bool, upgrade status-->true
</upgrading>
<percent>
<!--ro, req, int, upgrade progress (% complete), range:[0,100]-->1
</percent>
</upgradeStatus>
21.13 Video Image Settings
21.13.1 Get image standard parameters of a specific channel
Request URL
GET /ISAPI/Image/channels/<channelID>/powerLineFrequency
Query Parameter
Parameter Name Parameter Type Description
channelID
string
Request Message
None
Response Message
<?xml version="1.0" encoding="UTF-8"?>
<powerLineFrequency xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--ro, req, object, standard mode: "50hz, 60hz", attr:version{req, string, protocolVersion}-->
<powerLineFrequencyMode>
<!--ro, opt, enum, subType:string-->50hz
</powerLineFrequencyMode>
</powerLineFrequency>
21.13.2 Set the video signal standard for a specified channel
Request URL
PUT /ISAPI/Image/channels/<channelID>/powerLineFrequency
Query Parameter
Parameter Name Parameter Type Description
channelID
string
Request Message
<?xml version="1.0" encoding="UTF-8"?>
<powerLineFrequency xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--req, object, video signal standard, attr:version{req, string, protocolVersion}-->
<powerLineFrequencyMode>
<!--opt, enum, mode of the video signal standard, subType:string, desc:"50hz", "60hz"-->50hz
</powerLineFrequencyMode>
</powerLineFrequency>
Response Message
-
-


<?xml version="1.0" encoding="UTF-8"?>
<ResponseStatus xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--ro, req, object, response message, attr:version{ro, req, string, protocolVersion}-->
<requestURL>
<!--ro, req, string, request URL-->null
</requestURL>
<statusCode>
<!--ro, req, enum, status code, subType:int, desc:0 (OK), 1 (OK), 2 (Device Busy), 3 (Device Error), 4 (Invalid Operation), 5 (Invalid XML Format), 6
(Invalid XML Content), 7 (Reboot Required)-->0
</statusCode>
<statusString>
<!--ro, req, enum, status information, subType:string, desc:"OK" (succeeded), "Device Busy", "Device Error", "Invalid Operation", "Invalid XML Format",
"Invalid XML Content", "Reboot" (reboot device)-->OK
</statusString>
<subStatusCode>
<!--ro, req, string, sub status code, which describes the error in details, desc:sub status code, which describes the error in details-->OK
</subStatusCode>
</ResponseStatus>
21.14 Image Adjustment
21.14.1 Get the image adjustment parameters in auto mode of a specific channel
Request URL
GET /ISAPI/Image/channels/<channelID>/color
Query Parameter
Parameter Name Parameter Type Description
channelID
string
Request Message
None
Response Message
<?xml version="1.0" encoding="UTF-8"?>
<Color xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--ro, opt, object, attr:version{opt, string, protocolVersion}-->
<brightnessLevel>
<!--ro, opt, int, brightness-->24
</brightnessLevel>
<contrastLevel>
<!--ro, opt, int, contrast-->22
</contrastLevel>
<saturationLevel>
<!--ro, opt, int, saturation, dep:and,{$.Color.nightMode,eq,true}-->33
</saturationLevel>
<hueLevel>
<!--ro, opt, int, hue-->55
</hueLevel>
<grayScale>
<!--ro, opt, object-->
<grayScaleMode>
<!--ro, opt, enum, gray scale mode, subType:string, desc:"indoor", "outdoor"-->outdoor
</grayScaleMode>
</grayScale>
<nightMode>
<!--ro, opt, bool, whether to enable night mode-->true
</nightMode>
<redBrightnessLevel>
<!--ro, opt, int, range:[0,100]-->0
</redBrightnessLevel>
<sharpnessLevel>
<!--ro, opt, int, sharpness, range:[0,100]-->0
</sharpnessLevel>
</Color>
-
21.14.2 Set the image adjustment parameters in auto mode of a specific channel
Request URL
PUT /ISAPI/Image/channels/<channelID>/color
Query Parameter


Parameter Name Parameter Type Description
channelID
string
Request Message
<?xml version="1.0" encoding="UTF-8"?>
<Color xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--opt, object, attr:version{opt, string, protocolVersion}-->
<brightnessLevel>
<!--opt, int, brightness-->24
</brightnessLevel>
<contrastLevel>
<!--opt, int, contrast-->22
</contrastLevel>
<saturationLevel>
<!--opt, int, saturation, dep:and,{$.Color.nightMode,eq,true}-->33
</saturationLevel>
<hueLevel>
<!--opt, int, hue-->55
</hueLevel>
<grayScale>
<!--opt, object, gray scale-->
<grayScaleMode>
<!--opt, enum, gray scale mode, subType:string, desc:"indoor", "outdoor"-->outdoor
</grayScaleMode>
</grayScale>
<nightMode>
<!--opt, bool, whether to enable night mode, when its value is "true", the saturation can be adjusted, otherwise, the saturation cannot be adjusted-
>true
</nightMode>
<redBrightnessLevel>
<!--opt, int, range:[0,100]-->0
</redBrightnessLevel>
<sharpnessLevel>
<!--opt, int, range:[0,100]-->0
</sharpnessLevel>
</Color>
Response Message
<?xml version="1.0" encoding="UTF-8"?>
<ResponseStatus xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--ro, req, object, response message, attr:version{ro, req, string, protocolVersion}-->
<requestURL>
<!--ro, req, string, request URL-->/ISAPI/xxxx
</requestURL>
<statusCode>
<!--ro, req, enum, status code, subType:int, desc:0 (OK), 1 (OK), 2 (Device Busy), 3 (Device Error), 4 (Invalid Operation), 5 (Invalid XML Format), 6
(Invalid XML Content), 7 (Reboot Required)-->0
</statusCode>
<statusString>
<!--ro, req, enum, status information, subType:string, desc:"OK" (succeeded), "Device Busy", "Device Error", "Invalid Operation", "Invalid XML Format",
"Invalid XML Content", "Reboot" (reboot device)-->OK
</statusString>
<subStatusCode>
<!--ro, req, string, sub status code, which describes the error in details, desc:sub status code, which describes the error in details-->OK
</subStatusCode>
</ResponseStatus>
21.14.3 Get the sharpness control parameters of a specific channel
Request URL
GET /ISAPI/Image/channels/<channelID>/sharpness
Query Parameter
Parameter Name Parameter Type Description
channelID
string
Request Message
None
Response Message
-
-


<?xml version="1.0" encoding="UTF-8"?>
<Sharpness xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--ro, opt, object, sharpness, attr:version{opt, string, protocolVersion}-->
<SharpnessMode>
<!--ro, opt, enum, mode, subType:string, desc:"manual", "auto"-->manual
</SharpnessMode>
<SharpnessLevel>
<!--ro, req, int, sharpness level-->1
</SharpnessLevel>
</Sharpness>
21.14.4 Set the sharpness control parameters of a specific channel
Request URL
PUT /ISAPI/Image/channels/<channelID>/sharpness
Query Parameter
Parameter Name Parameter Type Description
channelID
string
Request Message
<?xml version="1.0" encoding="UTF-8"?>
<Sharpness xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--opt, object, sharpness, attr:version{opt, string, protocolVersion}-->
<SharpnessMode>
<!--opt, enum, mode, subType:string, desc:"manual", "auto"-->manual
</SharpnessMode>
<SharpnessLevel>
<!--req, int, sharpness level-->1
</SharpnessLevel>
</Sharpness>
Response Message
<?xml version="1.0" encoding="UTF-8"?>
<ResponseStatus xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--ro, req, object, response message, attr:version{ro, req, string, protocolVersion}-->
<requestURL>
<!--ro, req, string, request URL-->/ISAPI/xxxx
</requestURL>
<statusCode>
<!--ro, req, enum, status code, subType:int, desc:0 (OK), 1 (OK), 2 (Device Busy), 3 (Device Error), 4 (Invalid Operation), 5 (Invalid XML Format), 6
(Invalid XML Content), 7 (Reboot Required)-->0
</statusCode>
<statusString>
<!--ro, req, enum, status information, subType:string, desc:"OK" (succeeded), "Device Busy", "Device Error", "Invalid Operation", "Invalid XML Format",
"Invalid XML Content", "Reboot" (reboot device)-->OK
</statusString>
<subStatusCode>
<!--ro, req, string, sub status code, which describes the error in details, desc:sub status code, which describes the error in details-->OK
</subStatusCode>
</ResponseStatus>
21.14.5 Restore the image parameters of a specific channel to default settings
Request URL
PUT /ISAPI/Image/channels/<channelID>/restore
Query Parameter
Parameter Name Parameter Type Description
channelID
string
Request Message
None
-
-


Response Message
<?xml version="1.0" encoding="UTF-8"?>
<ResponseStatus xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--ro, req, object, response message, attr:version{ro, req, string, protocolVersion}-->
<requestURL>
<!--ro, req, string, request URL-->/ISAPI/xxxx
</requestURL>
<statusCode>
<!--ro, req, enum, status code, subType:int, desc:0 (OK), 1 (OK), 2 (Device Busy), 3 (Device Error), 4 (Invalid Operation), 5 (Invalid XML Format), 6
(Invalid XML Content), 7 (Reboot Required)-->0
</statusCode>
<statusString>
<!--ro, req, enum, status information, subType:string, desc:"OK" (succeeded), "Device Busy", "Device Error", "Invalid Operation", "Invalid XML Format",
"Invalid XML Content", "Reboot" (reboot device)-->OK
</statusString>
<subStatusCode>
<!--ro, req, string, sub status code, which describes the error in details, desc:sub status code, which describes the error in details-->OK
</subStatusCode>
</ResponseStatus>
21.14.6 Get the image mode parameters of all channels
Request URL
GET /ISAPI/Image/channels/imageModes
Query Parameter
None
Request Message
None
Response Message
<?xml version="1.0" encoding="UTF-8"?>
<ImageModeList xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--ro, req, array, image mode configurations, subType:object, attr:version{req, string, protocolVersion}-->
<ImageMode>
<!--ro, opt, object, image mode-->
<type>
<!--ro, req, enum, type, subType:string, desc:"standard", "indoor", "outdoor", "dimLight", "bright", "soft", "vivid"-->standard
</type>
<recommendation>
<!--ro, req, object, recommended configurations-->
<brightnessLevel>
<!--ro, opt, int, brightness, range:[0,100]-->1
</brightnessLevel>
<contrastLevel>
<!--ro, opt, int, contrast, range:[0,100]-->1
</contrastLevel>
<sharpnessLevel>
<!--ro, opt, int, sharpness, range:[0,100]-->1
</sharpnessLevel>
<saturationLevel>
<!--ro, opt, int, saturation, range:[0,100]-->1
</saturationLevel>
<hueLevel>
<!--ro, opt, int, hue, range:[0,100]-->1
</hueLevel>
<deNoiseLevel>
<!--ro, opt, int, noise reduction, range:[0,100]-->1
</deNoiseLevel>
</recommendation>
</ImageMode>
</ImageModeList>
21.14.7 Get the configuration parameters of all image modes of a specific channel
Request URL
GET /ISAPI/Image/channels/imageModes/<channelID>
Query Parameter


Parameter Name Parameter Type Description
channelID
string
Request Message
None
Response Message
<?xml version="1.0" encoding="UTF-8"?>
<ImageMode xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--ro, opt, object, attr:version{req, string, protocolVersion}-->
<type>
<!--ro, req, enum, "standard,indoor,outdoor,dimLight", subType:string-->standard
</type>
<recommendation>
<!--ro, req, object, ro-->
<brightnessLevel>
<!--ro, opt, int, ranging from 0 to 100, range:[0,100]-->1
</brightnessLevel>
<contrastLevel>
<!--ro, opt, int, ranging from 0 to 100, range:[0,100]-->1
</contrastLevel>
<sharpnessLevel>
<!--ro, opt, int, ranging from 0 to 100, range:[0,100]-->1
</sharpnessLevel>
<saturationLevel>
<!--ro, opt, int, ranging from 0 to 100, range:[0,100]-->1
</saturationLevel>
<hueLevel>
<!--ro, opt, int, ranging from 0 to 100, range:[0,100]-->1
</hueLevel>
<deNoiseLevel>
<!--ro, opt, int, ranging from 0 to 100, range:[0,100]-->1
</deNoiseLevel>
</recommendation>
</ImageMode>
-
21.15 Image Light Supplement
21.15.1 Set supplement light parameters of a specific channel
Request URL
PUT /ISAPI/Image/channels/<channelID>/supplementLight
Query Parameter
Parameter Name Parameter Type Description
channelID
string
Request Message
<?xml version="1.0" encoding="UTF-8"?>
<SupplementLight xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--req, object, attr:version{req, string, protocolVersion}-->
<mode>
<!--opt, enum, adjustment mode of supplement light, subType:string, desc:"schedule", "off", "on", "auto", "manual"-->auto
</mode>
<Schedule>
<!--opt, object-->
<TimeRange>
<!--req, object-->
<beginTime>
<!--req, time, start time-->00:08:00+08:00
</beginTime>
<endTime>
<!--req, time, end time-->00:18:00+08:00
</endTime>
</TimeRange>
</Schedule>
<brightnessLimit>
<!--opt, int, brightness limit of white supplement light, desc:the brightness can be adjust when the node mode is set to "on"-->80
</brightnessLimit>
<supplementLightMode>
<!--opt, enum, mode of supplement light, subType:string, desc:illumination mode: "mixed"-hybrid,"whitelight"-white light,"close"-disabled-->mixed
</supplementLightMode>
<irLightBrightness>
-


<irLightBrightness>
<!--opt, int, brightness of IR supplement light, range:[0,100], desc:this node is valid when supplementLightMode is set to "mixed" and
mixedLightBrightnessRegulatMode is set to "manual"-->80
</irLightBrightness>
<mixedLightBrightnessRegulatMode>
<!--opt, enum, brightness adjustment mode of mixed supplement light, subType:string, desc:"manual" (in this mode, you need to set the parameters
irLightBrightness and brightnessLimit), "auto" (brightness-related parameters are not required). This node is valid when supplementLightMode is set to
"mixed"-->auto
</mixedLightBrightnessRegulatMode>
<highIrLightBrightness>
<!--opt, int, brightness of far IR supplement light, range:[0,100], desc:it is shared by different supplement light modes, including "mixed",
"whiteLight", "colorVuWhiteLight", "irLight", and "dualLight"-->80
</highIrLightBrightness>
<highWhiteLightBrightness>
<!--opt, int, brightness of far white supplement light, range:[0,100], desc:it is shared by different supplement light modes, including "mixed",
"whiteLight", "colorVuWhiteLight", "irLight", and "dualLight"-->80
</highWhiteLightBrightness>
<lowIrLightBrightness>
<!--opt, int, brightness of near IR supplement light, range:[0,100], desc:it is shared by different supplement light modes, including "mixed",
"whiteLight", "colorVuWhiteLight", "irLight", and "dualLight"-->80
</lowIrLightBrightness>
<lowWhiteLightBrightness>
<!--opt, int, brightness of near white supplement light, range:[0,100], desc:it is shared by different supplement light modes, including "mixed",
"whiteLight", "colorVuWhiteLight", "irLight", and "dualLight"-->80
</lowWhiteLightBrightness>
<whiteLightBrightness>
<!--opt, int, light brightness (regardless of far or near light), range:[0,100], desc:it is shared by different supplement light modes, including
"mixed", "whiteLight", "colorVuWhiteLight", "irLight”, and "dualLight", when the adjustment mode of the supplement light is "auto"-->80
</whiteLightBrightness>
<WhiteLightModeCfg>
<!--opt, object-->
<highWhiteLightBrightness>
<!--opt, int, brightness of far white supplement light, range:[0,100]-->80
</highWhiteLightBrightness>
<lowWhiteLightBrightness>
<!--opt, int, brightness of near white supplement light, range:[0,100]-->80
</lowWhiteLightBrightness>
<whiteLightBrightness>
<!--opt, int, white light brightness (regardless of far or near light), range:[0,100]-->80
</whiteLightBrightness>
</WhiteLightModeCfg>
<irLightbrightnessLimit>
<!--opt, int, brightness limit of IR supplement light, range:[0,100], desc:this node is valid when the value of Mode is "auto" and supplementLightMode
is "mixed".-->80
</irLightbrightnessLimit>
<whiteLightbrightnessLimit>
<!--opt, int, brightness limit of white supplement light, range:[0,100], desc:this node is valid when the value of Mode is "auto" and
supplementLightMode is "mixed".-->80
</whiteLightbrightnessLimit>
<EventIntelligenceModeCfg>
<!--opt, object-->
<brightnessRegulatMode>
<!--opt, enum, subType:string-->auto
</brightnessRegulatMode>
<whiteLightBrightness>
<!--opt, int, white light brightness (regardless of far or near light), range:[0,100]-->80
</whiteLightBrightness>
<irLightBrightness>
<!--opt, int, IR light brightness (regardless of far or near light), range:[0,100]-->80
</irLightBrightness>
<BrightnessCtrlList>
<!--opt, array, subType:object-->
<BrightnessCtrl>
<!--opt, object-->
<lightType>
<!--opt, enum, subType:string-->highWhite
</lightType>
<brightness>
<!--opt, int, supplement light brightness, range:[0,100]-->80
</brightness>
</BrightnessCtrl>
</BrightnessCtrlList>
</EventIntelligenceModeCfg>
<MultiAzimuthMixedModeCfg>
<!--opt, object-->
<brightnessRegulatMode>
<!--opt, enum, subType:string-->auto
</brightnessRegulatMode>
<LightCtrlList>
<!--opt, array, subType:object-->
<LightCtrl>
<!--opt, object-->
<azimuthType>
<!--opt, enum, subType:string-->left
</azimuthType>
<lightType>
<!--opt, enum, subType:string-->highWhite
</lightType>
<brightness>
<!--opt, int, supplement light brightness, range:[0,100]-->80
</brightness>
</LightCtrl>
</LightCtrlList>
<regulatSensitivityType>


<regulatSensitivityType>
<!--opt, enum, subType:string, dep:and,{$.SupplementLight.MultiAzimuthMixedModeCfg.brightnessRegulatMode,eq,auto}-->fast
</regulatSensitivityType>
</MultiAzimuthMixedModeCfg>
<MultiAzimuthWhiteLightCfg>
<!--opt, object-->
<brightnessRegulatMode>
<!--opt, enum, subType:string-->auto
</brightnessRegulatMode>
<LightCtrlList>
<!--opt, array, subType:object-->
<LightCtrl>
<!--opt, object-->
<azimuthType>
<!--opt, enum, subType:string-->left
</azimuthType>
<lightType>
<!--opt, enum, subType:string-->highWhite
</lightType>
<brightness>
<!--opt, int, supplement light brightness, range:[0,100]-->80
</brightness>
</LightCtrl>
</LightCtrlList>
<regulatSensitivityType>
<!--opt, enum, subType:string, dep:and,{$.SupplementLight.MultiAzimuthWhiteLightCfg.brightnessRegulatMode,eq,auto}-->fast
</regulatSensitivityType>
</MultiAzimuthWhiteLightCfg>
<MultiAzimuthIrLightCfg>
<!--opt, object-->
<brightnessRegulatMode>
<!--opt, enum, subType:string-->auto
</brightnessRegulatMode>
<LightCtrlList>
<!--opt, array, subType:object-->
<LightCtrl>
<!--opt, object-->
<azimuthType>
<!--opt, enum, subType:string-->left
</azimuthType>
<lightType>
<!--opt, enum, subType:string-->highIrLight
</lightType>
<brightness>
<!--opt, int, supplement light brightness, range:[0,100]-->80
</brightness>
</LightCtrl>
</LightCtrlList>
</MultiAzimuthIrLightCfg>
<PanoramicWhiteLightCfg>
<!--opt, object-->
<brightnessRegulatMode>
<!--opt, enum, subType:string-->auto
</brightnessRegulatMode>
<LightCtrlList>
<!--opt, array, subType:object-->
<LightCtrl>
<!--opt, object-->
<lightID>
<!--opt, int, range:[1,4]-->1
</lightID>
<brightness>
<!--opt, int, supplement light brightness, range:[0,100]-->80
</brightness>
</LightCtrl>
</LightCtrlList>
</PanoramicWhiteLightCfg>
<PanoramicIrLightCfg>
<!--opt, object-->
<brightnessRegulatMode>
<!--opt, enum, subType:string-->auto
</brightnessRegulatMode>
<LightCtrlList>
<!--opt, array, subType:object-->
<LightCtrl>
<!--opt, object-->
<lightID>
<!--opt, int, range:[1,4]-->1
</lightID>
<brightness>
<!--opt, int, supplement light brightness, range:[0,100]-->80
</brightness>
</LightCtrl>
</LightCtrlList>
</PanoramicIrLightCfg>
<whiteLightEnhanceEnabled>
<!--opt, bool-->true
</whiteLightEnhanceEnabled>
<LightManualCtrlList>
<!--opt, array, subType:object, dep:and,{$.SupplementLight.mode,eq,manual}-->
<LightCtrl>
<!--opt, object-->
<lightType>
<!--opt, enum, subType:string-->highIrLight
</lightType>


</lightType>
<brightness>
<!--opt, int, supplement light brightness, range:[0,100]-->80
</brightness>
</LightCtrl>
</LightManualCtrlList>
</SupplementLight>
Response Message
<?xml version="1.0" encoding="UTF-8"?>
<ResponseStatus xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--ro, req, object, attr:version{ro, req, string, protocolVersion}-->
<requestURL>
<!--ro, req, string, request URL-->null
</requestURL>
<statusCode>
<!--ro, req, enum, status code, subType:int, desc:0 (OK), 1 (OK), 2 (Device Busy), 3 (Device Error), 4 (Invalid Operation), 5 (Invalid XML Format), 6
(Invalid XML Content), 7 (Reboot Required)-->0
</statusCode>
<statusString>
<!--ro, req, enum, status description, subType:string, desc:“OK” (succeeded), “Device Busy”, “Device Error”, “Invalid Operation”, “Invalid XML Format”,
“Invalid XML Content”, “Reboot” (reboot device)-->OK
</statusString>
<subStatusCode>
<!--ro, req, string, sub status code, desc:sub status code-->OK
</subStatusCode>
</ResponseStatus>
21.15.2 Get supplement light parameters of a specific channel
Request URL
GET /ISAPI/Image/channels/<channelID>/supplementLight
Query Parameter
Parameter Name Parameter Type Description
channelID
string
Request Message
None
Response Message
<?xml version="1.0" encoding="UTF-8"?>
<SupplementLight xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--ro, req, object, attr:version{req, string, protocolVersion}-->
<mode>
<!--ro, opt, enum, adjustment mode of supplement light, subType:string, desc:adjustment mode of supplement light,off,on,auto"-->auto
</mode>
<Schedule>
<!--ro, opt, object-->
<TimeRange>
<!--ro, req, object-->
<beginTime>
<!--ro, req, time, ISO8601 time-->00:08:00+08:00
</beginTime>
<endTime>
<!--ro, req, time, ISO8601 time-->00:18:00+08:00
</endTime>
</TimeRange>
</Schedule>
<brightnessLimit>
<!--ro, opt, int, brightness limit of supplement light, desc:brightness can be adjusted when mode is set to "on"-->80
</brightnessLimit>
<supplementLightMode>
<!--ro, opt, enum, illumination mode, subType:string, desc:"mixed" (hybrid), "whiteLight" (white light), "close" (disabled)-->mixed
</supplementLightMode>
<irLightBrightness>
<!--ro, opt, int, brightness of IR supplement light, range:[0,100], desc:this node is valid only when supplementLightMode is set to "mixed" and
mixedLightBrightnessRegulatMode is set to "manual"-->80
</irLightBrightness>
<mixedLightBrightnessRegulatMode>
<!--ro, opt, enum, brightness adjustment mode of hybrid supplement light, subType:string, desc:this node is valid only when supplementLightMode is set
to "mixed"-->auto
</mixedLightBrightnessRegulatMode>
<highIrLightBrightness>
<!--ro, opt, int, brightness of far IR light, range:[0,100], desc:brightness of far IR light,which is between 0 and 100; this node cannot be configured
together with node <irLightBrightness>-->80
-


together with node <irLightBrightness>-->80
</highIrLightBrightness>
<highWhiteLightBrightness>
<!--ro, opt, int, brightness of far white light, range:[0,100], desc:brightness of far white light,which is between 0 and 100; this node cannot be
configured together with node <brightnessLimit>-->80
</highWhiteLightBrightness>
<lowIrLightBrightness>
<!--ro, opt, int, brightness of near IR light, range:[0,100], desc:brightness of near IR light,which is between 0 and 100; this node cannot be
configured together with node <irLightBrightness>-->80
</lowIrLightBrightness>
<lowWhiteLightBrightness>
<!--ro, opt, int, brightness of near white light, range:[0,100], desc:brightness of near white light,which is between 0 and 100; this node cannot be
configured together with node <brightnessLimit>-->80
</lowWhiteLightBrightness>
<whiteLightBrightness>
<!--ro, opt, int, white light brightness, range:[0,100], desc:white light brightness,which is between 0 and 100-->80
</whiteLightBrightness>
<WhiteLightModeCfg>
<!--ro, opt, object-->
<highWhiteLightBrightness>
<!--ro, opt, int, brightness of far white light, range:[0,100]-->80
</highWhiteLightBrightness>
<lowWhiteLightBrightness>
<!--ro, opt, int, brightness of near white light, range:[0,100]-->80
</lowWhiteLightBrightness>
<whiteLightBrightness>
<!--ro, opt, int, white light brightness, range:[0,100]-->80
</whiteLightBrightness>
</WhiteLightModeCfg>
<irLightbrightnessLimit>
<!--ro, opt, int, IR light brightness limit, range:[0,100], desc:this node is valid only when mode is set to "auto" and supplementLightMode is set to
"mixed"-->80
</irLightbrightnessLimit>
<whiteLightbrightnessLimit>
<!--ro, opt, int, white light brightness limit, range:[0,100], desc:this node is valid only when mode is set to "auto" and supplementLightMode is set to
"mixed"-->80
</whiteLightbrightnessLimit>
<EventIntelligenceModeCfg>
<!--ro, opt, object-->
<brightnessRegulatMode>
<!--ro, opt, enum, subType:string-->auto
</brightnessRegulatMode>
<whiteLightBrightness>
<!--ro, opt, int, white light brightness, range:[0,100]-->80
</whiteLightBrightness>
<irLightBrightness>
<!--ro, opt, int, IR light brightness, range:[0,100]-->80
</irLightBrightness>
<BrightnessCtrlList>
<!--ro, opt, array, subType:object-->
<BrightnessCtrl>
<!--ro, opt, object-->
<lightType>
<!--ro, opt, enum, subType:string-->highWhite
</lightType>
<brightness>
<!--ro, opt, int, range:[0,100]-->80
</brightness>
</BrightnessCtrl>
</BrightnessCtrlList>
</EventIntelligenceModeCfg>
<MultiAzimuthMixedModeCfg>
<!--ro, opt, object-->
<brightnessRegulatMode>
<!--ro, opt, enum, subType:string-->auto
</brightnessRegulatMode>
<LightCtrlList>
<!--ro, opt, array, subType:object-->
<LightCtrl>
<!--ro, opt, object-->
<azimuthType>
<!--ro, opt, enum, subType:string-->left
</azimuthType>
<lightType>
<!--ro, opt, enum, subType:string-->highWhite
</lightType>
<brightness>
<!--ro, opt, int, range:[0,100]-->80
</brightness>
</LightCtrl>
</LightCtrlList>
<regulatSensitivityType>
<!--ro, opt, enum, subType:string, dep:and,{$.SupplementLight.MultiAzimuthMixedModeCfg.brightnessRegulatMode,eq,auto}-->fast
</regulatSensitivityType>
</MultiAzimuthMixedModeCfg>
<MultiAzimuthWhiteLightCfg>
<!--ro, opt, object-->
<brightnessRegulatMode>
<!--ro, opt, enum, subType:string-->auto
</brightnessRegulatMode>
<LightCtrlList>
<!--ro, opt, array, subType:object-->
<LightCtrl>
<!--ro, opt, object-->
<azimuthType>


<azimuthType>
<!--ro, opt, enum, subType:string-->left
</azimuthType>
<lightType>
<!--ro, opt, enum, subType:string-->highWhite
</lightType>
<brightness>
<!--ro, opt, int, range:[0,100]-->80
</brightness>
</LightCtrl>
</LightCtrlList>
<regulatSensitivityType>
<!--ro, opt, enum, subType:string, dep:and,{$.SupplementLight.MultiAzimuthWhiteLightCfg.brightnessRegulatMode,eq,auto}-->fast
</regulatSensitivityType>
</MultiAzimuthWhiteLightCfg>
<MultiAzimuthIrLightCfg>
<!--ro, opt, object-->
<brightnessRegulatMode>
<!--ro, opt, enum, subType:string-->auto
</brightnessRegulatMode>
<LightCtrlList>
<!--ro, opt, array, subType:object-->
<LightCtrl>
<!--ro, opt, object-->
<azimuthType>
<!--ro, opt, enum, subType:string-->left
</azimuthType>
<lightType>
<!--ro, opt, enum, subType:string-->highIrLight
</lightType>
<brightness>
<!--ro, opt, int, range:[0,100]-->80
</brightness>
</LightCtrl>
</LightCtrlList>
</MultiAzimuthIrLightCfg>
<PanoramicWhiteLightCfg>
<!--ro, opt, object-->
<brightnessRegulatMode>
<!--ro, opt, enum, subType:string-->auto
</brightnessRegulatMode>
<LightCtrlList>
<!--ro, opt, array, subType:object-->
<LightCtrl>
<!--ro, opt, object-->
<lightID>
<!--ro, opt, int, range:[1,4]-->1
</lightID>
<brightness>
<!--ro, opt, int, range:[0,100]-->80
</brightness>
</LightCtrl>
</LightCtrlList>
</PanoramicWhiteLightCfg>
<PanoramicIrLightCfg>
<!--ro, opt, object-->
<brightnessRegulatMode>
<!--ro, opt, enum, subType:string-->auto
</brightnessRegulatMode>
<LightCtrlList>
<!--ro, opt, array, subType:object-->
<LightCtrl>
<!--ro, opt, object-->
<lightID>
<!--ro, opt, int, range:[1,4]-->1
</lightID>
<brightness>
<!--ro, opt, int, range:[0,100]-->80
</brightness>
</LightCtrl>
</LightCtrlList>
</PanoramicIrLightCfg>
<whiteLightEnhanceEnabled>
<!--ro, opt, bool-->true
</whiteLightEnhanceEnabled>
<LightManualCtrlList>
<!--ro, opt, array, subType:object, dep:and,{$.SupplementLight.mode,eq,manual}-->
<LightCtrl>
<!--ro, opt, object-->
<lightType>
<!--ro, opt, enum, subType:string-->highIrLight
</lightType>
<brightness>
<!--ro, opt, int, range:[0,100]-->80
</brightness>
</LightCtrl>
</LightManualCtrlList>
</SupplementLight>
21.15.3 Get the configuration capability of the supplement light parameters of a specific


21.15.3 Get the configuration capability of the supplement light parameters of a specific
channel
Request URL
GET /ISAPI/Image/channels/<channelID>/supplementLight/capabilities
Query Parameter
Parameter Name Parameter Type Description
channelID
string
Request Message
None
Response Message
<?xml version="1.0" encoding="UTF-8"?>
<SupplementLight xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--ro, req, object, attr:version{req, string, protocolVersion}-->
<mode opt="schedule,off,on,auto,manual">
<!--ro, opt, enum, adjustment mode of supplement light, subType:string, attr:opt{req, string}, desc:adjustment mode of supplement light:
"schedule,off,on,auto"-->auto
</mode>
<Schedule>
<!--ro, opt, object-->
<TimeRange>
<!--ro, req, object-->
<beginTime>
<!--ro, req, time, start time-->00:08:00+08:00
</beginTime>
<endTime>
<!--ro, req, time, end time-->00:18:00+08:00
</endTime>
</TimeRange>
</Schedule>
<brightnessLimit min="0" max="100">
<!--ro, opt, int, brightness limit of white supplement light, attr:min{req, int},max{req, int}, desc:brightness of supplement light,which is between 0
and 100; the brightness can be adjust when <mode> is set to "on"-->80
</brightnessLimit>
<supplementLightMode
opt="mixed,whiteLight,colorVuWhiteLight,irLight,dualLight,close,eventIntelligence,multiAzimuthMixed,multiAzimuthWhiteLight,multiAzimuthIrLight,panoramicWhit
eLight,panoramicIrLight">
<!--ro, opt, enum, mode of supplement light, subType:string, attr:opt{req, string}, desc:illumination mode: "mixed"-hybrid,"whitelight"-white
light,"close"-disabled-->mixed
</supplementLightMode>
<irLightBrightness min="0" max="100">
<!--ro, opt, int, brightness of IR supplement light, range:[0,100], attr:min{req, int},max{req, int}, desc:this node is valid when supplementLightMode
is set to "mixed" and mixedLightBrightnessRegulatMode is set to "manual"-->80
</irLightBrightness>
<mixedLightBrightnessRegulatMode opt="manual,auto">
<!--ro, opt, enum, brightness adjustment mode of mixed supplement light, subType:string, attr:opt{req, string}, desc:"manual" (in this mode, you need to
set the parameters irLightBrightness and brightnessLimit), "auto" (brightness-related parameters are not required). This node is valid when
supplementLightMode is set to "mixed"-->auto
</mixedLightBrightnessRegulatMode>
<mixedModeSupportType opt="irLight,whiteLight">
<!--ro, opt, enum, supported types of supplement lights for the mixed mode, subType:string, attr:opt{req, string}, desc:this node is required when
"mixed" is included in the supplementLightMode-->irLight
</mixedModeSupportType>
<highIrLightBrightness min="0" max="100">
<!--ro, opt, int, brightness of far IR supplement light, range:[0,100], attr:min{req, int},max{req, int}, desc:it is shared by different supplement
light modes, including "mixed", "whiteLight", "colorVuWhiteLight", "irLight", and "dualLight"-->80
</highIrLightBrightness>
<highWhiteLightBrightness min="0" max="100">
<!--ro, opt, int, brightness of far white supplement light, range:[0,100], attr:min{req, int},max{req, int}, desc:it is shared by different supplement
light modes, including "mixed", "whiteLight", "colorVuWhiteLight", "irLight", and "dualLight"-->80
</highWhiteLightBrightness>
<lowIrLightBrightness min="0" max="100">
<!--ro, opt, int, brightness of near IR supplement light, range:[0,100], attr:min{req, int},max{req, int}, desc:it is shared by different supplement
light modes, including "mixed", "whiteLight", "colorVuWhiteLight", "irLight", and "dualLight"-->80
</lowIrLightBrightness>
<lowWhiteLightBrightness min="0" max="100">
<!--ro, opt, int, brightness of near white supplement light, range:[0,100], attr:min{req, int},max{req, int}, desc:it is shared by different supplement
light modes, including "mixed", "whiteLight", "colorVuWhiteLight", "irLight", and "dualLight"-->80
</lowWhiteLightBrightness>
<whiteLightBrightness min="0" max="100">
<!--ro, opt, int, light brightness (regardless of far or near light), range:[0,100], attr:min{req, int},max{req, int}, desc:white light brightness,which
is between 0 and 100-->80
</whiteLightBrightness>
<WhiteLightModeCfg>
<!--ro, opt, object-->
<highWhiteLightBrightness min="0" max="100">
<!--ro, opt, int, brightness of far white supplement light, range:[0,100], attr:min{req, int},max{req, int}-->80
</highWhiteLightBrightness>
<lowWhiteLightBrightness min="0" max="100">
-


<lowWhiteLightBrightness min="0" max="100">
<!--ro, opt, int, brightness of near white supplement light, range:[0,100], attr:min{req, int},max{req, int}-->80
</lowWhiteLightBrightness>
<whiteLightBrightness min="0" max="100">
<!--ro, opt, int, white light brightness (regardless of far or near light), range:[0,100], attr:min{req, int},max{req, int}-->80
</whiteLightBrightness>
</WhiteLightModeCfg>
<isAutoModeBrightnessCfg>
<!--ro, opt, bool-->true
</isAutoModeBrightnessCfg>
<irLightbrightnessLimit min="0" max="100">
<!--ro, opt, int, brightness limit of IR supplement light, range:[0,100], attr:min{req, int},max{req, int}, desc:this node is valid when the value of
Mode is "auto" and supplementLightMode is "mixed".-->80
</irLightbrightnessLimit>
<whiteLightbrightnessLimit min="0" max="100">
<!--ro, opt, int, brightness limit of white supplement light, range:[0,100], attr:min{req, int},max{req, int}, desc:this node is valid when the value of
Mode is "auto" and supplementLightMode is "mixed".-->80
</whiteLightbrightnessLimit>
<isNotSupportMixedWhiteLight>
<!--ro, opt, bool-->true
</isNotSupportMixedWhiteLight>
<EventIntelligenceModeCfg>
<!--ro, opt, object-->
<brightnessRegulatMode opt="manual,auto">
<!--ro, opt, enum, subType:string, attr:opt{req, string}-->auto
</brightnessRegulatMode>
<whiteLightBrightness min="0" max="100">
<!--ro, opt, int, white light brightness (regardless of far or near light), range:[0,100], attr:min{req, int},max{req, int}-->80
</whiteLightBrightness>
<irLightBrightness min="0" max="100">
<!--ro, opt, int, IR light brightness (regardless of far or near light), range:[0,100], attr:min{req, int},max{req, int}-->80
</irLightBrightness>
<BrightnessCtrlList size="4">
<!--ro, opt, array, subType:object, attr:size{req, int}-->
<BrightnessCtrl>
<!--ro, opt, object-->
<lightType opt="highWhite,lowWhite,highIrLight,lowIrLight">
<!--ro, opt, enum, subType:string, attr:opt{req, string}-->highWhite
</lightType>
<brightness min="0" max="100">
<!--ro, opt, int, supplement light brightness, range:[0,100], attr:min{req, int},max{req, int}-->80
</brightness>
</BrightnessCtrl>
</BrightnessCtrlList>
</EventIntelligenceModeCfg>
<MultiAzimuthMixedModeCfg>
<!--ro, opt, object-->
<brightnessRegulatMode opt="manual,auto">
<!--ro, opt, enum, subType:string, attr:opt{req, string}-->auto
</brightnessRegulatMode>
<LightCtrlList size="12">
<!--ro, opt, array, subType:object, attr:size{req, int}-->
<LightCtrl>
<!--ro, opt, object-->
<azimuthType opt="left,right">
<!--ro, opt, enum, subType:string, attr:opt{req, string}-->left
</azimuthType>
<lightType opt="highWhite,midWhite,lowWhite,highIrLight,midIrLight,lowIrLight">
<!--ro, opt, enum, subType:string, attr:opt{req, string}-->highWhite
</lightType>
<brightness min="0" max="100">
<!--ro, opt, int, supplement light brightness, range:[0,100], attr:min{req, int},max{req, int}-->80
</brightness>
</LightCtrl>
</LightCtrlList>
<regulatSensitivityType opt="fast,medium,slow">
<!--ro, opt, enum, subType:string, dep:and,{$.SupplementLight.MultiAzimuthMixedModeCfg.brightnessRegulatMode,eq,auto}, attr:opt{req, string}-->fast
</regulatSensitivityType>
</MultiAzimuthMixedModeCfg>
<MultiAzimuthWhiteLightCfg>
<!--ro, opt, object-->
<brightnessRegulatMode opt="manual,auto">
<!--ro, opt, enum, subType:string, attr:opt{req, string}-->auto
</brightnessRegulatMode>
<LightCtrlList size="6">
<!--ro, opt, array, subType:object, attr:size{req, int}-->
<LightCtrl>
<!--ro, opt, object-->
<azimuthType opt="left,right">
<!--ro, opt, enum, subType:string, attr:opt{req, string}-->left
</azimuthType>
<lightType opt="highWhite,midWhite,lowWhite,white">
<!--ro, opt, enum, subType:string, attr:opt{req, string}-->highWhite
</lightType>
<brightness min="0" max="100">
<!--ro, opt, int, supplement light brightness, range:[0,100], attr:min{req, int},max{req, int}-->80
</brightness>
</LightCtrl>
</LightCtrlList>
<regulatSensitivityType opt="fast,medium,slow">
<!--ro, opt, enum, subType:string, dep:and,{$.SupplementLight.MultiAzimuthWhiteLightCfg.brightnessRegulatMode,eq,auto}, attr:opt{req, string}-->fast
</regulatSensitivityType>
</MultiAzimuthWhiteLightCfg>
<MultiAzimuthIrLightCfg>
<!--ro, opt, object-->


<!--ro, opt, object-->
<brightnessRegulatMode opt="manual,auto">
<!--ro, opt, enum, subType:string, attr:opt{req, string}-->auto
</brightnessRegulatMode>
<LightCtrlList size="6">
<!--ro, opt, array, subType:object, attr:size{req, int}-->
<LightCtrl>
<!--ro, opt, object-->
<azimuthType opt="left,right">
<!--ro, opt, enum, subType:string, attr:opt{req, string}-->left
</azimuthType>
<lightType opt="highIrLight,midIrLight,lowIrLight,irLight">
<!--ro, opt, enum, subType:string, attr:opt{req, string}-->highIrLight
</lightType>
<brightness min="0" max="100">
<!--ro, opt, int, supplement light brightness, range:[0,100], attr:min{req, int},max{req, int}-->80
</brightness>
</LightCtrl>
</LightCtrlList>
</MultiAzimuthIrLightCfg>
<PanoramicWhiteLightCfg>
<!--ro, opt, object-->
<brightnessRegulatMode opt="manual,auto">
<!--ro, opt, enum, subType:string, attr:opt{req, string}-->auto
</brightnessRegulatMode>
<LightCtrlList size="4">
<!--ro, opt, array, subType:object, attr:size{req, int}-->
<LightCtrl>
<!--ro, opt, object-->
<lightID min="1" max="4">
<!--ro, opt, int, range:[1,4], attr:min{req, int},max{req, int}-->1
</lightID>
<brightness min="0" max="100">
<!--ro, opt, int, supplement light brightness, range:[0,100], attr:min{req, int},max{req, int}-->80
</brightness>
</LightCtrl>
</LightCtrlList>
</PanoramicWhiteLightCfg>
<PanoramicIrLightCfg>
<!--ro, opt, object-->
<brightnessRegulatMode opt="manual,auto">
<!--ro, opt, enum, subType:string, attr:opt{req, string}-->auto
</brightnessRegulatMode>
<LightCtrlList size="4">
<!--ro, opt, array, subType:object, attr:size{req, int}-->
<LightCtrl>
<!--ro, opt, object-->
<lightID min="1" max="4">
<!--ro, opt, int, range:[1,4], attr:min{req, int},max{req, int}-->1
</lightID>
<brightness min="0" max="100">
<!--ro, opt, int, supplement light brightness, range:[0,100], attr:min{req, int},max{req, int}-->80
</brightness>
</LightCtrl>
</LightCtrlList>
</PanoramicIrLightCfg>
<whiteLightEnhanceEnabled opt="true,false" def="false">
<!--ro, opt, bool, attr:opt{req, string},def{req, string}-->true
</whiteLightEnhanceEnabled>
<LightManualCtrlList size="12">
<!--ro, opt, array, subType:object, dep:and,{$.SupplementLight.mode,eq,manual}, attr:size{req, int}-->
<LightCtrl>
<!--ro, opt, object-->
<lightType opt="highIrLight,midIrLight,lowIrLight,irLight,highWhite,midWhite,lowWhite,white">
<!--ro, opt, enum, subType:string, attr:opt{req, string}-->highWhite
</lightType>
<brightness min="0" max="100">
<!--ro, opt, int, supplement light brightness, range:[0,100], attr:min{req, int},max{req, int}-->80
</brightness>
</LightCtrl>
</LightManualCtrlList>
</SupplementLight>
21.16 Face Picture Library Management
21.16.1 Get the information, including library ID, library type, name, and custom
information, of all face picture libraries
Request URL
GET /ISAPI/Intelligent/FDLib?security=<security>&iv=<iv>&identityKey=<identityKey>
Query Parameter


Parameter Name Parameter Type Description
security
string
iv
identityKey
Request Message
None
Response Message
string
string
-
-
-


<?xml version="1.0" encoding="UTF-8"?>
<FDLibBaseCfgList xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--ro, opt, array, subType:object, attr:version{req, string, protocolVersion}-->
<FDLibBaseCfg>
<!--ro, opt, object, face picture library information-->
<id>
<!--ro, opt, int, range:[1,15]-->1
</id>
<FDID>
<!--ro, opt, string, face picture library ID-->test
</FDID>
<name>
<!--ro, req, string, face picture library name, range:[1,64]-->faceLib1
</name>
<thresholdValue>
<!--ro, opt, int, detection threshold, range:[0,100]-->50
</thresholdValue>
<customInfo>
<!--ro, opt, string, custom information, range:[1,128]-->test
</customInfo>
<customFaceLibID>
<!--ro, opt, string, custom face picture library ID, range:[1,64]-->test
</customFaceLibID>
<faceLibType>
<!--ro, opt, enum, face picture library type, subType:string, desc:face picture library type-->ordinary
</faceLibType>
<autoUpdata>
<!--ro, opt, bool-->true
</autoUpdata>
<qualityThreshold>
<!--ro, opt, int, range:[0,100]-->50
</qualityThreshold>
<importFDThreshold>
<!--ro, opt, int, range:[0,100]-->40
</importFDThreshold>
<Age>
<!--ro, opt, object-->
<judgementCycleType>
<!--ro, req, enum, subType:string-->day
</judgementCycleType>
<statisticalCycleType>
<!--ro, req, enum, "day", "week"; "month", subType:string, desc:"day", "week"; "month"-->month
</statisticalCycleType>
<statisticalCycle>
<!--ro, req, int, range:[0,99999]-->1
</statisticalCycle>
<minFMCount>
<!--ro, req, int, range:[0,99999]-->1
</minFMCount>
<FMCountEnabled>
<!--ro, opt, bool-->true
</FMCountEnabled>
<FMCount>
<!--ro, opt, int, range:[0,99999]-->1
</FMCount>
<backgoundPicThreshold>
<!--ro, opt, int, range:[1,100]-->90
</backgoundPicThreshold>
<judgementCycle>
<!--ro, opt, int, range:[1,365], unit:d, dep:and,{$.FDLibCap.CreateFDLibList[*].CreateFDLib.Age.judgementCycleType,eq,duration}-->30
</judgementCycle>
</Age>
<FaceCounting>
<!--ro, opt, object-->
<enabled>
<!--ro, req, bool-->true
</enabled>
<uploadType>
<!--ro, req, enum, subType:string-->noUpload
</uploadType>
</FaceCounting>
<faceMonitor>
<!--ro, opt, bool-->true
</faceMonitor>
<monitorFaceNum>
<!--ro, opt, int-->1
</monitorFaceNum>
<customNoConfig>
<!--ro, opt, bool-->true
</customNoConfig>
<uploadID>
<!--ro, opt, string, range:[1,128], dep:and,{$.FDLibBaseCfglist.FDLibBaseCfg.autoUpdata,eq,true}-->test
</uploadID>
</FDLibBaseCfg>
</FDLibBaseCfgList>
21.16.2 Set the face picture library parameters


Request URL
PUT /ISAPI/Intelligent/FDLib?security=<security>&iv=<iv>&identityKey=<identityKey>
Query Parameter
Parameter Name Parameter Type Description
security
string
iv
identityKey
Request Message
string
string
-
-
-


<?xml version="1.0" encoding="UTF-8"?>
<FDLibBaseCfgList xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--opt, array, face picture library information list, subType:object, attr:version{req, string, protocolVersion}-->
<FDLibBaseCfg>
<!--opt, object, face picture library information-->
<id>
<!--opt, int, range:[1,15]-->1
</id>
<FDID>
<!--opt, string, unique ID of face picture library-->test
</FDID>
<name>
<!--req, string, face picture library name, range:[1,64]-->faceLib1
</name>
<thresholdValue>
<!--opt, int, detection threshold, range:[0,100]-->50
</thresholdValue>
<customInfo>
<!--opt, string, additional information of face picture library, range:[1,128]-->test
</customInfo>
<customFaceLibID>
<!--opt, string, custom face picture library ID, range:[1,64]-->test
</customFaceLibID>
<faceLibType>
<!--ro, opt, enum, face picture library type, subType:string, desc:"ordinary" (normal library), "private" (private library), "stranger" (stranger
library), "allowable" (allowlist library), "privacyMask" (privacy mask library)-->allowable
</faceLibType>
<autoUpdata>
<!--opt, bool-->true
</autoUpdata>
<qualityThreshold>
<!--opt, int, range:[0,100]-->50
</qualityThreshold>
<importFDThreshold>
<!--opt, int, range:[0,100]-->40
</importFDThreshold>
<Age>
<!--opt, object-->
<judgementCycleType>
<!--req, enum, subType:string-->day
</judgementCycleType>
<statisticalCycleType>
<!--ro, req, enum, subType:string-->month
</statisticalCycleType>
<statisticalCycle>
<!--req, int, range:[0,99999]-->1
</statisticalCycle>
<minFMCount>
<!--req, int, range:[0,99999]-->1
</minFMCount>
<FMCountEnabled>
<!--opt, bool-->true
</FMCountEnabled>
<FMCount>
<!--opt, int, range:[0,99999]-->1
</FMCount>
<backgoundPicThreshold>
<!--opt, int, range:[1,100]-->90
</backgoundPicThreshold>
<judgementCycle>
<!--opt, int, range:[1,365], unit:d, dep:and,{$.FDLibCap.CreateFDLibList[*].CreateFDLib.Age.judgementCycleType,eq,duration}-->30
</judgementCycle>
</Age>
<FaceCounting>
<!--opt, object-->
<enabled>
<!--req, bool-->true
</enabled>
<uploadType>
<!--ro, req, enum, subType:string-->noUpload
</uploadType>
</FaceCounting>
<faceMonitor>
<!--ro, opt, bool-->true
</faceMonitor>
<monitorFaceNum>
<!--ro, opt, int-->1
</monitorFaceNum>
<customNoConfig>
<!--ro, opt, bool-->true
</customNoConfig>
<uploadID>
<!--opt, string, range:[1,128], dep:and,{$.FDLibBaseCfglist.FDLibBaseCfg.autoUpdata,eq,true}-->test
</uploadID>
</FDLibBaseCfg>
</FDLibBaseCfgList>
Response Message


<?xml version="1.0" encoding="UTF-8"?>
<ResponseStatus xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--ro, req, object, response message, attr:version{ro, req, string, protocolVersion}-->
<requestURL>
<!--ro, req, string, request URL-->null
</requestURL>
<statusCode>
<!--ro, req, enum, status code, subType:int, desc:0 (OK), 1 (OK), 2 (Device Busy), 3 (Device Error), 4 (Invalid Operation), 5 (Invalid XML Format), 6
(Invalid XML Content), 7 (Reboot Required)-->0
</statusCode>
<statusString>
<!--ro, req, enum, status description, subType:string, desc:"OK" (succeeded), "Device Busy", "Device Error", "Invalid Operation", "Invalid XML Format",
"Invalid XML Content", "Reboot" (reboot device)-->OK
</statusString>
<subStatusCode>
<!--ro, req, string, sub status code, desc:sub status code, which describes the error in details-->OK
</subStatusCode>
</ResponseStatus>
21.16.3 Edit a face record in a specific face picture library
Request URL
PUT /ISAPI/Intelligent/FDLib/FDSearch?format=json&FDID=<FDID>&FPID=<FPID>&faceLibType=<faceLibType>
Query Parameter
Parameter Name Parameter Type Description
FDID
string
FPID
faceLibType
Request Message
string
string
-
-
-


{
"faceURL": "test",
/*opt, string, face picture URL, range:[0,256]*/
"name": "张三",
/*req, string, name of person in the face picture, range:[0,96]*/
"gender": "male",
/*opt, enum, gender of person in the face picture, subType:string, desc:"male", "female", "unknown"*/
"bornTime": "1970-01-01+08:00",
/*req, date, birthday of person in the face picture, ISO8601 time format, the maximum size is 20 bytes*/
"city": "130100",
/*opt, string, city code of birth for the person in the face picture, the maximum size is 32 bytes*/
"certificateType": "officerID",
/*opt, enum, certificate type, subType:string*/
"certificateNumber": "test",
/*opt, string, certificate No., the maximum size is 32 bytes*/
"caseInfo": "test",
/*opt, string, remarks, range:[0,192], desc:case information,the maximum size is 192 bytes,it is valid when faceLibType is blackFD*/
"tag": "aa,bb,cc,dd",
/*opt, string, custom tag, range:[0,195], desc:up to 4 tags, which are separated by commas. It is valid when faceLibType is blackFD*/
"address": "test",
/*opt, string, person address, range:[0,192], desc:person address,the maximum size is 192 bytes,it is valid when faceLibType is staticFD.*/
"customInfo": "test",
/*opt, string, custom information, range:[0,192], desc:custom information,the maximum size is 192 bytes,it is valid when faceLibType is staticFD.*/
"modelData": "test",
/*opt, string, target modeling data, desc:during the process of transmission, the non-modeling binary data will be encrypted with Base64 method*/
"rowKey": "test",
/*opt, string, main key of face picture library, range:[0,64], desc:searching by rowKey can be more efficient*/
"transfer": true,
/*opt, bool, whether to enable transfer, desc:whether to enable transfer*/
"PicFeaturePoints": [
/*opt, array, feature points to be applied., subType:object, desc:If the device only supports three types of feature points, when the platform applies
more than three types of feature points, the device will not return error information*/
{
"featurePointType": "face",
/*req, enum, feature point type, subType:string, desc:"face", "leftEye" (left eye), "rightEye" (right eye), "leftMouthCorner" (left corner of
mouth), "rightMouthCorner" (right corner of mouth), "nose”*/
"coordinatePoint": {
/*opt, object, region, desc:object,coordinates of the feature point*/
"x": 1,
/*req, int, X-coordinate, range:[0,1000], desc:normalized X-coordinate which is between 0 and 1000*/
"y": 1,
/*req, int, Y-coordinate, range:[0,1000], desc:normalized Y-coordinate which is between 0 and 1000*/
"width": 1,
/*opt, int, width, range:[0,1000], desc:width which is between 0 and 1000. This node is required when featurePointType is "face"*/
"height": 1
/*opt, int, height, range:[0,1000], desc:height which is between 0 and 1000. This node is required when featurePointType is "face"*/
}
}
],
"faceType": "normalFace",
/*opt, enum, face picture type, subType:string*/
"saveFacePic": true,
/*opt, bool, whether to save face pictures*/
"leaderPermission": [1, 2, 3, 4]
/*opt, array, subType:int, range:[1,4]*/
}
Response Message
{
"statusCode": 1,
/*ro, opt, int, status code, desc:1 (succeeded). It is required when an error occurred*/
"statusString": "ok",
/*ro, opt, string, status description, range:[1,64], desc:"ok" (succeeded). It is required when an error occurred*/
"subStatusCode": "ok",
/*ro, opt, string, sub status code, range:[1,64], desc:"ok" (succeeded). It is required when an error occurred*/
"errorCode": 1,
/*ro, req, int, error code, desc:when the value of statusCode is not 1, it corresponds to subStatusCode*/
"errorMsg": "ok"
/*ro, req, string, error details, desc:this node is required when the value of statusCode is not 1*/
}
21.16.4 Get face picture library capability
Request URL
GET /ISAPI/Intelligent/FDLib/capabilities
Query Parameter
None
Request Message
None


Response Message
<?xml version="1.0" encoding="UTF-8"?>
<FDLibCap xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--ro, req, object, attr:version{opt, string, protocolVersion}-->
<CreateFDLibList size="15">
<!--ro, req, array, subType:object, attr:size{opt, string}-->
<CreateFDLib>
<!--ro, req, object-->
<id max="15" min="1">
<!--ro, req, int, range:[1,15], attr:max{opt, string},min{opt, string}-->10
</id>
<name max="64" min="1">
<!--ro, req, string, range:[1,64], attr:max{opt, string},min{opt, string}-->64
</name>
<thresholdValue max="100" min="0" def="60">
<!--ro, opt, int, range:[0,100], attr:max{opt, string},min{opt, string},def{req, int}-->50
</thresholdValue>
<customInfo max="128" min="1">
<!--ro, opt, string, range:[1,128], attr:max{opt, string},min{opt, string}-->128
</customInfo>
<faceDataMax max="150000" min="1">
<!--ro, opt, int, range:[1,150000], attr:max{opt, string},min{opt, string}-->30000
</faceDataMax>
<customFaceLibID max="64" min="1">
<!--ro, opt, string, range:[1,64], attr:max{opt, string},min{opt, string}-->64
</customFaceLibID>
<PersonInfoExtendList size="128">
<!--ro, opt, array, subType:object, attr:size{opt, string}-->
<PersonInfoExtend>
<!--ro, opt, object-->
<id max="15000" min="1">
<!--ro, req, int, range:[1,15000], attr:max{opt, string},min{opt, string}-->30000
</id>
<enable opt="true,false">
<!--ro, req, bool, attr:opt{opt, string}-->true
</enable>
<name max="128" min="1">
<!--ro, opt, string, range:[1,128], attr:max{opt, string},min{opt, string}-->128
</name>
<value max="256" min="1">
<!--ro, opt, string, range:[1,256], attr:max{opt, string},min{opt, string}-->256
</value>
</PersonInfoExtend>
</PersonInfoExtendList>
<indentityKey max="64" min="0">
<!--ro, opt, string, range:[1,64], attr:max{opt, string},min{opt, string}-->64
</indentityKey>
<autoUpdata opt="true,false">
<!--ro, opt, bool, attr:opt{opt, string}-->true
</autoUpdata>
<qualityThreshold max="100" min="0">
<!--ro, opt, int, range:[0,100], attr:max{opt, string},min{opt, string}-->50
</qualityThreshold>
<importFDThreshold max="100" min="0">
<!--ro, opt, int, range:[0,100], attr:max{opt, string},min{opt, string}-->40
</importFDThreshold>
<Age>
<!--ro, opt, object-->
<judgementCycleType opt="day,week,month,duration">
<!--ro, req, enum, subType:string, attr:opt{opt, string}-->month
</judgementCycleType>
<statisticalCycleType opt="day,week,month">
<!--ro, req, enum, subType:string, attr:opt{opt, string}-->month
</statisticalCycleType>
<statisticalCycle max="99999" min="0">
<!--ro, opt, int, range:[0,99999], attr:max{opt, string},min{opt, string}-->30
</statisticalCycle>
<minFMCount max="99999" min="0">
<!--ro, req, int, range:[0,99999], attr:max{opt, string},min{opt, string}-->30
</minFMCount>
<FMCountEnabled opt="true,false">
<!--ro, opt, bool, attr:opt{opt, string}-->true
</FMCountEnabled>
<FMCount max="99999" min="0">
<!--ro, opt, int, range:[0,99999], attr:max{opt, string},min{opt, string}-->100
</FMCount>
<backgoundPicThreshold min="1" max="100">
<!--ro, opt, int, range:[1,100], attr:min{req, int},max{req, int}-->90
</backgoundPicThreshold>
<judgementCycle max="365" min="1">
<!--ro, opt, int, range:[1,365], unit:d, dep:and,{$.FDLibCap.CreateFDLibList[*].CreateFDLib.Age.judgementCycleType,eq,duration}, attr:max{opt,
string},min{opt, string}-->30
</judgementCycle>
</Age>
<FaceCounting>
<!--ro, req, object-->
<enabled opt="true,false">
<!--ro, req, bool, attr:opt{opt, string}-->true
</enabled>
<uploadType opt="out_repetition,noUpload">


<uploadType opt="out_repetition,noUpload">
<!--ro, req, enum, subType:string, attr:opt{opt, string}-->noUpload
</uploadType>
</FaceCounting>
<strangerLibNum max="1" min="2">
<!--ro, opt, int, range:[1,2], attr:max{opt, string},min{opt, string}-->1
</strangerLibNum>
<faceLibType opt="privacyMask">
<!--ro, opt, enum, face picture library types, subType:string, attr:opt{req, string}, desc:face picture library types: "blackFD"-list
library,"staticFD"-static library,"infraredFD"-infrared face picture library,the maximum size of value can be assigned to this node is 32 bytes-->ordinary
</faceLibType>
</CreateFDLib>
</CreateFDLibList>
<FaceAppendData>
<!--ro, opt, object-->
<bornTime>
<!--ro, opt, date, birth date of the person in the face picture-->1970-01-01+08:00
</bornTime>
<name max="64" min="1">
<!--ro, opt, string, range:[1,64], attr:max{opt, string},min{opt, string}-->64
</name>
<sex opt="male,female">
<!--ro, opt, enum, gender, subType:string, attr:opt{opt, string}, desc:male; female;-->male
</sex>
<province>
<!--ro, opt, string, province of birth-->01
</province>
<city>
<!--ro, opt, string, city-->01
</city>
<certificateType opt="officerID,ID,passportID,other">
<!--ro, opt, enum, certificate type capability, subType:string, attr:opt{opt, string}, desc:"officerID"-officer ID,"ID"-identify card,"passportID"passport,"other"-other
certificate-->officerID
</certificateType>
<certificateNumber max="32" min="1">
<!--ro, opt, string, capability of certificate No., range:[1,128], attr:max{opt, string},min{opt, string}-->32
</certificateNumber>
<PersonInfoExtendList size="128">
<!--ro, opt, array, subType:object, attr:size{opt, string}-->
<PersonInfoExtend>
<!--ro, opt, object-->
<id max="15000" min="1">
<!--ro, req, int, range:[1,15000], attr:max{opt, string},min{opt, string}-->30000
</id>
<enable opt="true,false">
<!--ro, req, bool, attr:opt{opt, string}-->true
</enable>
<name max="128" min="1">
<!--ro, opt, string, range:[1,128], attr:max{opt, string},min{opt, string}-->128
</name>
<value max="256" min="1">
<!--ro, opt, string, range:[1,256], attr:max{opt, string},min{opt, string}-->256
</value>
</PersonInfoExtend>
</PersonInfoExtendList>
<isSupportPhoneNumber>
<!--ro, opt, bool-->true
</isSupportPhoneNumber>
<isSupportImagesURLImport>
<!--ro, opt, bool-->true
</isSupportImagesURLImport>
<customHumanID max="128" min="1">
<!--ro, opt, string, range:[1,128], attr:max{opt, string},min{opt, string}-->64
</customHumanID>
<faceDescribe max="128" min="1">
<!--ro, opt, string, range:[1,128], attr:max{opt, string},min{opt, string}-->128
</faceDescribe>
<RegionCoordinatesList size="4">
<!--ro, opt, array, subType:object, attr:size{req, int}-->
<RegionCoordinates>
<!--ro, req, object-->
<positionX min="0" max="1000">
<!--ro, req, int, X-coordinate, attr:min{req, int},max{req, int}-->1
</positionX>
<positionY min="0" max="1000">
<!--ro, req, int, Y-coordinate, attr:min{req, int},max{req, int}-->1
</positionY>
</RegionCoordinates>
</RegionCoordinatesList>
<IMSIList size="5">
<!--ro, opt, array, subType:object, attr:size{req, int}-->
<IMSI min="1" max="15">
<!--ro, opt, string, range:[1,15], attr:min{req, int},max{req, int}-->123456789012345
</IMSI>
</IMSIList>
<plateNo min="0" max="32">
<!--ro, opt, string, range:[0,32], attr:min{req, int},max{req, int}-->test
</plateNo>
</FaceAppendData>
<FDSearchDescription>
<!--ro, opt, object-->
<searchID max="63" min="1">
<!--ro, opt, string, search ID, attr:max{opt, string},min{opt, string}-->63
</searchID>
<searchResultPosition>


<searchResultPosition>
<!--ro, opt, int-->1
</searchResultPosition>
<maxResults>
<!--ro, opt, int, the number of search results this time-->30
</maxResults>
<FDID>
<!--ro, opt, string-->1
</FDID>
<startTime>
<!--ro, opt, datetime-->1970-01-01T00:00:00+08:00
</startTime>
<endTime>
<!--ro, opt, datetime-->1970-01-01T00:00:00+08:00
</endTime>
<name max="64" min="1">
<!--ro, opt, string, person name, attr:max{opt, string},min{opt, string}-->64
</name>
<sex opt="male,female">
<!--ro, opt, enum, gender, subType:string, attr:opt{opt, string}, desc:male; female;-->male
</sex>
<province>
<!--ro, opt, string, province of birth-->01
</province>
<city>
<!--ro, opt, string, city-->01
</city>
<certificateType opt="officerID,ID,passportID,other">
<!--ro, opt, enum, certificate type capability, subType:string, attr:opt{opt, string}, desc:"officerID"-officer ID,"ID"-identify card,"passportID"passport,"other"-other
certificate-->officerID
</certificateType>
<certificateNumber max="32" min="1">
<!--ro, opt, string, capability of certificate No., range:[1,128], attr:max{opt, string},min{opt, string}-->32
</certificateNumber>
<FaceModeCap>
<!--ro, opt, object-->
<FaceMode>
<!--ro, opt, object-->
<similarity max="100.0" min="0.0">
<!--ro, opt, float, similarity, attr:max{opt, string},min{opt, string}-->50.0
</similarity>
</FaceMode>
<maxResultNum>
<!--ro, opt, int-->30
</maxResultNum>
</FaceModeCap>
<modelStatus opt="modeling,unmodeled,modelingFailed">
<!--ro, opt, enum, subType:string, attr:opt{opt, string}-->modeling
</modelStatus>
<modelingStatus opt="success,failed,none">
<!--ro, opt, enum, subType:string, attr:opt{opt, string}-->success
</modelingStatus>
<customFaceLibID max="64" min="0">
<!--ro, opt, string, range:[1,64], attr:max{opt, string},min{opt, string}-->64
</customFaceLibID>
<indentityKey max="64" min="0">
<!--ro, opt, string, attr:max{opt, string},min{opt, string}-->64
</indentityKey>
<occurrences max="30" min="1">
<!--ro, opt, int, attr:max{opt, string},min{opt, string}-->30
</occurrences>
<occurrencesSearchType opt="greaterThanOrEqual,lessThan,equal">
<!--ro, opt, enum, subType:string, attr:opt{opt, string}-->greaterThanOrEqual
</occurrencesSearchType>
<faceScore min="-1" max="100">
<!--ro, opt, int, face score (face picture quality), range:[-1,100], attr:min{opt, string},max{opt, string}-->-1
</faceScore>
<isSupportFDIDList>
<!--ro, opt, array, subType:object-->
</isSupportFDIDList>
<FaceScoreRange>
<!--ro, opt, object-->
<min min="0" max="100">
<!--ro, req, int, attr:min{req, int},max{req, int}-->1
</min>
<max min="0" max="100">
<!--ro, req, int, attr:min{req, int},max{req, int}-->1
</max>
</FaceScoreRange>
<pictureStatus opt="normal,abnormal">
<!--ro, opt, string, attr:opt{req, string}-->test
</pictureStatus>
<sortord opt="similarity,time,contrastSuccessTime,count">
<!--ro, opt, enum, subType:string, attr:opt{req, string}-->count
</sortord>
<order opt="DESC,ASC">
<!--ro, opt, string, attr:opt{req, string}-->test
</order>
<importStartTime>
<!--ro, opt, datetime-->1970-01-01T00:00:00+08:00
</importStartTime>
<importEndTime>
<!--ro, opt, datetime-->1970-01-01T00:00:00+08:00
</importEndTime>


</importEndTime>
<IMSIList size="5">
<!--ro, opt, array, subType:object, attr:size{req, int}-->
<IMSIItem>
<!--ro, opt, object-->
<IMSI min="1" max="15">
<!--ro, opt, string, range:[1,15], attr:min{req, int},max{req, int}-->123456789012345
</IMSI>
<count min="1">
<!--ro, opt, int, attr:min{req, int}-->10
</count>
<lastFMTime>
<!--ro, opt, datetime-->1970-01-01T00:00:00+08:00
</lastFMTime>
</IMSIItem>
</IMSIList>
<lastFMTime>
<!--ro, opt, datetime-->1970-01-01T00:00:00+08:00
</lastFMTime>
<faceContrastSuccessStartTime>
<!--ro, opt, datetime-->1970-01-01T00:00:00+08:00
</faceContrastSuccessStartTime>
<faceContrastSuccessEndTime>
<!--ro, opt, datetime-->1970-01-01T00:00:00+08:00
</faceContrastSuccessEndTime>
</FDSearchDescription>
<isSuportAnalysisFace>
<!--ro, opt, bool-->true
</isSuportAnalysisFace>
<isSuportFDLibImpEmp opt="true,false">
<!--ro, opt, bool, attr:opt{opt, string}-->true
</isSuportFDLibImpEmp>
<isSuportFCSearch opt="true,false">
<!--ro, opt, bool, whether supports searching face picture comparison alarms, attr:opt{opt, string}-->true
</isSuportFCSearch>
<FDLibType opt="faceContrast,blacklistFaceContrast,whitelistFaceContrast">
<!--ro, opt, enum, face comparison type, subType:string, attr:opt{opt, string}-->faceContrast
</FDLibType>
<isSupportFDLibEachImport>
<!--ro, opt, bool-->true
</isSupportFDLibEachImport>
<FCSearchDescription>
<!--ro, opt, object-->
<searchID max="63" min="1">
<!--ro, opt, string, search ID, attr:max{opt, string},min{opt, string}-->63
</searchID>
<searchResultPosition>
<!--ro, opt, int-->1
</searchResultPosition>
<maxResults>
<!--ro, opt, int, the number of search results this time-->30
</maxResults>
<snapStartTime>
<!--ro, opt, datetime, ISO 8601 time-->1970-01-01T00:00:00+08:00
</snapStartTime>
<snapEndTime>
<!--ro, opt, datetime, ISO 8601 time-->1970-01-01T00:00:00+08:00
</snapEndTime>
<faceMatchInfoEnable opt="true,false">
<!--ro, opt, bool, attr:opt{opt, string}-->true
</faceMatchInfoEnable>
<monitorName max="1" min="2">
<!--ro, opt, string, attr:max{opt, string},min{opt, string}-->1
</monitorName>
<similarity max="100.0" min="0.0">
<!--ro, opt, float, similarity, attr:max{opt, string},min{opt, string}-->50.0
</similarity>
<eventType opt="unlimit,faceContrast,whiteFaceContrast,faceCapture,faceContrastFailure">
<!--ro, opt, enum, subType:string, attr:opt{opt, string}-->unlimit
</eventType>
<FaceModeCap>
<!--ro, opt, object-->
<FaceMode>
<!--ro, opt, object-->
<similarity max="100.0" min="0.0">
<!--ro, opt, float, similarity, range:[0.0,100.0], attr:max{opt, string},min{opt, string}-->50.0
</similarity>
</FaceMode>
<maxResultNum>
<!--ro, opt, int-->30
</maxResultNum>
</FaceModeCap>
<PictureSearchCap>
<!--ro, req, object-->
<maxSearchPictureNum max="1" min="1">
<!--ro, opt, int, attr:max{opt, string},min{opt, string}-->50
</maxSearchPictureNum>
</PictureSearchCap>
<isSupportMultiChannelSearch>
<!--ro, opt, bool-->true
</isSupportMultiChannelSearch>
<isSupportTotalSearchResult>
<!--ro, opt, bool-->true
</isSupportTotalSearchResult>


<thermometryUnit opt="celsius,fahrenheit,kelvin">
<!--ro, opt, enum, temperature unit, subType:string, attr:opt{req, string}, desc:"celsius", "fahrenheit", "kelvin"-->celsius
</thermometryUnit>
<currTemperature min="-20.0" max="150.0℃">
<!--ro, opt, float, face temperature, range:[-20.0,150.0], attr:min{req, int},max{req, int}-->-20.0
</currTemperature>
<temperatureCondition opt="normal,abnormal,all,above">
<!--ro, opt, enum, face temperature status, subType:string, attr:opt{req, string}-->normal
</temperatureCondition>
<temperatureValue>
<!--ro, opt, float, range:[-20,105], unit:℃, dep:and,{$.FDLibCap.FCSearchDescription.temperatureCondition,eq,above}-->37.2
</temperatureValue>
<IMSIList size="5">
<!--ro, opt, array, subType:object, attr:size{req, int}-->
<IMSI min="1" max="15">
<!--ro, opt, string, range:[1,15], attr:min{req, int},max{req, int}-->123456789012345
</IMSI>
</IMSIList>
</FCSearchDescription>
<isSupportFDSearchDataPackage>
<!--ro, opt, bool, whether supports packaging the found data in the face picture library-->true
</isSupportFDSearchDataPackage>
<isSupportFCSearchDataPackage>
<!--ro, opt, bool, whether supports packaging the search results of face picture comparison alarms-->true
</isSupportFCSearchDataPackage>
<maxFCSearchDataPackageNum>
<!--ro, opt, int-->50
</maxFCSearchDataPackageNum>
<isSupportFDExecuteControl>
<!--ro, opt, bool, whether supports creating relation between face picture libraries and cameras-->true
</isSupportFDExecuteControl>
<isSupportManualModeling>
<!--ro, opt, bool-->true
</isSupportManualModeling>
<isSupportSingleManualModeling>
<!--ro, opt, bool-->true
</isSupportSingleManualModeling>
<isSupportRangeManualModeling>
<!--ro, opt, bool-->true
</isSupportRangeManualModeling>
<isSupportSingleManualModelingSearch>
<!--ro, opt, bool-->true
</isSupportSingleManualModelingSearch>
<isSupportRangeManualModelingSearch>
<!--ro, opt, bool-->true
</isSupportRangeManualModelingSearch>
<isSupportModelingStatusSearch>
<!--ro, opt, bool-->true
</isSupportModelingStatusSearch>
<Reboot>
<!--ro, opt, object-->
<thresholdValue>
<!--ro, opt, bool-->true
</thresholdValue>
<delFaceLib>
<!--ro, opt, bool-->true
</delFaceLib>
</Reboot>
<isSupportCoverImportpictures>
<!--ro, opt, bool-->true
</isSupportCoverImportpictures>
<isSupportCoverImportFaceLib>
<!--ro, opt, bool-->true
</isSupportCoverImportFaceLib>
<isSupportConcurrentImportpictures>
<!--ro, opt, bool-->true
</isSupportConcurrentImportpictures>
<isSupportSurplusCapacity>
<!--ro, opt, bool-->true
</isSupportSurplusCapacity>
<isSupportFDlibProgress>
<!--ro, opt, bool-->true
</isSupportFDlibProgress>
<isSupportFDlibPhotoWall>
<!--ro, opt, bool-->true
</isSupportFDlibPhotoWall>
<isSupportFDCoverInfo>
<!--ro, opt, bool-->true
</isSupportFDCoverInfo>
<isSupportStandardSearch>
<!--ro, opt, bool-->true
</isSupportStandardSearch>
<isSupportFaceDataExport>
<!--ro, opt, bool-->true
</isSupportFaceDataExport>
<isSupportNewlyPictureUpload>
<!--ro, opt, bool-->true
</isSupportNewlyPictureUpload>
<isSupportFCSearchNormal>
<!--ro, opt, bool-->true
</isSupportFCSearchNormal>
<FDLibEachImportCap>
<!--ro, opt, object-->
<isSupportImportLib>


<isSupportImportLib>
<!--ro, opt, bool-->true
</isSupportImportLib>
<isSupportImportLibPicture>
<!--ro, opt, bool-->true
</isSupportImportLibPicture>
</FDLibEachImportCap>
<isSupportPrompt>
<!--ro, opt, bool-->true
</isSupportPrompt>
<isSupportCustomHumanID>
<!--ro, opt, bool-->true
</isSupportCustomHumanID>
<isSupportCustomFaceLibID>
<!--ro, opt, bool-->true
</isSupportCustomFaceLibID>
<isSupportFCSearchAttendancePackage>
<!--ro, opt, bool-->true
</isSupportFCSearchAttendancePackage>
<isSupportFCSearchJsonFormat>
<!--ro, opt, bool-->true
</isSupportFCSearchJsonFormat>
<isSupportFCSearchDataPackageJsonFormat>
<!--ro, opt, bool-->true
</isSupportFCSearchDataPackageJsonFormat>
<isSupportFDCapacity>
<!--ro, opt, bool-->true
</isSupportFDCapacity>
<SupportUploadPictureType opt="binary,url">
<!--ro, opt, enum, subType:string, attr:opt{opt, string}-->binary
</SupportUploadPictureType>
<isSupportNoSaveUploadPicture>
<!--ro, opt, bool-->true
</isSupportNoSaveUploadPicture>
<isSupportUploadModeling>
<!--ro, opt, bool-->true
</isSupportUploadModeling>
<SupportUploadPictureUrlType opt="ipAddress,domain">
<!--ro, opt, enum, subType:string, attr:opt{opt, string}-->ipAddress
</SupportUploadPictureUrlType>
<isSptFDLibBatchFileManage>
<!--ro, opt, bool-->true
</isSptFDLibBatchFileManage>
<importImageSize max="300" min="1">
<!--ro, opt, int, unit:KB, attr:max{opt, string},min{opt, string}-->30
</importImageSize>
<isSupportUpdateHumanID>
<!--ro, opt, bool-->true
</isSupportUpdateHumanID>
<FDModelingStatusSearchDescription>
<!--ro, opt, object-->
<searchID max="63" min="1">
<!--ro, opt, string, search ID, attr:max{opt, string, range:[0,64]},min{opt, string}-->searchIDtest
</searchID>
<searchResultPosition>
<!--ro, opt, int-->30
</searchResultPosition>
<maxResults>
<!--ro, opt, int, the number of search results this time-->30
</maxResults>
<FDIDList>
<!--ro, req, array, subType:object-->
</FDIDList>
<taskID max="64" min="1">
<!--ro, opt, string, attr:max{opt, string},min{opt, string}-->64
</taskID>
</FDModelingStatusSearchDescription>
<StrangerLibFaceAppendData>
<!--ro, opt, object-->
<PersonInfoExtendList size="128">
<!--ro, opt, array, subType:object, attr:size{opt, string}-->
<PersonInfoExtend>
<!--ro, opt, object-->
<id max="15000" min="1">
<!--ro, req, int, range:[1,15000], attr:max{opt, string},min{opt, string}-->30000
</id>
<enable opt="true,false">
<!--ro, req, bool, attr:opt{opt, string}-->true
</enable>
<name max="128" min="1">
<!--ro, opt, string, range:[1,128], attr:max{opt, string},min{opt, string}-->128
</name>
<value max="256" min="1">
<!--ro, opt, string, range:[1,256], attr:max{opt, string},min{opt, string}-->256
</value>
</PersonInfoExtend>
</PersonInfoExtendList>
</StrangerLibFaceAppendData>
<StrangerLibFDSearchDescription>
<!--ro, opt, object-->
<FDID>
<!--ro, opt, string-->1
</FDID>
<PersonInfoExtendList size="128">


<!--ro, opt, array, subType:object, attr:size{opt, string}-->
<PersonInfoExtend>
<!--ro, opt, object-->
<id max="15000" min="1">
<!--ro, req, int, range:[1,15000], attr:max{opt, string},min{opt, string}-->30000
</id>
<enable opt="true,false">
<!--ro, req, bool, attr:opt{opt, string}-->true
</enable>
<name max="128" min="1">
<!--ro, opt, string, range:[1,128], attr:max{opt, string},min{opt, string}-->128
</name>
<value max="256" min="1">
<!--ro, opt, string, range:[1,256], attr:max{opt, string},min{opt, string}-->256
</value>
</PersonInfoExtend>
</PersonInfoExtendList>
<occurrences max="30" min="1">
<!--ro, opt, int, attr:max{opt, string},min{opt, string}-->30
</occurrences>
<occurrencesSearchType opt="greaterThanOrEqual,lessThan,equal">
<!--ro, opt, enum, subType:string, attr:opt{opt, string}-->greaterThanOrEqual
</occurrencesSearchType>
</StrangerLibFDSearchDescription>
<isSupportOccurrencesData>
<!--ro, opt, bool-->true
</isSupportOccurrencesData>
<isSupportCopyFaceRecord>
<!--ro, opt, bool-->true
</isSupportCopyFaceRecord>
<isSupportConferenceSmartCheck>
<!--ro, opt, bool-->true
</isSupportConferenceSmartCheck>
<isSupportControlSmartCheck>
<!--ro, opt, bool-->true
</isSupportControlSmartCheck>
<isSupportSmartCheckStatus>
<!--ro, opt, bool-->true
</isSupportSmartCheckStatus>
<isSupportSmartClockIn>
<!--ro, opt, bool-->true
</isSupportSmartClockIn>
<isSupportControlSmartClockIn>
<!--ro, opt, bool-->true
</isSupportControlSmartClockIn>
<isSupportSmartClockInStatus>
<!--ro, opt, bool-->true
</isSupportSmartClockInStatus>
<isSupportSmartClockInTemplate>
<!--ro, opt, bool-->true
</isSupportSmartClockInTemplate>
<isSupportFaceLibFormat>
<!--ro, opt, bool-->true
</isSupportFaceLibFormat>
<isSupportSurplusCapacityALL>
<!--ro, opt, bool-->true
</isSupportSurplusCapacityALL>
<importImageSize min="1" max="300">
<!--ro, opt, int, range:[10,100], attr:min{opt, string},max{opt, string}-->10
</importImageSize>
<AsyncImportCap>
<!--ro, opt, object-->
<singleFileMaxFaceNum max="100">
<!--ro, opt, int, attr:max{opt, string}-->100
</singleFileMaxFaceNum>
<singleFileMaxSize max="100">
<!--ro, opt, int, unit:KB, attr:max{opt, int}-->100
</singleFileMaxSize>
</AsyncImportCap>
<isSupportAsyncImportData>
<!--ro, opt, bool-->true
</isSupportAsyncImportData>
<isSupportTaskStatusSearch>
<!--ro, opt, bool-->true
</isSupportTaskStatusSearch>
<SyncDeletePicNum max="10">
<!--ro, opt, int, attr:max{opt, int}-->1
</SyncDeletePicNum>
<isSupportPICCertification>
<!--ro, opt, bool-->true
</isSupportPICCertification>
<deleteOriginalPicEnabled opt="true,false">
<!--ro, opt, bool, attr:opt{opt, string}-->true
</deleteOriginalPicEnabled>
<isSupportFaceScore>
<!--ro, opt, bool-->true
</isSupportFaceScore>
<ImportDetails>
<!--ro, opt, object-->
<checkCode min="0" max="16">
<!--ro, req, string, attr:min{req, int},max{req, int}-->1
</checkCode>
<concurrentRequest>
<!--ro, opt, int-->1


<!--ro, opt, int-->1
</concurrentRequest>
<chunkSize min="1024" max="2048">
<!--ro, opt, int, unit:KB, attr:min{req, int},max{req, int, unit:KB}-->1
</chunkSize>
</ImportDetails>
<ExportDetails>
<!--ro, opt, object-->
<checkCode min="0" max="16">
<!--ro, req, string, attr:min{req, int},max{req, int}-->1
</checkCode>
<GUID min="1" max="36">
<!--ro, req, string, attr:min{req, int},max{req, int}-->1
</GUID>
<concurrentRequest>
<!--ro, opt, int-->1
</concurrentRequest>
</ExportDetails>
</FDLibCap>
21.16.5 Set the face picture data in the face picture library
Request URL
PUT /ISAPI/Intelligent/FDLib/FDSetUp?format=json
Query Parameter
None
Request Message
{
"faceURL": "http",
/*opt, string, picture storage URL, which is inputted when uploading the face picture by URL*/
"faceLibType": "blackFD",
/*req, enum, face picture library type, subType:string, desc:"blackFD" (list library), "staticFD" (static library), the maximum length is 32 bytes*/
"FDID": "test",
/*req, string, face picture library ID, desc:the maximum length is 63 bytes. Multiple libraries are separated by commas*/
"FPID": " ",
/*opt, string, face record ID, desc:it can be generated by the device or inputted. If it is inputted, it should be the unique ID with the combination of
letters and digits, and the maximum length is 63 bytes; if it is generated by the device automatically, it is the same as the employee No. (person ID)*/
"deleteFP": true,
/*opt, bool, whether to delete the face record, desc:true (yes). This field required when the face record needs to be deleted; for adding or editing the
face record, it should not be configured*/
"modelData": "test",
/*opt, string, target model data, desc:during the process of transmission, the non-modeling binary data will be encrypted with Base64 method*/
"PicFeaturePoints": [
/*opt, array, feature picture coordinates, subType:object, desc:if the device only supports three types of feature points, when the platform applies
more than three types of feature points, the device will not return error information*/
{
"featurePointType": "face",
/*req, enum, feature point type, subType:string, desc:"face", "leftEye" (left eye), "rightEye" (right eye), "leftMouthCorner" (left corner of
mouth), "rightMouthCorner" (right corner of mouth), "nose"*/
"coordinatePoint": {
/*opt, object, coordinates of the feature point*/
"x": 1,
/*req, int, X-coordinate, range:[0,1000], desc:normalized coordinates*/
"y": 1,
/*req, int, Y-coordinate, range:[0,1000], desc:normalized coordinates*/
"width": 1,
/*opt, int, width, range:[0,1000], desc:it is required when featurePointType is "face"*/
"height": 1
/*opt, int, height, range:[0,1000], desc:it is required when featurePointType is "face"*/
}
}
],
"faceType": "normalFace",
/*opt, enum, face picture type, subType:string, desc:"normalFace" (normal face, default value), "patrolFace" (patrol person face), "hijackFace" (duress
person face), "superFace" (super person face)*/
"saveFacePic": true,
/*opt, bool, whether to save the registered face picture*/
"leaderPermission": [1, 2, 3, 4]
/*opt, array, first authentication permission, subType:int, range:[1,4], desc:first authentication permission*/
}
Parameter
Name
faceURL
img
Parameter
Value
[报文内容]
Parameter Type(Content-Type) Content-ID File Name Description
application/json
[图片二进制数据] image/jpeg
-
-
-
faceImage.jpg -


Note： The protocol is transmitted in form format. See Chapter 4.5.1.4 for form framework description, as shown in
the instance below.
--<frontier>
Content-Disposition: form-data; name=Parameter Name;filename=File Name
Content-Type: Parameter Type
Content-Length: ****
Content-ID: Content ID
Parameter Value
Parameter Name: the name property of Content-Disposition in the header of form unit; it refers to the form unit
name.
Parameter Type (Content-Type): the Content-Type property in the header of form unit.
File Name (filename): the filename property of Content-Disposition of form unit Headers. It exists only when the
transmitted data of form unit is file, and it refers to the file name of form unit body.
Parameter Value: the body content of form unit.
Response Message
{
"statusCode": 1,
/*ro, opt, int, status code, desc:1 (succeeded). It is required when an error occurred*/
"statusString": "ok",
/*ro, opt, string, status description, range:[1,64], desc:"ok" (succeeded). It is required when an error occurred*/
"subStatusCode": "ok",
/*ro, opt, string, sub status code, range:[1,64], desc:"ok" (succeeded). It is required when an error occurred*/
"errorCode": 1,
/*ro, req, int, error code, desc:it is required when the value of statusCode is not 1, it corresponds to subStatusCode*/
"errorMsg": "ok"
/*ro, req, string, error information, desc:this node is required when the value of statusCode is not 1*/
}
21.16.6 Add a face record to the face picture library
Request URL
POST /ISAPI/Intelligent/FDLib/FaceDataRecord?format=json
Query Parameter
None
Request Message


{
"faceURL": "test",
/*opt, string, picture storage URL inputted when uploading the face picture by URL*/
"faceLibType": "blackFD",
/*req, enum, face picture library type, subType:string, desc:face picture library type*/
"FDID": "test",
/*req, string, face picture library ID, desc:the maximum size is 63 bytes*/
"FPID": " test",
/*opt, string, face record ID, desc:face record ID,it can be generated by device or inputted. If it is inputted,it should be the unique ID with the
combination of letters and digits,and the maximum length is 63 bytes; if it is generated by the device automatically,it is the same as the employee No.
(person ID)*/
"name": "张三",
/*req, string, name of person in the face picture, desc:the maximum size is 96 bytes*/
"gender": "male",
/*opt, enum, gender of person in the face picture, subType:string, desc:“male”, “female”, “unknown”; the maximum size is 32 bytes*/
"bornTime": "2004-05-03",
/*req, string, birthday of person in the face picture, desc:the maximum size is 20 bytes*/
"city": "130100",
/*opt, string, city code of birth for the person in the face picture, desc:the maximum size is 32 bytes*/
"certificateType": "officerID",
/*opt, enum, certificate type, subType:string*/
"certificateNumber": "test",
/*opt, string, certificate No., desc:the maximum size is 32 bytes*/
"caseInfo": "test",
/*opt, string, case information, desc:the maximum size is 192 bytes; it is valid when faceLibType is "blackFD”*/
"tag": "aa,bb,cc,dd",
/*opt, string, custom tag, desc:up to 4 tags, which are separated by commas. The maximum size is 195 bytes. It is valid when faceLibType is "blackFD”*/
"address": "test",
/*opt, string, person address, desc:the maximum size is 192 bytes. It is valid when faceLibType is "staticFD”*/
"customInfo": "test",
/*opt, string, custom information, desc:the maximum size is 192 bytes. It is valid when faceLibType is "staticFD"*/
"modelData": "test",
/*opt, string, target modeling data, desc:target model data,non-modeled binary data needs to be encrypted by Base64 during transmission*/
"transfer": true,
/*opt, bool, whether to enable transfer, desc:whether to enable transfer*/
"operateType": "byTerminal",
/*opt, enum, operation type, subType:string, desc:"byTerminal” (operate by terminal)*/
"terminalNoList": [1],
/*opt, array, terminal ID list, subType:int, desc:this node is required when operation type is "byTerminal"; currently, only one terminal is supported*/
"PicFeaturePoints": [
/*opt, array, feature points to be applied, subType:object*/
{
"featurePointType": "face",
/*req, enum, feature point type, subType:string, desc:"face", "leftEye" (left eye), "rightEye" (right eye), "leftMouthCorner" (left corner of
mouth), "rightMouthCorner" (right corner of mouth), "nose"*/
"coordinatePoint": {
/*opt, object, coordinates of the feature point, desc:object,coordinates of the feature point*/
"x": 1,
/*req, int, X-coordinate, range:[0,1000], desc:normalized X-coordinate which is between 0 and 1000*/
"y": 1,
/*req, int, Y-coordinate, range:[0,1000], desc:normalized Y-coordinate which is between 0 and 1000*/
"width": 1,
/*opt, int, width, range:[0,1000], desc:this node is required when featurePointType is "face"*/
"height": 1
/*opt, int, height, range:[0,1000], desc:this node is required when featurePointType is "face"*/
}
}
],
"faceType": "normalFace",
/*opt, enum, face picture type, subType:string*/
"saveFacePic": true,
/*opt, bool, whether to save face pictures*/
"leaderPermission": [1, 2, 3, 4]
/*opt, array, subType:int, range:[1,4]*/
}
Parameter Name Parameter Value Parameter Type(Content-Type) Content-ID File Name Description
faceURL
[报文内容]
application/json
img
[图片二进制数据] image/jpeg
-
-
-
facePic.jpg -
Note： The protocol is transmitted in form format. See Chapter 4.5.1.4 for form framework description, as shown in
the instance below.
--<frontier>
Content-Disposition: form-data; name=Parameter Name;filename=File Name
Content-Type: Parameter Type
Content-Length: ****
Content-ID: Content ID
Parameter Value
Parameter Name: the name property of Content-Disposition in the header of form unit; it refers to the form unit


name.
Parameter Type (Content-Type): the Content-Type property in the header of form unit.
File Name (filename): the filename property of Content-Disposition of form unit Headers. It exists only when the
transmitted data of form unit is file, and it refers to the file name of form unit body.
Parameter Value: the body content of form unit.
Response Message
{
"requestURL": "test",
/*ro, opt, string, request URL*/
"statusCode": 1,
/*ro, req, int, status code*/
"statusString": "test",
/*ro, req, string, status description*/
"subStatusCode": "test",
/*ro, req, string, sub status code*/
"errorCode": 1,
/*ro, opt, int, error code*/
"errorMsg": "ok",
/*ro, opt, string, error description, desc:see the description of this node and above nodes in the message of JSON_ResponseStatus*/
"FPID": "test",
/*ro, opt, string, face record ID, desc:face record ID returned when the face record is added,it is unique,and the maximum size is 63 bytes. This node
is valid when errorCode is "1" and errorMsg is "ok"*/
"rowKey": "test"
/*ro, opt, string*/
}
21.16.7 Edit face records in the face picture library in a batch
Request URL
PUT /ISAPI/Intelligent/FDLib/FDModify?format=json
Query Parameter
None
Request Message


{
"faceURL": "test",
/*opt, string, picture storage URL inputted when uploading the face picture by URL, the maximum length is 256 bytes*/
"faceLibType": "blackFD",
/*req, enum, face picture library type, subType:string, desc:face picture library type: "blackFD"-list library,"staticFD"-static library,the maximum
length is 32 bytes*/
"FDID": "test",
/*req, string, face picture library ID, desc:face picture library ID,the maximum length is 63 bytes,multiple face picture libraries should be separated
by commas*/
"FPID": " ",
/*opt, string, face record ID*/
"name": "test",
/*opt, string, name*/
"gender": "any",
/*req, enum, gender, subType:string, desc:"any” (unlimited condition which is used in search), "male”, “female”, “unknown"*/
"bornTime": "2004-05-03",
/*req, time, date of birth of the person in the face picture in ISO8601 time format, the maximum length is 20 bytes, desc:date of birth of the person in
the face picture in ISO8601 time format,the maximum length is 20 bytes*/
"city": "130100",
/*opt, string, code of the city of birth for the person in the face picture, the maximum length is 32 bytes, desc:code of the city of birth for the
person in the face picture,the maximum length is 32 bytes*/
"certificateType": "ID",
/*req, enum, certificate type, subType:string*/
"certificateNumber": "test",
/*opt, string, ID No., the maximum length is 32 bytes*/
"caseInfo": "test",
/*opt, string, case information, it is valid when faceLibType is "blackFD”, range:[0,192]*/
"tag": "aa,bb,cc,dd",
/*opt, string, custom tag*/
"address": "test",
/*opt, string, person address, it is valid when faceLibType is "staticFD”*/
"customInfo": "test",
/*opt, string, custom information, it is valid when faceLibType is "staticFD”*/
"modelData": "test",
/*opt, string, target model data, non-modeled binary data needs to be encrypted by base64 during transmission*/
"operateType": "byTerminal",
/*opt, enum, operation type, subType:string, desc:"byTerminal"-by terminal*/
"terminalNoList": [1],
/*opt, array, terminal ID list, subType:int, desc:this node is required when operation type is "byTerminal"; currently, only one terminal is supported*/
"PicFeaturePoints": [
/*opt, array, feature points to be applied. If the device only supports three types of feature points, when the platform applies more than three types
of feature points,the device will not return error information, subType:object*/
{
"featurePointType": "face",
/*req, enum, feature point type, subType:string, desc:"face", "leftEye" (left eye), "rightEye" (right eye), "leftMouthCorner" (left corner of
mouth), "rightMouthCorner" (right corner of mouth), "nose”*/
"coordinatePoint": {
/*opt, object, point coordinates*/
"x": 1,
/*req, int, X-coordinate, range:[0,1000], desc:normalized X-coordinate which is between 0 and 1000*/
"y": 1,
/*req, int, Y-coordinate, range:[0,1000], desc:normalized Y-coordinate which is between 0 and 1000*/
"width": 1,
/*opt, int, width, range:[0,1000], desc:width which is between 0 and 1000. This node is required when featurePointType is "face"*/
"height": 1
/*opt, int, height, range:[0,1000], desc:height which is between 0 and 1000. This node is required when featurePointType is "face"*/
}
}
],
"faceType": "normalFace",
/*opt, enum, face picture type, subType:string*/
"saveFacePic": true,
/*opt, bool, whether to save face pictures*/
"leaderPermission": [1, 2, 3, 4]
/*opt, array, subType:int, range:[1,4]*/
}
Parameter
Name
faceURL
img
Parameter
Value
[报文内容]
Parameter Type(Content-Type) Content-ID File Name Description
application/json
[图片二进制数据] image/jpeg
-
-
-
faceImage.jpg -
Note： The protocol is transmitted in form format. See Chapter 4.5.1.4 for form framework description, as shown in
the instance below.
--<frontier>
Content-Disposition: form-data; name=Parameter Name;filename=File Name
Content-Type: Parameter Type
Content-Length: ****
Content-ID: Content ID
Parameter Value


Parameter Name: the name property of Content-Disposition in the header of form unit; it refers to the form unit
name.
Parameter Type (Content-Type): the Content-Type property in the header of form unit.
File Name (filename): the filename property of Content-Disposition of form unit Headers. It exists only when the
transmitted data of form unit is file, and it refers to the file name of form unit body.
Parameter Value: the body content of form unit.
Response Message
{
"statusCode": 1,
/*ro, opt, int, status code, desc:1 (succeeded). It is required when an error occurred*/
"statusString": "ok",
/*ro, opt, string, status description, range:[1,64], desc:"ok" (succeeded). It is required when an error occurred*/
"subStatusCode": "ok",
/*ro, opt, string, sub status code, range:[1,64], desc:"ok" (succeeded). It is required when an error occurred*/
"errorCode": 1,
/*ro, opt, int, error code, desc:when the value of statusCode is not 1, it corresponds to subStatusCode*/
"errorMsg": "ok"
/*ro, opt, string, error details, desc:this field is required when statusCode is not 1*/
}
21.17 Face Picture Library Management (To be Optimized)
21.17.1 Create a face picture library
Request URL
POST /ISAPI/Intelligent/FDLib?format=json
Query Parameter
None
Request Message
{
"faceLibType": "blackFD,staticFD",
/*req, string, face picture library type, desc:face picture library type*/
"name": "test",
/*req, string, name of the face picture library, range:[0,48], desc:name of the face picture library*/
"customInfo": "test",
/*opt, string, custom information, range:[0,192], desc:custom information*/
"libArmingType": "armingLib",
/*opt, enum, subType:string*/
"libAttribute": "blackList",
/*opt, enum, subType:string*/
"FDID": "test"
/*opt, string, face picture library ID, desc:face picture library ID*/
}
Response Message
{
"requestURL": "test",
/*ro, opt, string, request URL*/
"statusCode": 1,
/*ro, req, int, status code, desc:1 (succeeded). It is required when an error occurred*/
"statusString": "ok",
/*ro, req, string, status description, range:[1,64], desc:"ok" (succeeded). It is required when an error occurred*/
"subStatusCode": "ok",
/*ro, req, string, sub status code, range:[1,64], desc:"ok" (succeeded). It is required when an error occurred*/
"errorCode": 1,
/*ro, opt, int, error code, desc:when the value of statusCode is not 1, it corresponds to subStatusCode*/
"errorMsg": "ok",
/*ro, opt, string, error details, desc:this node is required when the value of statusCode is not 1*/
"FDID": "test"
/*ro, opt, string, face picture library ID, desc:face picture library ID*/
}
21.17.2 Get the total number of face records in all face picture libraries
Request URL


GET /ISAPI/Intelligent/FDLib/Count?format=json
Query Parameter
None
Request Message
None
Response Message
{
"requestURL": "http://10.7.52.31:8080/kms/services/rest/dataInfoService/downloadFile",
/*ro, opt, string, request URL*/
"statusCode": 1,
/*ro, opt, int, status code, desc:1 (succeeded). It is required when an error occurred*/
"statusString": "ok",
/*ro, opt, string, status description, range:[1,64], desc:"ok" (succeeded). It is required when an error occurred*/
"subStatusCode": "ok",
/*ro, opt, string, sub status code, range:[1,64], desc:"ok" (succeeded). It is required when an error occurred*/
"errorCode": 1,
/*ro, req, int, error code, desc:it is required when the value of statusCode is not 1, it corresponds to subStatusCode*/
"errorMsg": "ok",
/*ro, req, string, see the description of this node and above nodes in the message of JSON_ResponseStatus, desc:this node is required when the value of
statusCode is not 1*/
"FDRecordDataInfo": [
/*ro, opt, array, information of face records in face picture library, subType:object, desc:this node is valid when errorCode is 1 and errorMsg is
"ok"*/
{
"FDID": "test",
/*ro, opt, string, face picture library ID, desc:the maximum size is 63 bytes*/
"faceLibType": "blackFD",
/*ro, opt, enum, face picture library type, subType:string, desc:face picture library type "blackFD" list library,"staticFD" static library, the
maximum size is 32 bytes*/
"name": "test",
/*ro, opt, string, face picture library name, desc:the maximum size is 48 bytes*/
"recordDataNumber": 123,
/*ro, opt, int, number of records*/
"libArmingType": "armingLib",
/*ro, opt, enum, arming type, subType:string, desc:arming type*/
"libAttribute": "general",
/*ro, opt, enum, subType:string*/
"personnelFileEnabled": true
/*ro, opt, bool*/
}
],
"totalRecordDataNumber": 500000,
/*ro, opt, int, total number of records, desc:total number of records*/
"FDCapacity": {
/*ro, opt, object*/
"total": 0.000,
/*ro, req, float*/
"use": 0.000,
/*ro, req, float*/
"remain": 0.000,
/*ro, req, float, remaining space, desc:remaining space*/
"maxRecordDataNumber": 0,
/*ro, opt, int*/
"useRecordDataNumber": 0,
/*ro, opt, int*/
"remainRecordDataNumber": 0
/*ro, opt, int*/
}
}
21.17.3 Get face picture library capability
Request URL
GET /ISAPI/Intelligent/FDLib/capabilities?format=json
Query Parameter
None
Request Message
None
Response Message
{
"requestURL": "test",
/*ro, opt, string, request URL*/
"statusCode": 1,
/*ro, req, int, status code*/


/*ro, req, int, status code*/
"statusString": "test",
/*ro, req, string, status description*/
"subStatusCode": "test",
/*ro, req, string, sub status code*/
"errorCode": 1,
/*ro, opt, int, error code, this field is required when the value of statusCode is not 1, and it corresponds to subStatusCode*/
"errorMsg": "ok",
/*ro, opt, string, detailed error description, this field is required when the value of statusCode is not 1*/
"FDNameMaxLen": 64,
/*ro, req, int, maximum length of face picture library name*/
"customInfoMaxLen": 192,
/*ro, req, int, maximum length of custom information*/
"FDMaxNum": 3,
/*ro, req, int, maximum number of face picture libraries*/
"FDRecordDataMaxNum": 12345,
/*ro, req, int, maximum face records supported by face picture library*/
"supportFDFunction": "post,delete,put,get,setUp",
/*ro, req, string, the supported operations on face picture library, desc:"post” (create), "delete” (delete), "put” (edit), "get” (search), "setUp”
(set)*/
"isSuportFDSearch": true,
/*ro, req, bool, whether supports searching in face picture library*/
"isSupportFDSearchDataPackage": true,
/*ro, req, bool, whether supports packaging the found data in the face picture library*/
"isSuportFSsearchByPic": true,
/*ro, req, bool, whether supports searching by picture in the face picture library*/
"isSuportFSsearchByPicGenerate": true,
/*ro, req, bool, whether supports exporting search by picture results from the face picture library*/
"isSuportFDSearchDuplicate": true,
/*ro, req, bool, whether supports duplication checking*/
"isSuportFDSearchDuplicateGenerate": true,
/*ro, req, bool, whether supports exporting the duplication checking results*/
"isSuportFCSearch": true,
/*ro, req, bool, whether supports searching face picture comparison alarms*/
"isSupportFCSearchDataPackage": true,
/*ro, req, bool, whether supports packaging the search results of face picture comparison alarms*/
"isSupportFDExecuteControl": true,
/*ro, req, bool, whether supports creating relation between face picture libraries and cameras*/
"generateMaxNum": 1234,
/*ro, req, int, maximum face records can be exported from face picture library*/
"faceLibType": "blackFD,staticFD",
/*ro, opt, string, face picture library type*/
"modelMaxNum": 1000,
/*ro, opt, int, the maximum number of search results*/
"isSupportModelData": true,
/*ro, opt, bool, whether it supports applying model data*/
"isSuportFDLibArmingType": true,
/*ro, opt, bool, whether it supports face picture library arming type*/
"isSuportFDLibSearch": true,
/*ro, opt, bool, whether it supports searching face picture library*/
"FDArmingRecordDataMaxNum": 12345,
/*ro, opt, int, the supported maximum number of face records in the face picture arming library*/
"isSupportControlPersonRecordByHumanId": true,
/*ro, opt, bool, whether it supports modifying and deleting the face record by humanId*/
"isSupportControlPersonRecordByRowKey": true,
/*ro, opt, bool, whether it supports modifying and deleting the face record by rowKey*/
"isSupportFaceLibRebuildCfg": true,
/*ro, opt, bool, whether it supports recreating face picture library information and configuration*/
"isSupportFDMove": true,
/*ro, opt, bool, whether it supports moving face data in the face picture library in a batch, desc:the related URI is
/ISAPI/Intelligent/FDLib/FDMove/capabilities?format=json*/
"faceURLLen": 1024,
/*ro, opt, int, the maximum size of the face picture URL, desc:if this node is not returned, the default size of the face picture URL supported by the
device is 256 bytes; otherwise, the device should support that the value of this node is greater than or equal to 256*/
"isSupportArmingLibCfg": true,
/*ro, opt, bool, whether it supports configuring parameters of the armed face picture library, desc:related URI:
/ISAPI/Intelligent/FDLib/armingLibCfg/capabilities?format=json*/
"isSupportModelTransformation": true,
/*ro, opt, bool, whether it supports converting face picture models in the face picture list library, desc:related URI:
/ISAPI/Intelligent/FDLib/model/transformation/capabilities?format=json*/
"featurePointTypeList": ["face", "leftEye", "rightEye", "leftMouthCorner", "rightMouthCorner", "nose"],
/*ro, opt, array, feature point types of face pictures supported by the device, subType:string*/
"isSupportPresort": true,
/*ro, opt, bool*/
"libAttribute": {
/*ro, opt, object*/
"@opt": ["general", "blackList", "VIP", "passerby"]
/*ro, opt, array, subType:string*/
},
"faceType": {
/*ro, opt, object, face picture type*/
"@opt": ["normalFace", "patrolFace", "hijackFace", "superFace"]
/*ro, opt, array, options, subType:string*/
},
"saveFacePic": {
/*ro, opt, object, whether to save the registered face picture*/
"@opt": [true, false]
/*ro, opt, array, options, subType:bool*/
},
"leaderPermission": {
/*ro, opt, object*/
"@size": 4,
/*ro, opt, int, range:[1,4]*/
"@min": 1,


"@min": 1,
/*ro, opt, int, range:[1,4]*/
"@max": 4
/*ro, opt, int, range:[1,4]*/
}
}
21.17.4 Get the information, including library ID, library type, name, and custom
information, of all face picture libraries
Request URL
GET /ISAPI/Intelligent/FDLib?format=json&FDID=<FDID>&faceLibType=<faceLibType>&terminalNo=<terminalNo>
Query Parameter
Parameter Name Parameter Type Description
FDID
string
faceLibType
terminalNo
Request Message
None
Response Message
{
"requestURL": "test",
/*ro, opt, string, request URL*/
"statusCode": 1,
/*ro, req, int, status code, desc:status code*/
"statusString": "ok",
/*ro, req, string, status description, range:[1,64], desc:status description*/
"subStatusCode": "ok",
/*ro, req, string, sub status code, range:[1,64], desc:sub status code*/
"errorCode": 1,
/*ro, opt, int*/
"errorMsg": "ok",
/*ro, opt, string, error description, desc:error description*/
"faceLibType": "blackFD",
/*ro, opt, enum, face picture library type, subType:string, desc:"blackFD” (list library), "staticFD” (static library)*/
"name": "test",
/*ro, opt, string, face picture library name, range:[0,48]*/
"customInfo": "test",
/*ro, opt, string, custom information, range:[0,192]*/
"libArmingType": "armingLib",
/*ro, opt, enum, library arming type, subType:string, desc:library arming type*/
"libAttribute": "blackList",
/*ro, opt, enum, subType:string*/
"personnelFileEnabled": true
/*ro, opt, bool*/
}
21.17.5 Delete all face picture libraries
Request URL
DELETE /ISAPI/Intelligent/FDLib?format=json
Query Parameter
None
Request Message
None
Response Message
string
string
-
-
-


{
"statusCode": 1,
/*ro, opt, int, status code, desc:1 (succeeded). It is required when an error occurred*/
"statusString": "ok",
/*ro, opt, string, status description, range:[1,64], desc:"ok" (succeeded). It is required when an error occurred*/
"subStatusCode": "ok",
/*ro, opt, string, sub status code, range:[1,64], desc:"ok" (succeeded). It is required when an error occurred*/
"errorCode": 1,
/*ro, opt, int, error code, desc:it is required when the value of statusCode is not 1, it corresponds to subStatusCode*/
"errorMsg": "ok"
/*ro, opt, string, error information, desc:this field is required when the value of statusCode is not 1*/
}
21.18 Audio Input
21.18.1 Get parameters of all audio channels of the device
Request URL
GET /ISAPI/System/Audio/channels
Query Parameter
None
Request Message
None
Response Message
<?xml version="1.0" encoding="UTF-8"?>
<AudioChannelList xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--ro, opt, array, list of audio channels, subType:object, attr:version{req, string, protocolVersion}-->
<AudioChannel>
<!--ro, opt, object, audio channel-->
<id>
<!--ro, req, string, audio channel ID-->test
</id>
<enabled>
<!--ro, req, bool, whether to enable audio-->true
</enabled>
<type opt="audioIn,audioOut">
<!--ro, opt, enum, audio channel management, subType:string, attr:opt{req, string}, desc:"audioIn" (input audio), "audioOut" (output audio)-->audioIn
</type>
<name>
<!--ro, opt, string, audio channel name-->test
</name>
</AudioChannel>
</AudioChannelList>
21.18.2 Get the configuration of a specific audio channel of the device
Request URL
GET /ISAPI/System/Audio/channels/<audioID>
Query Parameter
Parameter Name Parameter Type Description
audioID
string
Request Message
None
Response Message
-


<?xml version="1.0" encoding="UTF-8"?>
<AudioChannel xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--ro, opt, object, audio channel, attr:version{req, string, protocolVersion}-->
<id>
<!--ro, req, string, audio channel index-->test
</id>
<enabled>
<!--ro, req, bool, whether to enable audio-->true
</enabled>
<type opt="audioIn,audioOut">
<!--ro, opt, enum, audio channel type, subType:string, attr:opt{req, string}, desc:"audioIn" (audio input), "audioOut" (audio output)-->audioIn
</type>
<name>
<!--ro, opt, string, audio channel name-->test
</name>
</AudioChannel>
21.18.3 Get the audio capabilities
Request URL
GET /ISAPI/System/Audio/capabilities
Query Parameter
None
Request Message
None
Response Message


<?xml version="1.0" encoding="UTF-8"?>
<AudioCap xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--ro, opt, object, attr:version{req, string, protocolVersion}-->
<audioInputNums>
<!--ro, req, int-->1
</audioInputNums>
<audioOutputNums>
<!--ro, req, int-->1
</audioOutputNums>
<mixAudioInSet>
<!--ro, opt, bool-->true
</mixAudioInSet>
<mixAudioOutSet>
<!--ro, opt, bool-->true
</mixAudioOutSet>
<isSupportAudioMixing>
<!--ro, opt, bool-->true
</isSupportAudioMixing>
<isSupportRemoveFrequencyPoint>
<!--ro, opt, bool-->true
</isSupportRemoveFrequencyPoint>
<isSupportAudioInConfig>
<!--ro, opt, bool-->true
</isSupportAudioInConfig>
<muteDuringPanTilt opt="MicIn">
<!--ro, opt, string, attr:opt{req, string}-->test
</muteDuringPanTilt>
<isSupportAudioOutConfig>
<!--ro, opt, bool-->true
</isSupportAudioOutConfig>
<isSupportSAIP>
<!--ro, opt, bool-->true
</isSupportSAIP>
<SAIPChannelsNum>
<!--ro, opt, int, dep:and,{$.AudioCap.isSupportSAIP,eq,true}-->1
</SAIPChannelsNum>
<isSupportDataStorage>
<!--ro, opt, bool-->true
</isSupportDataStorage>
<isSupportDataRelease>
<!--ro, opt, bool-->true
</isSupportDataRelease>
<isSupportAudioPlan>
<!--ro, opt, bool-->true
</isSupportAudioPlan>
<isSupportAudioTask>
<!--ro, opt, bool-->true
</isSupportAudioTask>
<isSupportaudioCollection>
<!--ro, opt, bool-->true
</isSupportaudioCollection>
<isSupportWirelessPickUp>
<!--ro, opt, bool-->true
</isSupportWirelessPickUp>
<audioOutputBroadcastNums opt="1,2,3,4">
<!--ro, opt, int, attr:opt{opt, string}-->0
</audioOutputBroadcastNums>
<isSupportAudioOutMixing>
<!--ro, opt, bool-->true
</isSupportAudioOutMixing>
<isSupportRTSPAudio>
<!--ro, opt, bool-->true
</isSupportRTSPAudio>
<AudioBoard>
<!--ro, opt, object-->
<isSupportNetworkParamCfg>
<!--ro, opt, bool-->true
</isSupportNetworkParamCfg>
</AudioBoard>
<isSupportRTSPAudioPlaybackByFile>
<!--ro, opt, bool-->true
</isSupportRTSPAudioPlaybackByFile>
</AudioCap>
21.18.4 Set audio input parameters of a specific channel
Request URL
PUT /ISAPI/System/Audio/AudioIn/channels/<audioID>
Query Parameter
Parameter Name Parameter Type Description
audioID
string
-


Request Message
<?xml version="1.0" encoding="UTF-8"?>
<AudioIn xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--opt, object, attr:version{req, string, protocolVersion}-->
<id>
<!--req, string, ID-->test
</id>
<MixAudioIn>
<!--opt, object, ro-->
<enabled>
<!--req, bool, whether to enable the function-->true
</enabled>
<audioInputType>
<!--opt, enum, subType:string-->macIn
</audioInputType>
<highPassFilter>
<!--opt, int, unit: Hz, range:[0,127], unit:Hz-->1
</highPassFilter>
<noiseMargin>
<!--opt, int, unit: dB, range:[0,127], desc:unit: dB-->1
</noiseMargin>
<AutoLimitWave>
<!--opt, object-->
<FBCEnable>
<!--req, bool-->true
</FBCEnable>
<mode>
<!--req, enum, mode, subType:string-->fast
</mode>
<filterQValue>
<!--req, string-->1
</filterQValue>
<staticFilterNum>
<!--req, int, range:[0,12]-->1
</staticFilterNum>
</AutoLimitWave>
<DSPParameter>
<!--opt, object-->
<FBCEnable>
<!--req, bool-->true
</FBCEnable>
<volume>
<!--req, int, range:[0,255]-->1
</volume>
</DSPParameter>
</MixAudioIn>
<AudioInVolumelist>
<!--opt, object-->
<AudioInVlome>
<!--opt, object-->
<type>
<!--req, enum, type, subType:string, desc:"audioInput”, “audioOutput”, “audioEncode"-->audioOutput
</type>
<volume>
<!--req, int-->1
</volume>
</AudioInVlome>
</AudioInVolumelist>
<automaticGainControl>
<!--opt, int-->1
</automaticGainControl>
<energyThreshold>
<!--opt, int-->1
</energyThreshold>
<PhantomPower>
<!--opt, object-->
<enabled>
<!--req, bool-->true
</enabled>
</PhantomPower>
<audioInCodingFormat>
<!--opt, enum, subType:string-->G.711U
</audioInCodingFormat>
<audioInModeEnabled>
<!--opt, bool-->true
</audioInModeEnabled>
<audioInMode>
<!--opt, enum, subType:string, dep:and,{$.AudioIn.audioInModeEnable,eq,true}-->leftMic
</audioInMode>
<audioInSensitivity>
<!--opt, enum, subType:string, dep:and,{$.AudioIn.audioInMode,eq,lineIn}-->high
</audioInSensitivity>
<AGCEnabled>
<!--opt, bool-->true
</AGCEnabled>
<noiseReductionEnabled>
<!--opt, bool-->true
</noiseReductionEnabled>
<AECEnable>
<!--opt, bool-->true


<!--opt, bool-->true
</AECEnable>
<audioSamplingRate>
<!--opt, int-->0
</audioSamplingRate>
<audioBitRate>
<!--opt, int-->0
</audioBitRate>
<noiseReductionLevel>
<!--opt, int, range:[0,6]-->0
</noiseReductionLevel>
</AudioIn>
Response Message
<?xml version="1.0" encoding="UTF-8"?>
<ResponseStatus xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--ro, req, object, response message, attr:version{ro, req, string, protocolVersion}-->
<requestURL>
<!--ro, req, string, request URL-->null
</requestURL>
<statusCode>
<!--ro, req, enum, status code, subType:int, desc:0 (OK), 1 (OK), 2 (Device Busy), 3 (Device Error), 4 (Invalid Operation), 5 (Invalid XML Format), 6
(Invalid XML Content), 7 (Reboot Required)-->0
</statusCode>
<statusString>
<!--ro, req, enum, status description, subType:string, desc:“OK” (succeeded), “Device Busy”, “Device Error”, “Invalid Operation”, “Invalid XML Format”,
“Invalid XML Content”, “Reboot” (reboot device)-->OK
</statusString>
<subStatusCode>
<!--ro, req, string, sub status code, desc:sub status code-->OK
</subStatusCode>
</ResponseStatus>
21.18.5 Get the audio input parameters of a specified channel
Request URL
GET /ISAPI/System/Audio/AudioIn/channels/<audioID>
Query Parameter
Parameter Name Parameter Type Description
audioID
string
Request Message
None
Response Message
<?xml version="1.0" encoding="UTF-8"?>
<AudioIn xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--ro, opt, object, attr:version{req, string, protocolVersion}-->
<id>
<!--ro, req, string, ID-->test
</id>
<MixAudioIn>
<!--ro, opt, object, ro-->
<enabled>
<!--ro, req, bool-->true
</enabled>
<audioInputType>
<!--ro, opt, enum, audio input type, subType:string, desc:audio input type-->macIn
</audioInputType>
<highPassFilter>
<!--ro, opt, int, unit: Hz, range:[0,127], unit:Hz-->1
</highPassFilter>
<noiseMargin>
<!--ro, opt, int, unit: dB, range:[0,127], desc:unit: dB-->1
</noiseMargin>
<AutoLimitWave>
<!--ro, opt, object-->
<FBCEnable>
<!--ro, req, bool-->true
</FBCEnable>
<mode>
<!--ro, req, enum, mode, subType:string, desc:mode-->fast
</mode>
<filterQValue>
<!--ro, req, string-->1
</filterQValue>
-


</filterQValue>
<staticFilterNum>
<!--ro, req, int, range:[0,12]-->1
</staticFilterNum>
</AutoLimitWave>
<DSPParameter>
<!--ro, opt, object-->
<FBCEnable>
<!--ro, req, bool-->true
</FBCEnable>
<volume>
<!--ro, req, int, input volume, range:[0,255]-->1
</volume>
</DSPParameter>
</MixAudioIn>
<AudioInVolumelist>
<!--ro, opt, object-->
<AudioInVlome>
<!--ro, opt, object-->
<type>
<!--ro, req, enum, type, subType:string, desc:type-->audioOutput
</type>
<volume>
<!--ro, req, int, volume-->1
</volume>
</AudioInVlome>
</AudioInVolumelist>
<automaticGainControl>
<!--ro, opt, int-->1
</automaticGainControl>
<energyThreshold>
<!--ro, opt, int-->1
</energyThreshold>
<PhantomPower>
<!--ro, opt, object-->
<enabled>
<!--ro, req, bool-->true
</enabled>
</PhantomPower>
<audioInCodingFormat>
<!--ro, opt, enum, subType:string-->G.711U
</audioInCodingFormat>
<audioInModeEnabled>
<!--ro, opt, bool-->true
</audioInModeEnabled>
<audioInMode>
<!--ro, opt, enum, audio input mode, subType:string, dep:and,{$.AudioIn.audioInModeEnable,eq,true}, desc:audio input mode-->leftMic
</audioInMode>
<audioInSensitivity>
<!--ro, opt, enum, audio input sensitivity, subType:string, dep:and,{$.AudioIn.audioInMode,eq,lineIn}, desc:audio input sensitivity-->high
</audioInSensitivity>
<AGCEnabled>
<!--ro, opt, bool-->true
</AGCEnabled>
<noiseReductionEnabled>
<!--ro, opt, bool-->true
</noiseReductionEnabled>
<AECEnable>
<!--ro, opt, bool-->true
</AECEnable>
<audioSamplingRate>
<!--ro, opt, int, audio sample rate, desc:audio sample rate-->0
</audioSamplingRate>
<audioBitRate>
<!--ro, opt, int, audio bit rate, desc:audio bit rate-->0
</audioBitRate>
<noiseReductionLevel>
<!--ro, opt, int, noise reduction level, range:[0,6], desc:noise reduction level-->0
</noiseReductionLevel>
</AudioIn>
21.18.6 Get the audio input capability of a specified channel
Request URL
GET /ISAPI/System/Audio/AudioIn/channels/<audioID>/capabilities
Query Parameter
Parameter Name Parameter Type Description
audioID
string
Request Message
None
Response Message
-


<?xml version="1.0" encoding="UTF-8"?>
<AudioInCap xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--ro, opt, object, attr:version{req, string, protocolVersion}-->
<id>
<!--ro, req, string, ID-->test
</id>
<MixAudioIn>
<!--ro, opt, object, ro-->
<enabled opt="true,false">
<!--ro, req, bool, attr:opt{req, string}-->true
</enabled>
<audioInputType opt="micIn, lineIn">
<!--ro, opt, enum, audio input type, subType:string, attr:opt{req, string}, desc:audio input type-->macIn
</audioInputType>
<highPassFilter
opt="0,8,16,24,31,39,47,55,63,71,79,87,94,102,110,118,126,134,142,150,157,165,173,181,189,197,205,213,220,228,236,244,252,260,268,276,283,291,299,307,315,32
3,331,339,346,354,362,370,378,386,394,402,409,417,425,433,441,449,457,465,472,480,488,496,504,512,520,528,535,543,551,559,567,575,583,591,598,606,614,622,63
0,638,646,654,661,669,677,685,693,701,709,717,724,732,740,748,756,764,772,780,787,795,803,811,819,827,835,843,850,858,866,874,882,890,898,906,913,921,929,93
7,945,953,961,969,976,984,992,1000" def="30">
<!--ro, opt, int, unit: Hz, range:[0,127], unit:Hz, attr:opt{req, string},def{req, string}-->1
</highPassFilter>
<noiseMargin opt="1000,660,657,653,650,647,643,640,637,633,630,627,623,620,617,613,610,607,603,600,597,593,590,587,583,580,577,573,570,567,563,560,557,553,550,547,543,540,537,533,530,527,523,520,517,513,510,507,503,
500,497,493,490,487,483,480,477,473,470,467,463,460,457,453,450,447,443,440,437,433,430,427,423,420,417,413,410,407,403,400,397,393,390,387,383,380,377,373,
370,367,363,360,357,353,350,347,343,340,337,333,330,327,323,320,317,313,310,307,303,300,297,293,290,287,283,280,277,273,270,267,263,260,257,253,250,247,243,
240"
def="30">
<!--ro, opt, int, unit: dB, range:[0,127], attr:opt{req, string},def{req, string}, desc:unit: dB-->1
</noiseMargin>
<AutoLimitWave>
<!--ro, opt, object, audioInputType-->
<FBCEnable opt="true,false">
<!--ro, req, bool, attr:opt{req, string}-->true
</FBCEnable>
<mode opt="fast,general,slow" def="general">
<!--ro, req, enum, mode, subType:string, attr:opt{req, string},def{req, string}, desc:mode-->fast
</mode>
<filterQValue opt="40,10" def="40">
<!--ro, req, int, attr:opt{req, string},def{req, string}-->1
</filterQValue>
<staticFilterNum min="0" max="12" def="0">
<!--ro, req, int, range:[0,12], attr:min{req, int},max{req, int},def{req, int}-->1
</staticFilterNum>
</AutoLimitWave>
<DSPParameter>
<!--ro, opt, object-->
<FBCEnable>
<!--ro, req, bool-->true
</FBCEnable>
<volume min="1" max="10">
<!--ro, req, int, input volume, range:[0,255], attr:min{req, int},max{req, int}-->1
</volume>
</DSPParameter>
</MixAudioIn>
<AudioInVolumelist>
<!--ro, opt, object-->
<AudioInVlome>
<!--ro, opt, object-->
<type opt="audioInput,audioOutput,audioEncode">
<!--ro, req, enum, type, subType:string, attr:opt{req, string}, desc:type-->audioOutput
</type>
<volume min="0" max="127" def="50">
<!--ro, req, int, volume, attr:min{req, int},max{req, int},def{req, int}-->1
</volume>
</AudioInVlome>
</AudioInVolumelist>
<automaticGainControl min="0" max="12" default="12">
<!--ro, opt, int, attr:min{req, int},max{req, int},default{opt, string}-->1
</automaticGainControl>
<energyThreshold min="-90" max="0" default="-55">
<!--ro, opt, int, attr:min{req, int},max{req, int},default{opt, string}-->1
</energyThreshold>
<PhantomPower>
<!--ro, opt, object-->
<enabled opt="true,false" def="false">
<!--ro, req, bool, attr:opt{req, string},def{opt, string}-->true
</enabled>
</PhantomPower>
<audioInCodingFormat opt="G.711U,G.711A,OPUS,PCM,AAC" def="G.711U">
<!--ro, opt, enum, subType:string, attr:opt{req, string},def{req, string}-->G.711U
</audioInCodingFormat>
<audioInModeEnabled>
<!--ro, opt, bool-->true
</audioInModeEnabled>
<audioInMode opt="leftMic,rightMic,bluetooth,lineIn,earphone,6.5mm,RCALeft,RCARight,embeddedAudio">
<!--ro, opt, enum, audio input mode, subType:string, dep:and,{$.AudioInCap.audioInModeEnable,eq,true}, attr:opt{req, string}, desc:audio input mode-
>leftMic
</audioInMode>
<audioInSensitivity opt="high,mid,low">
<!--ro, opt, enum, audio input sensitivity, subType:string, dep:and,{$.AudioInCap.audioInMode,eq,lineIn}, attr:opt{req, string}, desc:audio input
sensitivity-->high
</audioInSensitivity>


<AGCEnabled opt="true,false" def="true">
<!--ro, opt, bool, attr:opt{req, string},def{req, string}-->true
</AGCEnabled>
<noiseReductionEnabled opt="true,false">
<!--ro, opt, bool, attr:opt{req, string}-->true
</noiseReductionEnabled>
<AECEnable opt="true,false">
<!--ro, opt, bool, attr:opt{req, string}-->true
</AECEnable>
<audioSamplingRate opt="16,32" def="16">
<!--ro, opt, int, audio sample rate, attr:opt{req, string},def{req, string}, desc:audio sample rate-->0
</audioSamplingRate>
<audioBitRate opt="1,2,3,4,5" def="0">
<!--ro, opt, int, audio bit rate, attr:opt{req, string},def{req, string}, desc:audio bit rate-->0
</audioBitRate>
<isSupportAudioSceneSettings>
<!--ro, opt, bool-->true
</isSupportAudioSceneSettings>
<isSupportSoundSourcerPosition>
<!--ro, opt, bool-->true
</isSupportSoundSourcerPosition>
<noiseReductionLevel min="0" max="6">
<!--ro, opt, int, noise reduction level, range:[0,6], attr:min{req, int},max{req, int}, desc:noise reduction level-->0
</noiseReductionLevel>
</AudioInCap>
21.19 ID Card Management
21.19.1 Apply ID card blocklist
Request URL
PUT /ISAPI/AccessControl/IDBlackListCfg?security=<security>&iv=<iv>
Query Parameter
Parameter Name Parameter Type Description
security
string
iv
Request Message
string
-
-


<?xml version="1.0" encoding="UTF-8"?>
<IDBlackListCfg xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--req, object, ID card blocklist, attr:version{req, string, protocolVersion}-->
<blackListValid>
<!--req, enum, ID card blocklist status, subType:int, desc:0-invalid,1-valid. This node is used to delete the ID card blocklist by ID card number. If it
is 0, it indicates deleting the blocklist-->1
</blackListValid>
<IDCardInfo>
<!--opt, object, ID card information-->
<name>
<!--opt, string, name, range:[1,32]-->test
</name>
<birth>
<!--opt, date, date of birth-->1990-02-24
</birth>
<addr>
<!--opt, string, address, range:[1,32]-->test
</addr>
<IDNum>
<!--ro, req, string, ID card number-->542137199002241111
</IDNum>
<issuingAuthority>
<!--opt, string, issuing authority, range:[1,32]-->test
</issuingAuthority>
<startDate>
<!--opt, date, start date of expiry date-->1970-01-01
</startDate>
<endDate>
<!--opt, date, end date of expiry date, dep:and,{$.IDBlackListCfg.IDCardInfo.termOfValidity,ue,true}-->1977-01-01
</endDate>
<termOfValidity>
<!--opt, bool, whether it is permanently valid, desc:false-no, true-yes (the <endDate> is invalid)-->true
</termOfValidity>
<sex>
<!--opt, enum, gender, subType:string, desc:"male", "female"-->male
</sex>
<nation>
<!--opt, enum, subType:int-->1
</nation>
</IDCardInfo>
</IDBlackListCfg>
Response Message
<?xml version="1.0" encoding="UTF-8"?>
<ResponseStatus xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--ro, req, object, response message, attr:version{ro, req, string, protocolVersion}-->
<requestURL>
<!--ro, req, string-->null
</requestURL>
<statusCode>
<!--ro, req, enum, status code, subType:int, desc:0 (OK), 1 (OK), 2 (Device Busy), 3 (Device Error), 4 (Invalid Operation), 5 (Invalid XML Format), 6
(Invalid XML Content), 7 (Reboot Required)-->0
</statusCode>
<statusString>
<!--ro, req, enum, status information, subType:string, desc:"OK" (succeeded), "Device Busy", "Device Error", "Invalid Operation", "Invalid XML Format",
"Invalid XML Content", "Reboot" (reboot device)-->OK
</statusString>
<subStatusCode>
<!--ro, req, string, sub status code, which describes the error in details, desc:sub status code, which describes the error in details-->OK
</subStatusCode>
</ResponseStatus>
21.19.2 Get capability of applying ID card blocklist
Request URL
GET /ISAPI/AccessControl/IDBlackListCfg/capabilities
Query Parameter
None
Request Message
None
Response Message


<?xml version="1.0" encoding="UTF-8"?>
<IDBlackListCfg xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--ro, opt, object, ID card blocklist, attr:version{req, string, protocolVersion}-->
<blackListValid opt="0,1">
<!--ro, req, enum, ID card blocklist status, subType:int, attr:opt{req, string}, desc:0-invalid, 1-valid; this node is used to delete the ID card
blocklist by ID card number; if it is 0, it indicates deleting the blocklist-->1
</blackListValid>
<IDCardInfo>
<!--ro, opt, object, ID card information-->
<name min="1" max="10">
<!--ro, opt, string, name, range:[1,32], attr:min{req, int},max{req, int}-->test
</name>
<birth>
<!--ro, opt, date, date of birth-->1970-01-01
</birth>
<addr min="1" max="10">
<!--ro, opt, string, address, range:[1,32], attr:min{req, int},max{req, int}-->test
</addr>
<IDNum min="18" max="18">
<!--ro, req, const, ID card number, attr:min{req, int},max{req, int}-->542137199002241111
</IDNum>
<issuingAuthority min="1" max="10">
<!--ro, opt, string, issuing authority, attr:min{req, int},max{req, int}-->test
</issuingAuthority>
<startDate>
<!--ro, opt, date, start date of validity-->1970-01-01
</startDate>
<endDate>
<!--ro, opt, date, end date of validity, dep:and,{$.IDBlackListCfg.IDCardInfo.termOfValidity,ue,true}-->1970-01-01
</endDate>
<termOfValidity opt="true,false">
<!--ro, opt, bool, whether it is permanently valid, attr:opt{req, string}, desc:false-no, true-yes (the <endDate> is invalid)-->true
</termOfValidity>
<sex opt="male,female">
<!--ro, opt, enum, gender, subType:string, attr:opt{req, string}, desc:"male", "female"-->male
</sex>
<nation
opt="1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,5
4,55,56,57">
<!--ro, opt, enum, subType:int, attr:opt{req, string}-->1
</nation>
</IDCardInfo>
</IDBlackListCfg>
21.19.3 ID card information event
EventType:IDCardInfoEvent
{
"ipAddress": "172.6.64.7",
/*ro, req, string, IPv4 address of the device that triggers the alarm*/
"ipv6Address": "1080:0:0:0:8:800:200C:417A",
/*ro, opt, string, IPv6 address of the device that triggers the alarm*/
"portNo": 80,
/*ro, opt, int, communication port No. of the device that triggers the alarm*/
"protocol": "HTTP",
/*ro, opt, enum, transmission communication protocol type, subType:string, desc:when ISAPI protocol is transmitted via HCNetSDK, the channel No. is the
video channel No. of private protocol. When ISAPI protocol is transmitted via EZ protocol, the channel No. is the video channel No. of EZ protocol. When
ISAPI protocol is transmitted via ISUP, the channel No. is the video channel No. of ISUP*/
"macAddress": "01:17:24:45:D9:F4",
/*ro, opt, string, MAC address*/
"channelID": 1,
/*ro, opt, int, channel No. of the device that triggers the alarm, desc:when ISAPI protocol is transmitted via HCNetSDK, the channel No. is the video
channel No. of private protocol. When ISAPI protocol is transmitted via EZ protocol, the channel No. is the video channel No. of EZ protocol. When ISAPI
protocol is transmitted via ISUP, the channel No. is the video channel No. of ISUP*/
"dateTime": "2004-05-03T17:30:08+08:00",
/*ro, req, datetime, alarm trigger time*/
"activePostCount": 1,
/*ro, opt, int, times that the same alarm has been uploaded, desc:times that the same alarm has been uploaded*/
"eventType": "IDCardInfoEvent",
/*ro, req, string, event type, desc:"IDCardInfoEvent" (ID card information event)*/
"eventState": "active",
/*ro, req, enum, event status, subType:string, desc:for durative event: "active" (valid event or event starts), "inactive" (invalid event or the event
ends). For the heartbeat, the node value indicates the heartbeat data, and it is uploaded every 10 seconds*/
"eventDescription": "IDCard Info Event",
/*ro, req, string, event description*/
"deviceID": "test0123",
/*ro, opt, string, device ID (PUID), desc:it should be returned in ISUP alarm*/
"IDCardInfoEvent": {
/*ro, opt, object, ID card information*/
"deviceName": "test",
/*ro, opt, string, device name, range:[1,32]*/
"majorEventType": 1,
/*ro, req, int, major alarm type, desc:the type value should be transformed to the decimal number; see Access Control Alarm Types for details*/
"subEventType": 1,
/*ro, req, int, minor alarm type, dep:and,{$.IDCardInfoEvent.majorEventType,eq,任意值}, desc:the type value should be transformed to the decimal
number; see Access Control Alarm Types for details*/


number; see Access Control Alarm Types for details*/
"inductiveEventType": "authenticated",
/*ro, opt, enum, inductive event type, subType:string, desc:this node is used by storage devices; for access control devices, this node is invalid;
"authenticated", "authenticationFailed", "openingDoor", "closingDoor", "doorException", "remoteOperation", "timeSynchronization", "deviceException",
"deviceRecovered", "alarmTriggered", "alarmRecovered" (arming restoring event), "callCenter"*/
"netUser": "test",
/*ro, opt, string, user name for network operations, range:[1,32]*/
"remoteHostAddr": "test",
/*ro, opt, string, remote host address*/
"cardType": 1,
/*ro, opt, enum, card type, subType:int, desc:1 (normal card), 2 (disability card), 3 (blocklist card), 4 (patrol card), 5 (duress card), 6 (super
card), 7 (visitor card), 8 (dismiss card)*/
"cardReaderNo": 1,
/*ro, opt, int, card reader No.*/
"doorNo": 1,
/*ro, opt, int, door (floor) No.*/
"deviceNo": 1,
/*ro, opt, int, device No.*/
"serialNo": 1,
/*ro, opt, int, event serial No.*/
"currentEvent": true,
/*ro, opt, bool, whether it is a real-time event, desc:true (yes (real-time event)), false (no (offline event))*/
"QRCodeInfo": "test",
/*ro, opt, string, QR code information, range:[1,64]*/
"thermometryUnit": "celsius",
/*ro, opt, enum, temperature unit, subType:string, desc:"celsius" (Celsius (default)), "fahrenheit" (Fahrenheit), "kelvin" (Kelvin)*/
"currTemperature": 36.1,
/*ro, opt, float, skin-surface temperature, desc:it should be accurate to one decimal place*/
"isAbnomalTemperature": true,
/*ro, opt, bool, whether the skin-surface temperature is abnormal*/
"RegionCoordinates": {
/*ro, opt, object, coordinates of the skin-surface temperature*/
"positionX": 0,
/*ro, opt, int, X-coordinate, range:[0,1000], desc:the value is normalized to a number between 0 and 1000*/
"positionY": 0
/*ro, opt, int, Y-coordinate, range:[0,1000], desc:the value is normalized to a number between 0 and 1000*/
},
"remoteCheck": true,
/*ro, opt, bool, whether remote verification is required, desc:true (yes), false (no, default)*/
"mask": "unknown",
/*ro, opt, enum, whether the person wears a mask, subType:string, desc:"unknown", "yes", "no"*/
"frontSerialNo": 1,
/*ro, opt, int, the previous event's serial No., desc:if this node does not exist, the platform will check whether the event loss occurred according
to the node serialNo. If both the serialNo and frontSerialNo are returned, the platform will check whether the event loss occurred according to both nodes.
It is mainly used to solve the problem that the serialNo is inconsistent after subscribing events or alarms*/
"IDCardInfo": {
/*ro, opt, object, ID card information*/
"name": "test",
/*ro, opt, string, name, range:[1,128]*/
"sex": "male",
/*ro, opt, enum, gender, subType:string, desc:"male", "female"*/
"birth": "1970-01-01",
/*ro, opt, date, date of birth*/
"addr": "test",
/*ro, opt, string, address*/
"IDCardNo": "test",
/*ro, opt, string, ID card No.*/
"issuingAuthority": "test",
/*ro, opt, string, issuing authority*/
"startDate": "test",
/*ro, opt, string, start date of the effective period*/
"endDate": "test",
/*ro, opt, string, end date of the effective period*/
"nation": 1,
/*ro, opt, int, N/A, range:[1,57], desc:N/A*/
"isLongTermEffective": false
/*ro, opt, bool, whether the effective period is permanent*/
},
"pictureURL": "test",
/*ro, opt, string, URL of the captured picture, range:[1,256]*/
"IDCardPicURL": "test",
/*ro, opt, string, ID card picture URL, range:[1,256]*/
"certificatePicURL": "test",
/*ro, opt, string, URL of the captured ID picture, range:[1,256]*/
"contentId": "Picture",
/*ro, opt, string, contentID of picture, desc:contentID of the picture data binary data*/
"IDCardContentId": "IDCardPicture",
/*ro, opt, string, contentID of ID card picture, desc:contentID of the picture data binary data*/
"certificateContentId": "CertificatePicture",
/*ro, opt, string, contentID of captured ID picture, desc:contentID of the picture data binary data*/
"visibleLightURL": "test",
/*ro, opt, string, visible light picture URL of the thermal imaging camera, range:[0,256]*/
"thermalURL": "test",
/*ro, opt, string, thermal imaging picture URL, range:[0,256]*/
"picturesNumber": 1,
/*ro, opt, int, number of pictures, range:[0,4], desc:if there is no picture, this node is set to 0 or is not returned*/
"helmet": "unknown",
/*ro, opt, enum, whether the person wears a hard hat, subType:string, desc:"unknown", "yes", "no"*/
"HealthInfo": {
/*ro, opt, object, health information*/
"healthCode": 1,
/*ro, opt, enum, health code status, subType:int, desc:0 (no request), 1 (no health code), 2 (green QR code), 3 (yellow QR code), 4 (red QR
code), 5 (no such person), 6 (other error, e.g., searching failed due to API exception), 7 (searching for the health code timed out)*/
"NADCode": 1,
/*ro, opt, enum, nucleic acid test result, subType:int, desc:0 (no result), 1 (negative, which means normal), 2 (positive, which means


/*ro, opt, enum, nucleic acid test result, subType:int, desc:0 (no result), 1 (negative, which means normal), 2 (positive, which means
diagnosed), 3 (the result has expired)*/
"NADMsg": "test",
/*ro, opt, string, range:[0,64]*/
"travelCode": 1,
/*ro, opt, enum, trip code, subType:int, desc:0 (no trip in the past 14 days), 1 (has left the current area left in the past 14 days), 2 (has
been to the high-risk area in the past 14 days), 3 (other)*/
"travelInfo": "test",
/*ro, opt, string, trip information, desc:the empty string indicates that searching trip failed*/
"vaccineStatus": 1,
/*ro, opt, enum, whether the person is vaccinated, subType:int, desc:0 (not vaccinated), 1 (vaccinated)*/
"vaccineNum": 1,
/*ro, opt, int, step:1*/
"vaccineMsg": "test",
/*ro, opt, string, range:[0,64]*/
"ANTCode": 1,
/*ro, opt, enum, subType:int*/
"ANTMsg": "test"
/*ro, opt, string, range:[0,64]*/
},
"PhysicalInfo": {
/*ro, opt, object, BMI information, desc:this node is obtained after authentication by BMI scales which is connected to MinMoe terminals*/
"weight": 7000,
/*ro, opt, int, weight, unit:kg*/
"height": 18000
/*ro, opt, int, height, unit:cm*/
},
"FaceRect": {
/*ro, opt, object, rectangle frame for human face, desc:the origin is the upper-left corner of the screen*/
"height": 1.000,
/*ro, req, float, height, range:[0.000,1.000]*/
"width": 1.000,
/*ro, req, float, width, range:[0.000,1.000]*/
"x": 0.000,
/*ro, req, float, X-coordinate of the upper-left corner of the frame, range:[0.000,1.000]*/
"y": 0.000
/*ro, req, float, Y-coordinate of the upper-left corner of the frame, range:[0.000,1.000]*/
},
"currentAuthenticationTimes": 1,
/*ro, opt, int, range:[0,255], step:1*/
"allowAuthenticationTimes": 1
/*ro, opt, int, range:[0,255], step:1*/
}
}
Parameter Name
IDCardInfoEvent
IDCardPic
CertificatePicture
VisibleLight
Thermal
ProtocolFileAndSignPic
Parameter
Value
Parameter
Type(ContentType)
Content-ID
[报文内容]
application/json -
[图片二进
制数据]
[图片二进
制数据]
[图片二进
制数据]
[图片二进
制数据]
[图片二进
制数据]
image/jpeg
image/jpeg
image/jpeg
image/jpeg
image/jpeg
IDCardPicImage
File Name
Description
-
IDCardPic.jpg
CertificatePicture CertificatePicture.jpg
visibleLight_image VisibleLight.jpg
thermal_image
Thermal.jpg
-
-
-
-
-
ProtocolFileAndSignPic.jpg -
Note： The protocol is transmitted in form format. See Chapter 4.5.1.4 for form framework description, as shown in
the instance below.
--<frontier>
Content-Disposition: form-data; name=Parameter Name;filename=File Name
Content-Type: Parameter Type
Content-Length: ****
Content-ID: Content ID
Parameter Value
Parameter Name: the name property of Content-Disposition in the header of form unit; it refers to the form unit


name.
Parameter Type (Content-Type): the Content-Type property in the header of form unit.
File Name (filename): the filename property of Content-Disposition of form unit Headers. It exists only when the
transmitted data of form unit is file, and it refers to the file name of form unit body.
Parameter Value: the body content of form unit.
21.20 Access Control Module Management
21.20.1 Get the configuration of the door lock status when the device is powered off
Request URL
GET /ISAPI/AccessControl/Configuration/lockType?format=json
Query Parameter
None
Request Message
None
Response Message
{
"LockType": {
/*ro, opt, object, status*/
"status": "alwaysOpen"
/*ro, opt, enum, door lock status when the device is powered off, subType:string, desc:door lock status when the device is powered off:
"alwaysOpen"-remain open,"alwaysClose"-remain closed*/
}
}
21.20.2 Set door lock status when the device is powered off
Request URL
PUT /ISAPI/AccessControl/Configuration/lockType?format=json
Query Parameter
None
Request Message
{
"LockType": {
/*opt, object, status*/
"status": "alwaysOpen"
/*req, enum, door lock status when the device is powered off, subType:string, desc:"alwaysOpen"-remain open, "alwaysClose"-remain closed*/
}
}
Response Message
{
"requestURL": "test",
/*ro, opt, string, URI*/
"statusCode": "test",
/*ro, opt, string, status code*/
"statusString": "test",
/*ro, opt, string, status description*/
"subStatusCode": "test",
/*ro, opt, string, sub status code*/
"errorCode": 1,
/*ro, req, int, error code*/
"errorMsg": "ok"
/*ro, req, string, error information*/
}
21.20.3 Get the door configuration capability
Request URL


GET /ISAPI/AccessControl/Door/param/<doorID>/capabilities
Query Parameter
Parameter Name Parameter Type Description
doorID
string
Request Message
None
Response Message
<?xml version="1.0" encoding="UTF-8"?>
<DoorParam xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--ro, req, object, attr:version{req, string, protocolVersion}-->
<doorNo min="1" max="10">
<!--ro, opt, int, door No., attr:min{req, int},max{req, int}-->1
</doorNo>
<doorName min="1" max="32">
<!--ro, opt, string, door name, attr:min{req, int},max{req, int}-->test
</doorName>
<magneticType opt="alwaysClose,alwaysOpen">
<!--ro, opt, enum, magnetic contact type, subType:string, attr:opt{req, string}, desc:"alwaysClose” (remain locked), "alwaysOpen” (remain unlocked)-
>alwaysClose
</magneticType>
<openButtonType opt="alwaysClose,alwaysOpen">
<!--ro, opt, enum, door button type, subType:string, attr:opt{req, string}, desc:"alwaysClose” (remain locked), "alwaysOpen” (remain unlocked)-
>alwaysClose
</openButtonType>
<openDuration min="1" max="255">
<!--ro, opt, int, door open duration (floor relay action time), attr:min{req, int},max{req, int}-->1
</openDuration>
<disabledOpenDuration min="1" max="255">
<!--ro, opt, int, door open duration by disability card (delay duration of closing the door), attr:min{req, int},max{req, int}-->1
</disabledOpenDuration>
<magneticAlarmTimeout min="0" max="255">
<!--ro, opt, int, alarm time of magnetic contact detection timeout, range:[0,255], unit:s, attr:min{req, int},max{req, int}, desc:alarm time of magnetic
contact detection timeout,which is between 0 and 255,0 refers to not triggering alarm,unit: second-->1
</magneticAlarmTimeout>
<enableDoorLock opt="true,false">
<!--ro, opt, bool, whether to enable locking door when the door is closed, attr:opt{req, string}-->true
</enableDoorLock>
<enableLeaderCard opt="true,false">
<!--ro, opt, bool, whether to enable remaining open with first card, attr:opt{req, string}-->true
</enableLeaderCard>
<leaderCardMode opt="disable,alwaysOpen,authorize">
<!--ro, opt, enum, first card mode, subType:string, attr:opt{req, string}, desc:"disable", "alwaysOpen” (remain open with first card), "authorize”
(first card authentication)-->disable
</leaderCardMode>
<leaderCardOpenDuration min="1" max="1440">
<!--ro, opt, int, duration of remaining open with first card, attr:min{req, int},max{req, int}-->1
</leaderCardOpenDuration>
<stressPassword min="1" max="8">
<!--ro, opt, string, duress password, attr:min{req, int},max{req, int}, desc:the maximum length is 8 bytes, and the duress password should be encoded by
Base64 for transmission-->test
</stressPassword>
<superPassword min="1" max="8">
<!--ro, opt, string, super password, attr:min{req, int},max{req, int}, desc:the maximum length is 8 bytes, and the duress password should be encoded by
Base64 for transmission-->test
</superPassword>
<unlockPassword min="1" max="8">
<!--ro, opt, string, dismiss password,t, attr:min{req, int},max{req, int}, desc:the maximum length is 8 bytes, and the duress password should be encoded
by Base64 for transmission-->test
</unlockPassword>
<useLocalController opt="true,false">
<!--ro, opt, bool, whether it is connected to the distributed controller, attr:opt{req, string}-->true
</useLocalController>
<localControllerID min="0" max="64">
<!--ro, opt, int, distributed controller No., range:[0,64], attr:min{req, int},max{req, int}, desc:ro,distributed controller No.,which is between 1 and
64,0-unregistered-->1
</localControllerID>
<localControllerDoorNumber min="0" max="4">
<!--ro, opt, int, distributed controller door No., range:[0,4], attr:min{req, int},max{req, int}, desc:ro,distributed controller door No.,which is
between 1 and 4,0-unregistered-->1
</localControllerDoorNumber>
<localControllerStatus opt="0,1,2,3,4,5,6,7,8,9">
<!--ro, opt, enum, online status of the distributed controller, subType:int, attr:opt{req, string}, desc:0-offline, 1-network online, 2-RS-485 serial
port 1 on loop circuit 1, 3-RS-485 serial port 2 on loop circuit 1, 4-RS-485 serial port 1 on loop circuit 2, 5-RS-485 serial port 2 on loop circuit 2, 6RS-485
serial port 1 on loop circuit 3, 7-RS-485 serial port 2 on loop circuit 3,8-RS-485 serial port 1 on loop circuit 4, 9-RS-485 serial port 2 on loop
circuit 4-->1
</localControllerStatus>
<lockInputCheck opt="true,false">
<!--ro, opt, bool, whether to enable door lock input detection, attr:opt{req, string}-->true
</lockInputCheck>
<lockInputType opt="alwaysClose,alwaysOpen">
<!--ro, opt, enum, door lock input type, subType:string, attr:opt{req, string}, desc:"alwaysClose” (remain locked), "alwaysOpen” (remain unlocked)-
>alwaysClose
-


>alwaysClose
</lockInputType>
<doorTerminalMode opt="preventCutAndShort,preventCutAndShort,common">
<!--ro, opt, enum, working mode of door terminal, subType:string, attr:opt{req, string}, desc:working mode of door terminal: "preventCutAndShort"prevent
from broken-circuit and short-circuit (default),"common"-->preventCutAndShort
</doorTerminalMode>
<openButton opt="true,false">
<!--ro, opt, bool, whether to enable door button, attr:opt{req, string}, desc:whether to enable door button: "true"-yes (default),"false"-no-->true
</openButton>
<ladderControlDelayTime min="1" max="255">
<!--ro, opt, int, elevator control delay time (for visitor), attr:min{req, int},max{req, int}-->1
</ladderControlDelayTime>
<Leader>
<!--ro, opt, object-->
<continuousVerificationTimes min="1" max="10">
<!--ro, opt, int, range:[1,10], attr:min{req, int},max{req, int}-->1
</continuousVerificationTimes>
<continuousVerificationDuration min="1" max="10">
<!--ro, opt, int, range:[5,60], unit:s, attr:min{req, int},max{req, int}-->20
</continuousVerificationDuration>
<effectiveTimeEnabled opt="true,false">
<!--ro, req, bool, attr:opt{req, string}-->true
</effectiveTimeEnabled>
<dayBeginTime>
<!--ro, opt, time, dep:and,{$.DoorParam.Leader.effectiveTimeEnabled,eq,true}-->00:00:00
</dayBeginTime>
<beginEffectiveTime>
<!--ro, opt, time, dep:and,{$.DoorParam.Leader.effectiveTimeEnabled,eq,true}-->00:00:00
</beginEffectiveTime>
<endEffectiveTime>
<!--ro, opt, time, dep:and,{$.DoorParam.Leader.effectiveTimeEnabled,eq,true}-->00:00:00
</endEffectiveTime>
</Leader>
<verificationPassOpenDoor opt="true,false">
<!--ro, opt, bool, attr:opt{req, string}-->true
</verificationPassOpenDoor>
<relayReverseEnabled opt="true,false" def="false">
<!--ro, opt, bool, attr:opt{req, string},def{req, bool}-->true
</relayReverseEnabled>
</DoorParam>
21.20.4 Get the door (floor) configuration parameters
Request URL
GET /ISAPI/AccessControl/Door/param/<doorID>?security=<security>&iv=<iv>
Query Parameter
Parameter Name Parameter Type Description
doorID
string
security
iv
string
string
Request Message
None
Response Message
<?xml version="1.0" encoding="UTF-8"?>
<DoorParam xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--ro, req, object, attr:version{req, string, protocolVersion}-->
<doorName>
<!--ro, opt, string, door name-->test
</doorName>
<magneticType>
<!--ro, opt, enum, magnetic contact type, subType:string, desc:"alwaysClose"-remain locked, "alwaysOpen"-remain unlocked-->alwaysClose
</magneticType>
<openButtonType>
<!--ro, opt, enum, door button type, subType:string, desc:"alwaysClose"-remain locked, "alwaysOpen"-remain unlocked-->alwaysClose
</openButtonType>
<openDuration>
<!--ro, opt, int, door open duration, range:[1,255], unit:s-->1
</openDuration>
<disabledOpenDuration>
<!--ro, opt, int, door open duration by disability card (delay duration of closing the door), range:[1,255], unit:s-->1
</disabledOpenDuration>
<magneticAlarmTimeout>
<!--ro, opt, int, alarm time of magnetic contact detection timeout, range:[0,255], unit:s, desc:0 refers to not triggering alarm-->1
</magneticAlarmTimeout>
<enableDoorLock>
-
-
-


<enableDoorLock>
<!--ro, opt, bool, whether to enable locking door when the door is closed-->true
</enableDoorLock>
<enableLeaderCard>
<!--ro, opt, bool, whether to enable remaining open with first card. This node is invalid when leaderCardMode is configured-->true
</enableLeaderCard>
<leaderCardMode>
<!--ro, opt, enum, first card mode, subType:string, desc:"disable","alwaysOpen"-remain open with first card,"authorize"-first card authentication. If
this node is configured,the node <enableLeaderCard> is invalid-->disable
</leaderCardMode>
<leaderCardOpenDuration>
<!--ro, opt, int, duration of remaining open with first card, range:[0,1440], unit:min, dep:and,{$.DoorParam.leaderCardMode,eq,alwaysOpen}-->1
</leaderCardOpenDuration>
<stressPassword>
<!--ro, opt, string, duress password, desc:the maximum length is 8 bytes, and the duress password should be encoded by Base64 for transmission-->test
</stressPassword>
<superPassword>
<!--ro, opt, string, super password, desc:wo,super password,the maximum length is 8 bytes,and the super password should be encoded by Base64 for
transmission-->test
</superPassword>
<unlockPassword>
<!--ro, opt, string, dismiss password, desc:the maximum length is 8 bytes, and the dismiss password should be encoded by Base64 for transmission-->test
</unlockPassword>
<useLocalController>
<!--ro, opt, bool, whether it is connected to the distributed controller-->true
</useLocalController>
<localControllerID>
<!--ro, opt, int, distributed controller No., which is between 1 and 64, range:[0,64], desc:0-unregistered-->1
</localControllerID>
<localControllerDoorNumber>
<!--ro, opt, int, distributed controller door No., range:[0,4], desc:0-unregistered-->1
</localControllerDoorNumber>
<localControllerStatus>
<!--ro, opt, enum, online status of the distributed controller, subType:int, desc:0-offline,1-network online,2-RS-485 serial port 1 on loop circuit 1,3RS-485
serial port 2 on loop circuit 1,4-RS-485 serial port 1 on loop circuit 2,5-RS-485 serial port 2 on loop circuit 2,6-RS-485 serial port 1 on loop
circuit 3,7-RS-485 serial port 2 on loop circuit 3,8-RS-485 serial port 1 on loop circuit 4,9-RS-485 serial port 2 on loop circuit 4-->1
</localControllerStatus>
<lockInputCheck>
<!--ro, opt, bool, whether to enable door lock input detection-->true
</lockInputCheck>
<lockInputType>
<!--ro, opt, enum, door lock input type, subType:string, desc:"alwaysClose"-remain locked (default), "alwaysOpen"-remain unlocked-->alwaysClose
</lockInputType>
<doorTerminalMode>
<!--ro, opt, enum, working mode of door terminal, subType:string, desc:"preventCutAndShort"-prevent from broken-circuit and short-circuit
(default),"common”-->preventCutAndShort
</doorTerminalMode>
<openButton>
<!--ro, opt, bool, whether to enable door button: "true"-yes (default), "false"-no-->true
</openButton>
<ladderControlDelayTime>
<!--ro, opt, int, elevator control delay time (for visitor), range:[1,255], unit:min-->1
</ladderControlDelayTime>
<Leader>
<!--ro, opt, object-->
<continuousVerificationTimes>
<!--ro, opt, int, range:[1,10]-->1
</continuousVerificationTimes>
<continuousVerificationDuration>
<!--ro, opt, int, range:[5,60], unit:s-->20
</continuousVerificationDuration>
<effectiveTimeEnabled>
<!--ro, req, bool-->true
</effectiveTimeEnabled>
<dayBeginTime>
<!--ro, opt, time, dep:and,{$.DoorParam.Leader.effectiveTimeEnabled,eq,true}-->00:00:00
</dayBeginTime>
<beginEffectiveTime>
<!--ro, opt, time, dep:and,{$.DoorParam.Leader.effectiveTimeEnabled,eq,true}-->00:00:00
</beginEffectiveTime>
<endEffectiveTime>
<!--ro, opt, time, dep:and,{$.DoorParam.Leader.effectiveTimeEnabled,eq,true}-->00:00:00
</endEffectiveTime>
</Leader>
<verificationPassOpenDoor>
<!--ro, opt, bool-->true
</verificationPassOpenDoor>
<relayReverseEnabled>
<!--ro, opt, bool-->true
</relayReverseEnabled>
</DoorParam>
21.20.5 Set the door (floor) parameters
Request URL
PUT /ISAPI/AccessControl/Door/param/<doorID>?security=<security>&iv=<iv>
Query Parameter


Parameter Name Parameter Type Description
doorID
string
security
iv
Request Message
<?xml version="1.0" encoding="UTF-8"?>
<DoorParam xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--req, object, door parameter, attr:version{req, string, protocolVersion}-->
<doorName>
<!--opt, string, door name-->test
</doorName>
<magneticType>
<!--opt, enum, door magnetic sensor type, subType:string, desc:"alwaysClose” (remain locked), "alwaysOpen” (remain unlocked)-->alwaysClose
</magneticType>
<openButtonType>
<!--opt, enum, open door button type, subType:string, desc:"alwaysClose” (remain locked), "alwaysOpen” (remain unlocked)-->alwaysClose
</openButtonType>
<openDuration>
<!--opt, int, door open duration, range:[1,255], unit:s-->1
</openDuration>
<disabledOpenDuration>
<!--opt, int, door open duration by disability card (delay duration of closing the door), range:[1,255], unit:s-->1
</disabledOpenDuration>
<magneticAlarmTimeout>
<!--opt, int, alarm time of magnetic contact detection timeout, range:[0,255], unit:s, desc:0 refers to not triggering alarm-->1
</magneticAlarmTimeout>
<enableDoorLock>
<!--opt, bool, lock door when door closed-->true
</enableDoorLock>
<enableLeaderCard>
<!--opt, bool, whether to enable remaining open with first card-->true
</enableLeaderCard>
<leaderCardMode>
<!--opt, enum, first card mode, subType:string, desc:first card mode: "disable","alwaysOpen"-remain open with first card,"authorize"-first card
authentication. If this node is configured,the node <enableLeaderCard> is invalid-->disable
</leaderCardMode>
<leaderCardOpenDuration>
<!--opt, int, duration of remaining open with first card, range:[0,1440], unit:min, dep:and,{$.DoorParam.leaderCardMode,eq,alwaysOpen}-->1
</leaderCardOpenDuration>
<stressPassword>
<!--opt, string, duress password, desc:the maximum length is 8 bytes, and the duress password should be encoded by Base64 for transmission-->test
</stressPassword>
<superPassword>
<!--opt, string, super password, desc:the maximum length is 8 bytes, and the duress password should be encoded by Base64 for transmission-->test
</superPassword>
<unlockPassword>
<!--opt, string, unlock password, desc:the maximum length is 8 bytes, and the duress password should be encoded by Base64 for transmission-->test
</unlockPassword>
<useLocalController>
<!--opt, bool, whether it is connected to the distributed controller-->true
</useLocalController>
<localControllerID>
<!--opt, int, distributed controller No., range:[0,64], desc:ro,distributed controller No.,which is between 1 and 64,0-unregistered-->1
</localControllerID>
<localControllerDoorNumber>
<!--opt, int, distributed controller door No., range:[0,4], desc:ro,distributed controller door No.,which is between 1 and 4,0-unregistered-->1
</localControllerDoorNumber>
<localControllerStatus>
<!--opt, enum, online status of the distributed controller, subType:int, desc:ro,online status of the distributed controller: 0-offline,1-network
online,2-RS-485 serial port 1 on loop circuit 1,3-RS-485 serial port 2 on loop circuit 1,4-RS-485 serial port 1 on loop circuit 2,5-RS-485 serial port 2 on
loop circuit 2,6-RS-485 serial port 1 on loop circuit 3,7-RS-485 serial port 2 on loop circuit 3,8-RS-485 serial port 1 on loop circuit 4,9-RS-485 serial
port 2 on loop circuit 4-->1
</localControllerStatus>
<lockInputCheck>
<!--opt, bool, whether to enable door lock input detection-->true
</lockInputCheck>
<lockInputType>
<!--opt, enum, door lock input type, subType:string, desc:"alwaysClose” (remain locked), "alwaysOpen” (remain unlocked), lt remains locked by default-
>alwaysClose
</lockInputType>
<doorTerminalMode>
<!--opt, enum, working mode of door terminal, subType:string, desc:"preventCutAndShort” (prevent from broken-circuit and short-circuit
(default)),"common"-->preventCutAndShort
</doorTerminalMode>
<openButton>
<!--opt, bool, whether to enable door button-->true
</openButton>
<ladderControlDelayTime>
<!--opt, int, elevator control delay time (for visitor), range:[1,255], unit:min-->1
</ladderControlDelayTime>
<Leader>
<!--opt, object-->
<continuousVerificationTimes>
string
string
-
-
-


<continuousVerificationTimes>
<!--opt, int, range:[1,10]-->1
</continuousVerificationTimes>
<continuousVerificationDuration>
<!--opt, int, range:[5,60], unit:s-->20
</continuousVerificationDuration>
<effectiveTimeEnabled>
<!--req, bool-->true
</effectiveTimeEnabled>
<dayBeginTime>
<!--opt, time, dep:and,{$.DoorParam.Leader.effectiveTimeEnabled,eq,true}-->00:00:00
</dayBeginTime>
<beginEffectiveTime>
<!--opt, time, dep:and,{$.DoorParam.Leader.effectiveTimeEnabled,eq,true}-->00:00:00
</beginEffectiveTime>
<endEffectiveTime>
<!--opt, time, dep:and,{$.DoorParam.Leader.effectiveTimeEnabled,eq,true}-->00:00:00
</endEffectiveTime>
</Leader>
<verificationPassOpenDoor>
<!--opt, bool-->true
</verificationPassOpenDoor>
<relayReverseEnabled>
<!--opt, bool-->true
</relayReverseEnabled>
</DoorParam>
Response Message
<?xml version="1.0" encoding="UTF-8"?>
<ResponseStatus xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--ro, req, object, response message, attr:version{ro, req, string, protocolVersion}-->
<requestURL>
<!--ro, req, string, request URL-->null
</requestURL>
<statusCode>
<!--ro, req, enum, status code, subType:int, desc:0 (OK), 1 (OK), 2 (Device Busy), 3 (Device Error), 4 (Invalid Operation), 5 (Invalid XML Format), 6
(Invalid XML Content), 7 (Reboot Required)-->0
</statusCode>
<statusString>
<!--ro, req, enum, status description, subType:string, desc:“OK” (succeeded), “Device Busy”, “Device Error”, “Invalid Operation”, “Invalid XML Format”,
“Invalid XML Content”, “Reboot” (reboot device)-->OK
</statusString>
<subStatusCode>
<!--ro, req, string, error code description, desc:error code description-->OK
</subStatusCode>
</ResponseStatus>
21.20.6 Get the capability of getting the status of the secure door control unit
Request URL
GET /ISAPI/AccessControl/DoorSecurityModule/moduleStatus/capabilities
Query Parameter
None
Request Message
None
Response Message
<?xml version="1.0" encoding="UTF-8"?>
<ModuleStatus xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--ro, opt, object, module status, attr:version{req, string, protocolVersion}-->
<securityModuleNo min="1" max="256">
<!--ro, req, string, secure door control unit No., attr:min{req, int},max{req, int}-->test
</securityModuleNo>
<onlineStatus opt="0,1">
<!--ro, req, enum, online status, subType:int, attr:opt{req, string}, desc:0 (offline), 1 (online)-->1
</onlineStatus>
<desmantelStatus opt="0,1">
<!--ro, req, enum, tampering status, subType:int, attr:opt{req, string}, desc:0 (the unit is not tampered), 1 (the unit is tampered)-->1
</desmantelStatus>
</ModuleStatus>
21.20.7 Get the status of the secure door control unit
Request URL


GET /ISAPI/AccessControl/DoorSecurityModule/moduleStatus
Query Parameter
None
Request Message
None
Response Message
<?xml version="1.0" encoding="UTF-8"?>
<ModuleStatus xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--ro, opt, object, module status, attr:version{req, string, protocolVersion}-->
<securityModuleNo min="1" max="256">
<!--ro, req, string, secure door control unit No., attr:min{req, int},max{req, int}-->test
</securityModuleNo>
<onlineStatus opt="0,1">
<!--ro, req, enum, online status, subType:int, attr:opt{req, string}, desc:0 (offline), 1(online)-->1
</onlineStatus>
<desmantelStatus opt="0,1">
<!--ro, req, enum, tamper-proof status, subType:int, attr:opt{req, string}, desc:0 (the unit is not tampered), 1(the unit is tampered)-->1
</desmantelStatus>
</ModuleStatus>
21.20.8 Get the capability of configuring the door lock status when the device is powered off
Request URL
GET /ISAPI/AccessControl/Configuration/lockType/capabilities?format=json
Query Parameter
None
Request Message
None
Response Message
{
"LockTypeCap": {
/*ro, req, object, the capability of configuring the door lock status when the device is powered off*/
"status": {
/*ro, opt, object, door lock status when the device is powered off*/
"@opt": ["alwaysOpen", "alwaysClose"]
/*ro, req, array, options, subType:string*/
}
}
}
21.21 Capture Parameters Management
21.21.1 Get capture triggering parameters
Request URL
GET /ISAPI/AccessControl/SnapConfig
Query Parameter
None
Request Message
None
Response Message


<?xml version="1.0" encoding="UTF-8"?>
<SnapConfig xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--ro, opt, object, attr:version{req, string, protocolVersion}-->
<snapTimes>
<!--ro, req, int, capture times triggered by loop, range:[0,5]-->1
</snapTimes>
<snapWaitTime>
<!--ro, req, int, capture waiting time, this node is reserved, range:[0,6000]-->1
</snapWaitTime>
<intervalTimeList size="4">
<!--ro, req, array, subType:object, attr:size{req, int}-->
<intervalTime>
<!--ro, req, int, range:[0,6000]-->1
</intervalTime>
</intervalTimeList>
<JPEGParam>
<!--ro, opt, object-->
<pictureSize>
<!--ro, req, string, picture resolution, desc:0-CIF, 1-QCIF, 2-D1, 3-UXGA (1600 × 1200), 4-SVGA(800 × 600), 5-HD720p(1280 × 720), 6-VGA, 7-XVGA, 8Hd900p,
9-HD1080, 10-2560 × 1920, 11-1600 × 304, 12-2048 × 1536, 13-2448 × 2048, 14-2448 × 1200, 15-2448 × 800, 16-XGA(1024 × 768), 17-SXGA(1280 × 1024),
18-WD1(960 × 576/960 × 480), 19-1080i, 20-576 × 576, 21-1536 × 1536, 22-1920 × 1920, 161-288 × 320, 162-144 × 176, 163-480 × 640, 164-240 × 320, 165-120 ×
160, 166-576 × 720, 167-720 × 1280, 168-576 × 960, 180-180*240, 181-360*480, 182-540*720, 183-720*960, 184-960*1280, 185-1080*1440, 0xff-auto-->0xff
</pictureSize>
<pictureQuality>
<!--ro, req, enum, picture quality, subType:string, desc:"best", "better", "general”-->best
</pictureQuality>
</JPEGParam>
</SnapConfig>
21.21.2 Set the capture triggering parameters
Request URL
PUT /ISAPI/AccessControl/SnapConfig
Query Parameter
None
Request Message
<?xml version="1.0" encoding="UTF-8"?>
<SnapConfig xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--req, object, attr:version{req, string, protocolVersion}-->
<snapTimes>
<!--req, int, range:[0,5]-->1
</snapTimes>
<snapWaitTime>
<!--req, int, range:[0,6000]-->1
</snapWaitTime>
<intervalTimeList size="4">
<!--req, array, subType:object, attr:size{req, int}-->
<intervalTime>
<!--req, int, range:[0,6000]-->1
</intervalTime>
</intervalTimeList>
<JPEGParam>
<!--opt, object-->
<pictureSize>
<!--req, string-->0xff
</pictureSize>
<pictureQuality>
<!--req, enum, subType:string-->best
</pictureQuality>
<picSize>
<!--opt, enum, subType:int-->0
</picSize>
</JPEGParam>
</SnapConfig>
Response Message


<?xml version="1.0" encoding="UTF-8"?>
<ResponseStatus xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--ro, req, object, attr:version{ro, req, string, protocolVersion}-->
<requestURL>
<!--ro, req, string-->null
</requestURL>
<statusCode>
<!--ro, req, enum, subType:int-->0
</statusCode>
<statusString>
<!--ro, req, enum, subType:string-->OK
</statusString>
<subStatusCode>
<!--ro, req, string-->OK
</subStatusCode>
</ResponseStatus>
21.21.3 Get capability of getting capture triggering parameters
Request URL
GET /ISAPI/AccessControl/SnapConfig/capabilities
Query Parameter
None
Request Message
None
Response Message
<?xml version="1.0" encoding="UTF-8"?>
<SnapConfig xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--ro, req, object, attr:version{req, string, protocolVersion}-->
<snapTimes min="0" max="5">
<!--ro, req, int, capture times triggered by loop, range:[0,5], attr:min{req, int},max{req, int}-->1
</snapTimes>
<snapWaitTime min="0" max="6000">
<!--ro, req, int, capture waiting time, this node is reserved, range:[0,6000], attr:min{req, int},max{req, int}, desc:capture waiting time, this node is
reserved-->1
</snapWaitTime>
<intervalTimeList size="4">
<!--ro, req, array, subType:object, attr:size{req, int}-->
<intervalTime min="0" max="6000">
<!--ro, req, int, range:[0,6000], attr:min{req, int},max{req, int}-->1
</intervalTime>
</intervalTimeList>
<JPEGParam>
<!--ro, opt, object-->
<pictureSize
opt="0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,75,78,79,80,82,127,128,161,162,163,164,165,166,167,168,180,181,182,183,
184,185,0xff">
<!--ro, req, string, picture resolution, attr:opt{req, string}, desc:0-CIF, 1-QCIF, 2-D1, 3-UXGA (1600 × 1200), 4-SVGA(800 × 600), 5-HD720p(1280 ×
720), 6-VGA, 7-XVGA, 8-Hd900p, 9-HD1080, 10 (2560 × 1920), 11 (1600 × 304), 12 (2048 × 1536), 13 (2448 × 2048), 14 (2448 × 1200), 15 (2448 × 800), 16-XGA
(1024 × 768), 17-SXGA(1280 × 1024), 18-WD1(960 × 576/960 × 480), 19 (1080i), 20 (576 × 576), 21 (1536 × 1536), 22 (1920 × 1920), 161 (288 × 320), 162 (144 ×
176), 163 (480 × 640), 164 (240 × 320), 165 (120 × 160), 166 (576 × 720), 167 (720 × 1280), 168 (576 × 960), 180 (180*240), 181 (360*480), 182 (540*720),183
(720*960), 184 (960*1280), 185 (1080*1440), 0xff (auto)-->0xff
</pictureSize>
<pictureQuality opt="best, better, general">
<!--ro, req, enum, picture quality, subType:string, attr:opt{req, string}, desc:"best", "better", "general”-->best
</pictureQuality>
</JPEGParam>
<isSupportSetSnapConfig>
<!--ro, opt, bool, whether it supports capture parameter configuration, desc:true (support), this node is not returned (not support)-->true
</isSupportSetSnapConfig>
</SnapConfig>
21.22 Person and Credential Management
21.22.1 Get the configuration capability of fingerprint parameters
Request URL
GET /ISAPI/AccessControl/FingerPrintCfg/capabilities?format=json
Query Parameter
None


Request Message
None
Response Message
{
"FingerPrintCfg": {
/*ro, opt, object*/
"employeeNo": {
/*ro, req, object, employee No. (person ID) linked with the fingerprint*/
"@min": 1,
/*ro, opt, int, the minimum value*/
"@max": 32
/*ro, opt, int, the maximum value*/
},
"enableCardReader": {
/*ro, req, object, fingerprint module to apply fingerprint data to*/
"@min": 1,
/*ro, opt, int, the minimum value*/
"@max": 512
/*ro, opt, int, the maximum value*/
},
"fingerPrintID": {
/*ro, req, object, fingerprint No.*/
"@min": 1,
/*ro, opt, int, the minimum value*/
"@max": 10
/*ro, opt, int, the maximum value*/
},
"fingerType": {
/*ro, req, object, fingerprint type*/
"@opt": "normalFP"
/*ro, opt, enum, fingerprint type, subType:string, desc:"normalFP" (normal fingerprint), "hijackFP" (duress fingerprint), "patrolFP" (patrol
fingerprint), "superFP" (super fingerprint), "dismissingFP" (dismiss fingerprint)*/
},
"leaderFP": {
/*ro, opt, object, whether to support first time authentication function*/
"@min": 1,
/*ro, opt, int, the minimum value*/
"@max": 32
/*ro, opt, int, the maximum value*/
},
"checkEmployeeNo": "true,false",
/*ro, opt, string, whether to judge the existence of the employee No. (person ID)*/
"StatusList": {
/*ro, opt, object, status list*/
"id": {
/*ro, opt, object, fingerprint module No.*/
"@min": 1,
/*ro, opt, int, the minimum value*/
"@max": 512
/*ro, opt, int, the maximum value*/
},
"cardReaderRecvStatus": {
/*ro, opt, object, fingerprint module status*/
"@opt": "0,1,2,3,4,5,6,7,8,10"
/*ro, opt, string, fingerprint module status*/
},
"errorMsg": {
/*ro, opt, object, error information*/
"@min": 1,
/*ro, opt, int, the minimum value*/
"@max": 32
/*ro, opt, int, the maximum value*/
}
},
"totalStatus": {
/*ro, req, object, applying status*/
"@opt": "0,1"
/*ro, opt, string, 0-applying, 1-applied*/
},
"isSupportFingerCover": true,
/*ro, opt, bool, whether to support overwriting the original fingerprint when applying new fingerprint linked with the same person ID or employee
No. If it is supported, this node will be set to "true"; otherwise, this node will not be returned*/
"isSupportSetUp": true,
/*ro, opt, bool, whether to support setting fingerprint parameters. If it is supported, this node will be set to "true"; otherwise, this node will
not be returned*/
"maxRecordNum": 1,
/*ro, opt, int, range:[0,10000]*/
"isSupportCount": true
/*ro, opt, bool*/
}
}
21.22.2 Set the fingerprint parameters


Request URL
POST /ISAPI/AccessControl/FingerPrint/SetUp?format=json&security=<security>&iv=<iv>
Query Parameter
Parameter Name Parameter Type Description
security
string
iv
Request Message
{
"FingerPrintCfg": {
/*opt, object, fingerprint parameters*/
"employeeNo": "test",
/*req, string, employee No. (person ID) linked with the fingerprint, range:[1,32]*/
"enableCardReader": [1, 3, 5],
/*req, array, fingerprint modules to apply fingerprint data to, subType:int, desc:[1,3,5] indicates applying fingerprint data to fingerprint modules
No.1, No.3, and No.5*/
"fingerPrintID": 1,
/*req, int, fingerprint No., range:[1,10]*/
"deleteFingerPrint": true,
/*opt, bool, whether to delete the fingerprint, desc:"true" (yes). This field is required only when the fingerprint needs to be deleted; for adding
or editing fingerprint information, it can be empty*/
"fingerType": "normalFP",
/*req, enum, fingerprint type, subType:string, desc:"normalFP" (normal fingerprint), "hijackFP" (duress fingerprint), "patrolFP" (patrol
fingerprint), "superFP" (super fingerprint),"dismissingFP" (dismiss fingerprint)*/
"fingerData": "test",
/*opt, string, fingerprint data, desc:it is encoded by Base64*/
"leaderFP": [1, 3, 5],
/*opt, array, whether the access control points support first fingerprint authentication function, subType:int, range:[1,5], desc:[1,3,5] indicates
that access control points No.1, No.3, and No.5 support first fingerprint authentication function*/
"checkEmployeeNo": true
/*opt, bool, whether to check the existence of the employee No. (person ID)*/
}
}
Response Message
{
"FingerPrintStatus": {
/*ro, opt, object, fingerprint status*/
"status": "success",
/*ro, opt, enum, status, subType:string, desc:"success", "failed". For applying fingerprint data to the fingerprint module, this field will not be
returned. This field will be returned only when editing fingerprint parameters or deleting fingerprints*/
"StatusList": [
/*ro, opt, array, status list, subType:object, desc:This field will be returned only when applying fingerprint data to the fingerprint module. For
editing fingerprint parameters or deleting fingerprints, this filed will not be returned*/
{
"id": 1,
/*ro, opt, int, fingerprint module No.*/
"cardReaderRecvStatus": 1,
/*ro, opt, enum, fingerprint module status, subType:int, desc:0 (connecting failed), 1 (connected), 2 (the fingerprint module is offline), 3
(the fingerprint quality is poor, try again), 4 (the memory is full), 5 (the fingerprint already exists), 6 (the fingerprint ID already exists), 7 (invalid
fingerprint ID), 8 (this fingerprint module is already configured), 10 (the fingerprint module version is too old to support the employee No.)*/
"errorMsg": "test"
/*ro, opt, string, error information, range:[1,32], desc:error information*/
}
]
}
}
21.22.3 Get the capability of clearing all pictures in the device
Request URL
GET /ISAPI/AccessControl/ClearPictureCfg/capabilities?format=json
Query Parameter
None
Request Message
None
Response Message
string
-
-


{
"ClearPictureCfgCap": {
/*ro, req, object, clear all pictures in the device*/
"ClearFlags": {
/*ro, opt, object, clear status*/
"facePicture": {
/*ro, opt, object, clear registered face pictures*/
"@opt": [true, false]
/*ro, req, array, options, subType:bool*/
},
"capOrVerifyPicture": {
/*ro, opt, object, clear authenticated or captured face pictures*/
"@opt": [true, false]
/*ro, req, array, options, subType:bool*/
},
"irisPicture": {
/*ro, opt, object, clear registered iris pictures*/
"@opt": [true, false]
/*ro, req, array, options, subType:bool*/
}
}
}
}
21.22.4 Get the capability of deleting person information (including linked cards,
fingerprints, and faces) and permissions
Request URL
GET /ISAPI/AccessControl/UserInfoDetail/Delete/capabilities?format=json
Query Parameter
None
Request Message
None
Response Message
{
"UserInfoDetail": {
/*ro, opt, object, user Information*/
"mode": {
/*ro, req, object*/
"@opt": "all,byEmployeeNo"
/*ro, opt, string, deleting mode, desc:all (delete all), byEmployeeNo (delete by employee No. (person ID))*/
},
"EmployeeNoList": {
/*ro, opt, object, person ID list, desc:person ID list*/
"maxSize": 50,
/*ro, opt, int*/
"employeeNo": {
/*ro, opt, object, employee No. (person ID)*/
"@min": 1,
/*ro, opt, int, the maximum value*/
"@max": 32
/*ro, opt, int, the minimum value*/
}
}
}
}
21.22.5 Add cards and link them with a person
Request URL
POST /ISAPI/AccessControl/CardInfo/Record?format=json&security=<security>&iv=<iv>
Query Parameter
Parameter Name Parameter Type Description
security
string
iv
Request Message
string
-
-


{
"CardInfo": {
/*req, object, card information*/
"employeeNo": "test",
/*req, string, employee No. (person ID)*/
"cardNo": "1234567890",
/*req, string, card No.*/
"cardType": "normalCard",
/*opt, enum, card type, subType:string, desc:card type*/
"leaderCard": "1,3,5",
/*opt, string, whether the access control points support first fingerprint authentication function, desc:whether the access control points support
first fingerprint authentication function*/
"checkCardNo": true,
/*opt, bool, whether to enable duplicated card verification, desc:whether to enable duplicated card verification*/
"checkEmployeeNo": true,
/*opt, bool, whether to check the existence of the employee No. (person ID), desc:whether to check the existence of the employee No. (person ID)*/
"operateType": "byTerminal",
/*opt, string, operation mode*/
"terminalNoList": [1]
/*opt, array, terminal ID list, subType:int, desc:terminal ID list*/
}
}
Response Message
{
"statusCode": 1,
/*ro, opt, int, status code, desc:1 (succeeded). It is required when an error occurred*/
"statusString": "ok",
/*ro, opt, string, status description, range:[1,64], desc:"ok" (succeeded). It is required when an error occurred*/
"subStatusCode": "ok",
/*ro, opt, string, sub status code, range:[1,64], desc:"ok" (succeeded). It is required when an error occurred*/
"errorCode": 1,
/*ro, opt, int, error code, desc:when the value of statusCode is not 1, it corresponds to subStatusCode*/
"errorMsg": "ok"
/*ro, opt, string, error information, desc:this field is required when the value of statusCode is not 1*/
}
21.22.6 Delete person information
Request URL
PUT /ISAPI/AccessControl/UserInfo/Delete?format=json&security=<security>&iv=<iv>
Query Parameter
Parameter Name Parameter Type Description
security
string
iv
Request Message
{
"UserInfoDelCond": {
/*req, object, deleting conditions*/
"EmployeeNoList": [
/*opt, array, person ID list, subType:object*/
{
"employeeNo": "test"
/*req, string, employee No. (person ID), range:[1,32]*/
}
],
"operateType": "byTerminal",
/*opt, string, operation type*/
"terminalNoList": [1]
/*opt, array, terminal ID list, subType:int, desc:terminal ID list*/
}
}
Response Message
string
-
-


{
"statusCode": 1,
/*ro, opt, int, status code, desc:1 (succeeded). It is required when an error occurred*/
"statusString": "ok",
/*ro, opt, string, status description, range:[1,64], desc:"ok" (succeeded). It is required when an error occurred*/
"subStatusCode": "ok",
/*ro, opt, string, sub status code, range:[1,64], desc:"ok" (succeeded). It is required when an error occurred*/
"errorCode": 1,
/*ro, opt, int, error code, desc:when the value of statusCode is not 1, it corresponds to subStatusCode*/
"errorMsg": "ok"
/*ro, opt, string, error information, desc:this field is required when statusCode is not 1*/
}
21.22.7 Get the capabilities of applying person data asynchronously
Request URL
GET /ISAPI/AccessControl/UserInfo/asyncImportDatasTasks/capabilities?format=json
Query Parameter
None
Request Message
None
Response Message
{
"AsyncImportDatasCap": {
/*ro, req, object*/
"taskID": {
/*ro, req, object*/
"@min": 1,
/*ro, opt, int*/
"@max": 64
/*ro, opt, int*/
},
"taskNum": 1,
/*ro, req, int*/
"URL": {
/*ro, req, object*/
"@min": 1,
/*ro, opt, int*/
"@max": 256
/*ro, opt, int*/
},
"singleFileMaxSize": 1,
/*ro, req, int*/
"employeeNo": {
/*ro, opt, object*/
"@min": 1,
/*ro, opt, int*/
"@max": 32
/*ro, opt, int*/
},
"deleteUser": {
/*ro, opt, object*/
"@opt": [true, false]
/*ro, opt, array, subType:bool*/
},
"name": {
/*ro, opt, object*/
"@min": 1,
/*ro, opt, int*/
"@max": 32
/*ro, opt, int*/
},
"userType": {
/*ro, opt, object*/
"@opt": ["normal", "visitor", "blackList"]
/*ro, opt, array, subType:string*/
},
"Valid": {
/*ro, opt, object*/
"enable": {
/*ro, opt, object*/
"@opt": [true, false]
/*ro, opt, array, subType:bool*/
},
"beginTime": "1970-01-01T00:00:00+08:00",
/*ro, opt, string*/
"endTime": "2037-12-31T23:59:59+08:00"
/*ro, opt, string*/
},
"password": {


/*ro, opt, object*/
"@min": 8,
/*ro, opt, int*/
"@max": 16
/*ro, opt, int*/
},
"RightPlan": {
/*ro, opt, object*/
"doorNo": {
/*ro, opt, object*/
"@min": 1,
/*ro, opt, int*/
"@max": 1
/*ro, opt, int*/
},
"planTemplateNo": {
/*ro, opt, object*/
"@min": 1,
/*ro, opt, int*/
"@max": 1
/*ro, opt, int*/
},
"planTemplateNum": {
/*ro, opt, object*/
"@min": 0,
/*ro, opt, int*/
"@max": 1
/*ro, opt, int*/
}
},
"localUIRight": {
/*ro, opt, object*/
"@opt": [true, false]
/*ro, opt, array, subType:bool*/
},
"userVerifyMode": {
/*ro, opt, object*/
"@opt": ["cardAndPw", "card", "cardOrPw", "fp", "fpAndPw", "fpOrCard", "fpAndCard", "fpAndCardAndPw", "faceOrFpOrCardOrPw", "faceAndFp",
"faceAndPw", "faceAndCard", "face", "employeeNoAndPw", "fpOrPw", "employeeNoAndFp", "employeeNoAndFpAndPw", "faceAndFpAndCard", "faceAndPwAndFp",
"employeeNoAndFace", "faceOrfaceAndCard", "fpOrface", "cardOrfaceOrPw", "cardOrFace", "cardOrFaceOrFp"]
/*ro, opt, array, subType:string*/
},
"AccessControl": {
/*ro, opt, object*/
"doorRightNum": {
/*ro, opt, object*/
"@min": 0,
/*ro, opt, int*/
"@max": 1
/*ro, opt, int*/
},
"closeDelayEnabled": {
/*ro, opt, object*/
"@opt": [true, false]
/*ro, opt, array, subType:bool*/
},
"belongGroupNo": {
/*ro, opt, object*/
"@min": 1,
/*ro, opt, int*/
"@max": 1
/*ro, opt, int*/
},
"belongGroupNum": {
/*ro, opt, object*/
"@min": 0,
/*ro, opt, int*/
"@max": 1
/*ro, opt, int*/
},
"maxOpenDoorTime": {
/*ro, opt, object*/
"@min": 0,
/*ro, opt, int*/
"@max": 1
/*ro, opt, int*/
},
"openDoorTime": {
/*ro, opt, object*/
"@min": 1,
/*ro, opt, int*/
"@max": 1
/*ro, opt, int*/
},
"roomNumber": {
/*ro, opt, object*/
"@min": 1,
/*ro, opt, int*/
"@max": 1
/*ro, opt, int*/
},
"floorNumber": {
/*ro, opt, object*/
"@min": 1,


"@min": 1,
/*ro, opt, int*/
"@max": 1
/*ro, opt, int*/
}
},
"FaceInfo": {
/*ro, opt, object*/
"deleteAllFace": {
/*ro, opt, object*/
"@opt": [true, false]
/*ro, opt, array, subType:bool*/
},
"List": {
/*ro, opt, object*/
"FDID": "test",
/*ro, opt, string*/
"faceID": {
/*ro, opt, object*/
"@min": 1,
/*ro, opt, int*/
"@max": 1
/*ro, opt, int*/
},
"deleteFace": {
/*ro, opt, object*/
"@opt": [true, false]
/*ro, opt, array, subType:bool*/
},
"isSupportModelData": true
/*ro, opt, bool*/
}
},
"CardInfo": {
/*ro, opt, object*/
"deleteAllCard": {
/*ro, opt, object*/
"@opt": [true, false]
/*ro, opt, array, subType:bool*/
},
"List": {
/*ro, opt, object*/
"cardNo": {
/*ro, opt, object*/
"@min": 1,
/*ro, opt, int*/
"@max": 32
/*ro, opt, int*/
},
"deleteCard": {
/*ro, opt, object*/
"@opt": [true, false]
/*ro, opt, array, subType:bool*/
},
"cardType": {
/*ro, opt, object*/
"@opt": ["normalCard", "patrolCard", "hijackCard", "superCard", "dismissingCard", "emergencyCard"]
/*ro, opt, array, subType:string*/
},
"AccessControl": {
/*ro, opt, object*/
"leaderCardNum": {
/*ro, opt, object*/
"@min": 0,
/*ro, opt, int*/
"@max": 1
/*ro, opt, int*/
}
},
"numberPerPerson": 50
/*ro, opt, enum, subType:int*/
}
},
"FPInfo": {
/*ro, opt, object*/
"deleteAllFP": {
/*ro, opt, object*/
"@opt": [true, false]
/*ro, opt, array, subType:bool*/
},
"List": {
/*ro, opt, object*/
"fingerID": {
/*ro, opt, object*/
"@min": 1,
/*ro, opt, int*/
"@max": 10
/*ro, opt, int*/
},
"deleteFP": {
/*ro, opt, object*/
"@opt": [true, false]
/*ro, opt, array, subType:bool*/
},


},
"enableCardReaderNo": {
/*ro, opt, object*/
"@min": 1,
/*ro, opt, int*/
"@max": 1
/*ro, opt, int*/
},
"enableCardReaderNum": {
/*ro, opt, object*/
"@min": 0,
/*ro, opt, int*/
"@max": 1
/*ro, opt, int*/
},
"fingerType": {
/*ro, opt, object*/
"@opt": ["normalFP", "hijackFP", "patrolFP", "superFP", "dismissingFP"]
/*ro, opt, array, subType:string*/
},
"fingerData": {
/*ro, opt, object*/
"@opt": [768]
/*ro, opt, array, subType:int*/
},
"AccessControl": {
/*ro, opt, object*/
"leaderFPNum": {
/*ro, opt, object*/
"@min": 0,
/*ro, opt, int*/
"@max": 1
/*ro, opt, int*/
}
}
}
}
}
}
21.22.8 Get the card management capability
Request URL
GET /ISAPI/AccessControl/CardInfo/capabilities?format=json
Query Parameter
None
Request Message
None
Response Message
{
"CardInfo": {
/*ro, opt, object, card information*/
"supportFunction": {
/*ro, req, object, supported functions, desc:"post"-add, "delete", "put"-edit, "get"-search, "setUp"-set*/
"@opt": "post, delete, put, get, setUp"
/*ro, req, string*/
},
"CardInfoSearchCond": {
/*ro, opt, object, search condition*/
"searchID": {
/*ro, opt, object, search ID*/
"@min": 1,
/*ro, req, int, the minimum value*/
"@max": 36
/*ro, req, int, the maximum value*/
},
"maxResults": {
/*ro, req, object, the maximum number of search results this time by calling this URI*/
"@min": 1,
/*ro, req, int, the minimum value*/
"@max": 30
/*ro, req, int, the maximum value*/
},
"EmployeeNoList": {
/*ro, opt, object, person ID list*/
"maxSize": 56,
/*ro, req, int, the maximum value*/
"employeeNo": {
/*ro, opt, object, employee No. (person ID)*/
"@min": 1,
/*ro, req, int, the minimum value*/
"@max": 32
/*ro, req, int, the maximum value*/


/*ro, req, int, the maximum value*/
}
},
"CardNoList": {
/*ro, opt, object, card No. list*/
"maxSize": 56,
/*ro, req, int, the maximum value*/
"cardNo": {
/*ro, opt, object, card No.*/
"@min": 1,
/*ro, req, int, the minimum value*/
"@max": 32
/*ro, req, int, the maximum value*/
}
}
},
"CardInfoDelCond": {
/*ro, opt, object, deleting condition*/
"EmployeeNoList": {
/*ro, opt, object, person ID list*/
"maxSize": 56,
/*ro, req, int, the maximum value*/
"employeeNo": {
/*ro, opt, object, employee No. (person ID)*/
"@min": 1,
/*ro, req, int, the minimum value*/
"@max": 32
/*ro, req, int, the maximum value*/
}
},
"CardNoList": {
/*ro, opt, object, card No. list*/
"maxSize": 56,
/*ro, req, int, the maximum value*/
"cardNo": {
/*ro, opt, object, card No.*/
"@min": 1,
/*ro, req, int, the minimum value*/
"@max": 32
/*ro, req, int, the maximum value*/
}
}
},
"cardNo": {
/*ro, req, object, card No.*/
"@min": 1,
/*ro, req, int, the minimum value*/
"@max": 32
/*ro, req, int, the maximum value*/
},
"employeeNo": {
/*ro, req, object, employee No. (person ID)*/
"@min": 1,
/*ro, req, int, the minimum value*/
"@max": 32
/*ro, req, int, the maximum value*/
},
"cardType": {
/*ro, req, object, card type*/
"@opt": "normalCard, patrolCard, hijackCard, superCard, dismissingCard, emergencyCard"
/*ro, req, string*/
},
"leaderCard": {
/*ro, opt, object, whether it supports first card authentication function*/
"@min": 1,
/*ro, req, int, the minimum value*/
"@max": 32
/*ro, req, int, the maximum value*/
},
"checkCardNo": "true,false",
/*ro, opt, string, whether to enable duplicated card verification, desc:"false"-disable, "true"-enable. If this node is not configured, the device
will verify the duplicated card by default this node is used for speeding up applying card information (by setting the value to "false"). It is not
recommended to configure this node*/
"checkEmployeeNo": "true,false",
/*ro, opt, string, whether to check the existence of the employee No. (person ID), desc:"false"-no, "true"-yes. If this node is not configured, the
device will check the existence of the employee No. (person ID) by default. This node is used for speeding up applying card information (by setting the
value to "false"). It is not recommended to configure this node*/
"maxRecordNum": 10000,
/*ro, opt, int, maximum number of records (cards) allowed, desc:supported maximum number of records (card records)*/
"numberPerPerson": 50
/*ro, opt, enum, subType:int*/
}
}
21.22.9 whether to delete card information
Request URL
PUT /ISAPI/AccessControl/CardInfo/Delete?format=json&security=<security>&iv=<iv>


Query Parameter
Parameter Name Parameter Type Description
security
string
iv
Request Message
{
"CardInfoDelCond": {
/*req, object*/
"EmployeeNoList": [
/*opt, array, person ID list, subType:object*/
{
"employeeNo": "test"
/*opt, string, employee No. (person ID)*/
}
],
"CardNoList": [
/*opt, array, card No. list, subType:object, desc:(this node cannot exist together with the EmployeeNoList, and if this node does not exist or is
set to NULL, it indicates deleting all cards)*/
{
"cardNo": "1234567890"
/*opt, string, card No.*/
}
],
"operateType": "byTerminal",
/*opt, enum, operation type, subType:string, desc:"byTerminal"-by terminal*/
"terminalNoList": [1]
/*opt, array, terminal ID list, this node is required when operation type is "byTerminal"; currently, only one terminal is supported, subType:int*/
}
}
Response Message
{
"statusCode": 1,
/*ro, opt, int, status code, desc:1 (succeeded). It is required when an error occurred*/
"statusString": "ok",
/*ro, opt, string, status description, range:[1,64], desc:"ok" (succeeded). It is required when an error occurred*/
"subStatusCode": "ok",
/*ro, opt, string, sub status code, range:[1,64], desc:"ok" (succeeded). It is required when an error occurred*/
"errorCode": 1,
/*ro, opt, int, error code, desc:when the value of statusCode is not 1, it corresponds to subStatusCode*/
"errorMsg": "ok"
/*ro, opt, string, error information, desc:this field is required when the value of statusCode is not 1*/
}
21.22.10 Get the total number of the added persons
Request URL
GET /ISAPI/AccessControl/UserInfo/Count?format=json
Query Parameter
None
Request Message
None
Response Message
string
-
-


{
"UserInfoCount": {
/*ro, req, object*/
"userNumber": 100,
/*ro, req, int, number of persons*/
"bindFaceUserNumber": 100,
/*ro, opt, int*/
"bindFingerprintUserNumber": 100,
/*ro, opt, int*/
"bindCardUserNumber": 100,
/*ro, opt, int*/
"bindIrisUserNumber": 100
/*ro, opt, int*/
}
}
21.22.11 Edit person information
Request URL
PUT /ISAPI/AccessControl/UserInfo/Modify?format=json&security=<security>&iv=<iv>
Query Parameter
Parameter Name Parameter Type Description
security
string
iv
Request Message
{
"UserInfo": {
/*req, object, person information*/
"employeeNo": "test",
/*req, string, employee No. (person ID)*/
"name": "test",
/*opt, string, name*/
"userType": "normal",
/*opt, enum, person type, subType:string*/
"closeDelayEnabled": true,
/*opt, bool, whether to enable door close delay*/
"Valid": {
/*opt, object, parameters of the effective period,the effective period can be a period of time between 1970-01-01 00:00:00 and 2037-12-31 23:59:59*/
"enable": true,
/*opt, bool, whether to enable validity period*/
"beginTime": "2017-08-01T17:30:08+08:00",
/*opt, datetime, start time of the effective period, desc:if timeType does not exist or is "local", the beginTime is the device local time,
e.g., 2017-08-01T17:30:08; if timeType is "UTC", the beginTime is UTC time, e.g., 2017-08-01T17:30:08+08:00*/
"endTime": "2017-08-01T17:30:08+08:00",
/*opt, datetime, end time of the effective period, desc:if timeType does not exist or is "local", the endTime is the device local time, e.g.,
2017-08-01T17:30:08; if timeType is "UTC", the endTime is UTC time, e.g., 2017-08-01T17:30:08+08:00*/
"timeType": "local"
/*opt, enum, time type, subType:string, desc:"local" (device local time), "UTC" (UTC time)*/
},
"belongGroup": "1,3,5",
/*opt, string, group*/
"password": "123456",
/*opt, string, password*/
"doorRight": "1,3",
/*opt, string, door permission*/
"RightPlan": [
/*opt, array, door permission schedule (lock permission schedule), subType:object*/
{
"doorNo": 1,
/*opt, int, door No. (lock ID)*/
"planTemplateNo": "1,3,5"
/*opt, string, schedule template No., desc:schedule template No.*/
}
],
"maxOpenDoorTime": 0,
/*opt, int, maximum authentication attempts, desc:0-unlimited*/
"roomNumber": 123,
/*opt, int, room No.*/
"floorNumber": 1,
/*opt, int, floor No.*/
"doubleLockRight": true,
/*opt, bool, whether to have the permission to open the double-locked door*/
"localUIRight": true,
/*opt, bool, whether to have the permission to access the device local UI*/
"userVerifyMode": "card",
/*opt, enum, person authentication mode, subType:string,
desc:the person authentication mode is prior to the card reader authentication modeperson authentication mode
"cardAndPw” (card + password), "card” (card), "cardOrPw” (card or password), "fp” (fingerprint), "fpAndPw” (fingerprint + password), "fpOrCard”
string
-
-


"cardAndPw” (card + password), "card” (card), "cardOrPw” (card or password), "fp” (fingerprint), "fpAndPw” (fingerprint + password), "fpOrCard”
(fingerprint or card), "fpAndCard” (fingerprint + card), "fpAndCardAndPw” (fingerprint + card + password), "faceOrFpOrCardOrPw” (face or fingerprint or card
or password), "faceAndFp” (face + fingerprint), "faceAndPw” (face + password), "faceAndCard” (face + card), "face” (face), "employeeNoAndPw” (employee No. +
password), "fpOrPw” (fingerprint or password), "employeeNoAndFp” (employee No. + fingerprint), "employeeNoAndFpAndPw” (employee No. + fingerprint +
password), "faceAndFpAndCard” (face + fingerprint + card), "faceAndPwAndFp” (face + password + fingerprint), "employeeNoAndFace” (employee No. + face),
"faceOrfaceAndCard” (face or face + card), "fpOrface” (fingerprint or face), "cardOrfaceOrPw” (card or face or password), "cardOrFace” (card or face),
"cardOrFaceOrFp” (card or face or fingerprint), "cardOrFpOrPw” (card or fingerprint or password)*/
"checkUser": true,
/*opt, bool, whether to verify the duplicated person information, desc:"false"-no, "true"-yes. If checkUser is not configured, the device will
verify the duplicated person information by default. When there is no person information, you can set checkUser to "false" to speed up data applying;
otherwise, it is not recommended to configure this node*/
"gender": "male",
/*opt, enum, gender of the person in the face picture, subType:string, desc:"male", "female", "unknown"*/
"PersonInfoExtends": [
/*opt, array, extended fields for the additional person information, subType:object, desc:this node is used to configure the extended person
information displayed on the device's UI. For MinMoe series facial recognition terminals, currently only one value node can be supported for displaying the
employee No. and the node id is not supported*/
{
"id": 1,
/*opt, int, extended ID of the additional person information, range:[1,32], desc:it corresponds to the id in the message of the request URI
/ISAPI/AccessControl/personInfoExtendName?format=json and is used to link the value of the node value and its name (the node name in the message of the
request URI /ISAPI/AccessControl/personInfoExtendName?format=json). If the node id does not exist, the ID will start from 1 by default according to the
array order*/
"value": "test"
/*opt, string, extended content of the additional person information*/
}
],
"dynamicCode": "123456",
/*opt, string, dynamic permission code*/
"callNumbers": ["1-1-1-401"],
/*opt, array, room No. list to be called, subType:string, desc:it is extended from roomNumber; for standard SIP; it can be the SIP number*/
"floorNumbers": [1, 2],
/*opt, array, floor No. list, subType:int, desc:it is extended from floorNumber*/
"groupId": 1,
/*opt, int*/
"localAtndPlanTemplateId": 1,
/*opt, int*/
"operateType": "byTerminal",
/*opt, string, operation type, desc:"byTerminal"-by terminal*/
"terminalNoList": [1],
/*opt, array, terminal ID list, subType:int, desc:this node is required when operation type is "byTerminal"; currently, only one terminal is
supported*/
"groupName": "test",
/*opt, string, range:[1,64]*/
"age": 0,
/*opt, int, age, range:[0,120]*/
"PatientInfos": {
/*opt, object*/
"deviceID": "test",
/*opt, string*/
"admissionTime": "1970-01-01T00:00:00+08:00",
/*opt, datetime*/
"chargeNurse": "test",
/*opt, string, range:[0,32]*/
"chargeDoctor": "test",
/*opt, string, range:[0,32]*/
"nursingLevel": "tertiary",
/*opt, enum, subType:string*/
"doctorsAdvice": "test",
/*opt, string, range:[0,128]*/
"allergicHistory": "test"
/*opt, string, range:[0,128]*/
},
"ESDType": "handAndFoot",
/*opt, enum, subType:string*/
"userLevel": "Employee",
/*opt, enum, subType:string*/
"userName": "test",
/*opt, string, range:[1,32]*/
"loginPassword": "test"
/*opt, string, range:[8,16]*/
}
}
Response Message
{
"statusCode": 1,
/*ro, opt, int, status code, desc:1 (succeeded). It is required when an error occurred*/
"statusString": "ok",
/*ro, opt, string, status description, range:[1,64], desc:"ok" (succeeded). It is required when an error occurred*/
"subStatusCode": "ok",
/*ro, opt, string, sub status code, range:[1,64], desc:"ok" (succeeded). It is required when an error occurred*/
"errorCode": 1,
/*ro, opt, int, error code, desc:it is required when the value of statusCode is not 1, and it corresponds to subStatusCode*/
"errorMsg": "ok"
/*ro, opt, string, error information, desc:this field is required when the value of statusCode is not 1*/
}


21.22.12 Get the status of a specified task of applying person pictures asynchronously
Request URL
GET /ISAPI/AccessControl/UserPic/asyncImportDatasTasks/<taskID>/status?format=json
Query Parameter
Parameter Name Parameter Type Description
taskID
string
Request Message
None
Response Message
{
"AsyncImportDatasTask": {
/*ro, req, object*/
"taskID": "test",
/*ro, req, string, range:[1,64]*/
"URL": "test",
/*ro, opt, string, range:[1,256]*/
"status": 1,
/*ro, req, enum, subType:int*/
"totalNum": 1,
/*ro, opt, int*/
"successNum": 1,
/*ro, opt, int*/
"failedNum": 1
/*ro, opt, int*/
}
}
21.22.13 Start deleting all person information (including linked cards, fingerprints, and
faces) and permissions by employee No.
Request URL
PUT /ISAPI/AccessControl/UserInfoDetail/Delete?format=json
Query Parameter
None
Request Message
{
"UserInfoDetail": {
/*opt, object, user Information*/
"mode": "all",
/*req, enum, deleting mode, subType:string, desc:deleting mode*/
"EmployeeNoList": [
/*opt, array, person ID list, subType:object*/
{
"employeeNo": "test"
/*opt, string, employee No.*/
}
],
"operateType": "byTerminal",
/*opt, enum, operation mode, subType:string, desc:"byTerminal" (by terminal), "byOrg" (by organization), "byTerminalOrg" (by terminal
organization)*/
"terminalNoList": [1, 2, 3, 4],
/*opt, array, terminal list, subType:int, dep:and,{$.UserInfoDetail.operateType,eq,byTerminal}*/
"orgNoList": [1, 2, 3, 4]
/*opt, array, organization list, subType:int, dep:or,{$.UserInfoDetail.operateType,eq,byOrg},{$.UserInfoDetail.operateType,eq,byTerminalOrg}*/
}
}
Response Message
-


{
"statusCode": 1,
/*ro, opt, int, status code, desc:1 (succeeded). It is required when an error occurred*/
"statusString": "ok",
/*ro, opt, string, status description, range:[1,64], desc:"ok" (succeeded). It is required when an error occurred*/
"subStatusCode": "ok",
/*ro, opt, string, sub status code, range:[1,64], desc:"ok" (succeeded). It is required when an error occurred*/
"errorCode": 1,
/*ro, opt, int, error code, desc:when the value of statusCode is not 1, it corresponds to subStatusCode*/
"errorMsg": "ok"
/*ro, opt, string, error information, desc:this field is required when the value of statusCode is not 1*/
}
21.22.14 Add a person
Request URL
POST /ISAPI/AccessControl/UserInfo/Record?format=json&security=<security>&iv=<iv>
Query Parameter
Parameter Name Parameter Type Description
security
string
iv
Request Message
{
"UserInfo": {
/*req, object, person information*/
"employeeNo": "test",
/*req, string, employee No. (person ID)*/
"name": "test",
/*opt, string, person name*/
"userType": "normal",
/*req, enum, person type, subType:string, desc:"normal" (normal person (household)), "visitor", "blackList" (person in blocklist), "maintenance"
(maintenance persons including cleaners, repairmen, etc. )*/
"closeDelayEnabled": true,
/*opt, bool, whether to enable door close delay*/
"Valid": {
/*req, object, parameters of the effective period,the effective period can be a period of time between 1970-01-01 00:00:00 and 2037-12-31 23:59:59*/
"enable": true,
/*req, bool, whether to enable validity period*/
"beginTime": "2017-08-01T17:30:08+08:00",
/*req, datetime, start time of the effective period, desc:if timeType does not exist or is "local", the beginTime is the device local time,
e.g., 2017-08-01T17:30:08; if timeType is "UTC", the beginTime is UTC time, e.g., 2017-08-01T17:30:08+08:00*/
"endTime": "2017-08-01T17:30:08+08:00",
/*req, datetime, end time of the effective period, desc:if timeType does not exist or is "local", the endTime is the device local time, e.g.,
2017-08-01T17:30:08; if timeType is "UTC", the endTime is UTC time, e.g., 2017-08-01T17:30:08+08:00*/
"timeType": "local"
/*opt, enum, time type, subType:string, desc:"local" (device local time), "UTC" (UTC time)*/
},
"belongGroup": "1,3,5",
/*opt, string, group*/
"password": "123456",
/*opt, string, password*/
"doorRight": "1,3",
/*opt, string, door permission*/
"RightPlan": [
/*opt, array, door permission schedule (lock permission schedule), subType:object*/
{
"doorNo": 1,
/*opt, int, door No. (lock ID)*/
"planTemplateNo": "1,3,5"
/*opt, string, schedule template No., desc:schedule template No.*/
}
],
"maxOpenDoorTime": 0,
/*opt, int, maximum authentication attempts, desc:0-unlimited*/
"roomNumber": 123,
/*opt, int, room No.*/
"floorNumber": 1,
/*opt, int, floor No.*/
"doubleLockRight": true,
/*opt, bool, whether to have the permission to open the double-locked door*/
"localUIRight": true,
/*opt, bool, whether to have the permission to access the device local UI*/
"userVerifyMode": "card",
/*opt, enum, person authentication mode, subType:string, desc:"cardAndPw" (card+password), "card" (card), "cardOrPw" (card or password), "fp"
(fingerprint), "fpAndPw" (fingerprint+password), "fpOrCard" (fingerprint or card), "fpAndCard" (fingerprint+card), "fpAndCardAndPw"
(fingerprint+card+password), "faceOrFpOrCardOrPw" (face or fingerprint or card or password), "faceAndFp" (face+fingerprint), "faceAndPw" (face+password),
"faceAndCard" (face+card), "face" (face), "employeeNoAndPw" (employee No.+password), "fpOrPw" (fingerprint or password), "employeeNoAndFp" (employee
No.+fingerprint), "employeeNoAndFpAndPw" (employee No.+fingerprint+password), "faceAndFpAndCard" (face+fingerprint+card), "faceAndPwAndFp"
string
-
-


No.+fingerprint), "employeeNoAndFpAndPw" (employee No.+fingerprint+password), "faceAndFpAndCard" (face+fingerprint+card), "faceAndPwAndFp"
(face+password+fingerprint), "employeeNoAndFace" (employee No.+face), "faceOrfaceAndCard" (face or face+card), "fpOrface" (fingerprint or face),
"cardOrfaceOrPw" (card or face or password), "iris" (iris), "faceOrFpOrCardOrPwOrIris" (face, fingerprint, card, password, or iris), "faceOrCardOrPwOrIris"
(face, card, password, or iris). The person authentication mode is prior to the card reader authentication mode*/
"checkUser": true,
/*opt, bool, whether to verify the duplicated person information, desc:"false"-no, "true"-yes. If checkUser is not configured, the device will
verify the duplicated person information by default. When there is no person information, you can set checkUser to "false" to speed up data applying;
otherwise, it is not recommended to configure this node*/
"gender": "male",
/*opt, enum, gender of the person in the face picture, subType:string, desc:"male", "female", "unknown"*/
"PersonInfoExtends": [
/*opt, array, extended fields for the additional person information, subType:object, desc:This node is used to configure the extended person
information displayed on the device's UI. For MinMoe series facial recognition terminals, currently only one value node can be supported for displaying the
employee No. and the node id is not supported*/
{
"id": 1,
/*opt, int, extended ID of the additional person information, range:[1,32], desc:it corresponds to the id in the message of the request URI
/ISAPI/AccessControl/personInfoExtendName?format=json and is used to link the value of the node value and its name (the node name in the message of the
request URI /ISAPI/AccessControl/personInfoExtendName?format=json). If the node id does not exist, the ID will start from 1 by default according to the
array order*/
"value": "test"
/*opt, string, extended content of the additional person information*/
}
],
"operateType": "byTerminal",
/*opt, string, operation type, desc:"byTerminal"-by terminal*/
"terminalNoList": [1],
/*opt, array, terminal ID list, subType:int, desc:this node is required when operation type is "byTerminal"; currently, only one terminal is
supported*/
"dynamicCode": "123456",
/*opt, string, dynamic permission code*/
"callNumbers": ["1-1-1-401"],
/*opt, array, room No. list to be called, subType:string, desc:it is extended from roomNumber; for standard SIP, it can be the SIP number*/
"floorNumbers": [1, 2],
/*opt, array, floor No. list, subType:int, desc:it is extended from floorNumber*/
"groupId": 1,
/*opt, int*/
"localAtndPlanTemplateId": 1,
/*opt, int*/
"groupName": "test",
/*opt, string, range:[1,64]*/
"age": 0,
/*opt, int, age, range:[0,120]*/
"PatientInfos": {
/*opt, object*/
"deviceID": "test",
/*opt, string*/
"admissionTime": "1970-01-01T00:00:00+08:00",
/*opt, datetime*/
"chargeNurse": "test",
/*opt, string, range:[0,32]*/
"chargeDoctor": "test",
/*opt, string, range:[0,32]*/
"nursingLevel": "tertiary",
/*opt, enum, subType:string*/
"doctorsAdvice": "test",
/*opt, string, range:[0,128]*/
"allergicHistory": "test"
/*opt, string, range:[0,128]*/
},
"ESDType": "handAndFoot",
/*opt, enum, subType:string*/
"userLevel": "Employee",
/*opt, enum, subType:string*/
"userName": "test",
/*opt, string, range:[1,32]*/
"loginPassword": "test"
/*opt, string, range:[8,16]*/
}
}
Response Message
{
"statusCode": 1,
/*ro, opt, int, status code, desc:1 (succeeded). It is required when an error occurred*/
"statusString": "ok",
/*ro, opt, string, status description, range:[1,64], desc:"ok" (succeeded). It is required when an error occurred*/
"subStatusCode": "ok",
/*ro, opt, string, sub status code, range:[1,64], desc:"ok" (succeeded). It is required when an error occurred*/
"errorCode": 1,
/*ro, opt, int, error code, desc:it is required when the value of statusCode is not 1, and it corresponds to subStatusCode*/
"errorMsg": "ok"
/*ro, opt, string, error information, desc:this field is required when the value of statusCode is not 1*/
}
21.22.15 Set person information


Request URL
PUT /ISAPI/AccessControl/UserInfo/SetUp?format=json&security=<security>&iv=<iv>
Query Parameter
Parameter Name Parameter Type Description
security
string
iv
Request Message
{
"UserInfo": {
/*req, object, person information*/
"employeeNo": "test",
/*req, string, employee No. (person ID)*/
"deleteUser": true,
/*opt, bool, whether to delete the person*/
"name": "test",
/*opt, string, person name*/
"userType": "normal",
/*req, enum, person type, subType:string*/
"closeDelayEnabled": true,
/*opt, bool, whether to enable door close delay, desc:true (yes), false (no)*/
"Valid": {
/*req, object, the parameters of the effective period, desc:If this node is set to "false", the effective period is permanent. The effective period
can be a period of time between 1970-01-01 00:00:00 and 2037-12-31 23:59:59*/
"enable": true,
/*req, bool, whether to enable the effective period, desc:true (yes), false (no)*/
"beginTime": "test",
/*req, string, start date of the effective period, desc:start time of the effective period (if timeType does not exist or is "local",the
beginTime is the device local time,e.g.,2017-08-01T17:30:08; if timeType is "UTC",the beginTime is UTC time,e.g.,2017-08-01T17:30:08+08:00)*/
"endTime": "test",
/*req, string, end time of effective period, desc:end time of the effective period (if timeType does not exist or is "local",the endTime is the
device local time,e.g.,2017-08-01T17:30:08; if timeType is "UTC",the endTime is UTC time,e.g.,2017-08-01T17:30:08+08:00)*/
"timeType": "local"
/*opt, enum, time type, subType:string, desc:"local” (device local time), "UTC” (UTC time)*/
},
"belongGroup": "1,3,5",
/*opt, string, group*/
"password": "123456",
/*opt, string, password*/
"doorRight": "1,3",
/*opt, string, No. of the door or lock that has access permission, desc:e.g., "1,3" indicates having permission to access door (lock) No. 1 and No.
3*/
"RightPlan": [
/*opt, array, door permission schedule (lock permission schedule), subType:object*/
{
"doorNo": 1,
/*opt, int, door No. (lock ID)*/
"planTemplateNo": "1,3,5"
/*opt, string, schedule template No., desc:schedule template No.*/
}
],
"maxOpenDoorTime": 0,
/*opt, int, the maximum authentication attempts*/
"roomNumber": 123,
/*opt, int, room No.*/
"floorNumber": 1,
/*opt, int, floor No.*/
"doubleLockRight": true,
/*opt, bool, whether to have the permission to open the double-locked door, desc:true (yes), false (no)*/
"localUIRight": true,
/*opt, bool, whether to have the permission to access the device local UI: "true"-yes,"false"-no, desc:whether to have the permission to access the
device local UI: "true"-yes,"false"-no*/
"userVerifyMode": "card",
/*opt, enum, person authentication mode, subType:string, desc:"cardAndPw” (card+password), "card” (card), "cardOrPw” (card or password), "fp”
(fingerprint), "fpAndPw” (fingerprint+password), "fpOrCard” (fingerprint or card), "fpAndCard” (fingerprint+card), "fpAndCardAndPw”
(fingerprint+card+password), "faceOrFpOrCardOrPw” (face or fingerprint or card or password), "faceAndFp” (face+fingerprint), "faceAndPw” (face+password),
"faceAndCard” (face+card), "face” (face), "employeeNoAndPw” (employee No.+password), "fpOrPw” (fingerprint or password), "employeeNoAndFp” (employee
No.+fingerprint), "employeeNoAndFpAndPw” (employee No.+fingerprint+password), "faceAndFpAndCard” (face+fingerprint+card), "faceAndPwAndFp”
(face+password+fingerprint), "employeeNoAndFace” (employee No.+face), "faceOrfaceAndCard” (face or face+card), "fpOrface” (fingerprint or face),
"cardOrfaceOrPw” (card or face or password), "cardOrFace” (card or face), "cardOrFaceOrFp” (card or face or fingerprint), "cardOrFpOrPw” (card or
fingerprint or password); the priority of the person authentication mode is higher than that of the card reader authentication mode*/
"checkUser": true,
/*opt, bool, whether to verify the duplicated person information, desc:false (no), true (yes). If checkUser is not configured, the device will
verify the duplicated person information by default. When there is no person information, you can set checkUser to "false" to speed up data applying;
otherwise, it is not recommended to configure this node*/
"gender": "male",
/*opt, enum, gender of the person in the face picture, subType:string, desc:"male", "female", "unknown"*/
"PersonInfoExtends": [
/*opt, array, extended fields for the additional person information, subType:object, desc:this node is used to configure the extended person
information displayed on the device's UI. For MinMoe series facial recognition terminals, currently only one value node can be supported for displaying the
employee No. and the node id is not supported*/
{
"id": 1,
string
-
-


"id": 1,
/*opt, int, extended ID of the additional person information, range:[1,32], desc:It corresponds to the id in the message of the request URI
/ISAPI/AccessControl/personInfoExtendName?format=json and is used to link the value of the node value and its name (the node name in the message of the
request URI /ISAPI/AccessControl/personInfoExtendName?format=json). If the node id does not exist, the ID will start from 1 by default according to the
array order*/
"value": "test"
/*opt, string, extended content of the additional person information*/
}
],
"dynamicCode": "123456",
/*opt, string, dynamic permission code*/
"callNumbers": ["1-1-1-401"],
/*opt, array, room No. list to be called, subType:string, desc:this node is extended from roomNumber; for standard SIP, it can be the SIP number*/
"floorNumbers": [1, 2],
/*opt, array, floor No. list, subType:int, desc:this node is extended from floorNumber*/
"groupId": 1,
/*opt, int*/
"localAtndPlanTemplateId": 1,
/*opt, int*/
"groupName": "test",
/*opt, string, range:[1,64]*/
"ESDType": "handAndFoot",
/*opt, enum, subType:string*/
"userLevel": "Employee",
/*opt, enum, subType:string*/
"userName": "test",
/*opt, string, range:[1,32]*/
"loginPassword": "test"
/*opt, string, range:[8,16]*/
}
}
Response Message
{
"statusCode": 1,
/*ro, opt, int, status code, desc:1 (succeeded). It is required when an error occurred*/
"statusString": "ok",
/*ro, opt, string, status description, range:[1,64], desc:"ok" (succeeded). It is required when an error occurred*/
"subStatusCode": "ok",
/*ro, opt, string, sub status code, range:[1,64], desc:"ok" (succeeded). It is required when an error occurred*/
"errorCode": 1,
/*ro, opt, int, error code, desc:when the value of statusCode is not 1, it corresponds to subStatusCode*/
"errorMsg": "ok"
/*ro, opt, string, error details, desc:this node is required when statusCode is not 1*/
}
21.22.16 Edit card information
Request URL
PUT /ISAPI/AccessControl/CardInfo/Modify?format=json&security=<security>&iv=<iv>
Query Parameter
Parameter Name Parameter Type Description
security
string
iv
Request Message
{
"CardInfo": {
/*req, object, card information*/
"employeeNo": "test",
/*req, string, employee No. (person ID)*/
"cardNo": "1234567890",
/*req, string, card No.*/
"cardType": "normalCard",
/*opt, enum, card type, subType:string, desc:card type*/
"leaderCard": "1,3,5",
/*opt, string, whether to support first card authentication function, desc:e.g., the value "1, 3, 5" indicates that the access control points No.1,
No.3, and No.5 support first card authentication function*/
"operateType": "byTerminal",
/*opt, string, operation type*/
"terminalNoList": [1]
/*opt, array, terminal ID list, subType:int, desc:this node is required when operation type is "byTerminal"; currently, only one terminal is
supported*/
}
}
string
-
-


Response Message
{
"statusCode": 1,
/*ro, opt, int, status code, desc:1 (succeeded). It is required when an error occurred*/
"statusString": "ok",
/*ro, opt, string, status description, range:[1,64], desc:"ok" (succeeded). It is required when an error occurred*/
"subStatusCode": "ok",
/*ro, opt, string, sub status code, range:[1,64], desc:"ok" (succeeded). It is required when an error occurred*/
"errorCode": 1,
/*ro, opt, int, error code, desc:when the value of statusCode is not 1, it corresponds to subStatusCode*/
"errorMsg": "ok"
/*ro, opt, string, error information, desc:this node is required when the value of statusCode is not 1*/
}
21.22.17 Set card information
Request URL
PUT /ISAPI/AccessControl/CardInfo/SetUp?format=json&security=<security>&iv=<iv>
Query Parameter
Parameter Name Parameter Type Description
security
string
iv
Request Message
{
"CardInfo": {
/*opt, object, card information*/
"employeeNo": "test",
/*req, string, employee No. (person ID)*/
"cardNo": "1234567890",
/*req, string, card No.*/
"deleteCard": true,
/*opt, bool, whether to delete the card, desc:true (yes). This node is required only when the card needs to be deleted; for adding or editing card
information, this node can be set to NULL*/
"cardType": "normalCard",
/*req, enum, card type, subType:string, desc:normalCard (normal card), patrolCard (patrol card), hijackCard (duress card), superCard (super card),
dismissingCard (dismiss card), emergencyCard (emergency card: it is used to assign permission to a temporary card, but it cannot open the door)*/
"leaderCard": "1,3,5",
/*opt, string, whether to support first card authentication function, desc:e.g., the value "1, 3, 5" indicates that the access control points No.1,
No.3, and No.5 support first card authentication function*/
"checkCardNo": true,
/*opt, bool, whether to enable duplicated card verification, desc:false (disable), true (enable). If this node is not configured, the device will
verify the duplicated card by default. When there is no card information, you can set checkCardNo to "false" to speed up data applying; otherwise, it is not
recommended to configure this node*/
"checkEmployeeNo": true
/*opt, bool, whether to check the existence of the employee No. (person ID), desc:"false"-no, "true"-yes. If this node is not configured, the device
will check the existence of the employee No. (person ID) by default. This node is used for speeding up applying card information (by setting the value to
"false"). It is not recommended to configure this node*/
}
}
Response Message
{
"statusCode": 1,
/*ro, opt, int, status code, desc:1 (succeeded). It is required when an error occurred*/
"statusString": "ok",
/*ro, opt, string, status description, range:[1,64], desc:"ok" (succeeded). It is required when an error occurred*/
"subStatusCode": "ok",
/*ro, opt, string, sub status code, range:[1,64], desc:"ok" (succeeded). It is required when an error occurred*/
"errorCode": 1,
/*ro, opt, int, error code, desc:it is required when the value of statusCode is not 1, it corresponds to subStatusCode*/
"errorMsg": "ok"
/*ro, opt, string, error information, desc:this node is required when the value of statusCode is not 1*/
}
21.22.18 Search for person information
Request URL
POST /ISAPI/AccessControl/UserInfo/Search?format=json&security=<security>&iv=<iv>
string
-
-


Query Parameter
Parameter Name Parameter Type Description
security
string
iv
Request Message
{
"UserInfoSearchCond": {
/*req, object, search condition*/
"searchID": "123",
/*req, string, search ID, desc:it is used to confirm the upper-level platform or system. If the platform or the system is the same one during two
searching, the search history will be saved in the memory to speed up next searching*/
"searchResultPosition": 0,
/*req, int, the start position of the search result in the result list, desc:in a single search, if you cannot get all the records in the result
list, you can mark the end position and get the following records after the marked position in the next search*/
"maxResults": 30,
/*req, int, the maximum number of search results, desc:if maxResults exceeds the range returned by the device capability, the device will return the
maximum number of search results according to the device capability and will not return error message*/
"EmployeeNoList": [
/*opt, array, person ID list, subType:object*/
{
"employeeNo": "test"
/*req, string, employee ID*/
}
],
"fuzzySearch": "test",
/*opt, string, fuzzy search by key words*/
"groupIdList": [1, 2, 3, 4],
/*opt, array, subType:int*/
"arrangeType": "personal",
/*opt, enum, subType:string*/
"userType": "normal",
/*opt, enum, person type, subType:string*/
"deviceIDList": [1, 2],
/*opt, array, subType:int*/
"hasFace": true,
/*opt, bool*/
"hasCard": true,
/*opt, bool*/
"hasFingerprint": true,
/*opt, bool*/
"hasIris": true
/*opt, bool*/
}
}
Response Message
{
"UserInfoSearch": {
/*ro, req, object, search results*/
"searchID": "test",
/*ro, req, string, search ID*/
"responseStatusStrg": "OK",
/*ro, req, enum, search status, subType:string, desc:"OK" (searching completed), "NO MATCH" (no matched results), "MORE" (searching for more
results)*/
"numOfMatches": 1,
/*ro, req, int, number of results returned this time*/
"totalMatches": 1,
/*ro, req, int, total number of matched results*/
"UserInfo": [
/*ro, opt, array, person information, subType:object*/
{
"employeeNo": "test",
/*ro, req, string, employee ID (person ID)*/
"name": "test",
/*ro, opt, string, name*/
"userType": "normal",
/*ro, req, enum, person type, subType:string, desc:"normal" (normal person (house owner)), "visitor", "blockList" (person in blocklist),
"patient", "maintenance" (maintenance person)*/
"closeDelayEnabled": true,
/*ro, opt, bool, whether to enable door close delay*/
"Valid": {
/*ro, opt, object, effective period parameters*/
"enable": true,
/*ro, req, bool, whether to enable effective period*/
"beginTime": "test",
/*ro, req, string, start time of the effective period, desc:start time of the effective period (if timeType does not exist or is
"local",the beginTime is the device local time,e.g.,2017-08-01T17:30:08; if timeType is "UTC",the beginTime is UTC time,e.g.,2017-08-01T17:30:08+08:00)*/
"endTime": "test",
/*ro, req, string, end time of the effective period, desc:end time of the effective period (if timeType does not exist or is "local",the
endTime is the device local time,e.g.,2017-08-01T17:30:08; if timeType is "UTC",the endTime is UTC time,e.g.,2017-08-01T17:30:08+08:00)*/
string
-
-


"timeType": "test"
/*ro, opt, string, time type*/
},
"belongGroup": "1,3,5",
/*ro, opt, string, group*/
"password": "123456",
/*ro, opt, string, password*/
"doorRight": "1,3",
/*ro, opt, string, No. of door or lock that has access permission, desc:"1,3" indicates having permission to access door (lock) No. 1 and
No. 3*/
"RightPlan": [
/*ro, opt, array, access permission schedule of the door or lock, subType:object*/
{
"doorNo": 1,
/*ro, opt, int, door No. (lock ID)*/
"planTemplateNo": "1,3,5"
/*ro, opt, string, schedule template No., desc:schedule template No.*/
}
],
"maxOpenDoorTime": 0,
/*ro, opt, int, the maximum number of authentication attempts*/
"openDoorTime": 0,
/*ro, opt, int, number of authenticated attempts*/
"roomNumber": 123,
/*ro, opt, int, room No.*/
"floorNumber": 1,
/*ro, opt, int, floor No.*/
"doubleLockRight": true,
/*ro, opt, bool, whether to have the permission to open the double-locked door, desc:whether to have the permission to open the doublelocked
door: "true"-yes,"false"-no*/
"localUIRight": true,
/*ro, opt, bool, whether to have the permission to access the device local UI, desc:whether to have the permission to access the device
local UI: "true"-yes,"false"-no*/
"userVerifyMode": "card",
/*ro, opt, enum, person authentication mode, subType:string, desc:"cardAndPw" (card+password), "card" (card), "cardOrPw" (card or password),
"fp" (fingerprint), "fpAndPw" (fingerprint+password), "fpOrCard" (fingerprint or card), "fpAndCard" (fingerprint+card), "fpAndCardAndPw"
(fingerprint+card+password), "faceOrFpOrCardOrPw" (face or fingerprint or card or password), "faceAndFp" (face+fingerprint), "faceAndPw" (face+password),
"faceAndCard" (face+card), "face" (face), "employeeNoAndPw" (employee No.+password), "fpOrPw" (fingerprint or password), "employeeNoAndFp" (employee
No.+fingerprint), "employeeNoAndFpAndPw" (employee No.+fingerprint+password), "faceAndFpAndCard" (face+fingerprint+card), "faceAndPwAndFp"
(face+password+fingerprint), "employeeNoAndFace" (employee No.+face), "faceOrfaceAndCard" (face or face+card), "fpOrface" (fingerprint or face),
"cardOrfaceOrPw" (card or face or password), "cardOrFace" (card or face), "cardOrFaceOrFp" (card or face or fingerprint), "cardOrFpOrPw" (card or
fingerprint or password), the priority of the person authentication mode is higher than that of the card reader authentication mode*/
"dynamicCode": "123456",
/*ro, opt, string, dynamic permission code*/
"callNumbers": ["1-1-1-401"],
/*ro, opt, array, list of call No., subType:string, desc:this node is the extension of roomNumber*/
"floorNumbers": [1, 2],
/*ro, opt, array, list of floor No., subType:int, desc:this node is the extension of floorNumber*/
"groupId": 1,
/*ro, opt, int*/
"localAtndPlanTemplateId": 1,
/*ro, opt, int*/
"numOfFace": 0,
/*ro, opt, int, number of linked face pictures, desc:if this node is not returned, it indicates that device does not support this function*/
"numOfFP": 0,
/*ro, opt, int, number of linked fingerprints, desc:if this node is not returned, it indicates that device does not support this function*/
"numOfCard": 0,
/*ro, opt, int, number of linked cards, desc:if this node is not returned, it indicates that device does not support this function*/
"numOfIris": 0,
/*ro, opt, int*/
"gender": "male",
/*ro, opt, enum, gender of the person in the face picture, subType:string, desc:"male", "female", "unknown"*/
"PersonInfoExtends": [
/*ro, opt, array, person extension information, subType:object, desc:this node is used to configure the extended person information
displayed on the device's UI. For MinMoe series facial recognition terminals, currently only one value node can be supported for displaying the employee No.
and the node id is not supported*/
{
"id": 1,
/*ro, opt, int, serial No. of person extension information, range:[1,32], desc:it corresponds to the id in the message of the
request URI /ISAPI/AccessControl/personInfoExtendName?format=json and is used to link the value of the node value and its name. If the node id does not
exist, the ID will start from 1 by default according to the array order*/
"value": "test"
/*ro, opt, string, extended content of the additional person information*/
}
],
"groupName": "test",
/*ro, opt, string, range:[1,64]*/
"age": 0,
/*ro, opt, int, age, range:[0,120]*/
"PatientInfos": {
/*ro, opt, object*/
"deviceID": "test",
/*ro, opt, string*/
"admissionTime": "1970-01-01T00:00:00+08:00",
/*ro, opt, datetime*/
"chargeNurse": "test",
/*ro, opt, string, range:[0,32]*/
"chargeDoctor": "test",
/*ro, opt, string, range:[0,32]*/
"nursingLevel": "tertiary",
/*ro, opt, enum, subType:string*/
"doctorsAdvice": "test",
/*ro, opt, string, range:[0,128]*/
"allergicHistory": "test"


"allergicHistory": "test"
/*ro, opt, string, range:[0,128]*/
},
"TromboneRule": {
/*ro, opt, object*/
"industryType": "builidings",
/*ro, opt, enum, subType:string*/
"unitType": "indoor",
/*ro, opt, enum, subType:string*/
"SIPVersion": "V10"
/*ro, opt, string, range:[0,32]*/
},
"ESDType": "handAndFoot",
/*ro, opt, enum, subType:string*/
"userLevel": "Employee",
/*ro, opt, enum, subType:string*/
"userName": "test"
/*ro, opt, string, range:[1,32]*/
}
]
}
}
21.22.19 Get the person management capability
Request URL
GET /ISAPI/AccessControl/UserInfo/capabilities?format=json&terminalNo=<terminalNo>
Query Parameter
Parameter Name Parameter Type Description
terminalNo
string
Request Message
None
Response Message
{
"UserInfo": {
/*ro, req, object, person information*/
"supportFunction": {
/*ro, req, object, supported function of adding, deleting, editing, searching for person information, and getting total number of the added
persons*/
"@opt": "post,delete,put,get,setUp"
/*ro, opt, string, desc:"post” (add), "delete", "put” (edit), "get” (search), "setUp” (set)*/
},
"UserInfoSearchCond": {
/*ro, opt, object, search conditions*/
"maxResults": {
/*ro, req, object, the maximum number of search results this time by calling this URI*/
"@min": 1,
/*ro, opt, int, the minimum value among elements of the array*/
"@max": 100
/*ro, opt, int, the maximum value among elements of the array*/
},
"EmployeeNoList": {
/*ro, opt, object, person ID list*/
"maxSize": 56,
/*ro, opt, int, range of members in the array*/
"employeeNo": {
/*ro, opt, object, employee No. (person ID)*/
"@min": 1,
/*ro, opt, int, the minimum value among elements of the array*/
"@max": 32
/*ro, opt, int, the maximum value among elements of the array*/
}
},
"fuzzySearch": {
/*ro, opt, object, fuzzy search by key words*/
"@min": 1,
/*ro, opt, int, the minimum value among elements of the array*/
"@max": 32
/*ro, opt, int, the maximum value among elements of the array*/
},
"isSupportNumOfFace": true,
/*ro, opt, bool, whether it supports number of linked face pictures when searching*/
"isSupportNumOfFP": true,
/*ro, opt, bool, whether it supports number of linked fingerprints when searching*/
"isSupportNumOfCard": true,
/*ro, opt, bool, whether it supports number of linked cards when searching*/
"groupIdList": {
/*ro, opt, object*/
"@size": 1,
-


/*ro, req, int*/
"@min": 1,
/*ro, req, int*/
"@max": 1
/*ro, req, int*/
},
"arrangeType": {
/*ro, opt, object*/
"@opt": ["personal"]
/*ro, req, array, subType:string*/
},
"userType": {
/*ro, opt, object, person type*/
"@opt": ["normal", "visitor", "blackList", "patient", "maintenance"]
/*ro, opt, array, subType:string*/
},
"deviceIDList": {
/*ro, opt, object*/
"@min": 1,
/*ro, opt, int, the minimum value among elements of the array*/
"@max": 512
/*ro, opt, int, the maximum value among elements of the array*/
},
"hasFace": {
/*ro, opt, object*/
"@opt": [true, false]
/*ro, req, array, subType:bool*/
},
"hasCard": {
/*ro, opt, object*/
"@opt": [true, false]
/*ro, req, array, subType:bool*/
},
"hasFingerprint": {
/*ro, opt, object*/
"@opt": [true, false]
/*ro, req, array, subType:bool*/
},
"hasIris": {
/*ro, opt, object*/
"@opt": [true, false]
/*ro, req, array, subType:bool*/
}
},
"UserInfoDelCond": {
/*ro, opt, object, deleting conditions*/
"EmployeeNoList": {
/*ro, opt, object, person ID list*/
"maxSize": 56,
/*ro, opt, int, range of members in the array*/
"employeeNo": {
/*ro, opt, object, employee No. (person ID)*/
"@min": 1,
/*ro, opt, int, the minimum value among elements of the array*/
"@max": 32
/*ro, opt, int, the maximum value among elements of the array*/
}
}
},
"employeeNo": {
/*ro, req, object, employee No. (person ID)*/
"@min": 1,
/*ro, opt, int, the minimum value among elements of the array*/
"@max": 32
/*ro, opt, int, the maximum value among elements of the array*/
},
"name": {
/*ro, opt, object, name*/
"@min": 1,
/*ro, opt, int, the minimum value among elements of the array*/
"@max": 128
/*ro, opt, int, the maximum value among elements of the array*/
},
"userType": {
/*ro, req, object, person type*/
"@opt": "normal,visitor,blackList"
/*ro, opt, string*/
},
"closeDelayEnabled": "true,false",
/*ro, opt, string, whether to enable door close delay*/
"Valid": {
/*ro, req, object, parameters of the validity period*/
"enable": "true,false",
/*ro, req, string, whether to enable validity period*/
"beginTime": {
/*ro, req, object, start time of the effective period (if timeType does not exist or is "local", the beginTime is the device local time, e.g., :
2017-08-01T17:30:08; if timeType is "UTC", the beginTime is UTC time, e.g.,: 2017-08-01T17:30:08+08:00)*/
"@min": 1,
/*ro, opt, int, the minimum value among elements of the array*/
"@max": 32
/*ro, opt, int, the maximum value among elements of the array*/
},
"endTime": {
/*ro, req, object, end time of the effective period (if timeType does not exist or is "local", the endTime is the device local time, e.g.,:


/*ro, req, object, end time of the effective period (if timeType does not exist or is "local", the endTime is the device local time, e.g.,:
2017-08-01T17:30:08; if timeType is "UTC", the endTime is UTC time, e.g.,: 2017-08-01T17:30:08+08:00)*/
"@min": 1,
/*ro, opt, int, the minimum value among elements of the array*/
"@max": 32
/*ro, opt, int, the maximum value among elements of the array*/
},
"timeRangeBegin": "1970-01-01T00:00:00",
/*ro, opt, string, start time that can be configured for beginTime, desc:if the device does not return this node, the default start time that
can be configured for beginTime is "1970-01-01T00:00:00"*/
"timeRangeEnd": "2037-12-31T23:59:59",
/*ro, opt, string, end time that can be configured for endTime, desc:if the device does not return this node, the default start time that can be
configured for beginTime is "1970-01-01T00:00:00"*/
"timeType": {
/*ro, opt, object, time type*/
"@opt": "local,UTC"
/*ro, opt, string*/
}
},
"maxBelongGroup": 4,
/*ro, opt, int, maximum number of groups that a person can belong to*/
"belongGroup": {
/*ro, opt, object, group*/
"@min": 1,
/*ro, opt, int, the minimum value among elements of the array*/
"@max": 32
/*ro, opt, int, the maximum value among elements of the array*/
},
"password": {
/*ro, opt, object, password*/
"@min": 1,
/*ro, opt, int, the minimum value among elements of the array*/
"@max": 32
/*ro, opt, int, the maximum value among elements of the array*/
},
"doorRight": {
/*ro, opt, object, No. of door or lock that has access permission*/
"@min": 1,
/*ro, opt, int, the minimum value among elements of the array*/
"@max": 32
/*ro, opt, int, the maximum value among elements of the array*/
},
"RightPlan": {
/*ro, opt, object, door permission schedule (lock permission schedule)*/
"maxSize": 32,
/*ro, opt, int, range of members in the array*/
"doorNo": {
/*ro, opt, object, door No. (lock ID)*/
"@min": 1,
/*ro, opt, int, the minimum value among elements of the array*/
"@max": 32
/*ro, opt, int, the maximum value among elements of the array*/
},
"maxPlanTemplate": 4,
/*ro, opt, int, maximum number of schedule templates that can be configured for one door*/
"planTemplateNo": {
/*ro, opt, object, schedule template No.*/
"@min": 1,
/*ro, opt, int, the minimum value among elements of the array*/
"@max": 32,
/*ro, opt, int, the maximum value among elements of the array*/
"@opt": [65535, 65534, 65533]
/*ro, opt, array, subType:int*/
}
},
"maxOpenDoorTime": {
/*ro, opt, object, maximum authentication attempts*/
"@min": 0,
/*ro, opt, int, the minimum value among elements of the array*/
"@max": 100
/*ro, opt, int, the maximum value among elements of the array*/
},
"openDoorTime": {
/*ro, opt, object, authenticated attempts*/
"@min": 0,
/*ro, opt, int, the minimum value among elements of the array*/
"@max": 100
/*ro, opt, int, the maximum value among elements of the array*/
},
"roomNumber": {
/*ro, opt, object, room No.*/
"@min": 0,
/*ro, opt, int, the minimum value among elements of the array*/
"@max": 100
/*ro, opt, int, the maximum value among elements of the array*/
},
"floorNumber": {
/*ro, opt, object, floor No.*/
"@min": 0,
/*ro, opt, int, the minimum value among elements of the array*/
"@max": 100
/*ro, opt, int, the maximum value among elements of the array*/
},
"doubleLockRight": "true,false",


/*ro, opt, string, whether to have the permission to open the double-locked door*/
"localUIRight": "true,false",
/*ro, opt, string, whether to have the permission to access the device local UI*/
"userVerifyMode": {
/*ro, opt, object, person authentication mode*/
"@opt":
"cardAndPw,card,cardOrPw,fp,fpAndPw,fpOrCard,fpAndCard,fpAndCardAndPw,faceOrFpOrCardOrPw,faceAndFp,faceAndPw,faceAndCard,face,employeeNoAndPw,fpOrPw,employe
eNoAndFp,employeeNoAndFpAndPw,faceAndFpAndCard,faceAndPwAndFp,employeeNoAndFace,faceOrfaceAndCard,fpOrface,cardOrfaceOrPw,cardOrFace,cardOrFaceOrFp,cardOrFp
OrPw,faceOrPw,employeeNoAndFaceAndPw,cardOrFaceOrFaceAndCard,iris,faceOrFpOrCardOrPwOrIris,faceOrCardOrPwOrIris"
/*ro, opt, string, options, desc:"cardAndPw” (card + password), "card” (card), "cardOrPw” (card or password), "fp” (fingerprint), "fpAndPw”
(fingerprint + password), "fpOrCard” (fingerprint or card), "fpAndCard” (fingerprint + card), "fpAndCardAndPw” (fingerprint + card + password),
"faceOrFpOrCardOrPw” (face or fingerprint or card or password), "faceAndFp” (face + fingerprint), "faceAndPw” (face + password), "faceAndCard” (face +
card), "face” (face), "employeeNoAndPw” (employee No. + password), "fpOrPw” (fingerprint or password), "employeeNoAndFp” (employee No. + fingerprint),
"employeeNoAndFpAndPw” (employee No. + fingerprint + password), "faceAndFpAndCard” (face + fingerprint + card), "faceAndPwAndFp” (face + password +
fingerprint), "employeeNoAndFace” (employee No. + face), "faceOrfaceAndCard” (face or face + card), "fpOrface” (fingerprint or face), "cardOrfaceOrPw” (card
or face or password), "cardOrFace” (card or face), "cardOrFaceOrFp” (card or face or fingerprint), "cardOrFpOrPw” (card or fingerprint or password). The
priority of the person authentication mode is higher than that of the card reader authentication mode*/
},
"checkUser": "true,false",
/*ro, opt, string, whether to verify the duplicated person information*/
"maxRecordNum": 0,
/*ro, opt, int, supported maximum number of records (person records)*/
"gender": {
/*ro, opt, object, gender of the person in the face picture*/
"@opt": "male,female,unknown"
/*ro, opt, string, options*/
},
"PersonInfoExtends": {
/*ro, opt, object, extended fields for the additional person information*/
"maxSize": 3,
/*ro, req, int, range of members in the array*/
"id": {
/*ro, opt, object, extended ID of the additional person information*/
"@min": 1,
/*ro, opt, int, the minimum value among elements of the array*/
"@max": 32
/*ro, opt, int, the maximum value among elements of the array*/
},
"value": {
/*ro, opt, object, extended content of the additional person information*/
"@min": 0,
/*ro, opt, int, the minimum value among elements of the array*/
"@max": 100
/*ro, opt, int, the maximum value among elements of the array*/
}
},
"dynamicCode": {
/*ro, opt, object*/
"@min": 1,
/*ro, opt, int, the minimum value among elements of the array*/
"@max": 32
/*ro, opt, int, the maximum value among elements of the array*/
},
"callNumbers": {
/*ro, opt, object, room No. list to be called,which is extended from roomNumber and it is in higher priority; by default,the No. format is X-X-XX,e.g.,1-1-1-401,and
for standard SIP,it can be the SIP number; this node must be configured together with roomNumber*/
"maxSize": 0,
/*ro, opt, int, range of members in the array*/
"@min": 0,
/*ro, opt, int, the minimum value among elements of the array*/
"@max": 100
/*ro, opt, int, the maximum value among elements of the array*/
},
"floorNumbers": {
/*ro, opt, object, floor No. list*/
"maxSize": 0,
/*ro, opt, int, range of members in the array*/
"@min": 0,
/*ro, opt, int, the minimum value among elements of the array*/
"@max": 100
/*ro, opt, int, the maximum value among elements of the array*/
},
"groupId": {
/*ro, opt, object*/
"@min": 0,
/*ro, req, int*/
"@max": 0
/*ro, req, int*/
},
"localAtndPlanTemplateId": {
/*ro, opt, object*/
"@min": 0,
/*ro, req, int*/
"@max": 0
/*ro, req, int*/
},
"purePwdVerifyEnable": true,
/*ro, opt, bool, whether the device supports opening the door only by password, desc:true (yes), this node is not returned (no). The password used
to open the door is the value of the node password in the message JSON_UserInfo*/
"groupName": {
/*ro, opt, object*/
"@min": 1,
/*ro, opt, int, the minimum length, range:[1,256]*/
"@max": 256


"@max": 256
/*ro, opt, int, the maximum length, range:[1,256]*/
},
"age": {
/*ro, opt, object*/
"@min": 0,
/*ro, opt, int, the minimum value among elements of the array*/
"@max": 120
/*ro, opt, int, the maximum value among elements of the array*/
},
"PatientInfos": {
/*ro, opt, object*/
"admissionTime": "1970-01-01T00:00:00+08:00",
/*ro, opt, datetime*/
"chargeNurse": {
/*ro, opt, object*/
"@min": 0,
/*ro, opt, int, the minimum value among elements of the array, unit:Byte*/
"@max": 64
/*ro, opt, int, the maximum value among elements of the array, unit:Byte*/
},
"chargeDoctor": {
/*ro, opt, object*/
"@min": 0,
/*ro, opt, int, the minimum value among elements of the array, unit:Byte*/
"@max": 64
/*ro, opt, int, the maximum value among elements of the array*/
},
"nursingLevel": {
/*ro, opt, object*/
"@min": 0,
/*ro, opt, int, the minimum value among elements of the array*/
"@max": 0,
/*ro, opt, int, the maximum value among elements of the array*/
"@opt": ["unknow", "tertiary", "secondary", "primary", "special"]
/*ro, opt, array, subType:string*/
},
"doctorsAdvice": {
/*ro, opt, object*/
"@min": 0,
/*ro, opt, int, the minimum value among elements of the array*/
"@max": 256
/*ro, opt, int, the maximum value among elements of the array*/
},
"allergicHistory": {
/*ro, opt, object*/
"@min": 0,
/*ro, opt, int*/
"@max": 128
/*ro, opt, int*/
}
},
"ESDType": {
/*ro, opt, object*/
"@opt": ["handAndFoot", "no", "hand", "foot"]
/*ro, req, array, subType:string*/
},
"userLevel": {
/*ro, opt, object*/
"@opt": ["Employee", "DepartmentManager"]
/*ro, req, array, subType:string*/
},
"userName": {
/*ro, opt, object*/
"@min": 1,
/*ro, req, int*/
"@max": 32
/*ro, req, int*/
},
"loginPassword": {
/*ro, opt, object*/
"@min": 8,
/*ro, req, int*/
"@max": 16
/*ro, req, int*/
}
}
}
21.22.20 Get the capability of deleting fingerprint data
Request URL
GET /ISAPI/AccessControl/FingerPrint/Delete/capabilities?format=json
Query Parameter
None
Request Message


None
Response Message
{
"FingerPrintDelete": {
/*ro, opt, object*/
"mode": {
/*ro, req, object, mode*/
"@opt": "byEmployeeNo,byCardReader"
/*ro, opt, string, deleting mode, desc:"byEmployeeNo"-delete by employee No. (person ID), "byCardReader"-delete by fingerprint module*/
},
"EmployeeNoDetail": {
/*ro, opt, object, delete by employee No. (person ID); this node is valid when mode is "byEmployeeNo"*/
"employeeNo": {
/*ro, opt, object, employee No. (person ID) linked with the fingerprint*/
"@min": 1,
/*ro, opt, int, the minimum value*/
"@max": 32
/*ro, opt, int, the maximum value*/
},
"enableCardReader": {
/*ro, opt, object, fingerprint module whose fingerprints should be deleted*/
"@min": 1,
/*ro, opt, int, the minimum value*/
"@max": 512
/*ro, opt, int, the maximum value*/
},
"fingerPrintID": {
/*ro, opt, object, No. of fingerprint to be deleted*/
"@min": 1,
/*ro, opt, int, the minimum value*/
"@max": 10
/*ro, opt, int, the maximum value*/
}
},
"CardReaderDetail": {
/*ro, opt, object, delete by fingerprint module; this node is valid when mode is "byCardReader"*/
"cardReaderNo": {
/*ro, opt, object, fingerprint module No.*/
"@min": 1,
/*ro, opt, int, the minimum value*/
"@max": 512
/*ro, opt, int, the maximum value*/
},
"clearAllCard": "true,false",
/*ro, opt, string, whether to delete the fingerprint information of all cards: "false"-no (delete by employee No.), "true"-yes (delete the
fingerprint information of all employee No.)*/
"employeeNo": {
/*ro, opt, object, employee No. (person ID) linked with the fingerprint*/
"@min": 1,
/*ro, opt, int, the minimum value*/
"@max": 32
/*ro, opt, int, the maximum value*/
}
}
}
}
21.22.21 Get the progress of deleting fingerprint data
Request URL
GET /ISAPI/AccessControl/FingerPrint/DeleteProcess?format=json
Query Parameter
None
Request Message
None
Response Message
{
"FingerPrintDeleteProcess": {
/*ro, req, object*/
"status": "processing"
/*ro, req, enum, deleting status, subType:string, desc:"processing", "success", "failed"*/
}
}
21.22.22 Get the total number of the added cards


Request URL
GET /ISAPI/AccessControl/CardInfo/Count?format=json
Query Parameter
None
Request Message
None
Response Message
{
"CardInfoCount": {
/*ro, req, object, number of cards*/
"cardNumber": 100
/*ro, req, int, number of cards*/
}
}
21.22.23 Get the progress of applying fingerprint data
Request URL
GET /ISAPI/AccessControl/FingerPrintProgress?format=json
Query Parameter
None
Request Message
None
Response Message
{
"FingerPrintStatus": {
/*ro, opt, object*/
"StatusList": [
/*ro, opt, array, status list, subType:object*/
{
"id": 1,
/*ro, opt, int, fingerprint module No.*/
"cardReaderRecvStatus": 1,
/*ro, opt, enum, fingerprint module status, subType:int, desc:0 (connecting failed), 1 (connected), 2 (the fingerprint module is offline), 3
(the fingerprint quality is poor, try again), 4 (the memory is full), 5 (the fingerprint already exists), 6 (the fingerprint ID already exists), 7 (invalid
fingerprint ID), 8 (this fingerprint module is already configured), 10 (the fingerprint module version is too old to support the employee No.)*/
"errorMsg": "test"
/*ro, opt, string, error information, range:[1,32], desc:error information*/
}
],
"totalStatus": 1
/*ro, req, enum, applying status, subType:int, desc:0 (applying), 1 (applied)*/
}
}
21.22.24 Get the capabilities of applying person pictures asynchronously
Request URL
GET /ISAPI/AccessControl/UserPic/asyncImportDatasTasks/capabilities?format=json
Query Parameter
None
Request Message
None
Response Message


{
"AsyncImportDatasCap": {
/*ro, opt, object*/
"taskID": {
/*ro, opt, object*/
"@min": 1,
/*ro, opt, int*/
"@max": 64
/*ro, req, int*/
},
"taskNum": 1,
/*ro, req, int*/
"URL": {
/*ro, opt, object*/
"@min": 1,
/*ro, opt, int*/
"@max": 256
/*ro, req, int*/
},
"singleFileMaxSize": 1,
/*ro, req, int*/
"employeeNo": {
/*ro, opt, object*/
"@min": 1,
/*ro, opt, int*/
"@max": 32
/*ro, opt, int*/
},
"FDID": "test",
/*ro, opt, string*/
"deleteFacePic": {
/*ro, opt, object*/
"@opt": [true, false]
/*ro, opt, array, subType:bool*/
},
"picURL": {
/*ro, opt, object*/
"@min": 1,
/*ro, opt, int*/
"@max": 1
/*ro, opt, int*/
}
}
}
21.22.25 Delete a specified task of applying person pictures asynchronously
Request URL
DELETE /ISAPI/AccessControl/UserPic/asyncImportDatasTasks/<taskID>?format=json
Query Parameter
Parameter Name Parameter Type Description
taskID
string
Request Message
None
Response Message
{
"statusCode": 1,
/*ro, opt, int*/
"statusString": "ok",
/*ro, opt, string, range:[1,64]*/
"subStatusCode": "ok",
/*ro, opt, string, range:[1,64]*/
"errorCode": 1,
/*ro, opt, int*/
"errorMsg": "ok"
/*ro, opt, string*/
}
21.22.26 Get the status of all tasks of applying person pictures asynchronously
Request URL
GET /ISAPI/AccessControl/UserPic/asyncImportDatasTasks/status?format=json
-


Query Parameter
None
Request Message
None
Response Message
{
"TasksStatusList": [
/*ro, req, array, subType:object*/
{
"AsyncImportDatasTask": {
/*ro, opt, object*/
"taskID": "test",
/*ro, req, string, range:[1,64]*/
"URL": "test",
/*ro, opt, string, range:[1,256]*/
"status": 1,
/*ro, req, enum, subType:int*/
"totalNum": 1,
/*ro, opt, int*/
"successNum": 1,
/*ro, opt, int*/
"failedNum": 1
/*ro, opt, int*/
}
}
]
}
21.22.27 Delete a specified task of applying person data asynchronously
Request URL
DELETE /ISAPI/AccessControl/UserInfo/asyncImportDatasTasks/<taskID>?format=json
Query Parameter
Parameter Name Parameter Type Description
taskID
string
Request Message
None
Response Message
{
"statusCode": 1,
/*ro, opt, int*/
"statusString": "ok",
/*ro, opt, string, range:[1,64]*/
"subStatusCode": "ok",
/*ro, opt, string, range:[1,64]*/
"errorCode": 1,
/*ro, opt, int*/
"errorMsg": "ok"
/*ro, opt, string*/
}
21.22.28 Get the status of a specified task of applying person data asynchronously
Request URL
GET /ISAPI/AccessControl/UserInfo/asyncImportDatasTasks/<taskID>/status?format=json
Query Parameter
Parameter Name Parameter Type Description
taskID
string
Request Message
-
-


None
Response Message
{
"AsyncImportDatasTask": {
/*ro, req, object*/
"taskID": "test",
/*ro, req, string, range:[1,64]*/
"URL": "test",
/*ro, opt, string, range:[1,256]*/
"status": 0,
/*ro, req, enum, subType:int*/
"totalNum": 1,
/*ro, opt, int*/
"successNum": 1,
/*ro, opt, int*/
"failedNum": 1
/*ro, opt, int*/
}
}
21.22.29 Search for cards
Request URL
POST /ISAPI/AccessControl/CardInfo/Search?format=json&security=<security>&iv=<iv>
Query Parameter
Parameter Name Parameter Type Description
security
string
iv
Request Message
{
"CardInfoSearchCond": {
/*req, object*/
"searchID": "test",
/*req, string, unique ID of search records, desc:it is used to confirm the upper-level platform or system. If the platform or the system is the same
one during two searching, the search history will be saved in the memory to speed up next searching*/
"searchResultPosition": 0,
/*req, int, the start position of the search result in the result list, desc:the start position of the search result in the result list. When there
are multiple records and you cannot get all search results at a time,you can search for the records after the specified position next time. For example,if
the maximum total number of matched results (totalMatches) supported by the device is M and the total number of matched results (totalMatches) stored in the
device currently is N (here N is smaller than M),the valid range of this field is from 0 to N-1*/
"maxResults": 30,
/*req, int, the maximum number of search results this time by calling this URI, desc:if maxResults exceeds the range returned by the device
capability, the device will return the maximum number of search results according to the device capability and will not return error message*/
"EmployeeNoList": [
/*opt, array, person ID list, subType:object*/
{
"employeeNo": "test"
/*opt, string, employee No. (person ID)*/
}
],
"CardNoList": [
/*opt, array, card No. list, subType:object, desc:this node cannot exist together with EmployeeNoList*/
{
"cardNo": "1234567890"
/*opt, string, card No.*/
}
]
}
}
Response Message
string
-
-


{
"CardInfoSearch": {
/*ro, opt, object*/
"searchID": "test",
/*ro, req, string, unique ID of search records*/
"responseStatusStrg": "OK",
/*ro, req, enum, searching status description, subType:string, desc:"OK" (searching completed), "MORE" (searching for more data), "NO MATCH" (no
matched data)*/
"numOfMatches": 1,
/*ro, req, int, number of results returned this time*/
"totalMatches": 1,
/*ro, req, int, total number of matched results*/
"CardInfo": [
/*ro, opt, array, card information, subType:object*/
{
"employeeNo": "test",
/*ro, req, string, employee No. (person ID)*/
"cardNo": "test",
/*ro, req, string, card No.*/
"cardType": "normalCard",
/*ro, req, enum, card type, desc:card type: "normalCard"-normal card,"patrolCard"-patrol card,"hijackCard"-duress card,"superCard"-super
card,"dismissingCard"-dismiss card,"emergencyCard"-emergency card (it is used to assign permission to a temporary card,but it cannot open the door)*/
"leaderCard": "1,3,5"
/*ro, opt, string, whether to support first card authentication function, desc:the value "1, 3, 5" indicates that the access control points
No.1, No.3, and No.5 support first card authentication function*/
}
]
}
}
21.22.30 Edit fingerprint parameters
Request URL
POST /ISAPI/AccessControl/FingerPrintModify?format=json&security=<security>&iv=<iv>
Query Parameter
Parameter Name Parameter Type Description
security
string
iv
Request Message
{
"FingerPrintModify": {
/*opt, object*/
"employeeNo": "test",
/*req, string, employee No. (person ID) linked with the fingerprint, range:[1,32]*/
"cardReaderNo": 1,
/*req, int, fingerprint module No.*/
"fingerPrintID": 1,
/*req, int, fingerprint No., range:[1,10]*/
"fingerType": "normalFP",
/*req, enum, fingerprint type, subType:string, desc:"normalFP" (normal fingerprint), "hijackFP" (duress fingerprint), "patrolFP" (patrol
fingerprint), "superFP" (super fingerprint),"dismissingFP" (dismiss fingerprint)*/
"leaderFP": [1, 3, 5]
/*opt, array, whether the access control points support first fingerprint authentication function, subType:int, desc:e.g., [1,3,5] indicates that
access control points No.1, No.3, and No.5 support first fingerprint authentication function. If this node is not configured, the first fingerprint
authentication function will remain unchanged*/
}
}
Response Message
{
"statusCode": 1,
/*ro, opt, int, status code, desc:1 (succeeded). It is required when an error occurred*/
"statusString": "ok",
/*ro, opt, string, status description, range:[1,64], desc:"ok" (succeeded). It is required when an error occurred*/
"subStatusCode": "ok",
/*ro, opt, string, sub status code, range:[1,64], desc:"ok" (succeeded). It is required when an error occurred*/
"errorCode": 1,
/*ro, opt, int, error code, desc:when the value of statusCode is not 1, it corresponds to subStatusCode*/
"errorMsg": "ok"
/*ro, opt, string, error information, desc:this node is required when the value of statusCode is not 1*/
}
string
-
-


21.22.31 Search the fingerprint information
Request URL
POST /ISAPI/AccessControl/FingerPrintUpload?format=json&security=<security>&iv=<iv>
Query Parameter
Parameter Name Parameter Type Description
security
string
iv
Request Message
{
"FingerPrintCond": {
/*opt, object, search condition*/
"searchID": "test",
/*req, string, search ID, range:[1,32], desc:it is used to check whether the current search requester is the same as the previous one. If they are
the same, the search record will be stored in the device to speed up the next search*/
"employeeNo": "test",
/*req, string, employee No. (person ID) linked with the fingerprint, range:[1,32]*/
"cardReaderNo": 1,
/*opt, int, card reader No.*/
"fingerPrintID": 1
/*opt, int, finger ID, range:[1,10]*/
}
}
Response Message
{
"FingerPrintInfo": {
/*ro, opt, object, fingerprint information*/
"searchID": "test",
/*ro, req, string, search ID*/
"status": "OK",
/*ro, req, enum, status, subType:string, desc:"OK” (the fingerprint exists), "NoFP” (the fingerprint does not exist)*/
"FingerPrintList": [
/*ro, opt, array, subType:object*/
{
"cardReaderNo": 1,
/*ro, req, int, card reader No., range:[1,10]*/
"fingerPrintID": 1,
/*ro, req, int, fingerprint No.*/
"fingerType": "normalFP",
/*ro, req, enum, fingerprint type, subType:string, desc:fingerprint type: "normalFP"-normal fingerprint,"hijackFP"-duress
fingerprint,"patrolFP"-patrol fingerprint,"superFP"-super fingerprint,"dismissingFP"-dismiss fingerprint*/
"fingerData": "test",
/*ro, req, string, fingerprint data encoded by Base64*/
"leaderFP": [1, 3, 5]
/*ro, opt, array, whether the access control points support first fingerprint authentication function, subType:int, desc:e.g., [1,3,5]
indicates that access control points No.1, No.3, and No.5 support first fingerprint authentication function*/
}
]
}
}
21.22.32 Start deleting the fingerprint data
Request URL
PUT /ISAPI/AccessControl/FingerPrint/Delete?format=json&security=<security>&iv=<iv>
Query Parameter
Parameter Name Parameter Type Description
security
string
iv
Request Message
string
-
-
string
-
-


{
"FingerPrintDelete": {
/*req, object*/
"mode": "byEmployeeNo",
/*req, enum, deleting mode, subType:string, desc:"byEmployeeNo" (delete by employee No. (person ID)), "byCardReader" (delete by fingerprint
module)*/
"EmployeeNoDetail": {
/*opt, object, delete by employee No. (person ID), dep:and,{$.FingerPrintDelete.mode,eq,byEmployeeNo}, desc:this node is valid when mode is
"byEmployeeNo"*/
"employeeNo": "test",
/*opt, string, employee No. (person ID) linked with the fingerprint*/
"enableCardReader": [1, 3, 5],
/*opt, array, fingerprint module whose fingerprints should be deleted, subType:int*/
"fingerPrintID": [1, 3, 5]
/*opt, array, No. of fingerprint to be deleted, subType:int*/
},
"CardReaderDetail": {
/*opt, object, delete by fingerprint module, dep:and,{$.FingerPrintDelete.mode,eq,byCardReader}, desc:this node is valid when mode is
"byCardReader"*/
"cardReaderNo": 1,
/*opt, int, fingerprint module No.*/
"clearAllCard": false,
/*opt, bool, whether to delete the fingerprint information of all cards, desc:"false" (no (delete by employee No.)), "true" (yes (delete the
fingerprint information of all employee No.))*/
"employeeNo": "test"
/*opt, string, employee No. (person ID) linked with the fingerprint*/
}
}
}
Response Message
{
"statusCode": 1,
/*ro, opt, int, status code, desc:1 (succeeded). It is required when an error occurred*/
"statusString": "ok",
/*ro, opt, string, status description, range:[1,64], desc:"ok" (succeeded). It is required when an error occurred*/
"subStatusCode": "ok",
/*ro, opt, string, sub status code, range:[1,64], desc:"ok" (succeeded). It is required when an error occurred*/
"errorCode": 1,
/*ro, opt, int, error code, desc:it is required when the value of statusCode is not 1, it corresponds to subStatusCode*/
"errorMsg": "ok"
/*ro, opt, string, error description, desc:this field is required when the value of statusCode is not 1*/
}
21.22.33 Get the status of all tasks of applying person data asynchronously
Request URL
GET /ISAPI/AccessControl/UserInfo/asyncImportDatasTasks/status?format=json
Query Parameter
None
Request Message
None
Response Message


{
"TasksStatusList": [
/*ro, req, array, subType:object*/
{
"AsyncImportDatasTask": {
/*ro, opt, object*/
"taskID": "test",
/*ro, req, string, range:[1,64]*/
"URL": "test",
/*ro, opt, string, range:[1,256]*/
"status": 0,
/*ro, req, enum, subType:int*/
"totalNum": 1,
/*ro, opt, int*/
"successNum": 1,
/*ro, opt, int*/
"failedNum": 1,
/*ro, opt, int*/
"taskMissingReason": "deviceShutDown"
/*ro, opt, enum, subType:string, dep:and,{$.TasksStatusList[*].AsyncImportDatasTask.status,eq,4}*/
}
}
]
}
21.23 Anti-Passback
21.23.1 Set anti-passing back parameters of a card reader
Request URL
PUT /ISAPI/AccessControl/CardReaderAntiSneakCfg/<cardReaderID>?format=json
Query Parameter
Parameter Name Parameter Type Description
cardReaderID
string
Request Message
{
"CardReaderAntiSneakCfg": {
/*req, object, anti-passing back parameters of a card reader*/
"enable": true,
/*req, bool, whether to enable the anti-passing back function of the card reader, desc:"true"-enable, "false"-disable*/
"followUpCardReader": [2, 3, 4]
/*opt, array, following card reader No. after the first card reader, subType:int, desc:e.g., [2,3,4] indicates that card reader No. 2, No. 3, and
No. 4 can be swiped after the first card reader*/
}
}
Response Message
{
"requestURL": "test",
/*ro, opt, string, URI*/
"statusCode": 1,
/*ro, opt, int, status code, desc:1 (succeeded); it is required when an error occurred*/
"statusString": "ok",
/*ro, opt, string, status description, range:[1,64], desc:"ok" (succeeded); it is required when an error occurred*/
"subStatusCode": "ok",
/*ro, opt, string, sub status code, range:[1,64], desc:"ok" (succeeded); it is required when an error occurred*/
"errorCode": 1,
/*ro, opt, int, error code, desc:when the value of statusCode is not 1, it corresponds to subStatusCode*/
"errorMsg": "ok"
/*ro, opt, string, error information, desc:this node is required when the value of statusCode is not 1*/
}
21.23.2 Get the configuration capability of anti-passing back parameters of card readers
Request URL
GET /ISAPI/AccessControl/CardReaderAntiSneakCfg/capabilities?format=json
Query Parameter
-


None
Request Message
None
Response Message
{
"CardReaderAntiSneakCfg": {
/*ro, req, object*/
"cardReaderNo": {
/*ro, opt, object, card reader No.*/
"@min": 1,
/*ro, opt, int, the minimum value*/
"@max": 512,
/*ro, opt, int, the maximum value*/
"@opt": [1, 4]
/*ro, opt, array, subType:int*/
},
"enable": "true,false",
/*ro, req, string, whether to enable the anti-passing back function of the card reader*/
"followUpCardReader": {
/*ro, opt, object, array,following card reader No. after the first card reader*/
"@min": 1,
/*ro, opt, int*/
"@max": 512,
/*ro, opt, int*/
"@opt": [1, 4]
/*ro, opt, array, subType:int*/
}
}
}
21.23.3 Get the capability of clearing anti-passback parameters
Request URL
GET /ISAPI/AccessControl/ClearAntiSneakCfg/capabilities?format=json
Query Parameter
None
Request Message
None
Response Message
{
"ClearAntiSneakCfg": {
/*ro, req, object, the capability of clearing anti-passback*/
"ClearFlags": {
/*ro, req, object*/
"antiSneak": "true,false"
/*ro, req, string, whether to clear the anti-passback parameter*/
}
}
}
21.23.4 Get the anti-passing back configuration capability
Request URL
GET /ISAPI/AccessControl/AntiSneakCfg/capabilities?format=json
Query Parameter
None
Request Message
None
Response Message


{
"AntiSneakCfg": {
/*ro, req, object*/
"enable": "true,false",
/*ro, req, string, whether to enable anti-passing back*/
"startCardReaderNo": {
/*ro, opt, object, first card reader No., desc:first card reader No.*/
"@min": 1,
/*ro, opt, int, the minimum value*/
"@max": 4,
/*ro, opt, int, the maximum value*/
"@opt": [1, 4]
/*ro, opt, array, subType:int*/
}
}
}
21.23.5 Clear anti-passing back parameters
Request URL
PUT /ISAPI/AccessControl/ClearAntiSneakCfg?format=json
Query Parameter
None
Request Message
{
"ClearAntiSneakCfg": {
/*req, object*/
"ClearFlags": {
/*req, object*/
"antiSneak": true
/*req, bool, whether to clear the anti-passing back parameters*/
}
}
}
Response Message
{
"requestURL": "test",
/*ro, opt, string, URI*/
"statusCode": 1,
/*ro, opt, int, status code, desc:1 (succeeded); it is required when an error occurred*/
"statusString": "ok",
/*ro, opt, string, status description, range:[1,64], desc:"ok" (succeeded); it is required when an error occurred*/
"subStatusCode": "ok",
/*ro, opt, string, sub status code, range:[1,64], desc:"ok" (succeeded); it is required when an error occurred*/
"errorCode": 1,
/*ro, opt, int, error code, desc:when the value of statusCode is not 1, it corresponds to subStatusCode*/
"errorMsg": "ok"
/*ro, opt, string, error information, desc:this node is required when the value of statusCode is not 1*/
}
21.23.6 Set the anti-passing back parameters
Request URL
PUT /ISAPI/AccessControl/AntiSneakCfg?format=json
Query Parameter
None
Request Message
{
"AntiSneakCfg": {
/*req, object*/
"enable": true,
/*req, bool, whether to enable anti-passing back*/
"startCardReaderNo": 1
/*opt, int, first card reader No., desc:0-no first card reader*/
}
}


Response Message
{
"requestURL": "test",
/*ro, opt, string, URI*/
"statusCode": 1,
/*ro, opt, int, status code, desc:1 (succeeded). It is required when an error occurred*/
"statusString": "ok",
/*ro, opt, string, status description, range:[1,64], desc:"ok" (succeeded). It is required when an error occurred*/
"subStatusCode": "ok",
/*ro, opt, string, sub status code, range:[1,64], desc:"ok" (succeeded). It is required when an error occurred*/
"errorCode": 1,
/*ro, opt, int, error code, desc:when the value of statusCode is not 1, it corresponds to subStatusCode*/
"errorMsg": "ok"
/*ro, opt, string, error information, desc:this node is required when the value of statusCode is not 1*/
}
21.23.7 Get the anti-passing back configuration parameters of a specified card reader
Request URL
GET /ISAPI/AccessControl/CardReaderAntiSneakCfg/<cardReaderID>?format=json
Query Parameter
Parameter Name Parameter Type Description
cardReaderID
string
Request Message
None
Response Message
{
"CardReaderAntiSneakCfg": {
/*ro, req, object*/
"enable": true,
/*ro, req, bool, whether to enable the anti-passing back function of the card reader, desc:"true" (enable), "false" (disable)*/
"followUpCardReader": [2, 3, 4]
/*ro, opt, array, following card reader No. after the first card reader, subType:int, desc:[2,3,4] indicates that card reader No. 2, No. 3, or No. 4
can be swiped after the first card reader*/
}
}
21.23.8 Get the parameters of anti-passback configuration
Request URL
GET /ISAPI/AccessControl/AntiSneakCfg?format=json
Query Parameter
None
Request Message
None
Response Message
{
"AntiSneakCfg": {
/*ro, req, object*/
"enable": true,
/*ro, req, bool, whether to enable anti-passback*/
"startCardReaderNo": 1
/*ro, opt, int, first card reader No., desc:first card reader No.,0-no first card reader*/
}
}
-
21.24 Mask Detection
21.24.1 Set the mask detection parameters


Request URL
PUT /ISAPI/AccessControl/maskDetection?format=json
Query Parameter
None
Request Message
{
"MaskDetection": {
/*req, object*/
"enable": true,
/*opt, bool, whether to enable mask detection*/
"noMaskStrategy": "noTipsAndOpenDoor"
/*opt, enum, door control strategy when not wearing mask is detected, subType:string, desc:"noTipsAndOpenDoor" (open the door without prompt),
"tipsAndOpenDoor" (prompt and open the door (default)), "tipsAndNotOpenDoor" (prompt and not open the door)*/
}
}
Response Message
{
"statusCode": 1,
/*ro, opt, int, status code, desc:1 (succeeded). It is required when an error occurred*/
"statusString": "ok",
/*ro, opt, string, status description, range:[1,64], desc:"ok" (succeeded). It is required when an error occurred*/
"subStatusCode": "ok",
/*ro, opt, string, sub status code, range:[1,64], desc:"ok" (succeeded). It is required when an error occurred*/
"errorCode": 1,
/*ro, opt, int, error code, desc:it is required when the value of statusCode is not 1, it corresponds to subStatusCode*/
"errorMsg": "ok"
/*ro, opt, string, error information, desc:this node is required when the value of statusCode is not 1*/
}
21.24.2 Get the mask detection parameters
Request URL
GET /ISAPI/AccessControl/maskDetection?format=json
Query Parameter
None
Request Message
None
Response Message
{
"MaskDetection": {
/*ro, req, object, mask detection*/
"enable": true,
/*ro, opt, bool, whether to enable mask detection: true-enable, false-disable*/
"noMaskStrategy": "noTipsAndOpenDoor"
/*ro, opt, enum, door control strategy when not wearing mask is detected, subType:string, desc:This field is valid when enable is true;
"noTipsAndOpenDoor”-open the door without prompt, "tipsAndOpenDoor"-prompt and open the door (default), "tipsAndNotOpenDoor"-prompt and not open the door*/
}
}
21.24.3 Get the configuration capability of mask detection
Request URL
GET /ISAPI/AccessControl/maskDetection/capabilities?format=json
Query Parameter
None
Request Message
None
Response Message


{
"MaskDetectionCap": {
/*ro, req, object, configuration capability of mask detection*/
"enable": {
/*ro, opt, object, whether to enable mask detection, desc:true-enable, false-disable*/
"@opt": [true, false]
/*ro, opt, array, options, subType:bool*/
},
"noMaskStrategy": {
/*ro, opt, object, door control strategy when not wearing mask is detected, desc:"noTipsAndOpenDoor"-open the door without prompt,
"tipsAndOpenDoor"-prompt and open the door (default), "tipsAndNotOpenDoor"-prompt and not open the door. This field is valid when enable is true*/
"@opt": ["noTipsAndOpenDoor", "tipsAndOpenDoor", "tipsAndNotOpenDoor", "noTipsAndConsume", "tipsAndConsume", "tipsAndNotConsume"]
/*ro, opt, array, options, subType:string*/
}
}
}
21.25 Access Control Device Management
21.25.1 Get the capability of getting the working status of
the access controller Request URL
GET /ISAPI/AccessControl/AcsWorkStatus/capabilities?format=json
Query Parameter
None
Request Message
None
Response Message
{
"AcsWorkStatus": {
/*ro, req, object*/
"doorLockStatus": {
/*ro, opt, object, door lock status (relay status): 0-normally close, 1-normally open, 2-short-circuit alarm, 3-broken-circuit alarm, 4-exception
alarm*/
"@opt": "0,1,2,3,4"
/*ro, opt, string*/
},
"doorStatus": {
/*ro, opt, object, door (floor) status: 1-sleep, 2-remain unlocked (free), 3-remain locked (disabled), 4-normal status (controlled)*/
"@opt": "1,2,3,4"
/*ro, opt, string*/
},
"magneticStatus": {
/*ro, opt, object, magnetic contact status: 0-normally close,1-normally open, 2-short-circuit alarm, 3-broken-circuit alarm, 4-exception alarm*/
"@opt": "0,1,2,3,4"
/*ro, opt, string, magnetic contact status*/
},
"caseStatus": {
/*ro, opt, object, event trigger status*/
"@min": 1,
/*ro, opt, int, event trigger status*/
"@max": 1
/*ro, opt, int, event trigger status*/
},
"batteryVoltage": {
/*ro, opt, object, storage battery power voltage, the actual value will be 10 times of this value*/
"@min": 1,
/*ro, opt, int, storage battery power voltage*/
"@max": 1
/*ro, opt, int, storage battery power voltage*/
},
"batteryLowVoltage": "true,false",
/*ro, opt, string, whether the storage battery is in low voltage status: "true"-yes,"false"-no*/
"powerSupplyStatus": {
/*ro, opt, object, device power supply status: "ACPowerSupply"-alternative current, "BatteryPowerSupply"-storage battery power supply*/
"@opt": "ACPowerSupply,BatteryPowerSupply"
/*ro, opt, string*/
},
"multiDoorInterlockStatus": {
/*ro, opt, object, multi-door interlocking status: "close"-disabled, "open"-enabled*/
"@opt": "close,open"
/*ro, opt, string*/
},
"antiSneakStatus": {
/*ro, opt, object, anti-passback status: "close"-disabled,"open"-enabled*/
"@opt": "close,open"
/*ro, opt, string*/
},
"hostAntiDismantleStatus": {


"hostAntiDismantleStatus": {
/*ro, opt, object, tampering status of the access control device: "close"-disabled, "open"-enabled*/
"@opt": "close,open"
/*ro, opt, string*/
},
"indicatorLightStatus": {
/*ro, opt, object, indicator status: "offLine"-offline, "onLine"-online*/
"@opt": "offLine,onLine"
/*ro, opt, string*/
},
"cardReaderOnlineStatus": {
/*ro, opt, object, online status of the authentication unit*/
"@min": 1,
/*ro, opt, int, the minimum value, range:[1,8]*/
"@max": 1
/*ro, opt, int, the maximum value, range:[1,8]*/
},
"netReaderOnlineStatus": {
/*ro, opt, object*/
"@min": 1,
/*ro, opt, int, the minimum value, range:[1,8]*/
"@max": 1
/*ro, opt, int, the maximum value, range:[1,8]*/
},
"POEPortList": {
/*ro, opt, object*/
"@size": 8,
/*ro, opt, int, range:[1,8]*/
"port": {
/*ro, opt, object*/
"@min": 1,
/*ro, opt, int, the minimum value, range:[1,8]*/
"@max": 8
/*ro, opt, int, the maximum value, range:[1,8]*/
},
"readerID": {
/*ro, opt, object*/
"@size": 8,
/*ro, opt, int, range:[1,8]*/
"@min": 1,
/*ro, opt, int, the minimum value, range:[1,8]*/
"@max": 8
/*ro, opt, int, the maximum value, range:[1,8]*/
}
},
"cardReaderAntiDismantleStatus": {
/*ro, opt, object, tampering status of the authentication unit*/
"@min": 1,
/*ro, opt, int*/
"@max": 1
/*ro, opt, int*/
},
"cardReaderVerifyMode": {
/*ro, opt, object, current authentication mode of the authentication unit, desc:1-sleep,2-card+password,3-card,4-card or password,5-fingerprint,6fingerprint+password,7-fingerprint
or card,8-fingerprint+card,9-fingerprint+card+password,10-face or fingerprint or card or password,11-face+fingerprint,12face+password,13-face+card,14-face,15-employee
No.+password,16-fingerprint or password,17-employee No.+fingerprint,18-employee No.+fingerprint+password,19face+fingerprint+card,20-face+password+fingerprint,21-employee
No.+face,22-face or face+card,23-fingerprint or face,24-card or face or password,25-card or
face,26-card or face or fingerprint,27-card or fingerprint or password*/
"@opt": "1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34"
/*ro, opt, string*/
},
"setupAlarmStatus": {
/*ro, opt, object, No. of armed input port*/
"@min": 1,
/*ro, opt, int*/
"@max": 1
/*ro, opt, int*/
},
"alarmInStatus": {
/*ro, opt, object, No. of input port with alarms*/
"@min": 1,
/*ro, opt, int*/
"@max": 1
/*ro, opt, int*/
},
"alarmOutStatus": {
/*ro, opt, object, No. of output port with alarms*/
"@min": 1,
/*ro, opt, int*/
"@max": 1
/*ro, opt, int*/
},
"cardNum": {
/*ro, opt, object, number of added cards*/
"@min": 1,
/*ro, opt, int*/
"@max": 1
/*ro, opt, int*/
},
"fireAlarmStatus": {
/*ro, opt, object, fire alarm status*/
"@opt": "normal,shortCircuit,brokenCircuit"
/*ro, opt, string, "normal","shortCircuit"-short-circuit alarm, "brokenCircuit"-broken-circuit alarm*/
},


},
"batteryChargeStatus": {
/*ro, opt, object, battery charging status*/
"@opt": "charging,uncharged"
/*ro, opt, string, "charging","uncharged”*/
},
"masterChannelControllerStatus": {
/*ro, opt, object, online status of the main lane controller*/
"@opt": "offLine,onLine"
/*ro, opt, string, "offLine"-offline, "onLine"-online*/
},
"slaveChannelControllerStatus": {
/*ro, opt, object, online status of the sub lane controller*/
"@opt": "offLine,onLine"
/*ro, opt, string, "offLine"-offline,"onLine"-online*/
},
"antiSneakServerStatus": {
/*ro, opt, object, anti-passback server status: "disable"-disabled, "normal", "disconnect"-disconnected*/
"@opt": "disable,normal,disconnect"
/*ro, opt, string*/
},
"netStatus": {
/*ro, opt, object, network connection status*/
"@opt": ["connect", "disconnect", "ipConflict"]
/*ro, opt, array, subType:string*/
},
"InterfaceStatusList": {
/*ro, opt, object*/
"@size": 2,
/*ro, opt, int*/
"id": {
/*ro, opt, object*/
"@min": 1,
/*ro, opt, int*/
"@max": 2
/*ro, opt, int*/
},
"netStatus": {
/*ro, opt, object*/
"@opt": ["connect", "disconnect", "ipConflict"]
/*ro, opt, array, subType:string*/
}
},
"signalStatus": {
/*ro, opt, object, signal status*/
"@opt": ["noSignal", "2G", "3G", "4G", "5G"]
/*ro, opt, array, subType:string*/
},
"sipStatus": {
/*ro, opt, object*/
"@opt": ["connect", "disconnect", "unregistered"]
/*ro, opt, array, subType:string*/
},
"ezvizStatus": {
/*ro, opt, object*/
"@opt": ["unregistered", "notAdd", "connect"]
/*ro, opt, array, subType:string*/
},
"voipStatus": {
/*ro, opt, object*/
"@opt": ["unregistered", "connect"]
/*ro, opt, array, subType:string*/
},
"wifiStatus": {
/*ro, opt, object*/
"@opt": ["connect", " disconnect", "connecting", "noModule"]
/*ro, opt, array, subType:string*/
},
"TFCardStatus": {
/*ro, opt, object*/
"@opt": ["mounted", "unmounted"]
/*ro, opt, array, subType:string*/
},
"acrossHostInterlockStatus": {
/*ro, opt, object*/
"@opt": ["disable", "normal", "disconnect"]
/*ro, opt, array, subType:string*/
},
"faceReceivingStatus": {
/*ro, opt, object*/
"@opt": ["receiving", "received"]
/*ro, opt, array, subType:string*/
},
"QRCodeReaderStatusList": {
/*ro, opt, object*/
"id": {
/*ro, opt, object*/
"@min": 1,
/*ro, opt, int*/
"@max": 2
/*ro, opt, int*/
},
"QRCodeReaderStatus": {
/*ro, opt, object*/
"@opt": ["onLine", "offLine"]


"@opt": ["onLine", "offLine"]
/*ro, opt, array, subType:string*/
}
}
}
}
21.25.2 Get the working status of the access controller
Request URL
GET /ISAPI/AccessControl/AcsWorkStatus?format=json
Query Parameter
None
Request Message
None
Response Message
{
"AcsWorkStatus": {
/*ro, req, object*/
"doorLockStatus": [1, 2, 1, 2],
/*ro, opt, enumarray, door lock status (relay status), subType:int, desc:door lock status (relay status): 0 (normally close), 1 (normally open), 2
(short-circuit alarm), 3 (broken-circuit alarm), 4 (exception alarm). For example, [1,2,1,2] indicates that door lock 1 is normally open, door lock 2
triggers short-circuit alarm, door lock 3 is normally open, and door lock 4 triggers short-circuit alarm*/
"doorStatus": [1, 2, 1, 2],
/*ro, opt, enumarray, door (floor) status, subType:int, desc:door (floor) status: 1 (sleep), 2 (remain unlocked (free)), 3 (remain locked
(disabled)), 4 (normal status (controlled)). For example, [1,2,1,2] indicates that door 1 is sleeping, door 2 remains unlocked, door 3 is sleeping, and door
4 remains unlocked*/
"magneticStatus": [1, 2, 1, 2],
/*ro, opt, enumarray, magnetic contact status, subType:int, desc:magnetic contact status: 0 (normally close), 1 (normally open), 2 (short-circuit
alarm), 3 (broken-circuit alarm), 4 (exception alarm). For example, [1,2,1,2] indicates that magnetic contact No.1 is normally open, magnetic contact No.2
triggers short-circuit alarm, magnetic contact No.3 is normally open, and magnetic contact No.4 triggers short-circuit alarm*/
"caseStatus": [1, 3, 5],
/*ro, opt, array, event trigger status, subType:int, desc:event trigger status, e.g., [1,3,5] indicates that event trigger No.1, No.3, and No.5 have
input*/
"batteryVoltage": 50,
/*ro, opt, int, storage battery power voltage, desc:storage battery power voltage, the actual value will be 10 times of this value, unit: Volt*/
"batteryLowVoltage": false,
/*ro, opt, bool, whether the storage battery is in low voltage status, desc:"true” (yes), "false” (no)*/
"powerSupplyStatus": "ACPowerSupply",
/*ro, opt, enum, device power supply status, subType:string, desc:"ACPowerSupply” (alternative current), "BatteryPowerSupply” (storage battery power
supply)*/
"multiDoorInterlockStatus": "close",
/*ro, opt, enum, multi-door interlocking status, subType:string, desc:"close” (disabled), "open” (enabled)*/
"antiSneakStatus": "open",
/*ro, opt, enum, anti-passback status, subType:string, desc:"close” (disabled), "open” (enabled)*/
"hostAntiDismantleStatus": "open",
/*ro, opt, enum, tampering status of the access control device, subType:string, desc:"close” (disabled), "open” (enabled)*/
"indicatorLightStatus": "onLine",
/*ro, opt, enum, indicator status, subType:string, desc:"offLine” (offline), "onLine” (online)*/
"cardReaderOnlineStatus": [1, 3, 5],
/*ro, opt, array, online status of the authentication unit, subType:int, desc:online status of the authentication unit, e.g., [1,3,5] indicates that
authentication unit No.1, No.3, and No.5 are online*/
"netReaderOnlineStatus": [1, 3, 5],
/*ro, opt, array, subType:int*/
"POEPortList": [
/*ro, opt, array, subType:object, range:[1,8]*/
{
"port": 1,
/*ro, req, int, range:[1,8]*/
"readerID": [1, 2, 3]
/*ro, opt, array, subType:int*/
}
],
"cardReaderAntiDismantleStatus": [1, 3, 5],
/*ro, opt, array, tampering status of the authentication unit, subType:int, desc:tampering status of the authentication unit, e.g., [1,3,5]
indicates that the tampering function of authentication unit No.1, No.3, and No.5 is enabled*/
"cardReaderVerifyMode": [3, 5, 3, 5],
/*ro, opt, enumarray, current authentication mode of the authentication unit, subType:int, desc:1 (sleep), 2 (card + password), 3 (card), 4 (card or
password), 5 (fingerprint), 6 (fingerprint + password), 7 (fingerprint or card), 8 (fingerprint + card), 9 (fingerprint + card + password),10 (face or
fingerprint or card or password), 11 (face + fingerprint), 12 (face + password), 13 (face + card), 14 (face), 15 (employee No. + password), 16 (fingerprint
or password), 17 (employee No. + fingerprint), 18 (employee No. + fingerprint + password), 19 (face + fingerprint + card), 20 (face + password +
fingerprint), 21 (employee No. + face), 22 (face or face + card), 23 (fingerprint or face), 24 (card or face or password), 25 (card or face), 26 (card or
face or fingerprint), 27 (card or fingerprint or password). For example, [3,5,3,5] indicates that the authentication mode of authentication unit 1 is
"card", the authentication mode of authentication unit 2 is "fingerprint", the authentication mode of authentication unit 3 is "card", and the
authentication mode of authentication unit 4 is "fingerprint"*/
"setupAlarmStatus": [1, 3, 5],
/*ro, opt, array, No. of armed input port, subType:int, desc:No. of armed input port, e.g., [1,3,5] indicates that input port No.1, No.3, and No.5
are armed*/
"alarmInStatus": [1, 3, 5],
/*ro, opt, array, No. of input port with alarms, subType:int, desc:No. of input port with alarms, e.g., [1,3,5] indicates that input port No.1,
No.3, and No.5 trigger alarms*/
"alarmOutStatus": [1, 3, 5],


"alarmOutStatus": [1, 3, 5],
/*ro, opt, array, No. of output port with alarms, subType:int, desc:No. of output port with alarms, e.g., [1,3,5] indicates that output port No.1,
No.3, and No.5 trigger alarms*/
"cardNum": 3,
/*ro, opt, int, number of added cards, desc:number of added cards*/
"fireAlarmStatus": "normal",
/*ro, opt, enum, fire alarm status, subType:string, desc:fire alarm status: "normal", "shortCircuit” (short-circuit alarm), "brokenCircuit” (brokencircuit
alarm)*/
"batteryChargeStatus": "charging",
/*ro, opt, enum, battery charging status, subType:string, desc:battery charging status: "charging", "uncharged"*/
"masterChannelControllerStatus": "onLine",
/*ro, opt, enum, online status of the main-lane controller, subType:string, desc:online status of the main lane controller: "offLine” (offline),
"onLine” (online)*/
"slaveChannelControllerStatus": "onLine",
/*ro, opt, enum, online status of the sub lane controller, subType:string, desc:online status of the sub lane controller: "offLine” (offline),
"onLine” (online)*/
"antiSneakServerStatus": "normal",
/*ro, opt, enum, anti-passback server status, subType:string, desc:anti-passback server status: "disable” (disabled), "normal", "disconnect”
(disconnected)*/
"netStatus": "connect",
/*ro, opt, enum, subType:string*/
"InterfaceStatusList": [
/*ro, opt, array, subType:object*/
{
"id": 1,
/*ro, opt, int*/
"netStatus": "connect"
/*ro, opt, enum, subType:string*/
}
],
"signalStatus": "noSignal",
/*ro, opt, enum, subType:string*/
"sipStatus": "connect",
/*ro, opt, enum, subType:string*/
"ezvizStatus": "unregistered",
/*ro, opt, enum, subType:string*/
"voipStatus": "unregistered",
/*ro, opt, enum, subType:string*/
"wifiStatus": "connect",
/*ro, opt, enum, subType:string*/
"TFCardStatus": "mounted",
/*ro, opt, enum, subType:string*/
"acrossHostInterlockStatus": "disable",
/*ro, opt, enum, subType:string*/
"faceReceivingStatus": "receiving",
/*ro, opt, enum, subType:string*/
"QRCodeReaderStatusList": [
/*ro, opt, array, subType:object*/
{
"id": 1,
/*ro, opt, int*/
"QRCodeReaderStatus": "onLine"
/*ro, opt, enum, subType:string*/
}
]
}
}
21.25.3 Get the configuration capability of the access controller
Request URL
GET /ISAPI/AccessControl/AcsCfg/capabilities?format=json
Query Parameter
None
Request Message
None
Response Message
{
"AcsCfg": {
/*ro, req, object*/
"RS485Backup": "true,false",
/*ro, opt, string, whether to enable downstream RS-485 communication redundancy, desc:"true” (yes), "false” (no)*/
"showCapPic": "true,false",
/*ro, opt, string, whether to display the captured picture, desc:"true” (yes), "false” (no)*/
"showUserInfo": "true,false",
/*ro, opt, string, whether to display user information, desc:"true” (yes), "false” (no)*/
"overlayUserInfo": "true,false",
/*ro, opt, string, whether to overlay user information, desc:"true” (yes), "false” (no)*/
"voicePrompt": "true,false",
/*ro, opt, string, whether to enable voice prompt, desc:"true” (yes), "false” (no)*/
"uploadCapPic": "true,false",
/*ro, opt, string, whether to upload the picture from linked capture, desc:"true” (yes), "false” (no)*/
"saveCapPic": "true,false",


"saveCapPic": "true,false",
/*ro, opt, string, whether to save the captured picture, desc:"true” (yes), "false” (no)*/
"inputCardNo": "true,false",
/*ro, opt, string, whether to allow inputting card No. on keypad, desc:"true” (yes), "false” (no)*/
"enableWifiDetect": "true,false",
/*ro, opt, string, whether to enable Wi-Fi probe, desc:"true” (yes), "false” (no)*/
"enable3G4G": "true,false",
/*ro, opt, string, whether to enable 3G/4G, desc:"true” (yes), "false” (no)*/
"protocol": {
/*ro, opt, object, communication protocol type of the card reader, desc:"Private” (private protocol), "OSDP” (OSDP protocol)*/
"@opt": "Private,OSDP"
/*ro, opt, string, optional item*/
},
"enableCaptureCertificate": "true,false",
/*ro, opt, string, whether to enable capturing the ID picture, desc:true (yes), false (no). If this node does not exist, it indicates that this
function is not supported*/
"showPicture": "true,false",
/*ro, opt, string, whether to display the authenticated picture, desc:"true” (yes), "false” (no)*/
"showEmployeeNo": "true,false",
/*ro, opt, string, whether to display the authenticated employee ID, desc:"true” (yes), "false” (no)*/
"showName": "true,false",
/*ro, opt, string, whether to display the authenticated name, desc:"true” (yes), "false” (no)*/
"desensitiseEmployeeNo": {
/*ro, opt, object, whether to enable employee No. de-identification for local UI display*/
"@opt": [true, false]
/*ro, opt, array, subType:bool*/
},
"desensitiseName": {
/*ro, opt, object, whether to enable name de-identification for local UI display*/
"@opt": [true, false]
/*ro, opt, array, subType:bool*/
},
"thermalEnabled": {
/*ro, opt, object, whether to enable temperature measurement*/
"@opt": [true, false]
/*ro, opt, array, subType:bool*/
},
"thermalMode": {
/*ro, opt, object, whether to enable temperature measurement only mode: true-enable (only for temperature measurement),false-disable (default)*/
"@opt": [true, false]
/*ro, opt, array, subType:bool*/
},
"thermalPictureEnabled": {
/*ro, opt, object, whether to enable uploading visible light pictures in temperature measurement only mode: true-enable,false-disable (default).
This field is used to control uploading captured pictures and visible light pictures, desc:whether to enable uploading visible light pictures in temperature
measurement only mode: true-enable,false-disable (default). This field is used to control uploading captured pictures and visible light pictures*/
"@opt": [true, false]
/*ro, opt, array, whether to enable uploading visible light pictures in temperature measurement only mode, subType:bool*/
},
"isSupportThermalIp": true,
/*ro, opt, bool, whether it supports configuring IP address of the thermography device, desc:whether it supports configuring IP address of the
thermography device: true-yes,this field is not returned-no*/
"highestThermalThreshold": {
/*ro, opt, object, maximum value of the temperature threshold, desc:float,upper limit of the temperature threshold which is accurate to one decimal
place,unit: Celsius*/
"@min": 1.0,
/*ro, opt, float*/
"@max": 2.0
/*ro, opt, float*/
},
"lowestThermalThreshold": {
/*ro, opt, object, minimum value of the temperature threshold, desc:float,lower limit of the temperature threshold which is accurate to one decimal
place,unit: Celsius*/
"@min": 1.0,
/*ro, opt, float*/
"@max": 2.0
/*ro, opt, float*/
},
"thermalDoorEnabled": {
/*ro, opt, object, whether to open the door according to the temperature threshold, desc:whether to open the door when the temperature is above the
upper limit (highestThermalThreshold) or below the lower limit (lowestThermalThreshold) of the threshold: true (open the door), false (not open the door
(default))*/
"@opt": [true, false]
/*ro, opt, array, subType:bool*/
},
"QRCodeEnabled": {
/*ro, opt, object, whether to enable QR code function, desc:whether to enable QR code function: true-enable,false-disable (default)*/
"@opt": [true, false]
/*ro, opt, array, subType:bool*/
},
"remoteCheckDoorEnabled": {
/*ro, opt, object, whether to enable controlling the door by remote verification, desc:whether to enable controlling the door by remote
verification: true-control,false-not control (default)*/
"@opt": [true, false]
/*ro, opt, array, subType:bool*/
},
"checkChannelType": {
/*ro, opt, object, verification channel type, desc:verification channel type*/
"@opt": ["Ezviz", "ISUP", "ISAPI", "PrivateSDK", "ISAPIListen"]
/*ro, opt, array, subType:string*/
},
"isSupportChannelIp": true,
/*ro, opt, bool, whether it supports configuring IP address of the verification channel, desc:whether it supports configuring IP address of the
verification channel: true-yes,this field is not returned-no*/


verification channel: true-yes,this field is not returned-no*/
"needDeviceCheck": {
/*ro, opt, object*/
"@opt": [true, false]
/*ro, opt, array, subType:bool*/
},
"uploadVerificationPic": "true,false",
/*ro, opt, string, whether to upload the authenticated picture, desc:"true"-yes, "false"-no*/
"saveVerificationPic": "true,false",
/*ro, opt, string, whether to save the authenticated picture, desc:"true” (yes), "false” (no)*/
"saveFacePic": "true,false",
/*ro, opt, string, whether to save the registered face picture, desc:"true” (yes), "false” (no)*/
"thermalUnit": {
/*ro, opt, object, temperature unit, desc:object,temperature unit: "celsius" (default),"fahrenheit"*/
"@opt": ["celsius", "fahrenheit"]
/*ro, opt, array, subType:string*/
},
"highestThermalThresholdF": {
/*ro, opt, object, maximum value of the temperature threshold, desc:the value is accurate to one decimal place, and the unit is Fahrenheit*/
"@min": 1.0,
/*ro, opt, float*/
"@max": 1.0
/*ro, opt, float*/
},
"lowestThermalThresholdF": {
/*ro, opt, object, minimum value of the temperature threshold, desc:the value is accurate to one decimal place, and the unit is Fahrenheit*/
"@min": 1.0,
/*ro, opt, float*/
"@max": 1.0
/*ro, opt, float*/
},
"enable5G": {
/*ro, opt, object, whether to enable 5G*/
"@opt": [true, false]
/*ro, opt, array, subType:bool*/
},
"thermalCompensation": {
/*ro, opt, object, temperature compensation*/
"@min": -99.9,
/*ro, opt, float*/
"@max": 99.9
/*ro, opt, float*/
},
"externalCardReaderEnabled": {
/*ro, opt, object*/
"@opt": [true, false]
/*ro, req, array, subType:bool*/
},
"combinationAuthenticationTimeout": {
/*ro, opt, object*/
"@min": 1,
/*ro, req, int, range:[1,20], step:1, unit:s*/
"@max": 20
/*ro, req, int, range:[1,20], step:1, unit:s*/
},
"combinationAuthenticationLimitOrder": {
/*ro, opt, object*/
"@opt": [true, false]
/*ro, req, array, subType:bool*/
},
"passwordEnabled": {
/*ro, opt, object*/
"@opt": [true, false]
/*ro, req, array, subType:bool*/
},
"showGender": {
/*ro, opt, object, whether to display gender*/
"@opt": [true, false]
/*ro, req, array, subType:bool*/
},
"showSignInTime": {
/*ro, opt, object*/
"@opt": [true, false]
/*ro, req, array, subType:bool*/
},
"showsCustomInfo": {
/*ro, opt, object*/
"@opt": [true, false]
/*ro, req, array, subType:bool*/
},
"showMobileWebQRCode": {
/*ro, opt, object*/
"@opt": [true, false]
/*ro, req, array, subType:bool*/
},
"fireAlarmInputType": {
/*ro, opt, object*/
"@opt": ["alwaysClose", "alwaysOpen"]
/*ro, req, array, subType:string*/
},
"buzzerEnabled": {
/*ro, opt, object*/
"@opt": [true, false]
/*ro, opt, array, subType:bool*/
}


}
}
}
21.25.4 Set the parameters of the access controller
Request URL
PUT /ISAPI/AccessControl/AcsCfg?format=json
Query Parameter
None
Request Message
{
"AcsCfg": {
/*req, object, parameters of the access controller*/
"RS485Backup": true,
/*opt, bool, whether to enable downstream RS-485 communication redundancy*/
"showCapPic": true,
/*opt, bool, whether to display the captured picture*/
"showUserInfo": true,
/*opt, bool, whether to display user information*/
"overlayUserInfo": true,
/*opt, bool, whether to overlay user information*/
"voicePrompt": true,
/*opt, bool, whether to enable voice prompt*/
"uploadCapPic": true,
/*opt, bool, whether to upload the picture from linked capture*/
"saveCapPic": true,
/*opt, bool, whether to save the captured picture*/
"inputCardNo": true,
/*opt, bool, whether to allow inputting card No. on keypad*/
"enableWifiDetect": true,
/*opt, bool, whether to enable Wi-Fi probe*/
"enable3G4G": true,
/*opt, bool, whether to enable 3G/4G*/
"protocol": "Private",
/*opt, enum, communication protocol type of the card reader, subType:string, desc:"Private” (private protocol), "OSDP” (OSDP protocol)*/
"enableCaptureCertificate": true,
/*opt, bool, whether to enable capturing the ID picture, desc:true (yes), false (no). If this node does not exist, it indicates that this function
is not supported*/
"showPicture": true,
/*opt, bool, whether to display the authenticated picture*/
"showEmployeeNo": true,
/*opt, bool, whether to display the authenticated employee ID*/
"showName": true,
/*opt, bool, whether to display the authenticated name*/
"desensitiseEmployeeNo": true,
/*opt, bool, whether to enable employee No. de-identification for local UI display, dep:or,{$.AcsCfg.showEmployeeNo,eq,true}*/
"desensitiseName": true,
/*opt, bool, whether to enable name de-identification for local UI display, dep:or,{$.AcsCfg.showName,eq,true}*/
"thermalEnabled": true,
/*opt, bool, whether to enable temperature measurement*/
"thermalMode": true,
/*opt, bool, whether to enable temperature measurement only mode*/
"thermalPictureEnabled": true,
/*opt, bool, whether to enable uploading visible light pictures in temperature measurement only mode*/
"thermalIp": "192.168.1.1",
/*opt, string, IP address of the thermography device, desc:for access control devices, each device only requires one IP address; for metal detector
doors, this field does not need to be configured*/
"highestThermalThreshold": 37.3,
/*opt, float, maximum value of the temperature threshold*/
"lowestThermalThreshold": 38.5,
/*opt, float, minimum value of the temperature threshold*/
"thermalDoorEnabled": false,
/*opt, bool, whether to open the door when the temperature is above the upper limit (highestThermalThreshold) or below the lower limit
(lowestThermalThreshold) of the threshold: true-open the door,false-not open the door (default), desc:whether to open the door when the temperature is above
the upper limit (highestThermalThreshold) or below the lower limit (lowestThermalThreshold) of the threshold: true (open the door), false (not open the door
(default))*/
"QRCodeEnabled": false,
/*opt, bool, whether to enable QR code function*/
"remoteCheckDoorEnabled": false,
/*opt, bool, whether to enable controlling the door by remote verification*/
"checkChannelType": "Ezviz",
/*opt, enum, verification channel type, subType:string, desc:verification channel type: "Ezviz"-EZVIZ channel,"ISUP"-ISUP channel,"ISAPI"-ISAPI
channel,"PrivateSDK"-private SDK channel,"ISAPIListen"-ISAPI listening channel. This field is valid when remoteCheckDoorEnabled is true*/
"channelIp": "test",
/*opt, string, IP address of the verification channel, desc:this field is valid when checkChannelType is "PrivateSDK"*/
"needDeviceCheck": true,
/*opt, bool, dep:or,{$.AcsCfg.remoteCheckDoorEnabled,eq,true}*/
"uploadVerificationPic": true,
/*opt, bool, whether to upload the authenticated picture*/
"saveVerificationPic": true,
/*opt, bool, whether to save the authenticated picture*/
"saveFacePic": true,
/*opt, bool, whether to save the registered face picture*/


"thermalUnit": "celsius",
/*opt, enum, temperature unit, subType:string, desc:"celsius", "fahrenheit"*/
"highestThermalThresholdF": 1.0,
/*opt, float, the maximum value of the temperature threshold, desc:the value is accurate to one decimal place, and the unit is Fahrenheit this node
is used to check whether to open the door when the temperature is higher than the threshold*/
"lowestThermalThresholdF": 1.0,
/*opt, float, the minimum value of the temperature threshold, desc:the value is accurate to one decimal place, and the unit is Fahrenheit this node
is used to check whether to open the door when the temperature is higher than the threshold*/
"enable5G": true,
/*opt, bool, whether to enable 5G*/
"thermalCompensation": 1.0,
/*opt, float, temperature compensation, desc:float,temperature compensation,the value is accurate to one decimal place. The unit depends on the node
thermalUnit. If the node thermalUnit does not exist,the default unit is Celsius*/
"externalCardReaderEnabled": true,
/*opt, bool*/
"combinationAuthenticationTimeout": 1,
/*opt, int, range:[1,20], step:1, unit:s*/
"combinationAuthenticationLimitOrder": true
/*opt, bool*/
}
}
Response Message
{
"requestURL": "test",
/*ro, opt, string, URI*/
"statusCode": "test",
/*ro, opt, string, status code*/
"statusString": "test",
/*ro, opt, string, status description*/
"subStatusCode": "test",
/*ro, opt, string, sub status code*/
"errorCode": 1,
/*ro, req, int, error code*/
"errorMsg": "ok"
/*ro, req, string, error description*/
}
21.25.5 Get the configuration parameters of the access controller
Request URL
GET /ISAPI/AccessControl/AcsCfg?format=json
Query Parameter
None
Request Message
None
Response Message
{
"AcsCfg": {
/*ro, req, object*/
"RS485Backup": true,
/*ro, opt, bool, whether to enable downstream RS-485 communication redundancy*/
"showCapPic": true,
/*ro, opt, bool, whether to display the captured picture*/
"showUserInfo": true,
/*ro, opt, bool, whether to display user information*/
"overlayUserInfo": true,
/*ro, opt, bool, whether to overlay user information*/
"voicePrompt": true,
/*ro, opt, bool, whether to enable voice prompt*/
"uploadCapPic": true,
/*ro, opt, bool, whether to upload the picture from linked capture*/
"saveCapPic": true,
/*ro, opt, bool, whether to save the captured picture*/
"inputCardNo": true,
/*ro, opt, bool, whether to allow inputting card No. on keypad*/
"enableWifiDetect": true,
/*ro, opt, bool, whether to enable Wi-Fi probe*/
"enable3G4G": true,
/*ro, opt, bool, whether to enable 3G/4G*/
"protocol": "Private",
/*ro, opt, enum, communication protocol type of the card reader, subType:string, desc:"Private” (private protocol), "OSDP” (OSDP protocol)*/
"enableCaptureCertificate": true,
/*ro, opt, bool, whether to enable capturing the ID picture, desc:true (yes), false (no). If this node does not exist, it indicates that this
function is not supported*/
"showPicture": true,
/*ro, opt, bool, whether to display the authenticated picture*/
"showEmployeeNo": true,


"showEmployeeNo": true,
/*ro, opt, bool, whether to display the authenticated employee ID*/
"showName": true,
/*ro, opt, bool, whether to display the authenticated name*/
"desensitiseEmployeeNo": true,
/*ro, opt, bool, whether to enable employee No. de-identification for local UI display, dep:or,{$.AcsCfg.showEmployeeNo,eq,true}*/
"desensitiseName": true,
/*ro, opt, bool, whether to enable name de-identification for local UI display, dep:or,{$.AcsCfg.showName,eq,true}*/
"thermalEnabled": true,
/*ro, opt, bool, whether to enable temperature measurement*/
"thermalMode": true,
/*ro, opt, bool, whether to enable temperature measurement only mode*/
"thermalPictureEnabled": true,
/*ro, opt, bool, whether to enable uploading visible light pictures in temperature measurement only mode: true-enable,false-disable (default). This
field is used to control uploading captured pictures and visible light pictures*/
"thermalIp": "192.168.1.1",
/*ro, opt, string, IP address of the thermography device, desc:for access control devices, each device only requires one IP address; for metal
detector doors, this field does not need to be configured*/
"highestThermalThreshold": 37.3,
/*ro, opt, float, upper limit of the temperature threshold*/
"lowestThermalThreshold": 38.5,
/*ro, opt, float, lower limit of the temperature threshold*/
"thermalDoorEnabled": false,
/*ro, opt, bool, whether to open the door according to the temperature threshold, desc:whether to open the door when the temperature is above the
upper limit (highestThermalThreshold) or below the lower limit (lowestThermalThreshold) of the threshold: true (open the door), false (not open the door
(default))*/
"QRCodeEnabled": false,
/*ro, opt, bool, whether to enable QR code function*/
"remoteCheckDoorEnabled": false,
/*ro, opt, bool, whether to enable controlling the door by remote verification*/
"checkChannelType": "Ezviz",
/*ro, opt, enum, verification channel type, subType:string, desc:verification channel type*/
"channelIp": "test",
/*ro, opt, string, IP address of the verification channel, desc:this field is valid when checkChannelType is "PrivateSDK"*/
"needDeviceCheck": true,
/*ro, opt, bool, dep:or,{$.AcsCfg.remoteCheckDoorEnabled,eq,true}*/
"uploadVerificationPic": true,
/*ro, opt, bool, whether to upload the authenticated picture*/
"saveVerificationPic": true,
/*ro, opt, bool, whether to save the authenticated picture*/
"saveFacePic": true,
/*ro, opt, bool, whether to save the registered face picture*/
"thermalUnit": "celsius",
/*ro, opt, enum, temperature unit, subType:string, desc:"celsius", "fahrenheit"*/
"highestThermalThresholdF": 1.0,
/*ro, opt, float, the maximum value of the temperature threshold, desc:the value is accurate to one decimal place, and the unit is Fahrenheit this
node is used to check whether to open the door when the temperature is higher than the threshold*/
"lowestThermalThresholdF": 1.0,
/*ro, opt, float, the minimum value of the temperature threshold, desc:the value is accurate to one decimal place, and the unit is Fahrenheit this
node is used to check whether to open the door when the temperature is higher than the threshold*/
"enable5G": true,
/*ro, opt, bool, whether to enable 5G*/
"thermalCompensation": 1.0,
/*ro, opt, float, temperature compensation, desc:float,temperature compensation,the value is accurate to one decimal place. The unit depends on the
node thermalUnit. If the node thermalUnit does not exist,the default unit is Celsius*/
"externalCardReaderEnabled": true,
/*ro, opt, bool*/
"combinationAuthenticationTimeout": 1,
/*ro, opt, int, range:[1,20], step:1, unit:s*/
"combinationAuthenticationLimitOrder": true,
/*ro, opt, bool*/
"passwordEnabled": true,
/*ro, opt, bool*/
"showGender": true,
/*ro, opt, bool, whether to display gender*/
"showSignInTime": true,
/*ro, opt, bool*/
"showsCustomInfo": true,
/*ro, opt, bool*/
"showMobileWebQRCode": true,
/*ro, opt, bool*/
"fireAlarmInputType": "alwaysOpen",
/*ro, opt, enum, subType:string*/
"buzzerEnabled": true
/*ro, opt, bool*/
}
}
21.26 Access Point Attendance
21.26.1 Get the configuration capability of the attendance schedule template
Request URL
GET /ISAPI/AccessControl/Attendance/planTemplate/capabilities?format=json
Query Parameter
None


Request Message
None
Response Message
{
"AttendancePlanTemplateCap": {
/*ro, req, object*/
"templateNo": {
/*ro, opt, object, schedule template No.*/
"@min": 1,
/*ro, opt, int, the minimum value*/
"@max": 16
/*ro, opt, int, the maximum value*/
},
"property": {
/*ro, req, object, attendance attribute, desc:"check"-check in and check out, "break"-break out and break in, "overtime"-overtime in and overtime
out*/
"@opt": ["check", "break", "overtime"]
/*ro, opt, array, options, subType:string*/
},
"enable": {
/*ro, opt, object, whether to enable, desc:true (yes), false (no)*/
"@opt": [true, false]
/*ro, opt, array, options, subType:bool*/
},
"templateName": {
/*ro, opt, object, template name*/
"@min": 1,
/*ro, opt, int, the minimum value*/
"@max": 32
/*ro, opt, int, the maximum value*/
},
"weekPlanNo": {
/*ro, opt, object, week schedule No.*/
"@min": 1,
/*ro, opt, int, the minimum value*/
"@max": 16
/*ro, opt, int, the maximum value*/
},
"holidayGroupNo": {
/*ro, opt, object, holiday group No.*/
"@min": 1,
/*ro, opt, int, the minimum value*/
"@max": 16
/*ro, opt, int, the maximum value*/
}
}
}
21.26.2 Get the list of attendance schedule templates
Request URL
GET /ISAPI/AccessControl/Attendance/planTemplate?format=json
Query Parameter
None
Request Message
None
Response Message
{
"AttendancePlanTemplateList": [
/*ro, req, array, subType:object*/
{
"templateNo": 1,
/*ro, req, int, schedule template No., range:[1,16]*/
"enable": true,
/*ro, req, bool, whether to enable the function, desc:true (yes), false (no)*/
"property": "check",
/*ro, opt, enum, subType:string*/
"templateName": "test",
/*ro, req, string, template name, range:[1,32]*/
"weekPlanNo": 1
/*ro, req, int, week schedule No., range:[1,5]*/
}
]
}


21.26.3 Get the configuration capability of attendance check by pressing the key
Request URL
GET /ISAPI/AccessControl/keyCfg/attendance/capabilities?format=json
Query Parameter
None
Request Message
None
Response Message
{
"AttendanceCap": {
/*ro, req, object*/
"id": {
/*ro, req, object, key No.*/
"@min": 0,
/*ro, opt, int, the minimum value*/
"@max": 0
/*ro, opt, int, the maximum value*/
},
"enable": {
/*ro, req, object, whether to enable*/
"@opt": [true, false]
/*ro, opt, array, subType:bool*/
},
"label": {
/*ro, opt, object, custom name*/
"@min": 0,
/*ro, opt, int, the minimum value*/
"@max": 0
/*ro, opt, int, the maximum value*/
},
"attendanceStatus": {
/*ro, opt, object, attendance status, desc:attendance status*/
"@opt": ["checkIn", "checkOut", "breakOut", "breakIn", "overtimeIn", "overtimeOut"]
/*ro, opt, array, subType:string*/
}
}
}
21.26.4 Get the capability of attendance mode parameters
Request URL
GET /ISAPI/AccessControl/Configuration/attendanceMode/capabilities?format=json
Query Parameter
None
Request Message
None
Response Message


{
"AttendanceMode": {
/*ro, req, object, attendance mode*/
"mode": {
/*ro, opt, object, mode of attendance rule, desc:"disable", "manual", "auto", "manualAndAuto" (manual and auto)*/
"@opt": ["disable", "manual", "auto", "manualAndAuto"]
/*ro, opt, array, subType:string*/
},
"attendanceStatusTime": {
/*ro, opt, object, attendance status duration, desc:this node is valid when mode is "manual" or "manualAndAuto"*/
"@min": 0,
/*ro, opt, int, the minimum value*/
"@max": 0
/*ro, opt, int, the maximum value*/
},
"reqAttendanceStatus": {
/*ro, opt, object, whether attendance status is required*/
"@opt": [true, false]
/*ro, opt, array, subType:bool*/
}
}
}
21.26.5 Set the attendance mode parameters
Request URL
PUT /ISAPI/AccessControl/Configuration/attendanceMode?format=json
Query Parameter
None
Request Message
{
"AttendanceMode": {
/*req, object*/
"mode": "disable",
/*opt, enum, attendance mode, subType:string, desc:"disable", "manual", "auto" (automatic), "manualAndAuto" (manual and automatic)*/
"attendanceStatusTime": 0,
/*opt, int, attendance status duration, desc:unit: second; this node is valid when mode is "manual" or "manualAndAuto"*/
"reqAttendanceStatus": true
/*opt, bool, whether the attendance status is required*/
}
}
Response Message
{
"statusCode": 1,
/*ro, opt, int, status code, desc:1 (succeeded). It is required when an error occurred*/
"statusString": "ok",
/*ro, opt, string, status description, range:[1,64], desc:"ok" (succeeded). It is required when an error occurred*/
"subStatusCode": "ok",
/*ro, opt, string, sub status code, range:[1,64], desc:"ok" (succeeded). It is required when an error occurred*/
"errorCode": 1,
/*ro, opt, int, error code, desc:it is required when the value of statusCode is not 1, it corresponds to subStatusCode*/
"errorMsg": "ok"
/*ro, opt, string, error information, desc:this node is required when the value of statusCode is not 1*/
}
21.26.6 Get the attendance mode parameters
Request URL
GET /ISAPI/AccessControl/Configuration/attendanceMode?format=json
Query Parameter
None
Request Message
None
Response Message


{
"AttendanceMode": {
/*ro, req, object*/
"mode": "disable",
/*ro, opt, enum, attendance mode, subType:string, desc:"disable", "manual", "auto"-automatic, "manualAndAuto"-manual and automatic*/
"attendanceStatusTime": 0,
/*ro, opt, int, attendance status duration, desc:unit: second. This node is valid when mode is "manual" or "manualAndAuto"*/
"reqAttendanceStatus": true
/*ro, opt, bool, whether the attendance status is required*/
}
}
21.26.7 Get the capability of configuring weekly attendance schedules
Request URL
GET /ISAPI/AccessControl/Attendance/weekPlan/capabilities?format=json
Query Parameter
None
Request Message
None
Response Message
{
"AttendanceWeekPlanCap": {
/*ro, req, object, the capability of configuring weekly attendance schedules*/
"planNo": {
/*ro, opt, object, weekly schedule No.*/
"@min": 1,
/*ro, opt, int, the minimum value*/
"@max": 16
/*ro, opt, int, the maximum value*/
},
"enable": {
/*ro, opt, object, whether to enable: true-enable,false-disable*/
"@opt": [true, false]
/*ro, opt, array, subType:bool*/
},
"WeekPlanCfg": {
/*ro, opt, object, weekly schedule parameters*/
"maxSize": 5,
/*ro, opt, int*/
"id": {
/*ro, opt, object, time period No.*/
"@min": 1,
/*ro, opt, int*/
"@max": 8
/*ro, opt, int*/
},
"week": {
/*ro, opt, object*/
"@opt": ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"]
/*ro, opt, array, subType:string*/
},
"enable": {
/*ro, opt, object, whether to enable: true-enable,false-disable*/
"@opt": [true, false]
/*ro, opt, array, subType:bool*/
},
"TimeSegment": {
/*ro, opt, object*/
"beginTime": "10:10:00",
/*ro, opt, time, start time (device's local time)*/
"endTime": "12:10:00",
/*ro, opt, time, end time (device's local time)*/
"validUnit": "second"
/*ro, opt, enum, time accuracy, subType:string, desc:"hour", "minute", "second". If this node is not returned, the default time accuracy is
"minute"*/
}
}
}
}
21.26.8 Set the parameters of the week attendance schedule
Request URL
PUT /ISAPI/AccessControl/Attendance/weekPlan/<PlanNo>?format=json


Query Parameter
Parameter Name Parameter Type Description
PlanNo
string
Request Message
{
"AttendanceWeekPlan": {
/*req, object*/
"enable": true,
/*req, bool, whether to enable the function*/
"WeekPlanCfg": [
/*req, array, week schedule parameters, subType:object*/
{
"id": 1,
/*req, int, time period No.*/
"week": "Monday",
/*req, enum, days of the week, subType:string, desc:"Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"*/
"enable": true,
/*req, bool, whether to enable the function*/
"TimeSegment": {
/*req, object, time range*/
"beginTime": "10:10:00",
/*req, time, start time (device's local time)*/
"endTime": "12:10:00"
/*req, time, end time (device's local time)*/
}
}
]
}
}
Response Message
{
"statusCode": 1,
/*ro, opt, int, status code, desc:1 (succeeded). It is required when an error occurred*/
"statusString": "ok",
/*ro, opt, string, status description, range:[1,64], desc:"ok" (succeeded). It is required when an error occurred*/
"subStatusCode": "ok",
/*ro, opt, string, sub status code, range:[1,64], desc:"ok" (succeeded). It is required when an error occurred*/
"errorCode": 1,
/*ro, opt, int, error code, desc:it is required when the value of statusCode is not 1, it corresponds to subStatusCode*/
"errorMsg": "ok"
/*ro, opt, string, error information, desc:this node is required when the value of statusCode is not 1*/
}
21.26.9 Get the parameters of the week attendance schedule
Request URL
GET /ISAPI/AccessControl/Attendance/weekPlan/<PlanNo>?format=json
Query Parameter
Parameter Name Parameter Type Description
PlanNo
string
Request Message
None
Response Message
-
-


{
"AttendanceWeekPlan": {
/*ro, req, object*/
"enable": true,
/*ro, req, bool, whether to enable the function*/
"WeekPlanCfg": [
/*ro, req, array, week schedule parameters, subType:object*/
{
"id": 1,
/*ro, req, int, time period No.*/
"week": "Monday",
/*ro, req, enum, day of a week, subType:string, desc:"Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"*/
"enable": true,
/*ro, req, bool, whether to enable the function*/
"TimeSegment": {
/*ro, req, object, time range*/
"beginTime": "10:10:00",
/*ro, req, time, start time (device's local time)*/
"endTime": "12:10:00"
/*ro, req, time, end time (device's local time)*/
}
}
]
}
}
21.26.10 Set the parameters of the attendance schedule template
Request URL
PUT /ISAPI/AccessControl/Attendance/planTemplate/<TemplateNo>?format=json
Query Parameter
Parameter Name Parameter Type Description
TemplateNo
string
Request Message
{
"AttendancePlanTemplate": {
/*req, object, attendance schedule template*/
"enable": true,
/*req, bool, whether to enable, desc:true (yes), false (no)*/
"property": "check",
/*req, enum, attendance attribute, subType:string, desc:"check” (check in and check out), "break” (break out and break in), "overtime” (overtime in
and overtime out). Only one attendance attribute can be configured for each template*/
"templateName": "test",
/*req, string, template name, range:[1,32]*/
"weekPlanNo": 1
/*req, int, week schedule No., range:[1,5]*/
}
}
Response Message
{
"statusCode": 1,
/*ro, opt, int, status code, desc:1 (succeeded). It is required when an error occurred*/
"statusString": "ok",
/*ro, opt, string, status description, range:[1,64], desc:"ok" (succeeded). It is required when an error occurred*/
"subStatusCode": "ok",
/*ro, opt, string, sub status code, range:[1,64], desc:"ok" (succeeded). It is required when an error occurred*/
"errorCode": 1,
/*ro, opt, int, error code, desc:it is required when the value of statusCode is not 1, it corresponds to subStatusCode*/
"errorMsg": "ok"
/*ro, opt, string, error information, desc:this node is required when the value of statusCode is not 1*/
}
21.26.11 Get the parameters of the attendance schedule template
Request URL
GET /ISAPI/AccessControl/Attendance/planTemplate/<TemplateNo>?format=json
Query Parameter
-


Parameter Name Parameter Type Description
TemplateNo
string
Request Message
None
Response Message
{
"AttendancePlanTemplate": {
/*ro, req, object, attendance schedule template*/
"enable": true,
/*ro, req, bool, whether to enable the function, desc:whether to enable: true-enable,false-disable*/
"property": "check",
/*ro, req, enum, attendance attribute, subType:string, desc:"check” (check in and check out), "break” (break out and break in), "overtime” (overtime
in and overtime out). Only one attendance attribute can be configured for each template*/
"templateName": "test",
/*ro, req, string, template name, range:[1,32]*/
"weekPlanNo": 1
/*ro, req, int, week schedule No., range:[1,5]*/
}
}
21.26.12 Get the parameter configuration of attendance check by pressing the key
Request URL
GET /ISAPI/AccessControl/keyCfg/<keyID>/attendance?format=json
Query Parameter
Parameter Name Parameter Type Description
keyID
string
Request Message
None
Response Message
{
"Attendance": {
/*ro, req, object*/
"enable": true,
/*ro, req, bool, whether to enable*/
"attendanceStatus": "checkIn",
/*ro, opt, enum, attendance status, subType:string, desc:"checkIn” (check in), "checkOut” (check out), "breakOut” (break out), "breakIn” (break in),
"overtimeIn” (overtime in), "overtimeOut” (overtime out)*/
"label": "test"
/*ro, opt, string, self-defined name, range:[1,32]*/
}
}
21.26.13 Set the parameters of attendance check by pressing the key
Request URL
PUT /ISAPI/AccessControl/keyCfg/<keyID>/attendance?format=json
Query Parameter
Parameter Name Parameter Type Description
keyID
string
Request Message
-
-
-


{
"Attendance": {
/*req, object*/
"enable": true,
/*req, bool, whether to enable*/
"attendanceStatus": "checkIn",
/*opt, enum, attendance status, subType:string, desc:"checkIn” (check in), "checkOut” (check out), "breakOut” (break out), "breakIn” (break in),
"overtimeIn” (overtime in), "overtimeOut” (overtime out)*/
"label": "test"
/*opt, string, custom name, range:[1,32]*/
}
}
Response Message
{
"statusCode": 1,
/*ro, opt, int, status code, desc:1 (succeeded). It is required when an error occurred*/
"statusString": "ok",
/*ro, opt, string, status description, range:[1,64], desc:"ok" (succeeded). It is required when an error occurred*/
"subStatusCode": "ok",
/*ro, opt, string, sub status code, range:[1,64], desc:"ok" (succeeded). It is required when an error occurred*/
"errorCode": 1,
/*ro, opt, int, error code, desc:it is required when the value of statusCode is not 1, it corresponds to subStatusCode*/
"errorMsg": "ok"
/*ro, opt, string, error description, desc:this field is required when the value of statusCode is not 1*/
}
21.27 Multi-Factor Authentication
21.27.1 Clear group parameters
Request URL
PUT /ISAPI/AccessControl/ClearGroupCfg?format=json
Query Parameter
None
Request Message
{
"ClearGroupCfg": {
/*opt, object, group parameters*/
"ClearFlags": {
/*opt, object*/
"groupCfg": true
/*req, bool, whether to clear group parameters*/
}
}
}
Response Message
{
"requestURL": "test",
/*ro, opt, string, URI*/
"statusCode": "test",
/*ro, opt, string, status code*/
"statusString": "test",
/*ro, opt, string, status description*/
"subStatusCode": "test",
/*ro, opt, string, sub status code*/
"errorCode": 1,
/*ro, req, int, error code*/
"errorMsg": "ok"
/*ro, req, string, error description*/
}
21.27.2 Get the capability of clearing group parameters
Request URL
GET /ISAPI/AccessControl/ClearGroupCfg/capabilities?format=json


Query Parameter
None
Request Message
None
Response Message
{
"ClearGroupCfg": {
/*ro, opt, object*/
"ClearFlags": {
/*ro, opt, object*/
"groupCfg": "true,false"
/*ro, req, string, group parameters*/
}
}
}
21.27.3 Get the group configuration parameters
Request URL
GET /ISAPI/AccessControl/GroupCfg/<groupID>?format=json
Query Parameter
Parameter Name Parameter Type Description
groupID
string
Request Message
None
Response Message
{
"GroupCfg": {
/*ro, opt, object, group parameters*/
"enable": true,
/*ro, req, bool, whether to enable the function*/
"ValidPeriodCfg": {
/*ro, opt, object, validity period of the group*/
"enable": true,
/*ro, req, bool, whether to enable validity period*/
"beginTime": "1970-01-01T00:00:00+08:00",
/*ro, req, datetime, start time of the validity period (UTC time)*/
"endTime": "1970-01-01T00:00:00+08:00"
/*ro, req, datetime, end time of the validity period (UTC time)*/
},
"groupName": "test"
/*ro, opt, string*/
}
}
-
21.27.4 Set the group parameters
Request URL
PUT /ISAPI/AccessControl/GroupCfg/<groupID>?format=json
Query Parameter
Parameter Name Parameter Type Description
groupID
string
Request Message
-


{
"GroupCfg": {
/*opt, object, group parameters*/
"enable": true,
/*req, bool, whether to enable the group*/
"ValidPeriodCfg": {
/*opt, object, validity period of the group*/
"enable": true,
/*req, bool, whether to enable validity period*/
"beginTime": "1970-01-01T00:00:00+08:00",
/*req, datetime, start time of the validity period (UTC time)*/
"endTime": "1970-01-01T00:00:00+08:00"
/*req, datetime, end time of the validity period (UTC time)*/
},
"groupName": "test"
/*opt, string, group name*/
}
}
Response Message
{
"requestURL": "test",
/*ro, opt, string, request URL*/
"statusCode": "test",
/*ro, opt, string, status code*/
"statusString": "test",
/*ro, opt, string, status description*/
"subStatusCode": "test",
/*ro, opt, string, sub status code*/
"errorCode": 1,
/*ro, req, int, error code*/
"errorMsg": "ok"
/*ro, req, string, error information*/
}
21.27.5 Get the configuration capability of multi-factor authentication mode
Request URL
GET /ISAPI/AccessControl/MultiCardCfg/capabilities?format=json
Query Parameter
None
Request Message
None
Response Message


{
"MultiCardCfg": {
/*ro, opt, object*/
"doorNo": {
/*ro, opt, object, door No.*/
"@min": 1,
/*ro, opt, int, minimum value*/
"@max": 256
/*ro, opt, int, maximum value*/
},
"enable": "true,false",
/*ro, req, string, whether to enable multi-factor authentication*/
"swipeIntervalTimeout": {
/*ro, opt, object, timeout of swiping (authentication) interval*/
"@min": 1,
/*ro, opt, int, minimum value*/
"@max": 255
/*ro, opt, int, maximum value*/
},
"GroupCfg": {
/*ro, opt, object, multi-factor authentication parameters*/
"maxSize": 20,
/*ro, opt, int, maximum value*/
"id": {
/*ro, opt, object, multi-factor authentication No.*/
"@min": 1,
/*ro, opt, int, minimum value*/
"@max": 20
/*ro, opt, int, maximum value*/
},
"enable": "true,false",
/*ro, opt, string, whether to enable multi-factor authentication*/
"enableOfflineVerifyMode": "true,false",
/*ro, opt, string, whether to enable verification mode when the access control device is offline (the super password will replace opening door
remotely)*/
"templateNo": {
/*ro, opt, object, schedule template No. to enable the multi-factor authentication*/
"@min": 1,
/*ro, opt, int, minimum value*/
"@max": 20
/*ro, opt, int, maximum value*/
},
"GroupCombination": {
/*ro, opt, object, parameters of the multi-factor authentication group*/
"maxSize": 8,
/*ro, opt, int, maximum value*/
"enable": "true,false",
/*ro, opt, string, whether to enable multi-factor authentication*/
"memberNum": {
/*ro, opt, object, number of members swiping cards*/
"@min": 1,
/*ro, opt, int, minimum value*/
"@max": 20
/*ro, opt, int, maximum value*/
},
"sequenceNo": {
/*ro, opt, object, serial No. of swiping cards of the multi-factor authentication group*/
"@min": 1,
/*ro, opt, int, minimum value*/
"@max": 8
/*ro, opt, int, maximum value*/
},
"groupNo": {
/*ro, opt, object, group No.*/
"@min": 1,
/*ro, opt, int, minimum value*/
"@max": 20
/*ro, opt, int, the maximum value*/
}
}
}
}
}
21.27.6 Set parameters of multi-factor authentication mode
Request URL
PUT /ISAPI/AccessControl/MultiCardCfg/<doorID>?format=json
Query Parameter
Parameter Name Parameter Type Description
doorID
string
-


Request Message
{
"MultiCardCfg": {
/*opt, object, parameters of multi-factor authentication mode*/
"enable": true,
/*req, bool, whether to enable multi-factor authentication*/
"swipeIntervalTimeout": 10,
/*opt, int, timeout of swiping (authentication) interval*/
"GroupCfg": [
/*opt, array, multi-factor authentication parameters, subType:object*/
{
"id": 1,
/*opt, int, multi-factor authentication No.*/
"enable": true,
/*opt, bool, whether to enable multi-factor authentication*/
"enableOfflineVerifyMode": true,
/*opt, bool, whether to enable verification mode when the access control device is offline (the super password will replace opening door
remotely)*/
"templateNo": 1,
/*opt, int, schedule template No. to enable the multi-factor authentication*/
"GroupCombination": [
/*opt, array, parameters of the multi-factor authentication group, subType:object*/
{
"enable": true,
/*opt, bool, whether to enable multi-factor authentication*/
"memberNum": 3,
/*opt, int, number of members swiping cards*/
"sequenceNo": 1,
/*opt, int, serial No. of swiping cards of the multi-factor authentication group*/
"groupNo": 1
/*opt, int, group No.*/
}
]
}
]
}
}
Response Message
{
"requestURL": "test",
/*ro, opt, string, URI*/
"statusCode": "test",
/*ro, opt, string, status code*/
"statusString": "test",
/*ro, opt, string, status description*/
"subStatusCode": "test",
/*ro, opt, string, sub status code*/
"errorCode": 1,
/*ro, req, int, error code*/
"errorMsg": "ok"
/*ro, req, string, error information*/
}
21.27.7 Get the configuration parameters of multi-factor authentication mode
Request URL
GET /ISAPI/AccessControl/MultiCardCfg/<doorID>?format=json
Query Parameter
Parameter Name Parameter Type Description
doorID
string
Request Message
None
Response Message
-


{
"MultiCardCfg": {
/*ro, opt, object*/
"enable": true,
/*ro, req, bool, whether to enable multi-factor authentication*/
"swipeIntervalTimeout": 10,
/*ro, opt, int, timeout of swiping (authentication) interval*/
"GroupCfg": [
/*ro, opt, array, multi-factor authentication parameters, subType:object*/
{
"id": 1,
/*ro, opt, int, multi-factor authentication No.*/
"enable": true,
/*ro, opt, bool, whether to enable multi-factor authentication*/
"enableOfflineVerifyMode": true,
/*ro, opt, bool, whether to enable verification mode when the access control device is offline (the super password will replace opening door
remotely)*/
"templateNo": 1,
/*ro, opt, int, schedule template No. to enable the multi-factor authentication*/
"GroupCombination": [
/*ro, opt, array, multi-factor authentication parameters, subType:object*/
{
"enable": true,
/*ro, opt, bool, whether to enable multi-factor authentication*/
"memberNum": 3,
/*ro, opt, int, number of members swiping cards*/
"sequenceNo": 1,
/*ro, opt, int, serial No. of swiping cards of the multi-factor authentication group*/
"groupNo": 1
/*ro, opt, int, group No.*/
}
]
}
]
}
}
21.27.8 Get the group configuration capability
Request URL
GET /ISAPI/AccessControl/GroupCfg/capabilities?format=json
Query Parameter
None
Request Message
None
Response Message


{
"GroupCfg": {
/*ro, opt, object, group parameters*/
"groupNo": {
/*ro, opt, object, group No.*/
"@min": 1,
/*ro, opt, int, the minimum value*/
"@max": 1
/*ro, opt, int, the maximum value*/
},
"enable": "true,false",
/*ro, req, string, whether to enable the group*/
"ValidPeriodCfg": {
/*ro, req, object, whether to enable validity period parameters of the group*/
"enable": "true,false",
/*ro, req, string, whether to enable validity period*/
"beginTime": {
/*ro, req, object, start time of the validity period (UTC time)*/
"@min": 1,
/*ro, opt, int, the minimum value*/
"@max": 32
/*ro, opt, int, the maximum value*/
},
"endTime": {
/*ro, req, object, end time of the validity period (UTC time)*/
"@min": 1,
/*ro, opt, int, the minimum value*/
"@max": 32
/*ro, opt, int, the maximum value*/
}
},
"groupName": {
/*ro, opt, object, group name*/
"@min": 1,
/*ro, opt, int, the minimum value*/
"@max": 32
/*ro, opt, int, the maximum value*/
}
}
}
21.28 Access Control Event Management
21.28.1 Clear event card linkage configurations
Request URL
PUT /ISAPI/AccessControl/ClearEventCardLinkageCfg?format=json
Query Parameter
None
Request Message
{
"ClearEventCardLinkageCfg": {
/*req, object*/
"ClearFlags": {
/*opt, object*/
"eventCardLinkage": true
/*req, bool, whether to clear event and card linkage parameters*/
}
}
}
Response Message
{
"statusCode": 1,
/*ro, opt, int, status code, desc:1 (succeeded); it is required when an error occurred*/
"statusString": "ok",
/*ro, opt, string, status description, range:[1,64], desc:"ok" (succeeded); it is required when an error occurred*/
"subStatusCode": "ok",
/*ro, opt, string, sub status code, range:[1,64], desc:"ok" (succeeded); it is required when an error occurred*/
"errorCode": 1,
/*ro, opt, int, error code, desc:when the value of statusCode is not 1, it corresponds to subStatusCode*/
"errorMsg": "ok"
/*ro, opt, string, error information, desc:this node must be returned when the value of statusCode is not 1*/
}


21.28.2 Get the configuration capability of storing access control events
Request URL
GET /ISAPI/AccessControl/AcsEvent/StorageCfg/capabilities?format=json
Query Parameter
None
Request Message
None
Response Message
{
"EventStorageCfgCap": {
/*ro, req, object, configuration capability of event storing*/
"mode": {
/*ro, req, object, event storage method, desc:"regular" (delete old events periodically), "time" (delete old events by specified time), "cycle"
(overwriting)*/
"@opt": ["regular", "time", "cycle"]
/*ro, opt, array, subType:string*/
},
"checkTime": {
/*ro, opt, object, check time, desc:this node is valid when mode is "time". Events that occurred before the check time will be deleted*/
"@min": 0,
/*ro, opt, int, the minimum value*/
"@max": 0
/*ro, opt, int, the maximum value*/
},
"period": {
/*ro, opt, object, time period for deleting old events, desc:this node is valid when mode is "regular"*/
"@min": 10,
/*ro, opt, int, the minimum value*/
"@max": 10
/*ro, opt, int, the maximum value*/
}
}
}
21.28.3 Set the event card linkage parameters
Request URL
PUT /ISAPI/AccessControl/EventCardLinkageCfg/<ACEID>?format=json
Query Parameter
Parameter Name Parameter Type Description
ACEID
string
Request Message
{
"EventCardLinkageCfg": {
/*req, object, event card linkage parameters*/
"proMode": "event",
/*req, enum, linkage type, subType:string, desc:"event” (event linkage), "card” (card linkage), "mac" (MAC address linkage), "employee” (employee
No., i.e., person ID)*/
"EventLinkageInfo": {
/*opt, object, event linkage parameters, desc:it is valid when proMode is "event"*/
"mainEventType": 0,
/*opt, enum, major event type, subType:int, desc:0-device event, 1-alarm input event, 2-access control point event, 3-authentication unit (card
reader, fingerprint module) event*/
"subEventType": 54
/*opt, int, sub event type, desc:minor event type,refer to Event Linkage Types for details*/
},
"CardNoLinkageInfo": {
/*opt, object, card linkage parameters, desc:it is valid when proMode is "card”*/
"cardNo": "test"
/*opt, string, card No.*/
},
"MacAddrLinkageInfo": {
/*opt, object, MAC address linkage parameters, desc:it is valid when proMode is "mac"*/
"MACAddr": "test"
/*opt, string, MAC address linkage parameters*/
},
"EmployeeInfo": {
/*opt, object, employee No. (person ID) linkage parameters, desc:it is valid when proMode is "employee”*/
"employeeNo": "test"
/*opt, string, employee No. (person ID)*/
-


/*opt, string, employee No. (person ID)*/
},
"eventSourceID": 1,
/*opt, int, event source ID, desc:it is valid when proMode is "event". For device event (mainEventType is 0), this field is invalid; for access
control point event (mainEventType is 2), this field refers to the access control point No.; for authentication unit event (mainEventType is 3), this field
refers to the authentication unit No.; for alarm input event (mainEventType is 1), this field refers to the zone alarm input ID or the event alarm input ID
65535-all*/
"alarmout": [1, 3, 5],
/*opt, array, linked alarm output No., subType:int, desc:[1,3,5]: 1-linked alarm output No.1; 3-linked alarm output No.3; 5-linked alarm output
No.5*/
"ReaderAlarmout": [
/*opt, array, subType:object*/
{
"readerID": 1,
/*opt, int, card reader No.*/
"alarmOut": [1, 3, 5],
/*opt, array, subType:int*/
"alarmOutClose": [1, 3, 5]
/*opt, array, linked alarm output No. to disable, subType:int, desc:[1,3,5]: 1-alarm output No.1, 3-alarm output No.3, 5-alarm output No.5*/
}
],
"openDoor": [1, 3, 5],
/*opt, array, linked door No. to open, subType:int, desc:[1,3,5]: 1-linked door No.1, 3-linked door No.3, 5-linked door No.5*/
"closeDoor": [1, 3, 5],
/*opt, array, linked door No. to close, subType:int, desc:[1,3,5]: 1-linked door No.1, 3-linked door No.3, 5-linked door No.5*/
"alwaysOpen": [1, 3, 5],
/*opt, array, linked door No. to remain unlocked, subType:int, desc:[1,3,5]: 1-linked door No.1, 3-linked door No.3, 5-linked door No.5*/
"alwaysClose": [1, 3, 5],
/*opt, array, linked door No. to remain locked, subType:int, desc:[1,3,5]: 1-linked door No.1, 3-linked door No.3, 5-linked door No.5*/
"mainDevBuzzer": true,
/*opt, bool, whether to enable buzzer linkage of the access controller (start buzzing):, desc:false-no, true-yes*/
"capturePic": true,
/*opt, bool, whether to enable capture linkage, desc:false-no, true-yes*/
"readerCapturePic": [1, 2],
/*opt, array, subType:int, range:[0,8]*/
"recordVideo": true,
/*opt, bool, whether to enable recording linkage, desc:false-no, true-yes*/
"readerRecordVideo": [1, 2],
/*opt, array, subType:int, range:[0,8]*/
"mainDevStopBuzzer": true,
/*opt, bool, whether to enable buzzer linkage of access controller (stop buzzing), desc:false-no, true-yes*/
"audioSourceType": "TTS",
/*opt, enum, subType:string*/
"audioDisplayTTSLanguage": "SimChinese",
/*opt, enum, subType:string, dep:and,{$.EventCardLinkageCfg.audioSourceType,eq,TTS}*/
"audioDisplayTTS": "test",
/*opt, string, range:[1,64], dep:and,{$.EventCardLinkageCfg.audioSourceType,eq,TTS}*/
"customAudioID": 1,
/*opt, int, range:[1,65535], dep:and,{$.EventCardLinkageCfg.audioSourceType,eq,customFile}*/
"audioDisplayMode": "close",
/*opt, enum, linked audio announcement mode, subType:string, desc:"close", "single", "loop"*/
"readerBuzzer": [1, 3, 5],
/*opt, array, linked buzzer No., subType:int, desc:[1,3,5]: 1-buzzer No.1, 3-buzzer No.3, 5-buzzer No.5*/
"alarmOutClose": [1, 3, 5],
/*opt, array, linked alarm output No. to disable, subType:int, desc:[1,3,5]: 1-alarm output No.1, 3-alarm output No.3, 5-alarm output No.5*/
"alarmInSetup": [1, 3, 5],
/*opt, array, linked zone No. to arm, subType:int, desc:[1,3,5]: 1-zone No.1, 3-zone No.3, 5-zone No.5*/
"alarmInClose": [1, 3, 5],
/*opt, array, linked zone No. to disarm, subType:int, desc:[1,3,5]: 1-zone No.1, 3-zone No.3, 5-zone No.5*/
"readerStopBuzzer": [1, 3, 5],
/*opt, array, linked buzzer No. to stop buzzing, subType:int, desc:[1,3,5]: 1-buzzer No.1, 3-buzzer No.3, 5-buzzer No.5*/
"duration": 30,
/*opt, int, range:[0,30], unit:s*/
"eventCardLinkageName": "test",
/*opt, string, range:[0,128]*/
"FireMatrixEventSourceList": [
/*opt, array, subType:object, dep:and,{$.EventCardLinkageCfg.EventLinkageInfo.subEventType,eq,52}*/
{
"IoTChannelID": 1,
/*req, int*/
"channels": [1, 2, 3]
/*opt, array, subType:int, range:[0,20]*/
}
],
"Operations": {
/*opt, object*/
"eventSourceIDList": [1, 2],
/*req, array, subType:int*/
"TerminalsInfo": [
/*opt, array, terminal list, subType:object, range:[0,1024]*/
{
"terminalID": 1,
/*req, int, range:[1,1024]*/
"ACPChannels": [1, 2]
/*opt, array, subType:int, range:[0,4]*/
}
],
"audioSource": "audioFile",
/*req, enum, subType:string*/
"materialIdList": [1, 2],
/*opt, array, subType:int, range:[1,128]*/
"speechSynthesisContent": "test",
/*opt, string, range:[0,4096]*/
"voiceType": "male",
/*opt, enum, subType:string*/


/*opt, enum, subType:string*/
"audioLevel": 0,
/*req, int, range:[0,15], step:1*/
"audioVolume": 5,
/*opt, int, range:[0,10]*/
"playMode": "order",
/*opt, enum, play mode, subType:string*/
"duration": 30
/*opt, int, range:[0,3000], unit:s*/
}
}
}
Response Message
{
"requestURL": "test",
/*ro, opt, string, URI*/
"statusCode": "test",
/*ro, opt, string, status code*/
"statusString": "test",
/*ro, opt, string, status description*/
"subStatusCode": "test",
/*ro, opt, string, sub status code*/
"errorCode": 1,
/*ro, req, int, error code*/
"errorMsg": "ok"
/*ro, req, string, error description*/
}
21.28.4 Get the total number of access control events by specific conditions
Request URL
POST /ISAPI/AccessControl/AcsEventTotalNum?format=json
Query Parameter
None
Request Message
{
"AcsEventTotalNumCond": {
/*req, object*/
"major": 1,
/*req, int, major alarm type, desc:(the type value should be transformed to the decimal number), refer to Access Control Event Types for details*/
"minor": 1024,
/*req, int, sub type, step:1, desc:(the type value should be transformed to the decimal number),refer to Access Control Event Types for details*/
"startTime": "1970-01-01+08:00",
/*opt, date, start time (UTC time)*/
"endTime": "1970-01-01+08:00",
/*opt, date, end time (UTC time)*/
"cardNo": "test",
/*opt, string, card No.*/
"name": "test",
/*opt, string, name of the card holder*/
"picEnable": true,
/*opt, bool, whether to upload the picture along with the event information, desc:whether to contain pictures: "true"-yes,"false"-no*/
"beginSerialNo": 1,
/*opt, int, start serial No.*/
"endSerialNo": 100,
/*opt, int, end serial No.*/
"employeeNoString": "test"
/*opt, string, employee No. (person ID), range:[1,32]*/
}
}
Response Message
{
"AcsEventTotalNum": {
/*ro, req, object*/
"totalNum": 1,
/*ro, req, int, total number of events that match the search conditions*/
"existedEventNum": 1
/*ro, opt, int*/
}
}


21.28.5 Get the event and card linkage configuration parameters
Request URL
GET /ISAPI/AccessControl/EventCardLinkageCfg/<ACEID>?format=json
Query Parameter
Parameter Name Parameter Type Description
ACEID
string
Request Message
None
Response Message
{
"EventCardLinkageCfg": {
/*ro, req, object*/
"proMode": "event",
/*ro, req, enum, linkage type, subType:string, desc:"event"-event linkage, "card"-card linkage, "mac"-MAC address linkage, "employee"-employee No.
(person ID)*/
"EventLinkageInfo": {
/*ro, opt, object, event linage parameters, desc:it is valid when proMode is "event”*/
"mainEventType": 0,
/*ro, opt, enum, major event type, subType:int, desc:0-device event,1-alarm input event,2-access control point event,3-authentication unit (card
reader, fingerprint module) event*/
"subEventType": 54
/*ro, opt, int, event sub type, desc:minor event type,refer to Event Linkage Types for details*/
},
"CardNoLinkageInfo": {
/*ro, opt, object, card linkage parameters, desc:it is valid when proMode is "card”*/
"cardNo": "test"
/*ro, opt, string, card No.*/
},
"MacAddrLinkageInfo": {
/*ro, opt, object, MAC address linkage parameters, desc:it is valid when proMode is "mac”*/
"MACAddr": "test"
/*ro, opt, string, physical MAC address*/
},
"EmployeeInfo": {
/*ro, opt, object, employee No. (person ID) linkage parameters, desc:it is valid when proMode is "employee”*/
"employeeNo": "test"
/*ro, opt, string, employee No. (person ID)*/
},
"eventSourceID": 1,
/*ro, opt, int, event source ID, desc:it is valid when proMode is "event",65535-all. For device event (mainEventType is 0),this field is invalid;
for access control point event (mainEventType is 2),this field refers to the access control point No.; for authentication unit event (mainEventType is
3,this field refers to the authentication unit No.; for alarm input event (mainEventType is 1),this field refers to the zone alarm input ID or the event
alarm input ID*/
"alarmout": [1, 3, 5],
/*ro, opt, array, linked alarm output No., subType:int, desc:[1,3,5]: 1-linked alarm output No.1; 3-linked alarm output No.3; 5-linked alarm output
No.5*/
"ReaderAlarmout": [
/*ro, opt, array, subType:object*/
{
"readerID": 1,
/*ro, opt, int, card reader number*/
"alarmOut": [1, 3, 5],
/*ro, opt, array, subType:int*/
"alarmOutClose": [1, 3, 5]
/*ro, opt, array, linked alarm output No. to disable, subType:int, desc:e.g,[1,3,5]: 1-alarm output No.1,3-alarm output No.3,5-alarm output
No.5*/
}
],
"openDoor": [1, 3, 5],
/*ro, opt, array, linked door No. to open, subType:int, desc:[1,3,5]: 1-linked door No.1; 3-linked door No.3; 5-linked door No.5*/
"closeDoor": [1, 3, 5],
/*ro, opt, array, linked door No. to close, subType:int, desc:[1,3,5]: 1-linked door No.1; 3-linked door No.3; 5-linked door No.5*/
"alwaysOpen": [1, 3, 5],
/*ro, opt, array, linked door No. to remain unlocked, subType:int, desc:e.g.,[1,3,5]: 1-linked door No.1; 3-linked door No.3; 5-linked door No.5*/
"alwaysClose": [1, 3, 5],
/*ro, opt, array, linked door No. to remain locked, subType:int, desc:[1,3,5]: 1-linked door No.1; 3-linked door No.3; 5-linked door No.5*/
"mainDevBuzzer": true,
/*ro, opt, bool, whether to enable buzzer linkage of the access controller (start buzzing), desc:"false"-no, "true"-yes*/
"capturePic": true,
/*ro, opt, bool, whether to enable capture linkage, desc:"false"-no, "true"-yes*/
"readerCapturePic": [1, 2],
/*ro, opt, array, subType:int, range:[0,8]*/
"recordVideo": true,
/*ro, opt, bool, whether to enable recording linkage, desc:"false"-no, "true"-yes*/
"readerRecordVideo": [1, 2],
/*ro, opt, array, subType:int, range:[0,8]*/
"mainDevStopBuzzer": true,
/*ro, opt, bool, whether to enable buzzer linkage of access controller (stop buzzing), desc:"false"-no,"true"-yes*/
"audioSourceType": "TTS",
/*ro, opt, enum, subType:string*/
-


/*ro, opt, enum, subType:string*/
"audioDisplayTTSLanguage": "SimChinese",
/*ro, opt, enum, subType:string, dep:and,{$.EventCardLinkageCfg.audioSourceType,eq,TTS}*/
"audioDisplayTTS": "test",
/*ro, opt, string, range:[1,64], dep:and,{$.EventCardLinkageCfg.audioSourceType,eq,TTS}*/
"customAudioID": 1,
/*ro, opt, int, range:[1,65535], dep:and,{$.EventCardLinkageCfg.audioSourceType,eq,customFile}*/
"audioDisplayMode": "close",
/*ro, opt, enum, linked audio announcement mode: "close", "single", "loop", subType:string, desc:linked audio announcement mode:
"close","single","loop"*/
"readerBuzzer": [1, 3, 5],
/*ro, opt, array, linked buzzer No., subType:int, desc:[1,3,5]: 1-buzzer No.1,3-buzzer No.3,5-buzzer No.5*/
"alarmOutClose": [1, 3, 5],
/*ro, opt, array, linked alarm output No. to disable, subType:int, desc:[1,3,5]: 1-alarm output No.1, 3-alarm output No.3,5-alarm output No.5*/
"alarmInSetup": [1, 3, 5],
/*ro, opt, array, linked zone No. to arm, subType:int, desc:[1,3,5]: 1-zone No.1,3-zone No.3,5-zone No.5*/
"alarmInClose": [1, 3, 5],
/*ro, opt, array, linked zone No. to disarm, subType:int, desc:e.g,[1,3,5]: 1-zone No.1,3-zone No.3,5-zone No.5*/
"readerStopBuzzer": [1, 3, 5],
/*ro, opt, array, linked buzzer No. to stop buzzing, subType:int, desc:[1,3,5]: 1-buzzer No.1,3-buzzer No.3,5-buzzer No.*/
"duration": 30,
/*ro, opt, int, range:[0,30], unit:s*/
"eventCardLinkageName": "test",
/*ro, opt, string, range:[0,128]*/
"FireMatrixEventSourceList": [
/*ro, opt, array, subType:object, dep:and,{$.EventCardLinkageCfg.EventLinkageInfo.subEventType,eq,52}*/
{
"IoTChannelID": 1,
/*ro, req, int*/
"channels": [1, 2, 3]
/*ro, opt, array, subType:int, range:[0,20]*/
}
],
"Operations": {
/*ro, opt, object*/
"eventSourceIDList": [1, 2],
/*ro, req, array, subType:int*/
"TerminalsInfo": [
/*ro, opt, array, terminal list, subType:object, range:[0,1024]*/
{
"terminalID": 1,
/*ro, req, int, range:[1,1024]*/
"ACPChannels": [1, 2]
/*ro, opt, array, subType:int, range:[0,4]*/
}
],
"audioSource": "audioFile",
/*ro, req, enum, subType:string*/
"materialIdList": [1, 2],
/*ro, opt, array, subType:int, range:[1,128]*/
"speechSynthesisContent": "test",
/*ro, opt, string, range:[0,4096]*/
"voiceType": "male",
/*ro, opt, enum, subType:string*/
"audioLevel": 0,
/*ro, req, int, range:[0,15], step:1*/
"audioVolume": 5,
/*ro, opt, int, range:[0,10]*/
"playMode": "order",
/*ro, opt, enum, play mode, subType:string*/
"duration": 30
/*ro, opt, int, range:[0,3000], unit:s*/
}
}
}
21.28.6 Search for access control events
Request URL
POST /ISAPI/AccessControl/AcsEvent?format=json
Query Parameter
None
Request Message


{
"AcsEventCond": {
/*req, object, access control events*/
"searchID": "test",
/*req, string, search ID, desc:it is used to check whether the current search requester is the same as the previous one. If they are the same, the
search record will be stored in the device to speed up the next search*/
"searchResultPosition": 0,
/*req, int, the start position of the search result in the result list:, desc:in a single search, if you cannot get all the records in the result
list, you can mark the end position and get the following records after the marked position in the next search. If the maximum number of totalMatches
supported by the device is M and the number of totalMatches stored in the device now is N (N<=M), the valid range of this node is 0 to N-1*/
"maxResults": 30,
/*req, int, the maximum number of search results, which is defined by the device capability, will be returned if the value of maxResults reaches the
limit, desc:if maxResults exceeds the range returned by the device capability, the device will return the maximum number of search results according to the
device capability and will not return error message*/
"major": 1,
/*req, int, major type, desc:the type value should be transformed to the decimal number; see Access Control Event Types for details*/
"minor": 1024,
/*req, int, minor type, desc:the type value should be transformed to the decimal number; see Access Control Event Types for details*/
"startTime": "1970-01-01T00:00:00+08:00",
/*opt, datetime, start time (UTC time)*/
"endTime": "1970-01-01T00:00:00+08:00",
/*opt, datetime, end time (UTC time)*/
"cardNo": "test",
/*opt, string, card No.*/
"name": "test",
/*opt, string, name of the card holder*/
"videoChannel": 1,
/*opt, int, video channel No., range:[1,86400], desc:this node is newly added to DeepinMind devices for attendance*/
"picEnable": true,
/*opt, bool, whether to upload the picture along with the event information, desc:false (no), true (yes, default value); (1. all matched events will
be uploaded without pictures; 2. all matched events will be uploaded with pictures if there are any; 3. if this node is not configured, the default value is
true)*/
"beginSerialNo": 1,
/*opt, int, start serial No.*/
"endSerialNo": 1,
/*opt, int, end serial No.*/
"employeeNoString": "test",
/*opt, string, employee No. (person ID)*/
"timeReverseOrder": true,
/*opt, bool, whether to return events in descending order of time (later events will be returned first), desc:true (yes), false or this node is not
returned (no)*/
"isAbnomalTemperature": true,
/*opt, bool, whether the skin-surface temperature is abnormal*/
"temperatureSearchCond": "all",
/*opt, enum, temperature search condition, subType:string, desc:when this node and isAbnormalTemperature both exist, isAbnormalTemperature is
invalid; "all" (event with temperature), "normal" (event with normal temperature), "abnormal" (event with abnormal temperature)*/
"isAttendanceInfo": true,
/*opt, bool, whether it contains attendance records, desc:this node is newly added to HEOP protocol; if this node is true, main type, minor type,
employee No., name, and time will be returned*/
"hasRecordInfo": true
/*opt, bool*/
}
}
Response Message
{
"AcsEvent": {
/*ro, req, object, access control events*/
"searchID": "test",
/*ro, req, string, search ID, it is used to check whether the current search requester is the same as the previous one. If they are the same, the
search record will be stored in the device to speed up the next search*/
"responseStatusStrg": "OK",
/*ro, req, string, searching status description*/
"numOfMatches": 1,
/*ro, req, int, number of results returned this time*/
"totalMatches": 1,
/*ro, req, int, total number of matched results*/
"InfoList": [
/*ro, opt, array, information list, subType:object*/
{
"major": 1,
/*ro, req, int, major alarm type*/
"minor": 1,
/*ro, req, int, minor alarm type*/
"time": "2016-12-12T17:30:08+08:00",
/*ro, req, string, time (UTC time)*/
"netUser": "test",
/*ro, opt, string, user name*/
"remoteHostAddr": "test",
/*ro, opt, string, remote host address*/
"videoChannel": 1,
/*ro, opt, int, video channel No., range:[1,86400], desc:this node is newly added to DeepinMind devices for attendance*/
"cardNo": "test",
/*ro, opt, string, card No.*/
"cardType": 1,
/*ro, opt, enum, card type, subType:int, desc:1 (normal card), 2 (disability card), 3 (blocklist card), 4 (patrol card), 5 (duress card), 6
(super card), 7 (visitor card), 8 (dismiss card)*/
"whiteListNo": 1,


/*ro, opt, int, allowlist No.*/
"reportChannel": 1,
/*ro, opt, int, channel type for uploading alarm/event*/
"cardReaderKind": 1,
/*ro, opt, int, card reader type: 1 (IC card reader)*/
"cardReaderNo": 1,
/*ro, opt, int, card reader No.*/
"doorNo": 1,
/*ro, opt, int, door or floor No.*/
"verifyNo": 1,
/*ro, opt, int, multi-factor authentication No.*/
"alarmInNo": 1,
/*ro, opt, int, alarm input No.*/
"alarmOutNo": 1,
/*ro, opt, int, alarm output No.*/
"caseSensorNo": 1,
/*ro, opt, int, event trigger No.*/
"RS485No": 1,
/*ro, opt, int, RS-485 channel No.*/
"multiCardGroupNo": 1,
/*ro, opt, int, group No.*/
"accessChannel": 1,
/*ro, opt, int, RS-485 channel No.*/
"deviceNo": 1,
/*ro, opt, int, device No.*/
"distractControlNo": 1,
/*ro, opt, int, distributed controller No.*/
"employeeNoString": "test",
/*ro, opt, string, employee No. (person ID)*/
"localControllerID": 1,
/*ro, opt, int, distributed controller No.*/
"InternetAccess": 1,
/*ro, opt, int, network interface No.*/
"type": 1,
/*ro, opt, int, zone type, desc:0 (instant alarm zone), 1 (24-hour zone), 2 (delayed zone), 3 (internal zone), 4 (key zone), 5 (fire alarm
zone), 6 (perimeter zone), 7 (24-hour silent zone), 8 (24-hour auxiliary zone), 9 (24-hour shock zone), 10 (emergency door open zone), 11 (emergency door
closed zone), 255 (none)*/
"MACAddr": "test",
/*ro, opt, string, MAC address*/
"swipeCardType": 1,
/*ro, opt, enum, card swiping type, subType:int, desc:0 (invalid), 1 (QR code)*/
"serialNo": 1,
/*ro, opt, int, event serial No.*/
"channelControllerID": 1,
/*ro, opt, int, lane controller ID*/
"channelControllerLampID": 1,
/*ro, opt, int, light board ID of lane controller, range:[1,255]*/
"channelControllerIRAdaptorID": 1,
/*ro, opt, int, IR adapter ID of lane controller, range:[1,255]*/
"channelControllerIREmitterID": 1,
/*ro, opt, int, active infrared intrusion detector No. of lane controller, range:[1,255]*/
"userType": "normal",
/*ro, opt, string, person type*/
"currentVerifyMode": "cardAndPw",
/*ro, opt, enum, current authentication mode of the card reader, subType:string, desc:"cardAndPw" (card + password); "card", "cardOrPw"
(card or password), "fp" (fingerprint), "fpAndPw" (fingerprint + password), "fpOrCard" "fingerprint or card", "fpAndCard" (fingerprint + card),
"fpAndCardAndPw" (fingerprint + card + password), "faceOrFpOrCardOrPw" (face or fingerprint or card or password), "faceAndFp" (face + fingerprint),
"faceAndPw" (face + password), "faceAndCard" (face + card), "face", "employeeNoAndPw" (emplyee No. +password), "fpOrPw" (fingerprint or password),
"employeeNoAndFp" (employee No. + fingerprint), "employeeNoAndFpAndPw" (employee No. + fingerprint + password), "faceAndFpAndCard" (face + fingerprint +
card), "faceAndPwAndFp" (face + password + fingerprint), "employeeNoAndFace" (employee No. + face), "faceOrfaceAndCard" (face or face + card), "fpOrface"
(fingerprint or face), "cardOrfaceOrPw" (card or face or password), "faceOrFpOrCardOrPwOrIris" (face or fingerprint or card or password or iris),
"faceOrCardOrPwOrIris" (face or card or password or iris), "sleep", "invalid"*/
"QRCodeInfo": "test",
/*ro, opt, string, QR code information*/
"thermometryUnit": "celsius",
/*ro, opt, enum, temperature unit, subType:string, desc:"celsius" (Celsius, default value), "fahrenheit" (Fahrenheit), "kelvin" (Kelvin)*/
"currTemperature": 36.5,
/*ro, opt, float, skin-surface temperature, which is accurate to one decimal place*/
"isAbnomalTemperature": true,
/*ro, opt, bool, whether the skin-surface temperature is abnormal (true-yes)*/
"RegionCoordinates": {
/*ro, opt, object, coordinates of the skin-surface temperature*/
"positionX": 254,
/*ro, opt, int, normalized X-coordinate which is between 0 and 1000*/
"positionY": 133
/*ro, opt, int, normalized Y-coordinate which is between 0 and 1000*/
},
"mask": "unknown",
/*ro, opt, enum, whether the person wears a mask, subType:string, desc:"unknown"*/
"pictureURL": "test",
/*ro, opt, string, picture URL*/
"filename": "picture1",
/*ro, opt, string, file name, desc:if multiple pictures are returned at a time, filename of each picture should be unique*/
"attendanceStatus": "undefined",
/*ro, opt, enum, attendance status, subType:string, desc:"undefined", "checkIn" (check-in), "checkOut" (check-out), "breakOut" (start of
break), "breakIn" (end of break), "overtimeIn" (start of overtime), "overTimeOut" (end of overtime)*/
"label": "test",
/*ro, opt, string, custom attendance name*/
"statusValue": 1,
/*ro, opt, int, status value*/
"helmet": "unknown",
/*ro, opt, enum, whether the person wears a hard hat, subType:string, desc:"unknown", "yes", "no"*/
"visibleLightPicUrl": "test",
/*ro, opt, string, visible light picture URL*/


/*ro, opt, string, visible light picture URL*/
"thermalPicUrl": "test",
/*ro, opt, string, URL of the thermal imaging picture*/
"appType": "attendance",
/*ro, opt, enum, application type, subType:string, desc:"attendance" (Time & Attendance module), "signIn" (Check-In module, which is only
used for FocSign products)*/
"HealthInfo": {
/*ro, opt, object, health information*/
"healthCode": 1,
/*ro, opt, enum, health code status, subType:int, desc:0 (no request), 1 (no health code), 2 (green QR code), 3 (yellow QR code), 4 (red
QR code), 5 (no such person), 6 (other error, e.g., searching failed due to API exception), 7 (searching for the health code timed out)*/
"NADCode": 1,
/*ro, opt, enum, nucleic acid test result, subType:int, desc:0 (no result), 1 (negative, which means normal), 2 (positive, which means
diagnosed), 3 (the result has expired)*/
"travelCode": 1,
/*ro, opt, enum, trip code, subType:int, desc:0 (no trip in the past 14 days), 1 (has left the current area in the past 14 days), 2 (has
been to the high-risk area in the past 14 days), 3 (other)*/
"travelInfo": "test",
/*ro, opt, string*/
"vaccineStatus": 1,
/*ro, opt, enum, whether the person is vaccinated, subType:int, desc:0 (not vaccinated), 1 (vaccinated)*/
"vaccineNum": 1
/*ro, opt, int, step:1*/
},
"meetingID": "test",
/*ro, opt, string, meeting ID*/
"PersonInfoExtends": [
/*ro, opt, array, additional person information, subType:object, desc:this node displays additional person information on the device*/
{
"id": 1,
/*ro, opt, int, extended ID of the additional person information, range:[1,32], desc:related URL:
/ISAPI/AccessControl/personInfoExtendName?format=json; this node is used for displaying the name of value; if ID does not exists, it starts from 1*/
"value": "test"
/*ro, opt, string, extended content of the additional person information*/
}
],
"name": "test",
/*ro, opt, string, name, desc:person name*/
"FaceRect": {
/*ro, opt, object, rectangle frame for human face, desc:the origin is the upper-left corner of the screen*/
"height": 1.000,
/*ro, req, float, height, range:[0.000,1.000]*/
"width": 1.000,
/*ro, req, float, width, range:[0.000,1.000]*/
"x": 0.000,
/*ro, req, float, X-coordinate of the upper-left corner of the frame, range:[0.000,1.000]*/
"y": 0.000
/*ro, req, float, Y-coordinate of the upper-left corner of the frame, range:[0.000,1.000]*/
},
"RecordInfo": {
/*ro, opt, object*/
"startTime": "1970-01-01T00:00:00+08:00",
/*ro, opt, datetime, recording start time*/
"endTime": "1970-01-01T00:00:00+08:00",
/*ro, opt, datetime, recording end time*/
"playbackURL": "rtsp://10.65.130.168:554/ISAPI/Streaming/tracks/201/?starttime=20190213T091134Z&amp;endtime=20190213T092116Z"
/*ro, opt, string, range:[0,256]*/
},
"currentAuthenticationTimes": 1,
/*ro, opt, int, range:[0,255], step:1*/
"allowAuthenticationTimes": 1
/*ro, opt, int, range:[0,255], step:1*/
}
]
}
}
21.28.7 Get the capability of searching for access control events
Request URL
GET /ISAPI/AccessControl/AcsEvent/capabilities?format=json
Query Parameter
None
Request Message
None
Response Message
{
"AcsEvent": {
/*ro, req, object, access control events*/
"AcsEventCond": {
/*ro, opt, object, search conditions*/
"searchID": {


/*ro, req, object, search ID, it is used to check whether the current search requester is the same as the previous one. If they are the same,
the search record will be stored in the device to speed up the next search*/
"@min": 1,
/*ro, req, int, the minimum value*/
"@max": 1
/*ro, req, int, the maximum value*/
},
"searchResultPosition": {
/*ro, req, object, the start position of the search result in the result list*/
"@min": 1,
/*ro, req, int, the minimum value*/
"@max": 1
/*ro, req, int, the maximum value*/
},
"maxResults": {
/*ro, req, object, the maximum number of search results that can be obtained by calling this URL*/
"@min": 1,
/*ro, req, int, the minimum value*/
"@max": 1
/*ro, req, int, the maximum value*/
},
"major": {
/*ro, opt, object, major alarm type (the type value should be transformed to the decimal number)*/
"@opt": "0,1,2,3,5"
/*ro, req, string, major type*/
},
"minorAlarm": {
/*ro, opt, object, minor alarm type (the type value should be transformed to the decimal number)*/
"@opt": "1024,1025,1026,1027…"
/*ro, req, string, minor alarm type*/
},
"minorException": {
/*ro, opt, object, minor exception type (the type value should be transformed to the decimal number)*/
"@opt": "39,58,59,1024…"
/*ro, req, string, minor exception type*/
},
"minorOperation": {
/*ro, opt, object, minor operation type (the type value should be transformed to the decimal number)*/
"@opt": "80,90,112,113…"
/*ro, req, string, minor operation type*/
},
"minorEvent": {
/*ro, opt, object, minor event type (the type value should be transformed to the decimal number)*/
"@opt": "1,2,3,4…"
/*ro, req, string, minor event type*/
},
"startTime": {
/*ro, opt, object, start time*/
"@min": 0,
/*ro, req, int, the minimum value, range:[0,32]*/
"@max": 32
/*ro, req, int, the maximum value, range:[0,32]*/
},
"endTime": {
/*ro, opt, object, end time*/
"@min": 0,
/*ro, req, int, the minimum value, range:[0,32]*/
"@max": 32
/*ro, req, int, the maximum value, range:[0,32]*/
},
"cardNo": {
/*ro, opt, object, card No.*/
"@min": 1,
/*ro, req, int, the minimum value*/
"@max": 1
/*ro, req, int, the maximum value*/
},
"name": {
/*ro, opt, object, name of the card holder*/
"@min": 1,
/*ro, req, int, the minimum value*/
"@max": 1
/*ro, req, int, the maximum value*/
},
"videoChannel": {
/*ro, opt, object, video channel No. (this node is newly added to DeepinMind devices for attendance)*/
"@min": 1,
/*ro, req, int, the minimum value*/
"@max": 1
/*ro, req, int, the maximum value*/
},
"picEnable": "true,false",
/*ro, opt, string, whether to include pictures*/
"beginSerialNo": {
/*ro, opt, object, start serial No.*/
"@min": 1,
/*ro, req, int, the minimum value*/
"@max": 1
/*ro, req, int, the maximum value*/
},
"endSerialNo": {
/*ro, opt, object, end serial No.*/
"@min": 1,
/*ro, req, int, the minimum value*/


/*ro, req, int, the minimum value*/
"@max": 1
/*ro, req, int, the maximum value*/
},
"employeeNoString": {
/*ro, opt, object, employee No.*/
"@min": 1,
/*ro, req, int, the minimum value*/
"@max": 1
/*ro, req, int, the maximum value*/
},
"isAbnomalTemperature": {
/*ro, opt, object, whether the skin-surface temperature is abnormal*/
"@opt": [true, false]
/*ro, req, array, options, subType:bool, desc:true (yes), false (no)*/
},
"temperatureSearchCond": {
/*ro, opt, object, temperature search condition*/
"@opt": ["all", "normal", "abnormal"]
/*ro, req, array, options, subType:string*/
},
"isAttendanceInfo": {
/*ro, opt, object, whether it contains attendance records*/
"@opt": [true, false]
/*ro, req, array, options, subType:bool, desc:true (yes), false (no)*/
},
"hasRecordInfo": {
/*ro, opt, object*/
"@opt": [true, false]
/*ro, req, array, subType:bool*/
}
},
"InfoList": {
/*ro, opt, object, information list*/
"maxSize": 10,
/*ro, opt, int, the maximum value*/
"time": {
/*ro, opt, object, time (UTC time)*/
"@min": 0,
/*ro, req, int, the minimum value, range:[0,32]*/
"@max": 32
/*ro, req, int, the maximum value, range:[0,32]*/
},
"netUser": {
/*ro, opt, object, user name*/
"@min": 1,
/*ro, req, int, the minimum value*/
"@max": 1
/*ro, req, int, the maximum value*/
},
"remoteHostAddr": {
/*ro, opt, object, remote host address*/
"@min": 1,
/*ro, req, int, the minimum value*/
"@max": 1
/*ro, req, int, the maximum value*/
},
"cardNo": {
/*ro, opt, object, card No.*/
"@min": 1,
/*ro, req, int, the minimum value*/
"@max": 1
/*ro, req, int, the maximum value*/
},
"cardType": {
/*ro, opt, object, card type*/
"@opt": "1,2,3,4,5,6,7,8"
/*ro, req, string, 1 (normal card), 2 (disability card), 3 (blocklist card), 4 (patrol card), 5 (duress card), 6 (super card), 7 (visitor
card), 8 (dismiss card)*/
},
"whiteListNo": {
/*ro, opt, object, allowlist No.*/
"@min": 1,
/*ro, req, int, the minimum value*/
"@max": 1
/*ro, req, int, the maximum value*/
},
"reportChannel": {
/*ro, opt, object, channel type for uploading alarms/events*/
"@opt": "1,2,3"
/*ro, req, string, "1" (for uploading arming information), "2" (for uploading by central group 1), "3" (for uploading by central group 2)*/
},
"cardReaderKind": {
/*ro, opt, object, card reader type*/
"@opt": "1,2,3,4"
/*ro, req, string, "1" (IC card reader), "2" (ID card reader), "3" (QR code scanner), "4" (fingerprint module)*/
},
"cardReaderNo": {
/*ro, opt, object, card reader No.*/
"@min": 1,
/*ro, req, int, the minimum value*/
"@max": 1
/*ro, req, int, the maximum value*/
},


},
"doorNo": {
/*ro, opt, object, door (floor) No.*/
"@min": 1,
/*ro, req, int, the minimum value*/
"@max": 1
/*ro, req, int, the maximum value*/
},
"verifyNo": {
/*ro, opt, object, multiple authentication No.*/
"@min": 1,
/*ro, req, int, the minimum value*/
"@max": 1
/*ro, req, int, the maximum value*/
},
"alarmInNo": {
/*ro, opt, object, alarm input No.*/
"@min": 1,
/*ro, req, int, the minimum value*/
"@max": 1
/*ro, req, int, the maximum value*/
},
"alarmOutNo": {
/*ro, opt, object, alarm output No.*/
"@min": 1,
/*ro, req, int, the minimum value*/
"@max": 1
/*ro, req, int, the maximum value*/
},
"caseSensorNo": {
/*ro, opt, object, event trigger No.*/
"@min": 1,
/*ro, req, int, the minimum value*/
"@max": 1
/*ro, req, int, the maximum value*/
},
"RS485No": {
/*ro, opt, object, RS-485 channel No.*/
"@min": 1,
/*ro, req, int, the minimum value*/
"@max": 1
/*ro, req, int, the maximum value*/
},
"multiCardGroupNo": {
/*ro, opt, object, group No.*/
"@min": 1,
/*ro, req, int, the minimum value*/
"@max": 1
/*ro, req, int, the maximum value*/
},
"accessChannel": {
/*ro, opt, object, turnstile No.*/
"@min": 1,
/*ro, req, int, the minimum value*/
"@max": 1
/*ro, req, int, the maximum value*/
},
"deviceNo": {
/*ro, opt, object, device No.*/
"@min": 1,
/*ro, req, int, the minimum value*/
"@max": 1
/*ro, req, int, the maximum value*/
},
"distractControlNo": {
/*ro, opt, object, distributed access controller No.*/
"@min": 1,
/*ro, req, int, the minimum value*/
"@max": 1
/*ro, req, int, the maximum value*/
},
"employeeNo": {
/*ro, opt, object, employee No. (person ID)*/
"@min": 1,
/*ro, req, int, the minimum value*/
"@max": 1
/*ro, req, int, the maximum value*/
},
"localControllerID": {
/*ro, opt, object, distributed access controller No.*/
"@min": 1,
/*ro, req, int, the minimum value*/
"@max": 1
/*ro, req, int, the maximum value*/
},
"InternetAccess": {
/*ro, opt, object, network interface No.*/
"@min": 1,
/*ro, req, int, the minimum value*/
"@max": 1
/*ro, req, int, the maximum value*/
},
"type": {
/*ro, opt, object, zone type*/
"@opt": "0,1,2,3,4,5,6,7,8,9,10,11,255"


"@opt": "0,1,2,3,4,5,6,7,8,9,10,11,255"
/*ro, req, string, 0 (instant alarm zone), 1 (24-hour zone), 2 (delayed zone), 3 (internal zone), 4 (key zone), 5 (fire alarm zone), 6
(perimeter zone), 7 (24-hour silent zone), 8 (24-hour auxiliary zone), 9 (24-hour shock zone), 10 (emergency door open zone), 11 (emergency door closed
zone), 255 (none)*/
},
"MACAddr": {
/*ro, opt, object, MAC Address*/
"@min": 1,
/*ro, req, int, the minimum value*/
"@max": 1
/*ro, req, int, the maximum value*/
},
"swipeCardType": {
/*ro, opt, object, card swiping type*/
"@opt": "0,1"
/*ro, req, string, "0" (invalid), "1" (QR code)*/
},
"serialNo": {
/*ro, opt, object, event serial No.*/
"@min": 1,
/*ro, req, int, the minimum value*/
"@max": 1
/*ro, req, int, the maximum value*/
},
"channelControllerID": {
/*ro, opt, object, lane controller No.*/
"@opt": "0,1"
/*ro, req, string, "1" (main lane controller), "2" (sub lane controller)*/
},
"channelControllerLampID": {
/*ro, opt, object, light board ID of lane controller*/
"@min": 1,
/*ro, req, int, the minimum value*/
"@max": 1
/*ro, req, int, the maximum value*/
},
"channelControllerIRAdaptorID": {
/*ro, opt, object, IR adapter No. of lane controller*/
"@min": 1,
/*ro, req, int, the minimum value*/
"@max": 1
/*ro, req, int, the maximum value*/
},
"channelControllerIREmitterID": {
/*ro, opt, object, active infrared intrusion detector No. of lane controller*/
"@min": 1,
/*ro, req, int, the minimum value*/
"@max": 1
/*ro, req, int, the maximum value*/
},
"userType": {
/*ro, opt, object, person types*/
"@opt": "normal,visitor,blackList,administrators"
/*ro, req, string, "normal" (normal person (household)), "visitor" (visitor), "blacklist" (person in blocklist), "administrators"
(administrator)*/
},
"currentVerifyMode": {
/*ro, opt, object, current authentication mode of the card reader*/
"@opt":
"cardAndPw,card,cardOrPw,fp,fpAndPw,fpOrCard,fpAndCard,fpAndCardAndPw,faceOrFpOrCardOrPw,faceAndFp,faceAndPw,faceAndCard,face,employeeNoAndPw,fpOrPw,employe
eNoAndFp,employeeNoAndFpAndPw,faceAndFpAndCard,faceAndPwAndFp,employeeNoAndFace,faceOrfaceAndCard,fpOrface,cardOrfaceOrPw,iris,faceOrFpOrCardOrPwOrIris,face
OrCardOrPwOrIris"
/*ro, req, string, "cardAndPw"-card+password, "card", "cardOrPw"-card or password, "fp"-fingerprint, "fpAndPw"-fingerprint+password,
"fpOrCard"-fingerprint or card, "fpAndCard"-fingerprint+card, "fpAndCardAndPw"-fingerprint+card+password, "faceOrFpOrCardOrPw"-face or fingerprint or card
or password, "faceAndFp"-face+fingerprint, "faceAndPw"-face+password, "faceAndCard"-face+card, "face", "employeeNoAndPw"-employee No.+password, "fpOrPw"fingerprint
or password, "employeeNoAndFp"-employee No.+fingerprint, "employeeNoAndFpAndPw"-employee No.+fingerprint+password, "faceAndFpAndCard"face+fingerprint+card,
"faceAndPwAndFp"-face+password+fingerprint, "employeeNoAndFace"-employee No.+face, "faceOrfaceAndCard"-face or face+card, "fpOrface"fingerprint
or face, "cardOrfaceOrPw"-card or face or password, "cardOrFpOrPw"-card or fingerprint or password*/
},
"QRCodeInfo": {
/*ro, opt, object, QR code information*/
"@min": 1,
/*ro, req, int, the minimum value*/
"@max": 1
/*ro, req, int, the maximum value*/
},
"thermometryUnit": {
/*ro, opt, object, temperature unit*/
"@opt": ["celsius", "fahrenheit", "kelvin"]
/*ro, req, array, "celsius" (Celsius (default)), "fahrenheit" (Fahrenheit), "kelvin" (Kelvin), subType:string*/
},
"currTemperature": {
/*ro, opt, object, skin-surface temperature*/
"@min": 1,
/*ro, req, int, skin-surface temperature, which is accurate to one decimal place*/
"@max": 1
/*ro, req, int, skin-surface temperature, which is accurate to one decimal place*/
},
"isAbnomalTemperature": {
/*ro, opt, object, whether the skin-surface temperature is abnormal*/
"@opt": [true, false]
/*ro, req, array, whether the skin-surface temperature is abnormal (true-yes), subType:bool*/
},
"RegionCoordinates": {


"RegionCoordinates": {
/*ro, opt, object, coordinates of the skin-surface temperature*/
"positionX": {
/*ro, opt, object, X-coordinate*/
"@min": 0,
/*ro, req, int, the minimum value, normalized X-coordinate which is between 0 and 1000*/
"@max": 1000
/*ro, req, int, the maximum value, normalized X-coordinate which is between 0 and 1000*/
},
"positionY": {
/*ro, opt, object, Y-coordinate*/
"@min": 0,
/*ro, req, int, the minimum value, normalized Y-coordinate which is between 0 and 1000*/
"@max": 1000
/*ro, req, int, the maximum value, normalized Y-coordinate which is between 0 and 1000*/
}
},
"mask": {
/*ro, opt, object, whether the person is wearing mask*/
"@opt": ["unknown", "yes", "no"]
/*ro, req, array, "unknown", "yes", "no", subType:string*/
},
"pictureURL": {
/*ro, opt, object, URL of the captured picture*/
"@min": 1,
/*ro, req, int, the minimum value*/
"@max": 1
/*ro, req, int, the maximum value*/
},
"filename": {
/*ro, opt, object, file name, desc:if multiple pictures are returned, the file name of each picture should be unique*/
"@min": 1,
/*ro, req, int, the minimum value*/
"@max": 1
/*ro, req, int, the maximum value*/
},
"attendanceStatus": {
/*ro, opt, object, attendance status, desc:"undefined", "checkIn" (check-in), "checkOut" (check-out), "breakOut" (start of break), "breakIn"
(end of break), "overtimeIn" (start of overtime), "overTimeOut" (end of overtime)*/
"@opt": "undefined,checkIn,checkOut,breakOut,breakIn,overtimeIn,overtimeOut"
/*ro, req, string, options*/
},
"label": {
/*ro, opt, object, self-defined attendance name*/
"@min": 1,
/*ro, req, int, the minimum value*/
"@max": 1
/*ro, req, int, the maximum value*/
},
"statusValue": {
/*ro, opt, object, status value*/
"@min": 1,
/*ro, req, int, the minimum value*/
"@max": 1
/*ro, req, int, the maximum value*/
},
"helmet": {
/*ro, opt, object, whether the person is wearing hard hat, desc:"unknown", "yes", "no"*/
"@opt": "unknown,yes,no"
/*ro, req, string, options*/
},
"visibleLightPicUrl": {
/*ro, opt, object, URL of the visible light picture*/
"@min": 1,
/*ro, req, int, the minimum value*/
"@max": 1
/*ro, req, int, the maximum value*/
},
"thermalPicUrl": {
/*ro, opt, object, URL of the thermal imaging picture*/
"@min": 1,
/*ro, req, int, the minimum value*/
"@max": 1
/*ro, req, int, the maximum value*/
},
"HealthInfo": {
/*ro, opt, object, health information*/
"healthCode": {
/*ro, opt, object, health code status*/
"@opt": [0, 1, 2, 3, 4, 5, 6, 7]
/*ro, req, array, options, subType:int, desc:0 (no request), 1 (no health code), 2 (green QR code), 3 (yellow QR code), 4 (red QR code),
5 (no such person), 6 (other error, e.g., searching failed due to API exception), 7 (searching for the health code timed out)*/
},
"NADCode": {
/*ro, opt, object, nucleic acid test result, desc:0 (no result), 1 (negative, which means normal), 2 (positive, which means diagnosed), 3
(the result has expired)*/
"@opt": [0, 1, 2, 3, 4]
/*ro, req, array, options, subType:int*/
},
"travelCode": {
/*ro, opt, object, trip code, desc:0 (no trip in the past 14 days), 1 (has left the current area left in the past 14 days), 2 (has been to
the high-risk area in the past 14 days), 3 (other)*/
"@opt": [0, 1, 2, 3, 4]
/*ro, req, array, options, subType:int*/
},


},
"travelInfo": {
/*ro, opt, object*/
"@min": 0,
/*ro, req, int, step:1*/
"@max": 15
/*ro, req, int, step:1*/
},
"vaccineStatus": {
/*ro, opt, object, whether the person is vaccinated, desc:0 (not vaccinated), 1 (vaccinated)*/
"@opt": [0, 1, 2, 3, 4]
/*ro, req, array, options, subType:int*/
},
"vaccineNum": {
/*ro, opt, object*/
"@min": 0,
/*ro, req, int, step:1*/
"@max": 3
/*ro, req, int, step:1*/
}
},
"meetingID": {
/*ro, opt, object, meeting ID*/
"@min": 1,
/*ro, req, int, the minimum value*/
"@max": 32
/*ro, req, int, the maximum value*/
},
"PersonInfoExtends": {
/*ro, opt, object, extended nodes for the additional person information*/
"maxSize": 3,
/*ro, req, int, range of members in the array*/
"id": {
/*ro, opt, object, extended ID of the additional person information*/
"@min": 1,
/*ro, req, int, the minimum value*/
"@max": 32
/*ro, req, int, the maximum value*/
},
"value": {
/*ro, opt, object, extended content of the additional person information*/
"@min": 0,
/*ro, req, int, the minimum value*/
"@max": 100
/*ro, req, int, the maximum value*/
}
},
"name": {
/*ro, opt, object, name*/
"@min": 1,
/*ro, req, int, the minimum value*/
"@max": 128
/*ro, req, int, the maximum value*/
},
"FaceRect": {
/*ro, opt, object, rectangle frame for human face, desc:the origin is the upper-left corner of the screen*/
"height": {
/*ro, req, object, height*/
"@min": 0.000,
/*ro, req, float, the minimum value*/
"@max": 1.000
/*ro, req, float, the maximum value*/
},
"width": {
/*ro, req, object, width*/
"@min": 0.000,
/*ro, req, float, the minimum value*/
"@max": 1.000
/*ro, req, float, the maximum value*/
},
"x": {
/*ro, req, object, X-coordinate of the upper-left corner of the frame*/
"@min": 0.000,
/*ro, req, float, the minimum value*/
"@max": 1.000
/*ro, req, float, the maximum value*/
},
"y": {
/*ro, req, object, Y-coordinate of the upper-left corner of the frame*/
"@min": 0.000,
/*ro, req, float, the minimum value*/
"@max": 1.000
/*ro, req, float, the maximum value*/
}
},
"RecordInfo": {
/*ro, opt, object*/
"startTime": "1970-01-01T00:00:00+08:00",
/*ro, opt, datetime*/
"endTime": "1970-01-01T00:00:00+08:00",
/*ro, opt, datetime*/
"playbackURL": {
/*ro, opt, object*/
"@min": 0,


"@min": 0,
/*ro, req, int, the minimum length*/
"@max": 256
/*ro, req, int, the maximum length*/
}
},
"currentAuthenticationTimes": {
/*ro, req, object*/
"@min": 0,
/*ro, req, int*/
"@max": 255
/*ro, req, int*/
},
"allowAuthenticationTimes": {
/*ro, req, object*/
"@min": 0,
/*ro, req, int*/
"@max": 255
/*ro, req, int*/
}
}
}
}
21.28.8 Get the configuration capability of the event and card linkage
Request URL
GET /ISAPI/AccessControl/EventCardLinkageCfg/capabilities?format=json
Query Parameter
None
Request Message
None
Response Message
{
"EventCardLinkageCfg": {
/*ro, req, object, parameters of the event and card linkage*/
"eventID": {
/*ro, opt, object, event ID*/
"@min": 1,
/*ro, opt, int*/
"@max": 1
/*ro, opt, int*/
},
"proMode": {
/*ro, req, object, linkage type*/
"@opt": "event,card,mac,employee"
/*ro, opt, string, linkage method*/
},
"EventLinkageInfo": {
/*ro, opt, object, event linkage information*/
"mainEventType": {
/*ro, opt, object, event main type*/
"@opt": "0,1,2,3"
/*ro, opt, string, event main type*/
},
"devSubEventType": {
/*ro, opt, object, minor event type*/
"@opt": "0,1,2,3,54…"
/*ro, opt, string, minor event type*/
},
"alarmSubEventType": {
/*ro, opt, object, minor type of alarm input event*/
"@opt": "0,1,2,3,52…"
/*ro, opt, string, minor type of alarm input event*/
},
"doorSubEventType": {
/*ro, opt, object, minor type of access control point event*/
"@opt": "0,1,2,3…"
/*ro, opt, string, minor type of access control point event*/
},
"cardReaderSubEventType": {
/*ro, opt, object, minor type of authentication unit event*/
"@opt": "0,1,2,3…"
/*ro, opt, string, minor type of authentication unit event*/
}
},
"CardNoLinkageInfo": {
/*ro, opt, object, card linkage parameters*/
"cardNo": {
/*ro, opt, object, card No.*/
"@min": 1,
/*ro, opt, int*/


"@max": 32
/*ro, opt, int*/
}
},
"MacAddrLinkageInfo": {
/*ro, opt, object, MAC address linkage parameters*/
"MACAddr": {
/*ro, opt, object, physical MAC address*/
"@min": 1,
/*ro, opt, int*/
"@max": 1
/*ro, opt, int*/
}
},
"EmployeeInfo": {
/*ro, opt, object, person ID*/
"employeeNo": {
/*ro, opt, object, person ID*/
"@min": 1,
/*ro, opt, int, employee No. (person ID)*/
"@max": 32
/*ro, opt, int*/
}
},
"eventSourceID": {
/*ro, opt, object, event source ID*/
"@min": 1,
/*ro, opt, int*/
"@max": 1
/*ro, opt, int*/
},
"alarmout": {
/*ro, opt, object, linked alarm output No.*/
"@min": 1,
/*ro, opt, int*/
"@max": 1
/*ro, opt, int*/
},
"ReaderAlarmout": [
/*ro, opt, array, subType:object*/
{
"readerID": 1,
/*ro, opt, int, card reader No., range:[1,8]*/
"alarmOut": {
/*ro, opt, object*/
"@size": 5,
/*ro, opt, int, range:[0,5]*/
"@min": 1,
/*ro, opt, int, range:[1,5]*/
"@max": 5
/*ro, opt, int, range:[1,5]*/
},
"alarmOutClose": {
/*ro, opt, object, array,linked alarm output No.*/
"@size": 5,
/*ro, opt, int, range:[0,5]*/
"@min": 1,
/*ro, opt, int, range:[1,5]*/
"@max": 5
/*ro, opt, int, range:[1,5]*/
}
}
],
"openDoor": {
/*ro, opt, object, linked door No. to open*/
"@min": 1,
/*ro, opt, int*/
"@max": 1
/*ro, opt, int*/
},
"closeDoor": {
/*ro, opt, object, linked door No. to close*/
"@min": 1,
/*ro, opt, int*/
"@max": 1
/*ro, opt, int*/
},
"alwaysOpen": {
/*ro, opt, object, array,linked door No. to remain unlocked*/
"@min": 1,
/*ro, opt, int*/
"@max": 1
/*ro, opt, int*/
},
"alwaysClose": {
/*ro, opt, object, linked door No. to remain locked*/
"@min": 1,
/*ro, opt, int*/
"@max": 1
/*ro, opt, int*/
},
"mainDevBuzzer": "true,false",
/*ro, opt, string, buzzer linkage of the access controller*/
"capturePic": "true,false",


"capturePic": "true,false",
/*ro, opt, string, whether to enable capture linkage*/
"readerCapturePic": {
/*ro, opt, object*/
"@size": 8,
/*ro, opt, int, range:[0,8]*/
"@min": 1,
/*ro, opt, int, range:[1,8]*/
"@max": 8,
/*ro, opt, int, range:[1,8]*/
"@opt": [1, 4]
/*ro, opt, array, subType:int*/
},
"recordVideo": "true,false",
/*ro, opt, string, whether to enable recording linkage*/
"readerRecordVideo": {
/*ro, opt, object*/
"@size": 8,
/*ro, opt, int, range:[0,8]*/
"@min": 1,
/*ro, opt, int, range:[1,8]*/
"@max": 8,
/*ro, opt, int, range:[1,8]*/
"@opt": [1, 4]
/*ro, opt, array, subType:int*/
},
"mainDevStopBuzzer": "true,false",
/*ro, opt, string, whether to enable buzzer linkage of the access controller (stop buzzing): "false"-no,"true"-yes*/
"audioSourceType": {
/*ro, opt, object*/
"@opt": ["TTS", "customFile", "none"]
/*ro, opt, array, subType:string*/
},
"audioDisplayTTSLanguage": {
/*ro, opt, object*/
"@opt": ["SimChinese", "English"]
/*ro, req, array, subType:string*/
},
"audioDisplayTTS": {
/*ro, opt, object*/
"@min": 1,
/*ro, opt, int*/
"@max": 64
/*ro, opt, int*/
},
"customAudioID": {
/*ro, opt, object*/
"@min": 1,
/*ro, opt, int*/
"@max": 65535
/*ro, opt, int*/
},
"audioDisplayMode": {
/*ro, opt, object, linked audio announcement mode*/
"@opt": "close,single,loop"
/*ro, opt, string, linked audio announcement mode*/
},
"readerBuzzer": {
/*ro, opt, object, linked buzzer*/
"@min": 1,
/*ro, opt, int*/
"@max": 1,
/*ro, opt, int*/
"@opt": [1, 4]
/*ro, opt, array, subType:int*/
},
"alarmOutClose": {
/*ro, opt, object, array,linked alarm output No.*/
"@min": 1,
/*ro, opt, int*/
"@max": 1
/*ro, opt, int*/
},
"alarmInSetup": {
/*ro, opt, object, linked zone No. to arm*/
"@min": 1,
/*ro, opt, int*/
"@max": 1
/*ro, opt, int*/
},
"alarmInClose": {
/*ro, opt, object, linked zone No. to disarm*/
"@min": 1,
/*ro, opt, int*/
"@max": 1
/*ro, opt, int*/
},
"readerStopBuzzer": {
/*ro, opt, object, linked buzzer No. to stop buzzing*/
"@min": 1,
/*ro, opt, int*/
"@max": 1,
/*ro, opt, int*/
"@opt": [1, 4]


/*ro, opt, array, subType:int*/
},
"duration": {
/*ro, opt, object*/
"@min": 0,
/*ro, opt, int, unit:s*/
"@max": 30,
/*ro, opt, int, unit:s*/
"@def": 15
/*ro, opt, int, unit:s*/
},
"eventCardLinkageName": {
/*ro, opt, object*/
"@min": 1,
/*ro, opt, int, unit:Byte*/
"@max": 128
/*ro, opt, int, unit:Byte*/
},
"FireMatrixEventSourceList": {
/*ro, opt, object, dep:and,{$.EventCardLinkageCfg.EventLinkageInfo.subEventType,eq,52}*/
"@size": 32,
/*ro, opt, int*/
"IoTChannelID": {
/*ro, opt, object*/
"@min": 1,
/*ro, opt, int, the minimum value*/
"@max": 256
/*ro, opt, int, the maximum value*/
},
"channels": {
/*ro, opt, object*/
"@size": 20,
/*ro, opt, int*/
"@min": 1,
/*ro, opt, int, the minimum value*/
"@max": 16
/*ro, opt, int, the maximum value*/
}
},
"Operations": {
/*ro, opt, object*/
"eventSourceID": {
/*ro, opt, object, event source ID,it is valid when proMode is "event",65535-all. For device event (mainEventType is 0),this field is invalid;
for access control point event (mainEventType is 2),this field refers to the access control point No.; for authentication unit event (mainEventType is
3,this field refers to the authentication unit No.; for alarm input event (mainEventType is 1),this field refers to the zone alarm input ID or the event
alarm input ID*/
"@min": 1,
/*ro, opt, int*/
"@max": 128
/*ro, opt, int*/
},
"TerminalsInfoCap": {
/*ro, opt, object, terminal list*/
"size": 1024,
/*ro, opt, int*/
"terminalID": {
/*ro, opt, object*/
"@min": 1,
/*ro, opt, int*/
"@max": 1024
/*ro, opt, int*/
},
"isSupportACPChannel": true
/*ro, opt, bool*/
},
"audioSource": {
/*ro, opt, object*/
"@opt": ["audioFile", "speechSynthesis"]
/*ro, opt, array, subType:string*/
},
"materialId": {
/*ro, opt, object*/
"size": 32,
/*ro, opt, int*/
"@min": 1,
/*ro, opt, int*/
"@max": 128
/*ro, opt, int*/
},
"speechSynthesisContent": {
/*ro, opt, object*/
"@min": 0,
/*ro, opt, int, unit:Byte*/
"@max": 4096
/*ro, opt, int, unit:Byte*/
},
"voiceType": {
/*ro, opt, object*/
"@opt": ["male", "female"]
/*ro, opt, array, subType:string*/
},
"audioLevel": {
/*ro, opt, object*/
"@min": 0,


"@min": 0,
/*ro, opt, int*/
"@max": 15
/*ro, opt, int*/
},
"audioVolume": {
/*ro, opt, object*/
"@min": 0,
/*ro, opt, int*/
"@max": 15
/*ro, opt, int*/
},
"playMode": {
/*ro, opt, object*/
"@opt": ["order", "duration"]
/*ro, opt, array, subType:string*/
},
"duration": {
/*ro, opt, object*/
"@min": 0,
/*ro, opt, int, unit:s*/
"@max": 3000
/*ro, opt, int, unit:s*/
}
}
}
}
21.28.9 Get the capability of getting total number of access control events by specific
conditions
Request URL
GET /ISAPI/AccessControl/AcsEventTotalNum/capabilities?format=json
Query Parameter
None
Request Message
None
Response Message
{
"AcsEvent": {
/*ro, opt, object*/
"AcsEventTotalNumCond": {
/*ro, opt, object, search conditions*/
"major": {
/*ro, req, object, major alarm type*/
"@opt": "0,1,2,3,5"
/*ro, opt, string, major alarm type*/
},
"minorAlarm": {
/*ro, req, object, minor alarm type*/
"@opt": "1024,1025,1026,1027"
/*ro, opt, string, minor alarm type*/
},
"minorException": {
/*ro, req, object, minor exception type*/
"@opt": "39,58,59,1024"
/*ro, opt, string, minor exception type*/
},
"minorOperation": {
/*ro, req, object, minor operation type*/
"@opt": "80,90,112,113"
/*ro, opt, string, minor operation type*/
},
"minorEvent": {
/*ro, opt, object, minor event type*/
"@opt": "1,2,3,4"
/*ro, opt, string, minor event type*/
},
"startTime": {
/*ro, opt, object, start time*/
"@min": 1,
/*ro, opt, int, start time (UTC time)*/
"@max": 1
/*ro, opt, int, end time (UTC time)*/
},
"endTime": {
/*ro, opt, object, end time*/
"@min": 1,
/*ro, opt, int, start time (UTC time)*/
"@max": 1
/*ro, opt, int, end time (UTC time)*/
},


},
"cardNo": {
/*ro, opt, object, card No.*/
"@min": 1,
/*ro, opt, int, card No.*/
"@max": 32
/*ro, opt, int, card No.*/
},
"name": {
/*ro, opt, object, name of the card holder*/
"@min": 1,
/*ro, opt, int, name of the card holder*/
"@max": 32
/*ro, opt, int, name of the card holder*/
},
"picEnable": "true,false",
/*ro, opt, string*/
"beginSerialNo": {
/*ro, opt, object, start serial No.*/
"@min": 1,
/*ro, opt, int, start serial No.*/
"@max": 1
/*ro, opt, int, start serial No.*/
},
"endSerialNo": {
/*ro, opt, object, end serial No.*/
"@min": 1,
/*ro, opt, int, end serial No.*/
"@max": 1
/*ro, opt, int, end serial No.*/
},
"employeeNoString": {
/*ro, opt, object, employee No. (person ID)*/
"@min": 1,
/*ro, opt, int, employee No. (person ID)*/
"@max": 32
/*ro, opt, int, employee No. (person ID)*/
}
},
"totalNum": {
/*ro, req, object*/
"@min": 1,
/*ro, opt, int*/
"@max": 1
/*ro, opt, int*/
}
}
}
21.28.10 Get the capability of clearing event and card linkage parameters
Request URL
GET /ISAPI/AccessControl/ClearEventCardLinkageCfg/capabilities?format=json
Query Parameter
None
Request Message
None
Response Message
{
"ClearEventCardLinkageCfg": {
/*ro, opt, object, clear event and card linkage parameters*/
"ClearFlags": {
/*ro, opt, object*/
"eventCardLinkage": "true,false"
/*ro, req, string, event and card linkage parameters*/
}
}
}
21.28.11 Set the event optimization parameters
Request URL
PUT /ISAPI/AccessControl/EventOptimizationCfg?format=json
Query Parameter
None


Request Message
{
"EventOptimizationCfg": {
/*opt, object*/
"enable": true,
/*opt, bool, whether to enable event optimization*/
"isCombinedLinkageEvents": true
/*opt, bool, whether to enable linked event combination*/
}
}
Response Message
{
"requestURL": "test",
/*ro, opt, string, URI*/
"statusCode": "test",
/*ro, opt, string, status code*/
"statusString": "test",
/*ro, opt, string, status description*/
"subStatusCode": "test",
/*ro, opt, string, sub status code*/
"errorCode": 1,
/*ro, req, int, error code*/
"errorMsg": "ok"
/*ro, req, string, error details*/
}
21.28.12 Get the configuration capability of event optimization
Request URL
GET /ISAPI/AccessControl/EventOptimizationCfg/capabilities?format=json
Query Parameter
None
Request Message
None
Response Message
{
"EventOptimizationCfg": {
/*ro, opt, object*/
"enable": "true,false",
/*ro, opt, string, whether to enable event optimization*/
"isCombinedLinkageEvents": "true,false"
/*ro, opt, string, whether to enable linked event combination*/
}
}
21.28.13 Get the event optimization configuration parameters
Request URL
GET /ISAPI/AccessControl/EventOptimizationCfg?format=json
Query Parameter
None
Request Message
None
Response Message


{
"EventOptimizationCfg": {
/*ro, opt, object*/
"enable": true,
/*ro, opt, bool, whether to enable event optimization*/
"isCombinedLinkageEvents": true
/*ro, opt, bool, whether to enable linked event combination*/
}
}
21.28.14 Set storage parameters of access control events
Request URL
PUT /ISAPI/AccessControl/AcsEvent/StorageCfg?format=json
Query Parameter
None
Request Message
{
"EventStorageCfg": {
/*wo, req, object*/
"mode": "regular",
/*wo, req, enum, event storage method, subType:string, desc:"regular" (delete old events periodically), "time" (delete old events by specified
time), "cycle" (overwriting);*/
"checkTime": "1970-01-01 00:00:00",
/*wo, opt, string, check time; this node is valid when mode is "time"*/
"period": 10
/*wo, opt, int, time period for deleting old events; this node is valid when mode is "regular", unit:min, desc:time period for deleting old events;
this node is valid when mode is "regular"*/
}
}
Response Message
{
"statusCode": 1,
/*ro, opt, int, status code, desc:1 (succeeded); it is required when an error occurred*/
"statusString": "ok",
/*ro, opt, string, status description, range:[1,64], desc:"ok" (succeeded); it is required when an error occurred*/
"subStatusCode": "ok",
/*ro, opt, string, sub status code, range:[1,64], desc:"ok" (succeeded); it is required when an error occurred*/
"errorCode": 1,
/*ro, opt, int, error code, desc:when the value of statusCode is not 1, it corresponds to subStatusCode*/
"errorMsg": "ok"
/*ro, opt, string, error information, desc:this node must be returned when the value of statusCode is not 1*/
}
21.28.15 Get the storage parameters of access control events
Request URL
GET /ISAPI/AccessControl/AcsEvent/StorageCfg?format=json
Query Parameter
None
Request Message
None
Response Message


{
"EventStorageCfg": {
/*ro, req, object*/
"mode": "regular",
/*ro, req, enum, event storage mode, subType:string, desc:"regular" (delete old events periodically), "time" (delete old events by specified time),
"cycle" (overwriting)*/
"checkTime": "1970-01-01 00:00:00",
/*ro, opt, string, check time. This node is required when the storage mode is "time"*/
"period": 10
/*ro, opt, int, time period for deleting old events. This node is required when the storage mode is "regular", unit:min, desc:unit: minute*/
}
}
21.28.16 Getting arming information
Request URL
GET /ISAPI/AccessControl/DeployInfo
Query Parameter
None
Request Message
None
Response Message
<?xml version="1.0" encoding="UTF-8"?>
<DeployInfo xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--ro, opt, object, arming information, attr:version{req, string, protocolVersion}-->
<DeployList size="5">
<!--ro, opt, array, arming list, subType:object, attr:size{req, int}-->
<Content>
<!--ro, opt, object, subscribe to messages-->
<deployNo>
<!--ro, req, int, arming No.-->1
</deployNo>
<deployType>
<!--ro, req, enum, arming type, subType:int-->1
</deployType>
<protocolType>
<!--ro, opt, enum, protocol type, subType:string, dep:or,{$.DeployInfo.DeployList[*].Content.deployType,eq,2},
{$.DeployInfo.DeployList[*].Content.deployType,eq,3}, desc:"HTTP", "HTTPS"-->HTTP
</protocolType>
<ipAddr>
<!--ro, req, string, IP address-->test
</ipAddr>
<port>
<!--ro, opt, int, port No., range:[1,65535]-->1
</port>
<eventType>
<!--ro, opt, enum, subType:string-->AccessController
</eventType>
</Content>
</DeployList>
</DeployInfo>
21.28.17 Getting arming information capability
Request URL
GET /ISAPI/AccessControl/DeployInfo/capabilities
Query Parameter
None
Request Message
None
Response Message


<?xml version="1.0" encoding="UTF-8"?>
<DeployInfo xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--ro, opt, object, arming Information, attr:version{req, string, protocolVersion}-->
<DeployList size="5">
<!--ro, opt, array, arming list, subType:object, attr:size{req, int}-->
<Content>
<!--ro, opt, object-->
<deployNo min="1" max="10">
<!--ro, req, int, arming No., attr:min{req, int},max{req, int}-->1
</deployNo>
<deployType opt="0,1,2,3">
<!--ro, req, int, arming type, attr:opt{req, string}-->1
</deployType>
<protocolType opt="HTTP,HTTPS">
<!--ro, opt, enum, protocol type, subType:string, attr:opt{req, string}, desc:"HTTP", "HTTPS"-->HTTP
</protocolType>
<ipAddr min="1" max="10">
<!--ro, req, string, IP address, attr:min{req, int},max{req, int}-->test
</ipAddr>
<port min="0" max="10">
<!--ro, opt, int, port No., range:[1,65535], attr:min{req, int},max{req, int}-->1
</port>
<eventType opt="AccessController,Consumer,AccessControllerAndConsumer">
<!--ro, opt, enum, subType:string, attr:opt{req, string}-->AccessController
</eventType>
</Content>
</DeployList>
</DeployInfo>
21.28.18 Access control event
EventType:AccessControllerEvent
{
"ipAddress": "172.6.64.7",
/*ro, req, string, IPv4 address of the device that triggers the alarm*/
"ipv6Address": "1080:0:0:0:8:800:200C:417A",
/*ro, opt, string, IPv6 address of the device that triggers the alarm*/
"portNo": 80,
/*ro, opt, int, communication port No. of the device that triggers the alarm*/
"protocol": "HTTP",
/*ro, opt, enum, transmission communication protocol type, subType:string, desc:when ISAPI protocol is transmitted via HCNetSDK, the channel No. is the
video channel No. of private protocol. When ISAPI protocol is transmitted via EZ protocol, the channel No. is the video channel No. of EZ protocol. When
ISAPI protocol is transmitted via ISUP, the channel No. is the video channel No. of ISUP*/
"macAddress": "01:17:24:45:D9:F4",
/*ro, opt, string, MAC address*/
"channelID": 1,
/*ro, opt, int, channel No. of the device that triggers the alarm, desc:when ISAPI protocol is transmitted via HCNetSDK, the channel No. is the video
channel No. of private protocol. When ISAPI protocol is transmitted via EZ protocol, the channel No. is the video channel No. of EZ protocol. When ISAPI
protocol is transmitted via ISUP, the channel No. is the video channel No. of ISUP*/
"dateTime": "2004-05-03T17:30:08+08:00",
/*ro, req, datetime, alarm trigger time*/
"activePostCount": 1,
/*ro, req, int, times that the same alarm has been uploaded, desc:times that the same alarm has been uploaded*/
"eventType": "AccessControllerEvent",
/*ro, req, string, event type, desc:"AccessControllerEvent" (access control event)*/
"eventState": "active",
/*ro, req, enum, event status, subType:string, desc:for durative event: "active" (valid event or event starts), "inactive" (invalid event or the event
ends). For the heartbeat, the node value indicates the heartbeat data, and it is uploaded every 10 seconds*/
"eventDescription": "AccessControllerEvent",
/*ro, req, string, event description, desc:"AccessControllerEvent" (access control event)*/
"deviceID": "test0123",
/*ro, opt, string, device ID (PUID), desc:this node must be returned when ISAPI event information is transmitted via ISUP*/
"AccessControllerEvent": {
/*ro, req, object, access control event information*/
"deviceName": "test",
/*ro, opt, string, device name*/
"majorEventType": 1,
/*ro, req, int, major alarm type, desc:the type value should be transformed to the decimal number; see Access Control Alarm Types for details*/
"subEventType": 1,
/*ro, req, int, minor alarm type, desc:the type value should be transformed to the decimal number; see Access Control Alarm Types for details*/
"inductiveEventType": "authenticated",
/*ro, opt, enum, inductive event type, subType:string, desc:this node is used by storage devices; for access control devices, this node is invalid;
"authenticated", "authenticationFailed", "openingDoor", "closingDoor", "doorException", "remoteOperation", "timeSynchronization", "deviceException",
"deviceRecovered", "alarmTriggered", "alarmRecovered" (arming restoring event), "callCenter"*/
"netUser": "test",
/*ro, opt, string, user name for network operations*/
"remoteHostAddr": "test",
/*ro, opt, string, remote host address*/
"cardNo": "test",
/*ro, opt, string, card No.*/
"cardType": 1,
/*ro, opt, enum, card type, subType:int, desc:1 (normal card), 2 (disability card), 3 (blocklist card), 4 (patrol card), 5 (duress card), 6 (super
card), 7 (visitor card), 8 (dismiss card)*/
"name": "test",
/*ro, opt, string, person name*/
"sex": "male",


"sex": "male",
/*ro, opt, enum, subType:string, desc:"male", "female"*/
"whiteListNo": 1,
/*ro, opt, int, allowlist No.*/
"reportChannel": 1,
/*ro, opt, enum, channel type for uploading alarms/events, subType:int, desc:1 (uploading in arming mode), 2 (uploading by central group 1), 3
(uploading by central group 2)*/
"cardReaderKind": 1,
/*ro, opt, enum, card reader type, subType:int, desc:1 (IC card reader), 2 (ID card reader), 3 (QR code scanner), 4 (fingerprint module)*/
"cardReaderNo": 1,
/*ro, opt, int, card reader No., step:1, desc:card reader No.*/
"doorNo": 1,
/*ro, opt, int, door (floor) No.*/
"verifyNo": 1,
/*ro, opt, int, multiple authentication No.*/
"alarmInNo": 1,
/*ro, opt, int, alarm input No.*/
"alarmOutNo": 1,
/*ro, opt, int, alarm output No.*/
"caseSensorNo": 1,
/*ro, opt, int, event trigger No.*/
"RS485No": 1,
/*ro, opt, int, RS-485 channel No.*/
"multiCardGroupNo": 1,
/*ro, opt, int, group No.*/
"accessChannel": 1,
/*ro, opt, int, turnstile No.*/
"deviceNo": 1,
/*ro, opt, int, device No.*/
"distractControlNo": 1,
/*ro, opt, int, distributed access controller No.*/
"employeeNo": 1,
/*ro, opt, int, employee No. (person ID)*/
"employeeNoString": "test",
/*ro, opt, string, employee No. (person ID), desc:if the node employeeNo exists or the value of employeeNoString can be converted to that of
employeeNo, this node is required. For the upper-layer platform or client software, the node employeeNoString will be parsed in priority; if
employeeNoString is not configured, the node employeeNo will be parsed*/
"employeeName": "test",
/*ro, opt, string, person name, desc:this node is only used for FocSign products*/
"localControllerID": 1,
/*ro, opt, int, distributed access controller No., desc:0 (access controller), 1 to 64 (distributed access controller No. 1 to distributed access
controller No. 64)*/
"InternetAccess": 1,
/*ro, opt, enum, network interface No., subType:int, desc:1 (upstream network interface No. 1), 2 (upstream network interface No. 2), 3 (downstream
network interface No. 1)*/
"type": 1,
/*ro, opt, enum, zone type, subType:int, desc:0 (instant zone), 1 (24-hour zone), 2 (delayed zone), 3 (internal zone), 4 (key zone), 5 (fire alarm
zone), 6 (perimeter zone), 7 (24-hour silent zone), 8 (24-hour auxiliary zone), 9 (24-hour shock zone), 10 (emergency door open zone), 11 (emergency door
closed zone), 255 (none)*/
"MACAddr": "test",
/*ro, opt, string, MAC address*/
"swipeCardType": 1,
/*ro, opt, enum, card swiping types, subType:int, desc:0 (invalid), 1 (QR code)*/
"serialNo": 1,
/*ro, opt, int, event serial No., range:[1,100000], desc:it starts at 1 and each record increases by 1. It will be overwritten repeatedly when
reaching the maximum value supported by the device*/
"channelControllerID": 1,
/*ro, opt, enum, lane controller ID, subType:int, desc:1 (main lane controller), 2 (sub-lane controller)*/
"channelControllerLampID": 1,
/*ro, opt, int, light board ID of lane controller, range:[1,255]*/
"channelControllerIRAdaptorID": 1,
/*ro, opt, int, IR adaptor ID of the lane controller, range:[1,255]*/
"channelControllerIREmitterID": 1,
/*ro, opt, int, active infrared intrusion detector No. of the lane controller, range:[1,255]*/
"userType": "normal",
/*ro, opt, enum, person type, subType:string, desc:"normal" (normal person (resident)), "visitor" (visitor), "blacklist" (person in the blocklist),
"administrators" (administrator)*/
"currentVerifyMode": "cardAndPw",
/*ro, opt, enum, current authentication mode of the card reader, subType:string, desc:"cardAndPw" (card+password), "card" (card), "cardOrPw" (card
or password), "fp" (fingerprint), "fpAndPw" (fingerprint+password), "fpOrCard" (fingerprint or card), "fpAndCard" (fingerprint+card), "fpAndCardAndPw"
(fingerprint+card+password), "faceOrFpOrCardOrPw" (face or fingerprint or card or password), "faceAndFp" (face+fingerprint), "faceAndPw" (face+password),
"faceAndCard" (face+card), "face" (face), "employeeNoAndPw" (employee No.+password), "fpOrPw" (fingerprint or password), "employeeNoAndFp" (employee
No.+fingerprint), "employeeNoAndFpAndPw" (employee No.+fingerprint+password), "faceAndFpAndCard" (face+fingerprint+card), "faceAndPwAndFp"
(face+password+fingerprint), "employeeNoAndFace" (employee No.+face), "faceOrfaceAndCard" (face or face+card), "fpOrface" (fingerprint or face),
"cardOrfaceOrPw" (card or face or password), "iris" (iris), "faceOrFpOrCardOrPwOrIris" (face, fingerprint, card, password, or iris), "faceOrCardOrPwOrIris"
(face, card, password, or iris)*/
"currentEvent": true,
/*ro, opt, bool, whether it is a real-time event*/
"QRCodeInfo": "test",
/*ro, opt, string, QR code information*/
"thermometryResult": "success",
/*ro, opt, enum, temperature screening result, subType:string, desc:"success", "fail"*/
"thermometryUnit": "celsius",
/*ro, opt, enum, temperature unit, subType:string, desc:"celsius" (Celsius, default value), "fahrenheit" (Fahrenheit), "kelvin" (Kelvin)*/
"currTemperature": 36.1,
/*ro, opt, float, skin-surface temperature, which is accurate to one decimal place*/
"isAbnomalTemperature": true,
/*ro, opt, bool, whether the skin-surface temperature is abnormal*/
"RegionCoordinates": {
/*ro, opt, object, coordinates of the skin-surface temperature*/
"positionX": 0,
/*ro, opt, int, normalized X-coordinate which is between 0 and 1000, range:[0,1000]*/
"positionY": 0
/*ro, opt, int, normalized Y-coordinate which is between 0 and 1000, range:[0,1000]*/
},


},
"remoteCheck": true,
/*ro, opt, bool, whether remote verification is required: true-yes, false-no (default)*/
"mask": "unknown",
/*ro, opt, enum, whether the person wears a mask, subType:string, desc:"unknown", "yes", "no"*/
"frontSerialNo": 1,
/*ro, opt, int, serial No. of the previous event, desc:if this node does not exist, the platform will check whether the event loss occurred
according to the node serialNo. If both the serialNo and frontSerialNo are returned, the platform will check whether the event loss occurred according to
both nodes. It is mainly used to solve the problem that the serialNo is inconsistent after subscribing events or alarms*/
"attendanceStatus": "checkIn",
/*ro, opt, enum, attendance status, subType:string, desc:"checkIn" (check-in), "checkOut" (check-out), "breakOut" (start of break), "breakIn" (end
of break), "overtimeIn" (start of overtime), "overTimeOut" (end of overtime)*/
"label": "test",
/*ro, opt, string, self-defined attendance name*/
"statusValue": 1,
/*ro, opt, int, status value*/
"pictureURL": "test",
/*ro, opt, string, URL of the captured picture, range:[0,256]*/
"visibleLightURL": "test",
/*ro, opt, string, visible light picture URL of the thermal imaging camera, range:[0,256]*/
"thermalURL": "test",
/*ro, opt, string, URL of the thermal picture, range:[0,256]*/
"faceBasemapURL": "test",
/*ro, opt, string, range:[0,256]*/
"picturesNumber": 1,
/*ro, opt, int, number of captured pictures*/
"unlockType": "password",
/*ro, opt, enum, unlocking type, subType:string, desc:this node is returned when the minor type is MINOR_UNCLOCK_RECORD; "password" (unlock by
password), "hijcking" (unlock by duress), "card" (unlock by card), "householder" (unlock by householder), "centerplatform" (unlock by management center),
"bluetooth" (unlock by bluetooth), "qrcode" (unlocked via QR code), "face" (unlock by recognizing face), "fingerprint" (unlock by fingerprint)*/
"classroomId": "test",
/*ro, opt, string, class ID*/
"classroomName": "test",
/*ro, opt, string, class name*/
"analysisModule": "signageApp",
/*ro, opt, enum, analysis module, subType:string, desc:this node is not returned, and the value is report via signage App; "signageApp" (signage
App), "faceSDK" (face picture SDK)*/
"customInfo": "test",
/*ro, opt, string, custom information*/
"helmet": "unknown",
/*ro, opt, enum, whether the person is wearing hard hat, subType:string, desc:"unknown", "yes", "no"*/
"purePwdVerifyEnable": true,
/*ro, opt, bool, whether the device supports opening the door only by password,
desc:opening the door only by password:
the password in authentication method is person password; checking the repetition of person password is not supported by the device, it should be
performed by the upper-layer platform; adding, deleting, editing, and searching for person password locally is not supported by the device*/
"appType": "attendance",
/*ro, opt, enum, application type (for FocSign products), subType:string, desc:"attendance" (Time & Attendance module), "signIn" (Check-In module)*/
"HealthInfo": {
/*ro, opt, object, health information*/
"healthCode": 1,
/*ro, opt, enum, health code status, subType:int, desc:0 (no request), 1 (no health code), 2 (green QR code), 3 (yellow QR code), 4 (red QR
code), 5 (no such person), 6 (other error, e.g., searching failed due to API exception), 7 (searching for the health code timed out)*/
"NADCode": 1,
/*ro, opt, enum, nucleic acid test result, subType:int, desc:0 (no result), 1 (negative, which means normal), 2 (positive, which means
diagnosed), 3 (the result has expired)*/
"NADMsg": "test",
/*ro, opt, string, range:[0,64]*/
"NADTime": 1,
/*ro, opt, enum, subType:int*/
"travelCode": 1,
/*ro, opt, enum, trip code, subType:int, desc:0 (no trip in the past 14 days), 1 (has left the current area left in the past 14 days), 2 (has
been to the high-risk area in the past 14 days), 3 (other)*/
"travelInfo": "test",
/*ro, opt, string, trip information, desc:the empty string indicates that searching trip failed*/
"vaccineStatus": 1,
/*ro, opt, enum, whether the person is vaccinated, subType:int, desc:0 (not vaccinated), 1 (vaccinated)*/
"vaccineNum": 1,
/*ro, opt, int, step:1*/
"vaccineMsg": "test",
/*ro, opt, string, range:[0,64]*/
"ANTCode": 1,
/*ro, opt, enum, subType:int*/
"ANTMsg": "test"
/*ro, opt, string, range:[0,64]*/
},
"PhysicalInfo": {
/*ro, opt, object, BMI information, desc:this node is obtained after authentication by BMI scales which is connected to MinMoe terminals*/
"weight": 7000,
/*ro, opt, int, weight, unit:kg*/
"height": 18000
/*ro, opt, int, height, unit:cm*/
},
"meetingID": "test",
/*ro, opt, string, meeting ID, range:[1,32]*/
"PersonInfoExtends": [
/*ro, opt, array, additional person information, subType:object, desc:this node displays additional person information on the device*/
{
"id": 1,
/*ro, opt, int, extended ID of the additional person information, range:[1,32], desc:related URL: /ISAPI/AccessControl/personInfoExtendName?
format=json; this node is used for displaying the name of value; if ID does not exists, it starts from 1*/
"value": "test"
/*ro, opt, string, extended content of the additional person information*/
}


}
],
"customPrompt": "test",
/*ro, opt, string, custom prompt message, range:[1,128], desc:this node is displayed when the authentication result is authenticated, authentication
failed, or stranger*/
"FaceRect": {
/*ro, opt, object, rectangle frame for human face, desc:the origin is the upper-left corner of the screen*/
"height": 1.000,
/*ro, req, float, height, range:[0.000,1.000]*/
"width": 1.000,
/*ro, req, float, width, range:[0.000,1.000]*/
"x": 0.000,
/*ro, req, float, X-coordinate of the upper-left corner of the frame, range:[0.000,1.000]*/
"y": 0.000
/*ro, req, float, Y-coordinate of the upper-left corner of the frame, range:[0.000,1.000]*/
},
"faceSimilarity": 90,
/*ro, opt, int, Similarity, range:[0,100]*/
"faceRecognitionDistance": 0.1,
/*ro, opt, float, unit:m*/
"eyesDistance": 20,
/*ro, opt, int, range:[0,100], step:1*/
"faceRecognitionFailedReason": "attackBlacklist",
/*ro, opt, enum, subType:string*/
"currentAuthenticationTimes": 1,
/*ro, opt, int, range:[0,255], step:1*/
"allowAuthenticationTimes": 1,
/*ro, opt, int, range:[0,255], step:1*/
"LocalAttendanceData": {
/*ro, opt, object*/
"attendanceResult": [
/*ro, opt, array, subType:object*/
{
"date": "1970-01-01",
/*ro, opt, date*/
"week": 1,
/*ro, opt, enum, subType:int, desc:1 (Monday), 2 (Tuesday), 3 (Wednesday), 4 (Thursday), 5 (Friday), 6 (Saturday), 7 (Sunday)*/
"personalAttendanceStatus": "normal"
/*ro, opt, enum, subType:string*/
}
]
},
"hasRecord": true
/*ro, opt, bool*/
},
"URLCertificationType": "digest"
/*ro, opt, enum, picture URL authentication method, subType:string, desc:"no" (no authentication, it is used for the cloud protocol)，"digest" (digest
authentication, it is used for local picture URL returned by NVR or DVR)*/
}
Parameter Name
Parameter
Value
AccessControllerEvent [报文内容]
Picture
VisibleLight
Thermal
[图片二进制数
据]
[图片二进制数
据]
[图片二进制数
据]
Parameter
Type(Content-Type)
application/json
image/jpeg
image/jpeg
image/jpeg
Content-ID
-
pictureImage
File Name
-
Picture.jpg
Description
-
-
visibleLight_image VisibleLight.jpg -
thermal_image
Thermal.jpg
-
Note： The protocol is transmitted in form format. See Chapter 4.5.1.4 for form framework description, as shown in
the instance below.
--<frontier>
Content-Disposition: form-data; name=Parameter Name;filename=File Name
Content-Type: Parameter Type
Content-Length: ****
Content-ID: Content ID
Parameter Value
Parameter Name: the name property of Content-Disposition in the header of form unit; it refers to the form unit
name.
Parameter Type (Content-Type): the Content-Type property in the header of form unit.
File Name (filename): the filename property of Content-Disposition of form unit Headers. It exists only when the


transmitted data of form unit is file, and it refers to the file name of form unit body.
Parameter Value: the body content of form unit.
21.29 Access Point Status Schedule
21.29.1 Set parameters of door control weekly schedule
Request URL
PUT /ISAPI/AccessControl/DoorStatusWeekPlanCfg/<weekPlanID>?format=json
Query Parameter
Parameter Name Parameter Type Description
weekPlanID
string
Request Message
{
"DoorStatusWeekPlanCfg": {
/*opt, object, weekly schedule of door control*/
"enable": true,
/*req, bool, whether to enable, desc:"true"-enable, "false"-disable*/
"WeekPlanCfg": [
/*req, array, weekly schedule parameters, subType:object*/
{
"week": "Monday",
/*req, enum, days of the week, subType:string, desc:"Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"*/
"id": 1,
/*req, int, time period No., range:[1,8]*/
"enable": true,
/*req, bool, whether to enable*/
"doorStatus": "remainClosed",
/*req, enum, door control schedule, subType:string, desc:"remainOpen"-remain open (access without authentication), "remainClosed"-remain
closed (access is not allowed), "normal"-access by authentication, "sleep", "invalid”*/
"TimeSegment": {
/*req, object, time*/
"beginTime": "00:00:00",
/*req, time, start time, desc:device local time*/
"endTime": "10:00:00"
/*req, time, end time, desc:device local time*/
}
}
]
}
}
Response Message
{
"statusCode": 1,
/*ro, opt, int, status code, desc:1 (succeeded); it is required when an error occurred*/
"statusString": "ok",
/*ro, opt, string, status description, range:[1,64], desc:"ok" (succeeded); it is required when an error occurred*/
"subStatusCode": "ok",
/*ro, opt, string, sub status code, range:[1,64], desc:"ok" (succeeded); it is required when an error occurred*/
"errorCode": 1,
/*ro, opt, int, error code, desc:when the value of statusCode is not 1, it corresponds to subStatusCode*/
"errorMsg": "ok"
/*ro, opt, string, error information, desc:this node must be returned when the value of statusCode is not 1*/
}
21.29.2 Get the configuration parameters of the door control holiday schedule
Request URL
GET /ISAPI/AccessControl/DoorStatusHolidayPlanCfg/<holidayPlanID>?format=json
Query Parameter
Parameter Name Parameter Type Description
holidayPlanID
string
Request Message
None
-
-


Response Message
{
"DoorStatusHolidayPlanCfg": {
/*ro, req, object*/
"enable": true,
/*ro, req, bool, whether to enable, desc:true (enable), false (disable)*/
"beginDate": "2017-10-01",
/*ro, req, date, start date of the holiday*/
"endDate": "2017-10-08",
/*ro, req, date, end date of the holiday*/
"HolidayPlanCfg": [
/*ro, req, array, holiday schedule parameters, subType:object*/
{
"id": 1,
/*ro, req, int, time period No., range:[1,8]*/
"enable": true,
/*ro, req, bool, whether to enable, desc:true (enable), false (disable)*/
"doorStatus": "remainClosed",
/*ro, req, enum, door status, subType:string, desc:“remainOpen”-remain open (access without authentication), “remainClosed”-remain closed
(access is not allowed), “normal”-access by authentication, "sleep", "invalid”, “induction”, “barrierFree”*/
"TimeSegment": {
/*ro, opt, object, time*/
"beginTime": "00:00:00",
/*ro, req, time, start time of the time period, desc:device local time*/
"endTime": "10:00:00"
/*ro, req, time, end time of the time period, desc:device local time*/
}
}
]
}
}
21.29.3 Get the configuration capability of the door control week schedule
Request URL
GET /ISAPI/AccessControl/DoorStatusWeekPlanCfg/capabilities?format=json
Query Parameter
None
Request Message
None
Response Message


{
"DoorStatusWeekPlanCfg": {
/*ro, opt, object*/
"planNo": {
/*ro, opt, object, week schedule No.*/
"@min": 1,
/*ro, opt, int*/
"@max": 16
/*ro, opt, int*/
},
"enable": "true,false",
/*ro, opt, string, whether to enable: "true"-enable,"false"-disable, desc:"true" (enable), "false" (disable)*/
"WeekPlanCfg": {
/*ro, opt, object, week schedule parameters*/
"maxSize": 56,
/*ro, opt, int*/
"week": {
/*ro, opt, object*/
"@opt": "Monday,Tuesday,Wednesday,Thursday,Friday,Saturday,Sunday"
/*ro, opt, string, desc:"Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"*/
},
"id": {
/*ro, opt, object, weekly schedule No.*/
"@min": 1,
/*ro, opt, int*/
"@max": 8
/*ro, opt, int*/
},
"enable": "true,false",
/*ro, opt, string, whether to enable: "true"-enable,"false"-disable, desc:"true" (enable), "false" (disable)*/
"doorStatus": {
/*ro, opt, object, door status*/
"@opt": "remainOpen,remainClosed,normal,sleep,invalid,induction,barrierFree"
/*ro, opt, string, desc:"remainOpen" (remain open (access without authentication)), "remainClosed" (remain closed (access is not allowed)),
"normal" (access by authentication), "sleep", "invalid"*/
},
"TimeSegment": {
/*ro, opt, object, time*/
"beginTime": "00:00:00",
/*ro, opt, time, start time of the time period (device local time), desc:device local time*/
"endTime": "10:00:00",
/*ro, opt, time, end time of the time period (device local time), desc:device local time*/
"validUnit": "minute"
/*ro, opt, enum, time accuracy, subType:string, desc:"hour", "minute", "second"; if this node is not returned, the default time accuracy is
"minute"*/
}
}
}
}
21.29.4 Get the configuration capability of the door control holiday schedule
Request URL
GET /ISAPI/AccessControl/DoorStatusHolidayPlanCfg/capabilities?format=json
Query Parameter
None
Request Message
None
Response Message


{
"DoorStatusHolidayPlanCfg": {
/*ro, opt, object*/
"planNo": {
/*ro, opt, object, holiday schedule No.*/
"@min": 1,
/*ro, opt, int*/
"@max": 16
/*ro, opt, int*/
},
"enable": "true,false",
/*ro, opt, string, whether to enable: "true"-enable,"false"-disable, desc:"true" (enable), "false" (disable)*/
"beginDate": "1970-01-01",
/*ro, opt, date, start date of the holiday*/
"endDate": "1971-01-01",
/*ro, opt, date, end date of the holiday*/
"HolidayPlanCfg": {
/*ro, opt, object*/
"maxSize": 8,
/*ro, opt, int*/
"id": {
/*ro, opt, object, time period No.*/
"@min": 1,
/*ro, opt, int*/
"@max": 8
/*ro, opt, int*/
},
"enable": "true,false",
/*ro, opt, string, whether to enable: "true"-enable,"false"-disable, desc:"true" (enable), "false" (disable)*/
"doorStatus": {
/*ro, opt, object, door status*/
"@opt": "remainOpen,remainClosed,normal,sleep,invlid,induction,barrierFree"
/*ro, opt, string, desc:"remainOpen" (remain open (access without authentication)), "remainClosed" (remain closed (access is not allowed)),
"normal" (access by authentication), "sleep", "invalid"*/
},
"TimeSegment": {
/*ro, opt, object, time*/
"beginTime": "00:00:00",
/*ro, opt, time, start time of the time period (device local time), desc:device local time*/
"endTime": "00:00:00",
/*ro, opt, time, end time of the time period (device local time), desc:device local time*/
"validUnit": "minute"
/*ro, opt, enum, time accuracy, subType:string, desc:"hour", "minute", "second"; if this node is not returned, the default time accuracy is
"minute"*/
}
}
}
}
21.29.5 Get the configuration capability of the door control schedule template
Request URL
GET /ISAPI/AccessControl/DoorStatusPlanTemplate/capabilities?format=json
Query Parameter
None
Request Message
None
Response Message


{
"DoorStatusPlanTemplate": {
/*ro, opt, object, schedule template*/
"templateNo": {
/*ro, opt, object, schedule template No.*/
"@min": 1,
/*ro, opt, int, the minimum value of schedule template No.*/
"@max": 16
/*ro, opt, int, the maximum value of schedule template No.*/
},
"enable": "true,false",
/*ro, opt, string, whether to enable, desc:true (enable), false (disable)*/
"templateName": {
/*ro, opt, object, template name length*/
"@min": 1,
/*ro, opt, int, the minimum value of template name length*/
"@max": 32
/*ro, opt, int, the maximum value of template name length*/
},
"weekPlanNo": {
/*ro, opt, object, weekly schedule No.*/
"@min": 1,
/*ro, opt, int, the minimum value of weekly schedule No.*/
"@max": 16
/*ro, opt, int, the maximum value of weekly schedule No.*/
},
"holidayGroupNo": {
/*ro, opt, object, holiday group No.*/
"@min": 1,
/*ro, opt, int, the minimum value of holiday group No.*/
"@max": 16
/*ro, opt, int, the maximum value of holiday group No.*/
}
}
}
21.29.6 Get the configuration parameters of the door control week schedule
Request URL
GET /ISAPI/AccessControl/DoorStatusWeekPlanCfg/<weekPlanID>?format=json
Query Parameter
Parameter Name Parameter Type Description
weekPlanID
string
Request Message
None
Response Message
{
"DoorStatusWeekPlanCfg": {
/*ro, opt, object, door control week schedule*/
"enable": true,
/*ro, req, bool, whether to enable, desc:true (enable), false (disable)*/
"WeekPlanCfg": [
/*ro, req, array, week schedule parameters, subType:object*/
{
"week": "Monday",
/*ro, req, enum, days of the week, subType:string, desc:"Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday”*/
"id": 1,
/*ro, req, int, time period No., range:[1,8]*/
"enable": true,
/*ro, req, bool, whether to enable: "true"-enable, "false"-disable*/
"doorStatus": "remainClosed",
/*ro, req, enum, door status, subType:string, desc:"remainOpen"-remain open (access without authentication), "remainClosed"-remain closed
(access is not allowed), "normal"-access by authentication, "sleep","invalid”, “induction”, “barrierFree”*/
"TimeSegment": {
/*ro, req, object, time*/
"beginTime": "00:00:00",
/*ro, req, time, start time of the time period, desc:device local time*/
"endTime": "10:00:00"
/*ro, req, time, end time of the time period, desc:device local time*/
}
}
]
}
}
-


21.29.7 Set parameters of door control holiday schedule
Request URL
PUT /ISAPI/AccessControl/DoorStatusHolidayPlanCfg/<holidayPlanID>?format=json
Query Parameter
Parameter Name Parameter Type Description
holidayPlanID
string
Request Message
{
"DoorStatusHolidayPlanCfg": {
/*ro, req, object*/
"enable": true,
/*ro, req, bool, whether to enable, desc:"true"-enable, "false"-disable*/
"beginDate": "2017-10-01",
/*ro, req, date, start date of the holiday*/
"endDate": "2017-10-08",
/*ro, req, date, end data of the holiday*/
"HolidayPlanCfg": [
/*ro, req, array, holiday schedule parameters, subType:object*/
{
"id": 1,
/*ro, req, int, time period No., range:[1,8]*/
"enable": true,
/*ro, req, bool, whether to enable, desc:"true"-enable, "false"-disable*/
"doorStatus": "remainClosed",
/*ro, req, enum, door status, subType:string, desc:"remainOpen"-remain open (access without authentication), "remainClosed"-remain closed
(access is not allowed), "normal"-access by authentication, "sleep", "invalid”*/
"TimeSegment": {
/*ro, opt, object, time*/
"beginTime": "00:00:00",
/*ro, req, time, start time, desc:device local time*/
"endTime": "10:00:00"
/*ro, req, time, end time, desc:device local time*/
}
}
]
}
}
Response Message
{
"statusCode": 1,
/*ro, opt, int, status code, desc:1 (succeeded); it is required when an error occurred*/
"statusString": "ok",
/*ro, opt, string, status description, range:[1,64], desc:"ok" (succeeded); it is required when an error occurred*/
"subStatusCode": "ok",
/*ro, opt, string, sub status code, range:[1,64], desc:"ok" (succeeded); it is required when an error occurred*/
"errorCode": 1,
/*ro, opt, int, error code, desc:when the value of statusCode is not 1, it corresponds to subStatusCode*/
"errorMsg": "ok"
/*ro, opt, string, error information, desc:this node must be returned when the value of statusCode is not 1*/
}
21.29.8 Set parameters of door control schedule template
Request URL
PUT /ISAPI/AccessControl/DoorStatusPlanTemplate/<planTemplateID>?format=json
Query Parameter
Parameter Name Parameter Type Description
planTemplateID string
-
Request Message
-


{
"DoorStatusPlanTemplate": {
/*ro, opt, object, door control schedule template*/
"enable": true,
/*ro, req, bool, whether to enable, desc:"true"-enable, "false"-disable*/
"templateName": "test",
/*ro, req, string, template name*/
"weekPlanNo": 1,
/*ro, req, int, weekly schedule No.*/
"holidayGroupNo": "1,3,5"
/*ro, req, string, holiday group No., desc:holiday group No.*/
}
}
Response Message
{
"statusCode": 1,
/*ro, opt, int, status code, desc:1 (succeeded); it is required when an error occurred*/
"statusString": "ok",
/*ro, opt, string, status description, range:[1,64], desc:"ok" (succeeded); it is required when an error occurred*/
"subStatusCode": "ok",
/*ro, opt, string, sub status code, range:[1,64], desc:"ok" (succeeded); it is required when an error occurred*/
"errorCode": 1,
/*ro, opt, int, error code, desc:when the value of statusCode is not 1, it corresponds to subStatusCode*/
"errorMsg": "ok"
/*ro, opt, string, error information, desc:this node must be returned when the value of statusCode is not 1*/
}
21.29.9 Get parameters of door control schedule template
Request URL
GET /ISAPI/AccessControl/DoorStatusPlanTemplate/<planTemplateID>?format=json
Query Parameter
Parameter Name Parameter Type Description
planTemplateID string
-
Request Message
None
Response Message
{
"DoorStatusPlanTemplate": {
/*ro, opt, object, door control schedule template*/
"enable": true,
/*ro, req, bool, whether to enable, desc:"true"-enable, "false"-disable*/
"templateName": "test",
/*ro, req, string, template name*/
"weekPlanNo": 1,
/*ro, req, int, weekly schedule No.*/
"holidayGroupNo": "1,3,5"
/*ro, req, string, holiday group No.*/
}
}
21.29.10 Get the configuration capability of the door control schedule
Request URL
GET /ISAPI/AccessControl/DoorStatusPlan/capabilities?format=json
Query Parameter
None
Request Message
None
Response Message


{
"DoorStatusPlan": {
/*ro, opt, object*/
"doorNo": {
/*ro, opt, object, door No.*/
"@min": 1,
/*ro, opt, int*/
"@max": 4
/*ro, opt, int*/
},
"templateNo": {
/*ro, opt, object, schedule template No.*/
"@min": 1,
/*ro, opt, int*/
"@max": 16
/*ro, opt, int*/
}
}
}
21.29.11 Get the configuration capability of door status parameters of holiday group
Request URL
GET /ISAPI/AccessControl/DoorStatusHolidayGroupCfg/capabilities?format=json
Query Parameter
None
Request Message
None
Response Message
{
"DoorStatusHolidayGroupCfg": {
/*ro, opt, object*/
"groupNo": {
/*ro, opt, object, holiday group No.*/
"@min": 1,
/*ro, opt, int, the minimum value*/
"@max": 16
/*ro, opt, int, the maximum value*/
},
"enable": "true,false",
/*ro, opt, string, whether to enable, desc:true (enable)*/
"groupName": {
/*ro, opt, object, length of holiday group name*/
"@min": 1,
/*ro, opt, int, the minimum length*/
"@max": 32
/*ro, opt, int, the maximum length*/
},
"holidayPlanNo": {
/*ro, opt, object, holiday group plan No.*/
"@min": 1,
/*ro, opt, int, the minimum value*/
"@max": 16
/*ro, opt, int, the maximum value*/
}
}
}
21.29.12 Get the holiday group configuration parameters of the door control schedule
Request URL
GET /ISAPI/AccessControl/DoorStatusHolidayGroupCfg/<holidayGroupID>?format=json
Query Parameter
Parameter Name Parameter Type Description
holidayGroupID string
-
Request Message
None


Response Message
{
"DoorStatusHolidayGroupCfg": {
/*ro, opt, object*/
"enable": true,
/*ro, req, bool, whether to enable: "true"-enable, "false"-disable*/
"groupName": "test",
/*ro, req, string, holiday group name*/
"holidayPlanNo": "1,3,5"
/*ro, req, string*/
}
}
21.29.13 Set parameters of door control schedule
Request URL
PUT /ISAPI/AccessControl/DoorStatusPlan/<doorID>?format=json
Query Parameter
Parameter Name Parameter Type Description
doorID
string
Request Message
{
"DoorStatusPlan": {
/*req, object*/
"templateNo": 1
/*req, int, schedule template No., desc:0-cancel linking the template with the schedule and restore to the default status (normal status)*/
}
}
Response Message
{
"statusCode": 1,
/*ro, opt, int, status code, desc:1 (succeeded); it is required when an error occurred*/
"statusString": "ok",
/*ro, opt, string, status description, range:[1,64], desc:"ok" (succeeded); it is required when an error occurred*/
"subStatusCode": "ok",
/*ro, opt, string, sub status code, range:[1,64], desc:"ok" (succeeded); it is required when an error occurred*/
"errorCode": 1,
/*ro, opt, int, error code, desc:when the value of statusCode is not 1, it corresponds to subStatusCode*/
"errorMsg": "ok"
/*ro, opt, string, error information, desc:this node must be returned when the value of statusCode is not 1*/
}
21.29.14 Get the configuration parameters of the door control schedule
Request URL
GET /ISAPI/AccessControl/DoorStatusPlan/<doorID>?format=json
Query Parameter
Parameter Name Parameter Type Description
doorID
string
Request Message
None
Response Message
-
-


{
"DoorStatusPlan": {
/*ro, req, object*/
"templateNo": 1
/*ro, req, int, schedule template No., desc:0-cancel linking the template with the schedule and restore to the default status (normal status)*/
}
}
21.29.15 Clear access control schedule configuration parameters
Request URL
PUT /ISAPI/AccessControl/ClearPlansCfg?format=json
Query Parameter
None
Request Message
{
"ClearPlansCfg": {
/*opt, object*/
"ClearFlags": {
/*opt, object*/
"doorStatusWeekPlan": true,
/*opt, bool, whether to clear the week schedule of the door control*/
"cardReaderWeekPlan": true,
/*opt, bool, whether to clear the week schedule of the card reader authentication mode control*/
"userRightWeekPlan": true,
/*opt, bool, whether to clear the week schedule of the access permission control*/
"doorStatusHolidayPlan": true,
/*opt, bool, whether to clear the holiday schedule of the door control*/
"cardReaderHolidayPlan": true,
/*opt, bool, whether to clear the holiday schedule of the card reader authentication mode control*/
"userRightHolidayPlan": true,
/*opt, bool, whether to clear the holiday schedule of the access permission control*/
"doorStatusHolidayGroup": true,
/*opt, bool, whether to clear the holiday group of the door control*/
"cardReaderHolidayGroup": true,
/*opt, bool, whether to clear the holiday group of the card reader authentication mode control*/
"userRightHolidayGroup": true,
/*opt, bool, whether to clear the holiday group of the access permission control*/
"doorStatusTemplate": true,
/*opt, bool, whether to clear the schedule template of the door control*/
"cardReaderTemplate": true,
/*opt, bool, whether to clear the control schedule template of card reader authentication mode*/
"userRightTemplate": true
/*opt, bool, whether to clear the schedule template of access permission control*/
}
}
}
Response Message
{
"statusCode": 1,
/*ro, opt, int, status code, desc:1 (succeeded); it is required when an error occurred*/
"statusString": "ok",
/*ro, opt, string, status description, range:[1,64], desc:"ok" (succeeded); it is required when an error occurred*/
"subStatusCode": "ok",
/*ro, opt, string, sub status code, range:[1,64], desc:"ok" (succeeded); it is required when an error occurred*/
"errorCode": 1,
/*ro, opt, int, error code, desc:when the value of statusCode is not 1, it corresponds to subStatusCode*/
"errorMsg": "ok"
/*ro, opt, string, error information, desc:this node must be returned when the value of statusCode is not 1*/
}
21.29.16 Get the capability of clearing access control schedule configuration.
Request URL
GET /ISAPI/AccessControl/ClearPlansCfg/capabilities?format=json
Query Parameter
None
Request Message


None
Response Message
{
"ClearPlansCfg": {
/*ro, req, object*/
"ClearFlags": {
/*ro, opt, object*/
"doorStatusWeekPlan": "true,false",
/*ro, opt, string, whether to clear the week schedule of the door control*/
"cardReaderWeekPlan": "true,false",
/*ro, opt, string, whether to clear the week schedule of the card reader authentication mode control*/
"userRightWeekPlan": "true,false",
/*ro, opt, string, whether to clear the week schedule of the access permission control*/
"doorStatusHolidayPlan": "true,false",
/*ro, opt, string, whether to clear the holiday schedule of the door control*/
"cardReaderHolidayPlan": "true,false",
/*ro, opt, string, whether to clear the holiday schedule of the card reader authentication mode control*/
"userRightHolidayPlan": "true,false",
/*ro, opt, string, whether to clear the holiday schedule of the access permission control*/
"doorStatusHolidayGroup": "true,false",
/*ro, opt, string, whether to clear the holiday group of the door control*/
"cardReaderHolidayGroup": "true,false",
/*ro, opt, string, whether to clear the holiday group of the card reader authentication mode control*/
"userRightHolidayGroup": "true,false",
/*ro, opt, string, whether to clear the holiday group of the access permission control*/
"doorStatusTemplate": "true,false",
/*ro, opt, string, whether to clear the schedule template of the door control*/
"cardReaderTemplate": "true,false",
/*ro, opt, string, whether to clear the control schedule template of the card reader authentication mode*/
"userRightTemplate": "true,false"
/*ro, opt, string, whether to clear the schedule template of the access permission control*/
}
}
}
21.29.17 Set holiday group parameters of door control schedule
Request URL
PUT /ISAPI/AccessControl/DoorStatusHolidayGroupCfg/<holidayGroupID>?format=json
Query Parameter
Parameter Name Parameter Type Description
holidayGroupID string
-
Request Message
{
"DoorStatusHolidayGroupCfg": {
/*opt, object*/
"enable": true,
/*req, bool, whether to enable, desc:whether to enable*/
"groupName": "test",
/*req, string, holiday group name*/
"holidayPlanNo": "1,3,5"
/*opt, string*/
}
}
Response Message
{
"statusCode": 1,
/*ro, opt, int, status code, desc:1 (succeeded); it is required when an error occurred*/
"statusString": "ok",
/*ro, opt, string, status description, range:[1,64], desc:"ok" (succeeded); it is required when an error occurred*/
"subStatusCode": "ok",
/*ro, opt, string, sub status code, range:[1,64], desc:"ok" (succeeded); it is required when an error occurred*/
"errorCode": 1,
/*ro, opt, int, error code, desc:when the value of statusCode is not 1, it corresponds to subStatusCode*/
"errorMsg": "ok"
/*ro, opt, string, error information, desc:this node must be returned when the value of statusCode is not 1*/
}
21.30 Credential Recognition Module Management


21.30.1 Get the configuration capability of enabling NFC (Near-Field Communication)
function
Request URL
GET /ISAPI/AccessControl/Configuration/NFCCfg/capabilities?format=json
Query Parameter
None
Request Message
None
Response Message
{
"NFCCfgCap": {
/*ro, opt, object, configuration capability of enabling NFC (Near-Field Communication) function*/
"enable": "true,false"
/*ro, req, string, whether to enable NFC function, desc:true-yes, false-no (default)*/
}
}
21.30.2 Get the capability of configuring card No. authentication rule
Request URL
GET /ISAPI/AccessControl/CardVerificationRule/capabilities?format=json
Query Parameter
None
Request Message
None
Response Message
{
"CardVerificationRuleCap": {
/*ro, req, object*/
"cardNoLenMode": {
/*ro, opt, object, length mode of card No. authentication (comparison), desc:length mode of card No. authentication (comparison)*/
"@opt": ["full", "4Bytes", "3Bytes", "wiegand27", "wiegand35", "Corporate1000_35", "Corporate1000_48", "H10302_37", "H10304_37",
"wiegand_26CSN", "H103130_32CSN", "wiegand_56CSN", "wiegand_58"]
/*ro, opt, array, options, subType:string*/
},
"CardVerificationRuleRes": {
/*ro, opt, object*/
"checkStatus": {
/*ro, opt, object, status of switching card No. authentication (comparison) mode, desc:"continue" (switching result can be searched for later),
"ok" (switching completed), "duplicate" (duplicate data exist and switching failed)*/
"@opt": ["continue", "ok", "duplicate"]
/*ro, opt, array, options, subType:string*/
},
"progress": {
/*ro, opt, object, switching progress in percentage, desc:which is between 0 and 100,and 100 indicates that the card No. authentication
(comparison) mode is switched*/
"@min": 0,
/*ro, opt, int, the minimum value*/
"@max": 0
/*ro, opt, int, the maximum value*/
}
},
"reverseCardNoEnabled": {
/*ro, opt, object*/
"@opt": [true, false]
/*ro, opt, array, options, subType:bool, range:[1,2]*/
}
}
}
21.30.3 Set Wiegand parameters
Request URL
PUT /ISAPI/AccessControl/WiegandCfg/wiegandNo/<wiegandID>


Query Parameter
Parameter Name Parameter Type Description
wiegandID
string
Request Message
<?xml version="1.0" encoding="UTF-8"?>
<WiegandCfg xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--wo, req, object, Wiegand parameters, attr:version{req, string, protocolVersion}-->
<communicateDirection>
<!--wo, req, enum, communication direction, subType:string, desc:"receive", "send"-->receive
</communicateDirection>
<wiegandMode>
<!--wo, opt, enum, Wiegand mode, subType:string, dep:or,{$.WiegandCfg.communicateDirection,eq,send}, desc:"wiegand26", "wiegand34", "wiegand27",
"wiegand35", "Corporate1000_35", "Corporate1000_48", "H10302_37", "H10304_37", "wiegand_26CSN", "H103130_32CSN", "wiegand_56CSN", "wiegand_58"-->wiegand26
</wiegandMode>
<inputWiegandMode>
<!--wo, opt, enum, subType:string, dep:or,{$.WiegandCfg.communicateDirection,eq,receive}-->wiegand26
</inputWiegandMode>
<signalInterval>
<!--wo, opt, int, it is between 1 and 20,unit: ms, range:[1,20], desc:unit: ms-->1
</signalInterval>
<enable>
<!--wo, opt, bool, whether to enable the function or not-->true
</enable>
<pulseDuration>
<!--wo, opt, int, range:[1,10]-->1
</pulseDuration>
<facilityCodeEnabled>
<!--opt, bool-->true
</facilityCodeEnabled>
<facilityCode>
<!--opt, int, range:[0,65535], dep:and,{$.WiegandCfg.facilityCodeEnabled,eq,true}-->1
</facilityCode>
<dataType>
<!--opt, enum, data type, subType:string, dep:or,{$.WiegandCfg.wiegandMode,eq,send}, desc:data type-->employeeNo
</dataType>
</WiegandCfg>
Response Message
<?xml version="1.0" encoding="UTF-8"?>
<ResponseStatus xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--ro, req, object, response message, attr:version{ro, req, string, protocolVersion}-->
<requestURL>
<!--ro, req, string, request URL-->null
</requestURL>
<statusCode>
<!--ro, req, enum, status code, subType:int, desc:0 (OK), 1 (OK), 2 (Device Busy), 3 (Device Error), 4 (Invalid Operation), 5 (Invalid XML Format), 6
(Invalid XML Content), 7 (Reboot Required)-->0
</statusCode>
<statusString>
<!--ro, req, enum, status information, subType:string, desc:"OK" (succeeded), "Device Busy", "Device Error", "Invalid Operation", "Invalid XML Format",
"Invalid XML Content", "Reboot" (reboot device)-->OK
</statusString>
<subStatusCode>
<!--ro, req, string, sub status code, which describes the error in details, desc:sub status code, which describes the error in details-->OK
</subStatusCode>
</ResponseStatus>
-
21.30.4 Get Wiegand parameters
Request URL
GET /ISAPI/AccessControl/WiegandCfg/wiegandNo/<wiegandID>
Query Parameter
Parameter Name Parameter Type Description
wiegandID
string
Request Message
None
-


Response Message
<?xml version="1.0" encoding="UTF-8"?>
<WiegandCfg xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--ro, req, object, Wiegand parameters, attr:version{req, string, protocolVersion}-->
<communicateDirection>
<!--ro, req, enum, communication direction, subType:string, desc:"receive", "send"-->receive
</communicateDirection>
<wiegandMode>
<!--ro, opt, enum, Wiegand mode, subType:string, dep:or,{$.WiegandCfg.communicateDirection,eq,send}, desc:"wiegand26", "wiegand34", "wiegand27",
"wiegand35", "Corporate1000_35", "Corporate1000_48", "H10302_37", "H10304_37", "wiegand_26CSN", "H103130_32CSN", "wiegand_56CSN", "wiegand_58"-->wiegand26
</wiegandMode>
<inputWiegandMode>
<!--ro, opt, enum, subType:string, dep:or,{$.WiegandCfg.communicateDirection,eq,receive}-->wiegand26
</inputWiegandMode>
<signalInterval>
<!--ro, opt, int, Wiegand signal sending interval, range:[1,20], desc:unit: ms-->1
</signalInterval>
<enable>
<!--ro, opt, bool, whether to enable the function or not-->true
</enable>
<pulseDuration>
<!--ro, opt, int, range:[1,10]-->1
</pulseDuration>
<facilityCodeEnabled>
<!--ro, opt, bool-->true
</facilityCodeEnabled>
<facilityCode>
<!--ro, opt, int, range:[0,65535], dep:and,{$.WiegandCfg.facilityCodeEnabled,eq,true}-->1
</facilityCode>
<dataType>
<!--ro, opt, enum, data type, subType:string, dep:or,{$.WiegandCfg.wiegandMode,eq,send}, desc:data type-->employeeNo
</dataType>
</WiegandCfg>
21.30.5 Get the card reader configuration parameters
Request URL
GET /ISAPI/AccessControl/CardReaderCfg/<cardReaderID>?format=json
Query Parameter
Parameter Name Parameter Type Description
cardReaderID
string
Request Message
None
Response Message
{
"CardReaderCfg": {
/*ro, req, object, card reader information*/
"enable": true,
/*ro, req, bool, whether to enable, desc:true (enable), false (disable)*/
"okLedPolarity": "cathode",
/*ro, opt, enum, OK LED polarity, subType:string, desc:"cathode", "anode"*/
"errorLedPolarity": "cathode",
/*ro, opt, enum, Error LED polarity, subType:string, desc:"cathode", "anode"*/
"buzzerPolarity": "cathode",
/*ro, opt, enum, buzzer polarity, subType:string, desc:“cathode", "anode"*/
"swipeInterval": 1,
/*ro, opt, int, time interval of repeated authentication, unit:s, desc:which is valid for authentication modes such as fingerprint, card, face,
etc.*/
"pressTimeout": 1,
/*ro, opt, int, timeout to reset entry on keypad, unit:s*/
"enableFailAlarm": true,
/*ro, opt, bool, whether to enable excessive failed authentication attempts alarm*/
"maxReadCardFailNum": 1,
/*ro, opt, int, maximum number of failed authentication attempts*/
"enableTamperCheck": true,
/*ro, opt, bool, whether to enable tampering detection*/
"offlineCheckTime": 1,
/*ro, opt, int, time to detect after the card reader is offline, unit:s*/
"fingerPrintCheckLevel": 1,
/*ro, opt, enum, fingerprint recognition level, subType:int, desc:1-1/10 false acceptance rate (FAR), 2-1/100 false acceptance rate (FAR), 3-1/1000
false acceptance rate (FAR), 4-1/10000 false acceptance rate (FAR), 5-1/100000 false acceptance rate (FAR), 6-1/1000000 false acceptance rate (FAR), 71/10000000
false acceptance rate (FAR), 8-1/100000000 false acceptance rate (FAR), 9-3/100 false acceptance rate (FAR), 10-3/1000 false acceptance rate
(FAR), 11-3/10000 false acceptance rate (FAR), 12-3/100000 false acceptance rate (FAR), 13-3/1000000 false acceptance rate (FAR), 14-3/10000000 false
acceptance rate (FAR), 15-3/100000000 false acceptance rate (FAR), 16-Automatic Normal, 17-Automatic Secure, 18-Automatic More Secure (currently not
support)*/
-


"useLocalController": true,
/*ro, opt, bool, whether it is connected to the distributed controller*/
"localControllerID": 1,
/*ro, opt, int, distributed controller No., range:[0,64], dep:and,{$.CardReaderCfg.localControllerID,eq,true}, desc:which is between 1 and 64, 0unregistered.
This field is valid only when useLocalController is "true”*/
"localControllerReaderID": 1,
/*ro, opt, int, card reader ID of the distributed controller, 0-unregistered, dep:and,{$.CardReaderCfg.localControllerID,eq,true}, desc:this field
is valid only when useLocalController is "true”*/
"cardReaderChannel": 1,
/*ro, opt, enum, communication channel No. of the card reader, subType:int, dep:and,{$.CardReaderCfg.localControllerID,eq,true}, desc:0-Wiegand or
offline, 1-RS-485A, 2-RS-485B. This field is valid only when useLocalController is "true”*/
"fingerPrintImageQuality": 1,
/*ro, opt, enum, fingerprint image quality, subType:int, desc:1-low quality (V1), 2-medium quality (V1), 3-high quality (V1), 4-highest quality
(V1), 5-low quality (V2), 6-medium quality (V2), 7-high quality (V2), 8-highest quality (V2)*/
"fingerPrintContrastTimeOut": 1,
/*ro, opt, enum, fingerprint comparison timeout, subType:int, desc:fingerprint comparison timeout,which is between 1 and 20,unit: second,255infinite*/
"fingerPrintRecogizeInterval":
1,
/*ro, opt, enum, fingerprint scanning interval, subType:int, desc:fingerprint scanning interval,which is between 1 and 10,unit: second,255-no
delay*/
"fingerPrintMatchFastMode": 1,
/*ro, opt, enum, fingerprint matching quick mode, subType:int, desc:1-quick mode 1, 2-quick mode 2, 3-quick mode 3, 4-quick mode 4, 5-quick mode 5,
255-automatic*/
"fingerPrintModuleSensitive": 1,
/*ro, opt, enum, fingerprint module sensitivity, subType:int, desc:fingerprint module sensitivity,which is between 1 and 8*/
"fingerPrintModuleLightCondition": "outdoor",
/*ro, opt, enum, fingerprint module light condition, subType:string, desc:"outdoor", "indoor”*/
"faceMatchThresholdN": 1,
/*ro, opt, int, threshold of face picture 1:N comparison,which is between 0 and 100, range:[0,100]*/
"faceQuality": 1,
/*ro, opt, int, face picture quality, range:[0,100]*/
"faceRecogizeTimeOut": 1,
/*ro, opt, enum, face recognition timeout, subType:int, desc:face recognition timeout,which is between 1 and 20,unit: second,255-infinite*/
"faceRecogizeInterval": 1,
/*ro, opt, enum, face recognition interval, subType:int, desc:face recognition interval,which is between 1 and 10,unit: second,255-no delay*/
"cardReaderFunction": ["fingerPrint", "face", "card"],
/*ro, opt, enumarray, card reader type, subType:string, desc:"fingerPrint”, "face", "fingerVein". For example, ["fingerPrint", "face"] indicates
that the card reader supports both fingerprint and face*/
"cardReaderDescription": "Wiegand\u000485Offline",
/*ro, opt, string, card reader description, desc:if the card reader is the Wiegand card reader or if offline, this field will be set to "Wiegand" or
"485Offline”*/
"faceImageSensitometry": 1,
/*ro, opt, int, face picture exposure, range:[0,655535]*/
"livingBodyDetect": true,
/*ro, opt, bool, whether to enable human detection*/
"faceMatchThreshold1": 1,
/*ro, opt, int, threshold of face picture 1:1 comparison, range:[0,100]*/
"buzzerTime": 1,
/*ro, opt, int, buzzing duration, range:[0,59999], unit:s, desc:buzzing duration,which is between 0 and 5999,unit: second,0-long buzzing*/
"faceMatch1SecurityLevel": 1,
/*ro, opt, enum, security level of face 1:1 recognition, subType:int, desc:1 (normal), 2 (high), 3 (higher)*/
"faceMatchNSecurityLevel": 1,
/*ro, opt, enum, security level of face 1:N recognition: 1-normal,2-high,3-higher, subType:int, desc:1 (normal), 2 (high), 3 (higher)*/
"envirMode": "other",
/*ro, opt, enum, environment mode of face recognition, subType:string, desc:"indoor", "other”*/
"liveDetLevelSet": "low",
/*ro, opt, enum, threshold level of liveness detection, subType:string, desc:"low", "middle", "high”*/
"liveDetAntiAttackCntLimit": 1,
/*ro, opt, int, number of anti-attacks of liveness detection, range:[1,255], desc:this value should be configured as the same one on both client and
device*/
"enableLiveDetAntiAttack": true,
/*ro, opt, bool, whether to enable anti-attack for liveness detection*/
"supportDelFPByID": true,
/*ro, opt, bool, whether the card reader supports deleting fingerprint by fingerprint ID, desc:"true"-yes, "false"-no*/
"fingerPrintCapacity": 1,
/*ro, opt, int, fingerprint capacity*/
"fingerPrintNum": 1,
/*ro, opt, int, number of added fingerprints*/
"defaultVerifyMode": "cardAndPw",
/*ro, opt, enum, default authentication mode of the fingerprint and card reader (factory defaults), subType:string, desc:(factory defaults):
"cardAndPw"-card+password, "card", "cardOrPw"-card or password, "fp"-fingerprint, "fpAndPw"-fingerprint+password, "fpOrCard"-fingerprint or card,
"fpAndCard"-fingerprint+card, "fpAndCardAndPw"-fingerprint+card+password, "faceOrFpOrCardOrPw"-face or fingerprint or card or password, "faceAndFp"face+fingerprint,
"faceAndPw"-face+password, "faceAndCard"-face+card, "face", "employeeNoAndPw"-employee No.+password, "fpOrPw"-fingerprint or password,
"employeeNoAndFp"-employee No.+fingerprint, "employeeNoAndFpAndPw"-employee No.+fingerprint+password, "faceAndFpAndCard"-face+fingerprint+card,
"faceAndPwAndFp"-face+password+fingerprint, "employeeNoAndFace"-employee No.+face, "faceOrfaceAndCard"-face or face+card, "fpOrface"-fingerprint or face,
"cardOrfaceOrPw"-card or face or password, "cardOrFace"-card or face, "cardOrFaceOrFp"-card or face or fingerprint*/
"faceRecogizeEnable": 1,
/*ro, opt, enum, whether to enable facial recognition, subType:int, desc:1 (enable), 2 (disable), 3 (attendence checked in/out by recognition of
multiple faces)*/
"FPAlgorithmVersion": "test",
/*ro, opt, string, fingerprint algorithm library version, range:[1,32]*/
"cardReaderVersion": "test",
/*ro, opt, string, card reader version, range:[1,32]*/
"enableReverseCardNo": true,
/*ro, opt, bool, whether to enable reversing the card No.*/
"independSwipeIntervals": 0,
/*ro, opt, int, time interval of person authentication, desc:unit: second. This time interval is calculated for each person separately and is
different from swipeInterval*/
"maskFaceMatchThresholdN": 1,
/*ro, opt, int, 1:N face picture (face with mask and normal background) comparison threshold, range:[0,100]*/
"maskFaceMatchThreshold1": 1,
/*ro, opt, int, 1:1 face picture (face with mask and normal background) comparison threshold, range:[0,100]*/
"faceMotionDetLevel": "low",
/*ro, opt, enum, subType:string*/


/*ro, opt, enum, subType:string*/
"showMode": "normal",
/*ro, opt, enum, subType:string*/
"enableScreenOff": true,
/*ro, opt, bool*/
"screenOffTimeout": 1
/*ro, opt, int, step:1, unit:s*/
}
}
21.30.6 Set the card reader parameters
Request URL
PUT /ISAPI/AccessControl/CardReaderCfg/<cardReaderID>?format=json
Query Parameter
Parameter Name Parameter Type Description
cardReaderID
string
Request Message
{
"CardReaderCfg": {
/*req, object, card reader information*/
"enable": true,
/*req, bool, whether to enable, desc:true-yes, false-no*/
"okLedPolarity": "cathode",
/*opt, enum, OK LED polarity, subType:string, desc:"cathode", "anode”*/
"errorLedPolarity": "cathode",
/*opt, enum, Error LED polarity, subType:string, desc:"cathode", "anode"*/
"buzzerPolarity": "cathode",
/*opt, enum, buzzer polarity, subType:string, desc:"cathode", "anode"*/
"swipeInterval": 1,
/*opt, int, time interval of repeated authentication, unit:s, desc:it is valid for authentication modes such as fingerprint, card, face, etc.*/
"pressTimeout": 1,
/*opt, int, timeout to reset entry on keypad, unit:s*/
"enableFailAlarm": true,
/*opt, bool, whether to enable excessive failed authentication attempt alarm*/
"maxReadCardFailNum": 1,
/*opt, int, maximum number of failed authentication attempts*/
"enableTamperCheck": true,
/*opt, bool, whether to enable tampering detection*/
"offlineCheckTime": 1,
/*opt, int, time to detect after the card reader is offline, unit:s*/
"fingerPrintCheckLevel": 1,
/*opt, enum, fingerprint recognition level, subType:int, desc:1-1/10 false acceptance rate (FAR), 2-1/100 false acceptance rate (FAR), 3-1/1000
false acceptance rate (FAR), 4-1/10000 false acceptance rate (FAR), 5-1/100000 false acceptance rate (FAR), 6-1/1000000 false acceptance rate (FAR), 71/10000000
false acceptance rate (FAR), 8-1/100000000 false acceptance rate (FAR), 9-3/100 false acceptance rate (FAR), 10-3/1000 false acceptance rate
(FAR), 11-3/10000 false acceptance rate (FAR), 12-3/100000 false acceptance rate (FAR), 13-3/1000000 false acceptance rate (FAR), 14-3/10000000 false
acceptance rate (FAR), 15-3/100000000 false acceptance rate (FAR), 16-Automatic Normal, 17-Automatic Secure, 18-Automatic More Secure (currently not
support)*/
"useLocalController": true,
/*opt, bool, whether it is connected to the distributed controller*/
"localControllerID": 1,
/*opt, int, distributed controller No., range:[0,64], dep:and,{$.CardReaderCfg.localControllerID,eq,true}, desc:0-unregistered. This field is valid
only when useLocalController is "true"*/
"localControllerReaderID": 1,
/*opt, int, card reader ID of the distributed controller, dep:and,{$.CardReaderCfg.localControllerID,eq,true}, desc:0-unregistered. This field is
valid only when useLocalController is "true"*/
"cardReaderChannel": 1,
/*opt, enum, communication channel No. of the card reader, subType:int, dep:and,{$.CardReaderCfg.localControllerID,eq,true}, desc:0-Wiegand or
offline, 1-RS-485A, 2-RS-485B. This field is valid only when useLocalController is "true"*/
"fingerPrintImageQuality": 1,
/*opt, enum, fingerprint image quality, subType:int, desc:1-low quality (V1), 2-medium quality (V1), 3-high quality (V1), 4-highest quality (V1), 5low
quality (V2), 6-medium quality (V2), 7-high quality (V2), 8-highest quality (V2)*/
"fingerPrintContrastTimeOut": 1,
/*opt, enum, fingerprint comparison timeout, subType:int, desc:it is between 1 and 20, unit: second, 255-infinite*/
"fingerPrintRecogizeInterval": 1,
/*opt, enum, fingerprint scanning interval, subType:int, desc:it is between 1 and 10, unit: second, 255-no delay*/
"fingerPrintMatchFastMode": 1,
/*opt, enum, fingerprint matching quick mode, subType:int, desc:1-quick mode 1, 2-quick mode 2, 3-quick mode 3, 4-quick mode 4, 5-quick mode 5, 255automatic*/
"fingerPrintModuleSensitive":
1,
/*opt, enum, fingerprint module sensitivity, subType:int, desc:fingerprint module sensitivity,which is between 1 and 8*/
"fingerPrintModuleLightCondition": "outdoor",
/*opt, enum, fingerprint module light condition, subType:string, desc:"outdoor", "indoor”*/
"faceMatchThresholdN": 1,
/*opt, int, threshold of face picture 1:N comparison, range:[0,100], desc:threshold of face picture 1:N comparison,which is between 0 and 100*/
"faceQuality": 1,
/*opt, int, face picture quality, range:[0,100]*/
"faceRecogizeTimeOut": 1,
/*opt, enum, face recognition timeout, subType:int, desc:it is between 1 and 20, unit: second, 255-infinite*/
"faceRecogizeInterval": 1,
/*opt, enum, face recognition interval, subType:int, desc:it is between 1 and 10, unit: second, 255-no delay*/
"cardReaderFunction": ["fingerPrint", "face", "fingerVein", "iris", "card"],
-


"cardReaderFunction": ["fingerPrint", "face", "fingerVein", "iris", "card"],
/*opt, enumarray, card reader type, subType:string, desc:"fingerPrint"-fingerprint, "face", "fingerVein"-finger vein, “iris”. For example,
["fingerPrint","face"] indicates that the card reader supports both fingerprint and face*/
"cardReaderDescription": "Wiegand\u000485Offline",
/*opt, string, card reader description, desc:if the card reader is the Wiegand card reader or if offline, this field will be set to "Wiegand" or
"485Offline”*/
"faceImageSensitometry": 1,
/*opt, int, face picture exposure, range:[0,655535]*/
"livingBodyDetect": true,
/*opt, bool, whether to enable human detection*/
"faceMatchThreshold1": 1,
/*opt, int, threshold of face picture 1:1 comparison, range:[0,100], desc:threshold of face picture 1:1 comparison,which is between 0 and 100*/
"buzzerTime": 1,
/*opt, int, buzzing duration, range:[0,59999], unit:s, desc:0-long buzzing*/
"faceMatch1SecurityLevel": 1,
/*opt, enum, security level of face 1:1 recognition, subType:int, desc:1-normal, 2-high, 3-higher*/
"faceMatchNSecurityLevel": 1,
/*opt, enum, security level of face 1:N recognition, subType:int, desc:1-normal, 2-high, 3-higher*/
"envirMode": "indoor",
/*opt, enum, environment mode of face recognition, subType:string, desc:"indoor", "other”*/
"liveDetLevelSet": "low",
/*opt, enum, threshold level of liveness detection, subType:string, desc:"low", "middle"-medium, "high"*/
"liveDetAntiAttackCntLimit": 1,
/*opt, int, number of anti-attacks of liveness detection,, range:[1,255], desc:this value should be configured as the same one on both client and
device*/
"enableLiveDetAntiAttack": true,
/*opt, bool, whether to enable anti-attack for liveness detection*/
"supportDelFPByID": true,
/*opt, bool, whether the card reader supports deleting fingerprint by fingerprint ID, desc:true-yes, false-no*/
"fingerPrintCapacity": 1,
/*opt, int, fingerprint capacity*/
"fingerPrintNum": 1,
/*opt, int, number of added fingerprints*/
"defaultVerifyMode": "cardAndPw",
/*opt, enum, default authentication mode of the fingerprint and card reader (factory defaults):, subType:string, desc:"cardAndPw"-card+password,
"card", "cardOrPw"-card or password, "fp"-fingerprint, "fpAndPw"-fingerprint+password, "fpOrCard"-fingerprint or card, "fpAndCard"-fingerprint+card,
"fpAndCardAndPw"-fingerprint+card+password, "faceOrFpOrCardOrPw"-face or fingerprint or card or password, "faceAndFp"-face+fingerprint, "faceAndPw"face+password,
"faceAndCard"-face+card, "face", "employeeNoAndPw"-employee No.+password, "fpOrPw"-fingerprint or password, "employeeNoAndFp"-employee
No.+fingerprint, "employeeNoAndFpAndPw"-employee No.+fingerprint+password, "faceAndFpAndCard"-face+fingerprint+card, "faceAndPwAndFp"face+password+fingerprint,
"employeeNoAndFace"-employee No.+face, "faceOrfaceAndCard"-face or face+card, "fpOrface"-fingerprint or face, "cardOrfaceOrPw"card
or face or password, “iris”, “faceOrFpOrCardOrPwOrIris"-face or fingerprint or card password or iris”, "faceOrCardOrPwOrIris"-face or card or password
or iris*/
"faceRecogizeEnable": 1,
/*opt, enum, whether to enable facial recognition, subType:int, desc:1-enable, 2-disable, 3-attendence checked in/out by recognition of multiple
faces*/
"FPAlgorithmVersion": "test",
/*opt, string, fingerprint algorithm library version, range:[1,32]*/
"cardReaderVersion": "test",
/*opt, string, card reader version, range:[1,32]*/
"enableReverseCardNo": true,
/*opt, bool, whether to enable reversing the card No.*/
"independSwipeIntervals": 0,
/*opt, int, time interval of person authentication, unit: second. This time interval is calculated for each person separately and is different from
swipeInterval, desc:time interval of person authentication,unit: second. This time interval is calculated for each person separately and is different from
swipeInterval*/
"maskFaceMatchThresholdN": 1,
/*opt, int, 1:N face picture (face with mask and normal background) comparison threshold, range:[0,100], desc:1:N face picture (face with mask and
normal background) comparison threshold,value range: [0,100]*/
"maskFaceMatchThreshold1": 1,
/*opt, int, 1:1 face picture (face with mask and normal background) comparison threshold, range:[0,100], desc:1:1 face picture (face with mask and
normal background) comparison threshold,value range: [0,100]*/
"faceMotionDetLevel": "low",
/*opt, enum, subType:string*/
"showMode": "normal",
/*opt, enum, subType:string*/
"enableScreenOff": true,
/*opt, bool*/
"screenOffTimeout": 1
/*opt, int, step:1, unit:s*/
}
}
Response Message
{
"statusCode": 1,
/*ro, opt, int, status code, desc:1 (succeeded). It is required when an error occurred*/
"statusString": "ok",
/*ro, opt, string, status description, range:[1,64], desc:"ok" (succeeded). It is required when an error occurred*/
"subStatusCode": "ok",
/*ro, opt, string, sub status code, range:[1,64], desc:"ok" (succeeded). It is required when an error occurred*/
"errorCode": 1,
/*ro, opt, int, error code, desc:when the value of statusCode is not 1, it corresponds to subStatusCode*/
"errorMsg": "ok"
/*ro, opt, string, error description, desc:this node is required when the value of statusCode is not 1*/
}
21.30.7 Get the configuration capability of the card reader


Request URL
GET /ISAPI/AccessControl/CardReaderCfg/capabilities?format=json
Query Parameter
None
Request Message
None
Response Message
{
"CardReaderCfg": {
/*ro, req, object*/
"cardReaderNo": {
/*ro, opt, object, card reader No., desc:card reader No.*/
"@min": 1,
/*ro, opt, int*/
"@max": 512,
/*ro, opt, int*/
"@opt": [1, 4]
/*ro, opt, array, subType:int*/
},
"enable": "true,false",
/*ro, opt, string, whether to enable: "true"-yes,"false"-no, desc:whether to enable: "true"-yes,"false"-no*/
"okLedPolarity": {
/*ro, opt, object, OK LED polarity*/
"@opt": "cathode,anode"
/*ro, req, string, desc:"cathode", "anode"*/
},
"errorLedPolarity": {
/*ro, opt, object, error LED polarity*/
"@opt": "cathode,anode"
/*ro, req, string*/
},
"buzzerPolarity": {
/*ro, opt, object, buzzer polarity, desc:buzzer polarity: "cathode","anode"*/
"@opt": "cathode,anode"
/*ro, req, string*/
},
"swipeInterval": {
/*ro, opt, object, time interval of repeated authentication, desc:it is valid for authentication modes such as fingerprint, card, face, etc., unit:
second*/
"@min": 1,
/*ro, req, int*/
"@max": 255
/*ro, req, int*/
},
"pressTimeout": {
/*ro, opt, object, timeout to reset entry on keypad, desc:unit: second*/
"@min": 1,
/*ro, req, int*/
"@max": 255
/*ro, req, int*/
},
"enableFailAlarm": "true,false",
/*ro, opt, string, whether to enable excessive failed authentication attempts alarm*/
"maxReadCardFailNum": {
/*ro, opt, object, maximum number of failed authentication attempts*/
"@min": 1,
/*ro, req, int*/
"@max": 255
/*ro, req, int*/
},
"enableTamperCheck": "true,false",
/*ro, opt, string, whether to enable tampering detection*/
"offlineCheckTime": {
/*ro, opt, object, time to detect after the card reader is offline, desc:unit: second*/
"@min": 1,
/*ro, req, int*/
"@max": 255
/*ro, req, int*/
},
"fingerPrintCheckLevel": {
/*ro, opt, object, fingerprint recognition level*/
"@opt": "1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18"
/*ro, req, string*/
},
"useLocalController": "true,false",
/*ro, opt, string, whether it is connected to the distributed controller*/
"localControllerID": {
/*ro, opt, object, distributed controller No., desc:it is between 1 and 64, 0 (unregistered). This field is valid only when useLocalController is
"true"*/
"@min": 0,
/*ro, req, int*/
"@max": 64
/*ro, req, int*/
},


"localControllerReaderID": {
/*ro, opt, object, card reader ID of the distributed controller, desc:0 (unregistered). This field is valid only when useLocalController is "true"*/
"@min": 0,
/*ro, req, int*/
"@max": 4
/*ro, req, int*/
},
"cardReaderChannel": {
/*ro, opt, object, communication channel No. of the card reader, desc:this field is valid only when useLocalController is "true"*/
"@opt": "0,1,2"
/*ro, req, string*/
},
"fingerPrintImageQuality": {
/*ro, opt, object, fingerprint image quality, desc:fingerprint image quality: 1 (low quality (V1)), 2 (medium quality (V1)), 3 (high quality (V1)),
4 (highest quality (V1)), 5 (low quality (V2)), 6 (medium quality (V2)), 7 (high quality (V2)), 8 (highest quality (V2))*/
"@opt": "1,2,3,4,5,6,7,8"
/*ro, req, string*/
},
"fingerPrintContrastTimeOut": {
/*ro, opt, object, fingerprint comparison timeout, desc:it is between 1 and 20, unit: second, 0 (infinite)*/
"@min": 0,
/*ro, req, int*/
"@max": 20
/*ro, req, int*/
},
"fingerPrintRecogizeInterval": {
/*ro, opt, object, fingerprint scanning interval, desc:it is between 1 and 10, unit: second, 0 (no delay)*/
"@min": 0,
/*ro, req, int*/
"@max": 10
/*ro, req, int*/
},
"fingerPrintMatchFastMode": {
/*ro, opt, object, fingerprint matching quick mode, desc:1 (quick mode 1), 2 (quick mode 2), 3 (quick mode 3), 4 (quick mode 4), 5 (quick mode 5), 0
(automatic)*/
"@min": 0,
/*ro, req, int*/
"@max": 5
/*ro, req, int*/
},
"fingerPrintModuleSensitive": {
/*ro, opt, object, fingerprint module sensitivity, desc:it is between 1 and 8*/
"@min": 1,
/*ro, req, int*/
"@max": 8
/*ro, req, int*/
},
"fingerPrintModuleLightCondition": {
/*ro, opt, object, fingerprint module light condition*/
"@opt": "outdoor,indoor"
/*ro, req, string, desc:"outdoor", "indoor"*/
},
"faceMatchThresholdN": {
/*ro, opt, object, threshold of face picture 1:N comparison, desc:it is between 0 and 100*/
"@min": 0,
/*ro, req, int*/
"@max": 100
/*ro, req, int*/
},
"faceQuality": {
/*ro, opt, object, face picture quality, desc:it is between 0 and 100*/
"@min": 0,
/*ro, req, int*/
"@max": 100
/*ro, req, int, the maximum value*/
},
"faceRecogizeTimeOut": {
/*ro, opt, object, face recognition timeout, desc:it is between 1 and 20, unit: second, 0 (infinite)*/
"@min": 0,
/*ro, req, int*/
"@max": 20
/*ro, req, int*/
},
"faceRecogizeInterval": {
/*ro, opt, object, face recognition interval, desc:it is between 1 and 10, unit: second, 0 (no delay)*/
"@min": 0,
/*ro, req, int*/
"@max": 10
/*ro, req, int*/
},
"cardReaderFunction": {
/*ro, opt, object, card reader type*/
"@opt": "fingerPrint,face,fingerVein,iris,card"
/*ro, req, string, desc:"fingerPrint” (fingerprint), "face", "fingerVein” (finger vein), “iris”*/
},
"cardReaderDescription": {
/*ro, opt, object, card reader description, desc:if the card reader is the Wiegand card reader or if offline, this field will be set to "Wiegand" or
"485Offline"*/
"@min": 1,
/*ro, req, int*/
"@max": 16
/*ro, req, int*/
},
"isSupportOfflineSendPermission": true,


"isSupportOfflineSendPermission": true,
/*ro, opt, bool*/
"faceImageSensitometry": {
/*ro, opt, object, face picture exposure, desc:it is between 0 and 65535*/
"@min": 0,
/*ro, req, int*/
"@max": 65535
/*ro, req, int*/
},
"livingBodyDetect": "true,false",
/*ro, opt, string, whether to enable human detection*/
"faceMatchThreshold1": {
/*ro, opt, object, threshold of face picture 1:1 comparison, desc:it is between 0 and 100*/
"@min": 0,
/*ro, req, int*/
"@max": 100
/*ro, req, int*/
},
"buzzerTime": {
/*ro, opt, object, buzzing duration, desc:it is between 0 and 5999, unit: second, 0 (long buzzing)*/
"@min": 0,
/*ro, req, int*/
"@max": 5999
/*ro, req, int*/
},
"faceMatch1SecurityLevel": {
/*ro, opt, object, security level of face 1:1 recognition*/
"@opt": "1,2,3"
/*ro, req, string, desc:1 (normal), 2 (high), 3 (higher)*/
},
"faceMatchNSecurityLevel": {
/*ro, opt, object, security level of face 1:N recognition*/
"@opt": "1,2,3"
/*ro, req, string, desc:1 (normal), 2 (high), 3 (higher)*/
},
"envirMode": {
/*ro, opt, object, environment mode of face recognition*/
"@opt": "indoor,other"
/*ro, req, string, desc:"indoor", "other"*/
},
"liveDetLevelSet": {
/*ro, opt, object, threshold level of liveness detection*/
"@opt": "low,middle,high"
/*ro, req, string, desc:"low", "middle” (medium), "high"*/
},
"liveDetAntiAttackCntLimit": {
/*ro, opt, object, number of anti-attacks of liveness detection, desc:it is between 1 and 255. This value should be configured as the same one on
both client and device*/
"@min": 1,
/*ro, req, int*/
"@max": 255
/*ro, req, int*/
},
"enableLiveDetAntiAttack": "true,false",
/*ro, opt, string, whether to enable anti-attack for liveness detection, desc:whether to enable anti-attack for liveness detection*/
"supportDelFPByID": "true,false",
/*ro, opt, string, whether the card reader supports deleting the fingerprint by fingerprint ID, desc:"true” (yes), "false” (no)*/
"fingerPrintCapacity": {
/*ro, opt, object, maximum number of fingerprints that can be added*/
"@min": 1,
/*ro, req, int*/
"@max": 100
/*ro, req, int*/
},
"fingerPrintNum": {
/*ro, opt, object, number of added fingerprints*/
"@min": 1,
/*ro, req, int*/
"@max": 100
/*ro, req, int*/
},
"defaultVerifyMode": {
/*ro, opt, object, default authentication mode of the card reader, desc:default authentication mode of the card reader (factory defaults)*/
"@opt":
"cardAndPw,card,cardOrPw,fp,fpAndPw,fpOrCard,fpAndCard,fpAndCardAndPw,faceOrFpOrCardOrPw,faceAndFp,faceAndPw,faceAndCard,face,employeeNoAndPw,fpOrPw,employe
eNoAndFp,employeeNoAndFpAndPw,faceAndFpAndCard,faceAndPwAndFp,employeeNoAndFace,faceOrfaceAndCard,fpOrface,cardOrfaceOrPw,cardOrFace,cardOrFaceOrFp,iris,fac
eOrFpOrCardOrPwOrIris,faceOrCardOrPwOrIris"
/*ro, req, string*/
},
"FPAlgorithmVersion": {
/*ro, opt, object, fingerprint algorithm library version*/
"@min": 1,
/*ro, req, int*/
"@max": 1
/*ro, req, int*/
},
"cardReaderVersion": {
/*ro, opt, object, card reader version*/
"@min": 1,
/*ro, req, int*/
"@max": 1
/*ro, req, int*/
},
"faceRecogizeEnable": {


"faceRecogizeEnable": {
/*ro, opt, object, whether to enable facial recognition*/
"@opt": "1,2,3"
/*ro, req, string, desc:1 (enable), 2 (disable), 3 (attendence checked in/out by recognition of multiple faces)*/
},
"enableReverseCardNo": "true,false",
/*ro, opt, string, whether to enable reversing the card No.*/
"independSwipeIntervals": {
/*ro, opt, object, time interval of person authentication, desc:unit: second. This time interval is calculated for each person separately and is
different from swipeInterval*/
"@min": 1,
/*ro, req, int*/
"@max": 1
/*ro, req, int*/
},
"maskFaceMatchThresholdN": {
/*ro, opt, object, 1:N face picture (face with mask and normal background) comparison threshold, desc:value range: [0,100]*/
"@min": 0,
/*ro, req, int*/
"@max": 100
/*ro, req, int*/
},
"maskFaceMatchThreshold1": {
/*ro, opt, object, 1:1 face picture (face with mask and normal background) comparison threshold, desc:value range: [0,100]*/
"@min": 0,
/*ro, req, int*/
"@max": 100
/*ro, req, int*/
},
"faceMotionDetLevel": {
/*ro, opt, object*/
"@opt": ["low", "meduim", "height"]
/*ro, req, array, subType:string*/
},
"showMode": {
/*ro, opt, object*/
"@opt": ["concise", "normal", "advertising", "meeting", "selfDefine"]
/*ro, req, array, subType:string*/
},
"enableScreenOff": {
/*ro, opt, object*/
"@opt": [true, false]
/*ro, req, array, subType:bool*/
},
"screenOffTimeout": {
/*ro, opt, object*/
"@min": 0,
/*ro, req, int*/
"@max": 10
/*ro, req, int*/
}
}
}
21.30.8 Set the parameters of intelligent identity recognition terminal
Request URL
PUT /ISAPI/AccessControl/IdentityTerminal
Query Parameter
None
Request Message
<?xml version="1.0" encoding="UTF-8"?>
<IdentityTerminal xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--req, object, the parameters of intelligent identity recognition terminal, attr:version{req, string, protocolVersion}-->
<terminalMode>
<!--req, enum, terminal mode, subType:string, desc:"authMode” (authentication mode), "registerMode” (registration mode)-->authMode
</terminalMode>
<idCardReader>
<!--req, enum, ID card reader, subType:string, desc:“iDR210”, “DS-K1F110-I”, “DS-K1F1110-B”, “DS-K1F1110-AB”, “none”, “DS-K1F1001-I (USB)”, “DS-K1F1002I
(USB)”-->iDR210
</idCardReader>
<camera>
<!--req, enum, camera, subType:string, desc:"C270", "DS-2CS5432B-S"-->C270
</camera>
<fingerPrintModule>
<!--req, enum, fingerprint module, subType:string, desc:fingerprint module type: ALIWARD,HikModule-->ALIWARD
</fingerPrintModule>
<videoStorageTime>
<!--req, int, time for saving video, range:[0,10], desc:unit: second-->1
</videoStorageTime>
<faceContrastThreshold>
<!--req, int, face picture comparison threshold, range:[0,100]-->1
</faceContrastThreshold>
<twoDimensionCode>


<twoDimensionCode>
<!--req, enum, whether to enable QR code recognition, subType:string, desc:“enable”, “disable”-->enable
</twoDimensionCode>
<blackListCheck>
<!--req, enum, whether to enable blocklist verification, subType:string, desc:“enable”, “disable”-->enable
</blackListCheck>
<idCardCheckCenter>
<!--req, enum, ID card comparison mode, subType:string, desc:“local” (compare with ID card of local storage), “server” (compare with ID card of remote
server storage)-->local
</idCardCheckCenter>
<faceAlgorithm>
<!--req, enum, face picture algorithm, subType:string, desc:face picture algorithm: HIK-Z-Hikviison algorithm,HIK-H-third-party algorithm-->DeepLearn
</faceAlgorithm>
<comNo>
<!--req, int, COM No., range:[1,9]-->1
</comNo>
<memoryLearning>
<!--req, enum, whether to enable learning and memory function, subType:string, desc:“enable”, “disable”-->enable
</memoryLearning>
<saveCertifiedImage>
<!--req, enum, whether to enable saving authenticated picture, subType:string, desc:“enable”, “disable”-->enable
</saveCertifiedImage>
<MCUVersion>
<!--opt, string, MCU Version-->test
</MCUVersion>
<usbOutput>
<!--opt, enum, whether to enable USB output of ID card reader, subType:string, desc:“enable”, “disable”-->enable
</usbOutput>
<serialOutput>
<!--opt, enum, whether to enable serial port output of ID card reade, subType:string, desc:“enable”, “disable”-->enable
</serialOutput>
<readInfoOfCard>
<!--opt, enum, set content to be read from CPU card, subType:string, desc:“serialNo” (read serial No.), “file” (read file)-->serialNo
</readInfoOfCard>
<workMode>
<!--opt, enum, authentication mode, subType:string, desc:“passMode”, “accessControlMode”-->passMode
</workMode>
<ecoMode>
<!--opt, object-->
<eco>
<!--opt, enum, whether to enable ECO mode, subType:string, desc:“enable”, “disable”-->enable
</eco>
<faceMatchThreshold1>
<!--req, int, 1V1 face picture comparison threshold of ECO mode, range:[0,100]-->1
</faceMatchThreshold1>
<faceMatchThresholdN>
<!--req, int, 1VN face picture comparison threshold of ECO mode, range:[0,100]-->1
</faceMatchThresholdN>
<changeThreshold>
<!--opt, int, ECO mode threshold, desc:switching threshold of ECO mode,which is between 0 and 8-->0
</changeThreshold>
<maskFaceMatchThresholdN>
<!--opt, int, 1:N face picture (face with mask and normal background picture) comparison threshold of ECO mode, range:[0,100]-->1
</maskFaceMatchThresholdN>
<maskFaceMatchThreshold1>
<!--opt, int, 1:1 face picture (face with mask and normal background picture) comparison threshold of ECO mode, range:[0,100]-->1
</maskFaceMatchThreshold1>
</ecoMode>
<readCardRule>
<!--opt, enum, card No. setting rule, subType:string, desc:"wiegand26", "wiegand34"-->wiegand26
</readCardRule>
<enableScreenOff>
<!--opt, bool, whether the device enters the sleep mode when there is no operation after the configured sleep time-->true
</enableScreenOff>
<screenOffTimeout>
<!--opt, int, sleep time, desc:unit: second-->1
</screenOffTimeout>
<enableScreensaver>
<!--opt, bool, whether to enable the screen saver function-->true
</enableScreensaver>
<faceModuleVersion>
<!--opt, string, range:[1,32]-->test
</faceModuleVersion>
<showMode>
<!--opt, enum, display mode, subType:string, desc:"concise" (simple mode,only the authentication result will be displayed), "normal" (normal mode). The
default mode is normal mode. If this node does not exist, the default mode is normal mode-->concise
</showMode>
<needDeviceCheck>
<!--opt, bool, dep:or,{$.IdentityTerminal.workMode,eq,passMode}-->true
</needDeviceCheck>
</IdentityTerminal>
Response Message


<?xml version="1.0" encoding="UTF-8"?>
<ResponseStatus xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--ro, req, object, attr:version{req, string, protocolVersion}-->
<requestURL>
<!--ro, req, string, desc:request URL-->test
</requestURL>
<statusCode>
<!--ro, req, enum, status code, subType:int, desc:read-only,status code: 0,1-OK,2-Device Busy,3-Device Error,4-Invalid Operation,5-Invalid XML Format,6Invalid
XML Content,7-Reboot Required,9-Additional Error-->1
</statusCode>
<statusString>
<!--ro, req, enum, read-only,status description, subType:string, desc:“OK” (succeeded), “Device Busy”, “Device Error”, “Invalid Operation”, “Invalid XML
Format”, “Invalid XML Content”, “Reboot” (reboot device)-->OK
</statusString>
<subStatusCode>
<!--ro, req, string, sub status code, desc:read-only,describe the error reason in detail-->test
</subStatusCode>
</ResponseStatus>
21.30.9 Get the parameters of intelligent identity recognition terminal
Request URL
GET /ISAPI/AccessControl/IdentityTerminal
Query Parameter
None
Request Message
None
Response Message
<?xml version="1.0" encoding="UTF-8"?>
<IdentityTerminal xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--ro, req, object, parameters of intelligent identity recognition terminal, attr:version{req, string, protocolVersion}-->
<terminalMode>
<!--ro, req, enum, terminal mode, subType:string, desc:"authMode” (authentication mode), "registerMode” (registration mode)-->authMode
</terminalMode>
<idCardReader>
<!--ro, req, enum, ID card reader model, subType:string, desc:“iDR210”, “DS-K1F110-I”, “DS-K1F1110-B”, “DS-K1F1110-AB”, “none”, “DS-K1F1001-I(USB)”,
“DS-K1F1002-I(USB)”-->iDR210
</idCardReader>
<camera>
<!--ro, req, enum, camera, subType:string, desc:camera model: C270,DS-2CS5432B-S-->C270
</camera>
<fingerPrintModule>
<!--ro, req, enum, fingerprint module type, subType:string, desc:“ALIWARD”, “HikModule”-->ALIWARD
</fingerPrintModule>
<videoStorageTime>
<!--ro, req, int, time for saving video, range:[0,10], desc:unit: second-->1
</videoStorageTime>
<faceContrastThreshold>
<!--ro, req, int, face picture comparison threshold, range:[0,100]-->1
</faceContrastThreshold>
<twoDimensionCode>
<!--ro, req, enum, whether to enable QR code recognition, subType:string, desc:“enable”, “disable”-->enable
</twoDimensionCode>
<blackListCheck>
<!--ro, req, enum, whether to enable blocklist verification, subType:string, desc:“enable”, “disable”-->enable
</blackListCheck>
<idCardCheckCenter>
<!--ro, req, enum, ID card comparison mode, subType:string, desc:“local” (compare with ID card of local storage), “server” (compare with ID card of
remote server storage)-->local
</idCardCheckCenter>
<faceAlgorithm>
<!--ro, req, enum, face picture algorithm, subType:string, desc:face picture algorithm: HIK-Z-Hikviison algorithm,HIK-H-third-party algorithm-
>DeepLearn
</faceAlgorithm>
<comNo>
<!--ro, req, int, COM No., range:[1,9]-->1
</comNo>
<memoryLearning>
<!--ro, req, enum, whether to enable learning and memory function, subType:string, desc:“enable”, “disable”-->enable
</memoryLearning>
<saveCertifiedImage>
<!--ro, req, enum, whether to enable saving authenticated picture, subType:string, desc:“enable”, “disable”-->enable
</saveCertifiedImage>
<MCUVersion>
<!--ro, opt, string, MCU version information-->test
</MCUVersion>
<usbOutput>
<!--ro, opt, enum, whether to enable USB output of ID card reader, subType:string, desc:“enable”, “disable”-->enable


</usbOutput>
<serialOutput>
<!--ro, opt, enum, whether to enable serial port output of ID card reader, subType:string, desc:“enable”, “disable”-->enable
</serialOutput>
<readInfoOfCard>
<!--ro, opt, enum, set content to be read from CPU card, subType:string, desc:“serialNo” (read serial No.), “file” (read file)-->serialNo
</readInfoOfCard>
<workMode>
<!--ro, opt, enum, authentication mode, subType:string, desc:“passMode”, “accessControlMode”-->passMode
</workMode>
<ecoMode>
<!--ro, opt, object-->
<eco>
<!--ro, opt, enum, whether to enable ECO mode, subType:string, desc:“enable”, “disable”-->enable
</eco>
<faceMatchThreshold1>
<!--ro, req, int, 1V1 face picture comparison threshold of ECO mode, range:[0,100]-->1
</faceMatchThreshold1>
<faceMatchThresholdN>
<!--ro, req, int, 1:N face picture comparison threshold of ECO mode, range:[0,100]-->1
</faceMatchThresholdN>
<changeThreshold>
<!--ro, opt, int, switching threshold of ECO mode, desc:switching threshold of ECO mode,which is between 0 and 8-->0
</changeThreshold>
<maskFaceMatchThresholdN>
<!--ro, opt, int, 1:N face picture (face with mask and normal background picture) comparison threshold of ECO mode, range:[0,100]-->0
</maskFaceMatchThresholdN>
<maskFaceMatchThreshold1>
<!--ro, opt, int, 1:1 face picture (face with mask and normal background picture) comparison threshold of ECO mode, range:[0,100]-->0
</maskFaceMatchThreshold1>
</ecoMode>
<readCardRule>
<!--ro, opt, enum, card No. setting rule, subType:string, desc:"wiegand26", "wiegand34”-->wiegand26
</readCardRule>
<enableScreenOff>
<!--ro, opt, bool, whether the device enters the sleep mode when there is no operation after the configured sleep time-->true
</enableScreenOff>
<screenOffTimeout>
<!--ro, opt, int, sleep time, desc:unit: second-->1
</screenOffTimeout>
<enableScreensaver>
<!--ro, opt, bool, whether to enable the screen saver function-->true
</enableScreensaver>
<faceModuleVersion>
<!--ro, opt, string, range:[1,32]-->test
</faceModuleVersion>
<showMode>
<!--ro, opt, enum, display mode, subType:string, desc:"concise" (simple mode,only the authentication result will be displayed), "normal" (normal mode).
The default mode is normal mode. If this node does not exist, the default mode is normal mode-->concise
</showMode>
<needDeviceCheck>
<!--ro, opt, bool, dep:or,{$.IdentityTerminal.workMode,eq,passMode}-->true
</needDeviceCheck>
</IdentityTerminal>
21.30.10 Get configuration capability of intelligent identity recognition terminal
Request URL
GET /ISAPI/AccessControl/IdentityTerminal/capabilities
Query Parameter
None
Request Message
None
Response Message
<?xml version="1.0" encoding="UTF-8"?>
<IdentityTerminal xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--ro, req, object, parameters of intelligent identity recognition terminal, attr:version{req, string, protocolVersion}-->
<terminalMode opt="authMode,registerMode">
<!--ro, req, enum, terminal mode, subType:string, attr:opt{req, string}, desc:"authMode” (authentication mode), "registerMode” (registration mode)-
>authMode
</terminalMode>
<idCardReader opt="iDR210,DS-K1F110-I,DS-K1F1110-B,DS-K1F1110-AB,none ">
<!--ro, req, enum, ID card reader model, subType:string, attr:opt{req, string}, desc:“iDR210”, “DS-K1F110-I”, “DS-K1F1110-B”, “DS-K1F1110-AB”, “none”,
“DS-K1F1001-I (USB)”, “DS-K1F1002-I (USB)”-->iDR210
</idCardReader>
<camera opt="C270,DS-2CS5432B-S">
<!--ro, req, enum, camera, subType:string, attr:opt{req, string}, desc:camera-->C270
</camera>
<fingerPrintModule opt="ALIWARD,HikModule">
<!--ro, req, enum, fingerprint module, subType:string, attr:opt{req, string}, desc:fingerprint module-->ALIWARD
</fingerPrintModule>


</fingerPrintModule>
<videoStorageTime min="0" max="10">
<!--ro, req, int, time for saving video (unit: second), range:[0,10], attr:min{req, int},max{req, int}, desc:unit: second-->1
</videoStorageTime>
<faceContrastThreshold min="0" max="100">
<!--ro, req, int, face picture comparison threshold, range:[0,100], attr:min{req, int},max{req, int}-->1
</faceContrastThreshold>
<twoDimensionCode opt="enable,disable">
<!--ro, req, enum, whether to enable QR code recognition, subType:string, attr:opt{req, string}, desc:“enable”, “disable”-->enable
</twoDimensionCode>
<blackListCheck opt="enable,disable">
<!--ro, req, enum, whether to enable blocklist verification, subType:object, attr:opt{req, string}, desc:“enable”, “disable”-->enable
</blackListCheck>
<idCardCheckCenter opt="local,server">
<!--ro, req, enum, ID card comparison mode, subType:string, attr:opt{req, string}, desc:“local” (compare with ID card of local storage), “server”
(compare with ID card of remote server storage)-->local
</idCardCheckCenter>
<faceAlgorithm opt="DeepLearn,Tradition">
<!--ro, req, enum, face picture algorithm, subType:string, attr:opt{req, string}, desc:face picture algorithm: HIK-Z-Hikviison algorithm,HIK-H-thirdparty
algorithm-->DeepLearn
</faceAlgorithm>
<comNo min="1" max="9">
<!--ro, req, int, COM No., range:[1,9], attr:min{req, int},max{req, int}-->1
</comNo>
<memoryLearning opt="enable,disable">
<!--ro, req, enum, whether to enable learning and memory function, subType:object, attr:opt{req, string}, desc:“enable”, “disable”-->enable
</memoryLearning>
<saveCertifiedImage opt="enable,disable">
<!--ro, req, enum, whether to enable saving authenticated picture, subType:string, attr:opt{req, string}, desc:“enable”, “disable”-->enable
</saveCertifiedImage>
<MCUVersion min="1" max="10">
<!--ro, opt, string, MCU version information, attr:min{req, int},max{req, int}-->test
</MCUVersion>
<usbOutput opt="enable,disable">
<!--ro, req, enum, whether to enable USB output of ID card reader, subType:string, attr:opt{req, string}, desc:whether to enable USB output of ID card
reader-->enable
</usbOutput>
<serialOutput opt="enable,disable">
<!--ro, req, enum, whether to enable serial port output of ID card reader, subType:string, attr:opt{req, string}, desc:whether to enable serial port
output of ID card reader-->enable
</serialOutput>
<readInfoOfCard opt="serialNo,file">
<!--ro, opt, enum, set content to be read from CPU card, subType:string, attr:opt{req, string}, desc:set content to be read from CPU card-->serialNo
</readInfoOfCard>
<workMode opt="passMode,accessControlMode">
<!--ro, opt, enum, authentication mode, subType:string, attr:opt{req, string}, desc:authentication mode-->passMode
</workMode>
<ecoMode>
<!--ro, opt, object-->
<eco opt="enable,disable">
<!--ro, opt, enum, whether to enable ECO mode, subType:string, attr:opt{req, string}, desc:whether to enable ECO mode-->enable
</eco>
<faceMatchThreshold1 min="0" max="100">
<!--ro, req, int, 1V1 face picture comparison threshold of ECO mod, range:[0,100], attr:min{req, int},max{req, int}-->1
</faceMatchThreshold1>
<faceMatchThresholdN min="0" max="100">
<!--ro, req, int, 1:N face picture comparison threshold of ECO mode, range:[0,100], attr:min{req, int},max{req, int}-->1
</faceMatchThresholdN>
<changeThreshold min="1" max="10">
<!--ro, opt, int, switching threshold of ECO mode, attr:min{req, int},max{req, int}, desc:switching threshold of ECO mode,which is between 0 and 8-->0
</changeThreshold>
<maskFaceMatchThresholdN min="0" max="100">
<!--ro, opt, int, 1:N face picture (face with mask and normal background picture) comparison threshold of ECO mode, range:[0,100], attr:min{req,
int},max{req, int}-->1
</maskFaceMatchThresholdN>
<maskFaceMatchThreshold1 min="0" max="100">
<!--ro, opt, int, 1:1 face picture (face with mask and normal background picture) comparison threshold of ECO mode, range:[0,100], attr:min{req,
int},max{req, int}-->1
</maskFaceMatchThreshold1>
</ecoMode>
<readCardRule opt="wiegand26,wiegand34">
<!--ro, opt, enum, card No. setting rule, subType:string, attr:opt{req, string}, desc:card No. setting rule: "wiegand26","wiegand34"-->wiegand26
</readCardRule>
<enableScreenOff opt="true,false">
<!--ro, opt, bool, whether the device enters the sleep mode when there is no operation after the configured sleep time, attr:opt{req, string}-->true
</enableScreenOff>
<screenOffTimeout min="0" max="10">
<!--ro, opt, int, sleep time, attr:min{req, int},max{req, int}, desc:unit: second-->1
</screenOffTimeout>
<enableScreensaver opt="true,false">
<!--ro, opt, bool, whether to enable the screen saver function, attr:opt{req, string}-->true
</enableScreensaver>
<faceModuleVersion min="0" max="10">
<!--ro, opt, string, attr:min{req, int},max{req, int}-->test
</faceModuleVersion>
<showMode opt="concise,normal,advertising,meeting,selfDefine,boxStatus">
<!--ro, opt, enum, display mode, subType:string, attr:opt{req, string}, desc:"concise" (simple mode,only the authentication result will be displayed),
"normal" (normal mode). The default mode is normal mode. If this node does not exist, the default mode is normal mode-->concise
</showMode>
<needDeviceCheck opt="true,false">
<!--ro, opt, bool, dep:or,{$.IdentityTerminal.workMode,eq,passMode}, attr:opt{req, string}-->true
</needDeviceCheck>
</IdentityTerminal>


21.30.11 Set the condition parameters of face picture comparison
Request URL
PUT /ISAPI/AccessControl/FaceCompareCond
Query Parameter
None
Request Message
<?xml version="1.0" encoding="UTF-8"?>
<FaceCompareCond xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--req, object, facial recognition parameters, attr:version{opt, string, protocolVersion}-->
<faceWidthLowerLimit>
<!--opt, int, face width threshold, range:[0,100], desc:when the detected face width is larger than this threshold, the following conditions will be
ignored and the face comparison will be executed it has the highest priority-->50
</faceWidthLowerLimit>
<pitch>
<!--opt, int, face raising or bowing angle, range:[0,90], desc:the smaller the better-->0
</pitch>
<yaw>
<!--opt, int, face siding left or right angle, range:[0,90], desc:the smaller the better-->0
</yaw>
<width>
<!--opt, int, face width, range:[0,100]-->50
</width>
<height>
<!--opt, int, face height, range:[0,100]-->50
</height>
<leftBorder>
<!--opt, int, left border of face, range:[0,100]-->50
</leftBorder>
<rightBorder>
<!--opt, int, right border of face, range:[0,100]-->50
</rightBorder>
<upBorder>
<!--opt, int, top border of face, range:[0,100]-->50
</upBorder>
<bottomBorder>
<!--opt, int, bottom border of face, range:[0,100]-->50
</bottomBorder>
<interorbitalDistance>
<!--opt, int, pupillary distance, range:[0,100]-->50
</interorbitalDistance>
<faceScore>
<!--opt, int, face score (face picture quality), range:[0,100], desc:the valid face score must be larger than this value-->50
</faceScore>
<maxDistance>
<!--opt, enum, maximum recognition distance, subType:string, desc:"0.5" (0.5 m), "1" (1 m), "1.5" (1.5 m), "2" (2m), "auto" (automatic)-->0.5
</maxDistance>
<similarity>
<!--opt, float, face comparison similarity-->50
</similarity>
<antiFake>
<!--opt, int-->50
</antiFake>
<identifyType>
<!--opt, enum, subType:string-->highest
</identifyType>
<chooseType>
<!--opt, enum, subType:string-->all
</chooseType>
<enabled>
<!--opt, enum, subType:string-->singleFace
</enabled>
<faceScoreEnabled>
<!--opt, bool, whether to enable face scoring, desc:whether to enable face scoring-->true
</faceScoreEnabled>
</FaceCompareCond>
Response Message


<?xml version="1.0" encoding="UTF-8"?>
<ResponseStatus xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--ro, req, object, response message, attr:version{ro, req, string, protocolVersion}-->
<requestURL>
<!--ro, req, string, request URL-->null
</requestURL>
<statusCode>
<!--ro, req, enum, status code, subType:int, desc:0 (OK), 1 (OK), 2 (Device Busy), 3 (Device Error), 4 (Invalid Operation), 5 (Invalid XML Format), 6
(Invalid XML Content), 7 (Reboot Required)-->0
</statusCode>
<statusString>
<!--ro, req, enum, status information, subType:string, desc:"OK" (succeeded), "Device Busy", "Device Error", "Invalid Operation", "Invalid XML Format",
"Invalid XML Content", "Reboot" (reboot device)-->OK
</statusString>
<subStatusCode>
<!--ro, req, string, sub status code, which describes the error in details, desc:sub status code, which describes the error in details-->OK
</subStatusCode>
</ResponseStatus>
21.30.12 Get the facial recognition parameters.
Request URL
GET /ISAPI/AccessControl/FaceCompareCond
Query Parameter
None
Request Message
None
Response Message


<?xml version="1.0" encoding="UTF-8"?>
<FaceCompareCond xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--ro, req, object, facial recognition parameters, attr:version{opt, string, protocolVersion}-->
<faceWidthLowerLimit>
<!--ro, opt, int, face width threshold, range:[0,100], desc:When the width of the face to be detected exceeds the threshold, the following conditions
will be ignored and the face comparison will be executed. That is, this parameter has the highest priority.-->50
</faceWidthLowerLimit>
<pitch>
<!--ro, opt, int, face pitching angle, range:[0,90], desc:The smaller, the better.-->0
</pitch>
<yaw>
<!--ro, opt, int, face yawing angle, range:[0,90], desc:The smaller, the better.-->0
</yaw>
<width>
<!--ro, opt, int, face width, range:[0,100]-->50
</width>
<height>
<!--ro, opt, int, face height, range:[0,100]-->50
</height>
<leftBorder>
<!--ro, opt, int, left border of the face, range:[0,100]-->50
</leftBorder>
<rightBorder>
<!--ro, opt, int, right border of the face, range:[0,100]-->50
</rightBorder>
<upBorder>
<!--ro, opt, int, upper border of the face, range:[0,100]-->50
</upBorder>
<bottomBorder>
<!--ro, opt, int, lower border of the face, range:[0,100]-->50
</bottomBorder>
<interorbitalDistance>
<!--ro, opt, int, pupillary distance, range:[0,100]-->50
</interorbitalDistance>
<faceScore>
<!--ro, opt, int, face score, range:[0,100], desc:The face to be detected is valid when its score is higher than the value of this node.-->50
</faceScore>
<maxDistance>
<!--ro, opt, enum, maximum recognition distance, subType:string, desc:0.5 (0.5m), 1 (1m), 1.5 (1.5m), 2 (2m), auto (automatic)-->0.5
</maxDistance>
<similarity>
<!--ro, opt, float, face comparison similarity-->50
</similarity>
<antiFake>
<!--ro, opt, int, face anti-spoofing parameters-->50
</antiFake>
<identifyType>
<!--ro, opt, enum, facial recognition type, subType:string, desc:highest (the highest similarity, default), single (one picture whose similarity exceeds
the threshold), multiple (multiple pictures whose similarity exceeds the threshold). If the value of this node is highest, it indicates all face pictures in
the whole face picture library will be compared and the one with the highest similarity will be returned. If the value of this node is single, it indicates
that the first picture whose similarity exceeds the threshold will be returned. If the value of this node is multiple, the first 30 pictures whose
similarity exceeds the threshold will be returned.-->highest
</identifyType>
<chooseType>
<!--ro, opt, enum, face selection type, subType:string, desc:middle (the face in the middle of the picture), biggest (the biggest face), all (all faces,
default). If the value of this node is middle, only the face in the middle of a picture will be recognized. If the value of this node is biggest, the
biggest face in a picture will be recognized. If the value of this node is all, all faces in a picture will be recognized.-->all
</chooseType>
<enabled>
<!--ro, opt, enum, whether to enable facial recognition, subType:string, desc:singleFace (recognizing a single face, default), close (disable facial
recognition), multiFace (recognizing multiple faces). This node can be used to enable facial recognition for the device and it will take effect in all
readers.-->singleFace
</enabled>
<faceScoreEnabled>
<!--ro, opt, bool, whether to enable face grading, desc:Face grading is used to select the high-quality pictures during person and ID comparison or face
picture collection. This field is used together with the faceScore.-->true
</faceScoreEnabled>
</FaceCompareCond>
21.30.13 Get the capability of configuring facial recognition parameters.
Request URL
GET /ISAPI/AccessControl/FaceCompareCond/capabilities
Query Parameter
None
Request Message
None
Response Message


<?xml version="1.0" encoding="UTF-8"?>
<FaceCompareCond xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--ro, req, object, capability of configuring facial recognition parameters, attr:version{req, string, protocolVersion}-->
<faceWidthLowerLimit min="1" max="10">
<!--ro, opt, int, face width threshold, range:[0,100], attr:min{req, int},max{req, int}, desc:When the width of the face to be detected exceeds the
threshold, the following conditions will be ignored and the face comparison will be executed. That is, this parameter has the highest priority.-->1
</faceWidthLowerLimit>
<pitch min="1" max="10">
<!--ro, opt, int, face pitching angle, range:[0,90], attr:min{req, int},max{req, int}, desc:The smaller, the better.-->1
</pitch>
<yaw min="1" max="10">
<!--ro, opt, int, face yawing angle, range:[0,90], attr:min{req, int},max{req, int}, desc:The smaller, the better.-->1
</yaw>
<width min="1" max="10">
<!--ro, opt, int, face width, range:[0,100], attr:min{req, int},max{req, int}-->1
</width>
<height min="1" max="10">
<!--ro, opt, int, face height, range:[0,100], attr:min{req, int},max{req, int}-->1
</height>
<leftBorder min="1" max="10">
<!--ro, opt, int, left border of the face, range:[0,100], attr:min{req, int},max{req, int}-->1
</leftBorder>
<rightBorder min="1" max="10">
<!--ro, opt, int, right border of the face, range:[0,100], attr:min{req, int},max{req, int}-->1
</rightBorder>
<upBorder min="1" max="10">
<!--ro, opt, int, upper border of the face, range:[0,100], attr:min{req, int},max{req, int}-->1
</upBorder>
<bottomBorder min="1" max="10">
<!--ro, opt, int, lower border of the face, range:[0,100], attr:min{req, int},max{req, int}-->1
</bottomBorder>
<interorbitalDistance min="1" max="10">
<!--ro, opt, int, pupillary distance, range:[0,100], attr:min{req, int},max{req, int}-->1
</interorbitalDistance>
<faceScore min="1" max="10">
<!--ro, opt, int, face score, range:[0,100], attr:min{req, int},max{req, int}, desc:The face to be detected is valid when its score is higher than the
value of this node.-->1
</faceScore>
<maxDistance opt="0.5,1,1.5,2,auto">
<!--ro, opt, string, maximum recognition distance, attr:opt{req, string}, desc:This field takes precedence over interorbitalDistance, unit: m.-->test
</maxDistance>
<similarity min="0.0" max="1.0">
<!--ro, opt, float, face comparison similarity, attr:min{req, int},max{req, int}-->0.000
</similarity>
<antiFake min="1" max="10">
<!--ro, opt, int, face anti-spoofing parameters, attr:min{req, int},max{req, int}-->1
</antiFake>
<identifyType opt="highest,single,multipl">
<!--ro, opt, enum, facial recognition type, subType:string, attr:opt{req, string}, desc:highest (the highest similarity, default), single (one picture
whose similarity exceeds the threshold), multiple (multiple pictures whose similarity exceeds the threshold). If the value of this node is highest, it
indicates all face pictures in the whole face picture library will be compared and the one with the highest similarity will be returned. If the value of
this node is single, it indicates that the first picture whose similarity exceeds the threshold will be returned. If the value of this node is multiple, the
first 30 pictures whose similarity exceeds the threshold will be returned.-->highest
</identifyType>
<chooseType opt="middle,biggest,all">
<!--ro, opt, enum, face selection type, subType:string, attr:opt{req, string}, desc:middle (the face in the middle of the picture), biggest (the biggest
face), all (all faces, default). If the value of this node is middle, only the face in the middle of a picture will be recognized. If the value of this node
is biggest, the biggest face in a picture will be recognized. If the value of this node is all, all faces in a picture will be recognized.-->middle
</chooseType>
<enabled opt="singleFace,close,multiFace">
<!--ro, opt, enum, whether to enable facial recognition, subType:string, attr:opt{req, string}, desc:singleFace (recognizing a single face, default),
close (disable facial recognition), multiFace (recognizing multiple faces). This node can be used to enable facial recognition for the device and it will
take effect in all readers.-->singleFace
</enabled>
<faceScoreEnabled opt="true,false">
<!--ro, opt, bool, whether to enable face grading, attr:opt{req, string}, desc:Face grading is used to select the high-quality pictures during person
and ID comparison or face picture collection. This field is used together with the faceScore.-->true
</faceScoreEnabled>
</FaceCompareCond>
21.30.14 Get the capability of Wiegand parameters
Request URL
GET /ISAPI/AccessControl/WiegandCfg/capabilities
Query Parameter
None
Request Message
None
Response Message


<?xml version="1.0" encoding="UTF-8"?>
<WiegandCfg xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--ro, req, object, configuration of Wiegand parameters, attr:version{req, string, protocolVersion}-->
<wiegandNo min="1" max="4" opt="1,4">
<!--ro, req, int, Wiegand interface No., range:[0,4], step:1, attr:min{opt, int},max{opt, int},opt{opt, string}, desc:Wiegand interface No.-->1
</wiegandNo>
<communicateDirection opt="receive,send">
<!--ro, req, enum, communication direction, subType:string, attr:opt{req, string}, desc:"receive", "send"-->receive
</communicateDirection>
<wiegandMode
opt="wiegand26,wiegand34,wiegand27,wiegand35,Corporate1000_35,Corporate1000_48,H10302_37,H10304_37,wiegand_26CSN,H103130_32CSN,wiegand_56CSN,wiegand_58">
<!--ro, opt, enum, Wiegand mode, subType:string, attr:opt{req, string}, desc:Wiegand mode-->wiegand26
</wiegandMode>
<inputWiegandMode>
<!--ro, opt, enum, subType:string, dep:or,{$.WiegandCfg.communicateDirection,eq,receive}-->wiegand26
</inputWiegandMode>
<signalInterval min="1" max="20">
<!--ro, opt, int, it is between 1 and 20,unit: ms, range:[1,20], attr:min{req, int},max{req, int}, desc:it is between 1 and 20,unit: ms-->1
</signalInterval>
<enable opt="true,false">
<!--ro, opt, bool, whether to enable Wiegand parameters, attr:opt{req, string}-->true
</enable>
<pulseDuration min="1" max="10">
<!--ro, opt, int, pulse duration, range:[1,10], attr:min{req, int},max{req, int}, desc:pulse duration-->1
</pulseDuration>
<facilityCodeEnabled opt="true,false">
<!--ro, opt, bool, whether to enable facilityCode, attr:opt{req, string}-->true
</facilityCodeEnabled>
<facilityCode min="0" max="65535">
<!--ro, opt, int, range:[0,65535], dep:and,{$.WiegandCfg.facilityCodeEnabled,eq,true}, attr:min{req, int, range:[0,65535]},max{req, int, range:
[0,65535]}-->1
</facilityCode>
<dataType opt="employeeNo,cardNo">
<!--ro, opt, enum, data type, subType:string, dep:or,{$.WiegandCfg.wiegandMode,eq,send}, attr:opt{req, string}, desc:data type-->employeeNo
</dataType>
</WiegandCfg>
21.30.15 Get the capability of configuring parameters of the facial recognition mode.
Request URL
GET /ISAPI/AccessControl/FaceRecognizeMode/capabilities?format=json
Query Parameter
None
Request Message
None
Response Message
{
"FaceRecognizeMode": {
/*ro, opt, object, facial recognition mode*/
"mode": {
/*ro, req, object, mode*/
"@opt": "normalMode"
/*ro, opt, enum, mode options, subType:string, desc:"normalMode" (normal mode), "deepMode" (deep mode)*/
}
}
}
21.30.16 Set the parameters of enabling NFC (Near-Field Communication) function
Request URL
PUT /ISAPI/AccessControl/Configuration/NFCCfg?format=json
Query Parameter
None
Request Message


{
"NFCCfg": {
/*req, object, configuration capability of enabling NFC (Near-Field Communication) function*/
"enable": true
/*req, bool, whether to enable NFC function, desc:true-yes, false-no (default)*/
}
}
Response Message
{
"requestURL": "test",
/*ro, opt, string, URI*/
"statusCode": 1,
/*ro, opt, int, status code, desc:1 (succeeded). It is required when an error occurred*/
"statusString": "test",
/*ro, opt, string, status description, desc:"ok" (succeeded). It is required when an error occurred*/
"subStatusCode": "test",
/*ro, opt, string, sub status code, desc:"ok" (succeeded). It is required when an error occurred*/
"errorCode": 1,
/*ro, req, int, error code, desc:it is required when the value of statusCode is not 1, and it corresponds to subStatusCode*/
"errorMsg": "ok"
/*ro, req, string, error information, desc:this node is required when the value of statusCode is not 1*/
}
21.30.17 Get the parameters of enabling NFC (Near-Field Communication) function
Request URL
GET /ISAPI/AccessControl/Configuration/NFCCfg?format=json
Query Parameter
None
Request Message
None
Response Message
{
"NFCCfg": {
/*ro, req, object*/
"enable": true
/*ro, req, bool, whether to enable NFC function, desc:true (yes), false (no). The value of this node is "false" by default*/
}
}
21.30.18 Set the facial recognition mode parameters
Request URL
PUT /ISAPI/AccessControl/FaceRecognizeMode?format=json
Query Parameter
None
Request Message
{
"FaceRecognizeMode": {
/*opt, object, facial recognition mode*/
"mode": "normalMode"
/*req, enum, facial recognition mode, subType:string, desc:"normalMode" (normal mode), "deepMode" (deep mode)*/
}
}
Response Message


{
"requestURL": "/ISAPI/Intelligent/FDLib/asyncImportDatas?format=json",
/*ro, opt, string, request URL*/
"statusCode": 1,
/*ro, opt, int, status code, desc:1 (succeeded). It is required when an error occurred*/
"statusString": "ok",
/*ro, opt, string, status description, range:[1,64], desc:"ok" (succeeded). It is required when an error occurred*/
"subStatusCode": "ok",
/*ro, opt, string, sub status code, range:[1,64], desc:"ok" (succeeded). It is required when an error occurred*/
"errorCode": 1,
/*ro, opt, int, error code, desc:it is required when the value of statusCode is not 1, it corresponds to subStatusCode*/
"errorMsg": "ok"
/*ro, opt, string, error information, desc:this node is required when the value of statusCode is not 1*/
}
21.30.19 Get the parameters of the facial recognition mode.
Request URL
GET /ISAPI/AccessControl/FaceRecognizeMode?format=json
Query Parameter
None
Request Message
None
Response Message
{
"FaceRecognizeMode": {
/*ro, opt, object, facial recognition mode*/
"mode": "normalMode"
/*ro, req, enum, facial recognition mode, subType:string, desc:"normalMode" (normal mode), "deepMode" (deep mode)*/
}
}
21.30.20 Get the configuration capability of the M1 card encryption verification
Request URL
GET /ISAPI/AccessControl/M1CardEncryptCfg/capabilities
Query Parameter
None
Request Message
None
Response Message
<?xml version="1.0" encoding="UTF-8"?>
<M1CardEncryptCfg xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--ro, req, object, configuration capability of the M1 card encryption verification, attr:version{req, string, protocolVersion}-->
<enable opt="true,false">
<!--ro, req, bool, whether to enable, attr:opt{req, string}-->true
</enable>
<sectionID min="0" max="100">
<!--ro, req, int, sector ID, range:[0,100], attr:min{req, int},max{req, int}-->1
</sectionID>
</M1CardEncryptCfg>
21.30.21 Get the configuration parameters of M1 card encryption verification
Request URL
GET /ISAPI/AccessControl/M1CardEncryptCfg
Query Parameter
None
Request Message


None
Response Message
<?xml version="1.0" encoding="UTF-8"?>
<M1CardEncryptCfg xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--ro, req, object, configuration capability of the M1 card encryption verification, attr:version{req, string, protocolVersion}-->
<enable>
<!--ro, req, bool, whether to enable the function-->true
</enable>
<sectionID>
<!--ro, req, int, sector ID, desc:sector ID,only one sector can be configured at a time-->1
</sectionID>
</M1CardEncryptCfg>
21.30.22 Set the parameters of M1 card encryption verification
Request URL
PUT /ISAPI/AccessControl/M1CardEncryptCfg
Query Parameter
None
Request Message
<?xml version="1.0" encoding="UTF-8"?>
<M1CardEncryptCfg xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--req, object, configuration capability of the M1 card encryption verification, attr:version{req, string, protocolVersion}-->
<enable>
<!--req, bool, whether to enable the function-->true
</enable>
<sectionID>
<!--req, int, sector ID, desc:only one sector can be configured at a time-->1
</sectionID>
</M1CardEncryptCfg>
Response Message
<?xml version="1.0" encoding="UTF-8"?>
<ResponseStatus xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--ro, req, object, response status, attr:version{req, string, protocolVersion}-->
<requestURL>
<!--ro, req, string, request URL, desc:request URL-->test
</requestURL>
<statusCode>
<!--ro, req, enum, status code, subType:string, desc:0 (OK), 1 (OK), 2 (Device Busy), 3 (Device Error), 4 (Invalid Operation), 5 (Invalid XML Format), 6
(Invalid XML Content), 7 (Reboot Required)-->1
</statusCode>
<statusString>
<!--ro, req, enum, status description, subType:string, desc:"OK,Device Busy,Device Error,Invalid Operation,Invalid XML Format,Invalid XML
Content,Reboot"-->OK
</statusString>
<subStatusCode>
<!--ro, req, string, sub status code, desc:sub status code description-->test
</subStatusCode>
</ResponseStatus>
21.30.23 Get the parameters of enabling RF (Radio Frequency) card recognition
Request URL
GET /ISAPI/AccessControl/Configuration/RFCardCfg?format=json
Query Parameter
None
Request Message
None
Response Message


{
"RFCardCfg": [
/*ro, req, array, subType:object*/
{
"cardType": "EMCard",
/*ro, req, enum, card type, subType:string, desc:"EMCard” (EM card), "M1Card” (M1 card), "CPUCard” (CPU card), "IDCard” (ID card), "DesfireCard”
(DESFire card), "FelicaCard” (FeliCa card)*/
"enabled": true
/*ro, req, bool, whether to enable RF card recognition, desc:true-yes, false-no*/
}
]
}
21.30.24 Set the parameters of enabling RF (Radio Frequency) card recognition
Request URL
PUT /ISAPI/AccessControl/Configuration/RFCardCfg?format=json
Query Parameter
None
Request Message
{
"RFCardCfg": [
/*req, array, the parameters of enabling RF (Radio Frequency) card recognition, subType:object*/
{
"cardType": "EMCard",
/*req, enum, card type, subType:string, desc:"EMCard"(EM card), "M1Card"(M1 card), "CPUCard"(CPU card), "IDCard"(ID card), "DesfireCard"(DESFire
card), "FelicaCard"(FeliCa card)*/
"enabled": true
/*req, bool, whether to enable RF card recognition, desc:"true"(yes), "false"(no)*/
}
]
}
Response Message
{
"requestURL": "test",
/*ro, opt, string, URI*/
"statusCode": 1,
/*ro, opt, int, status code, desc:1 (succeeded). It is required when an error occurred*/
"statusString": "test",
/*ro, opt, string, status description, desc:"ok" (succeeded). It is required when an error occurred*/
"subStatusCode": "test",
/*ro, opt, string, sub status code, desc:"ok" (succeeded). It is required when an error occurred*/
"errorCode": 1,
/*ro, req, int, error code, desc:it is required when the value of statusCode is not 1, and it corresponds to subStatusCode*/
"errorMsg": "ok"
/*ro, req, string, error information, desc:this node is required when the value of statusCode is not 1*/
}
21.30.25 Get the configuration capability of enabling RF (Radio Frequency) card recognition
Request URL
GET /ISAPI/AccessControl/Configuration/RFCardCfg/capabilities?format=json
Query Parameter
None
Request Message
None
Response Message


{
"RFCardCfgCap": {
/*ro, req, object*/
"cardType": {
/*ro, opt, object, card type, desc:"EMCard"-EM card, "M1Card"-M1 card, "CPUCard"-CPU card, "IDCard"-ID card, "DesfireCard"-DESFire card,
"FelicaCard"-FeliCa card*/
"@opt": ["EMCard", "M1Card", "CPUCard", "IDCard", "FelicaCard"]
/*ro, req, array, options, subType:string*/
},
"enabled": {
/*ro, opt, object, whether to enable RF card recognition*/
"@opt": [true, false]
/*ro, req, array, options, subType:bool*/
}
}
}
21.30.26 Set the parameters of card No. authentication mode
Request URL
PUT /ISAPI/AccessControl/CardVerificationRule?format=json
Query Parameter
None
Request Message
{
"CardVerificationRule": {
/*req, object*/
"cardNoLenMode": "full",
/*req, enum, length mode of card No. authentication (comparison), subType:string, desc:"full", "3Bytes", "4Bytes". After the card No. authentication
(comparison) mode is switched, the device should check the card No. compatibility*/
"reverseCardNoEnabled": true
/*opt, bool*/
}
}
Response Message
{
"statusCode": 1,
/*ro, opt, int, status code, desc:1 (succeeded). It is required when an error occurred*/
"statusString": "ok",
/*ro, opt, string, status description, range:[1,64], desc:"ok" (succeeded). It is required when an error occurred*/
"subStatusCode": "ok",
/*ro, opt, string, sub status code, range:[1,64], desc:"ok" (succeeded). It is required when an error occurred*/
"errorCode": 1,
/*ro, opt, int, error code, desc:it is required when the value of statusCode is not 1, it corresponds to subStatusCode*/
"errorMsg": "ok"
/*ro, opt, string, error information, desc:this node is required when the value of statusCode is not 1*/
}
21.30.27 Get the parameters of card No. authentication mode
Request URL
GET /ISAPI/AccessControl/CardVerificationRule?format=json
Query Parameter
None
Request Message
None
Response Message


{
"CardVerificationRule": {
/*ro, req, object*/
"cardNoLenMode": "full",
/*ro, req, enum, length mode of card No. authentication (comparison), subType:string, desc:"full", "3Bytes", "4Bytes". After the card No.
authentication (comparison) mode is switched, the device should check the card No. compatibility*/
"reverseCardNoEnabled": true
/*ro, opt, bool*/
}
}
21.30.28 Get the switching progress and configuration result of card No. authentication
mode
Request URL
GET /ISAPI/AccessControl/CardVerificationRule/progress?format=json
Query Parameter
None
Request Message
None
Response Message
{
"CardVerificationRuleRes": {
/*ro, req, object*/
"checkStatus": "continue",
/*ro, opt, enum, status of switching card No. authentication (comparison) mode, subType:string, desc:"continue" (switching result can be searched
for later), "ok" (switching succeeded), "duplicate" (duplicate data exist and switching failed)*/
"progress": 100
/*ro, opt, int, switching progress in percentage, range:[0,100], desc:100 indicates that card No. authentication (comparison) mode is switched*/
}
}
21.31 Voice Prompt of Access Authentication
21.31.1 audio prompt control parameters
Request URL
PUT /ISAPI/AccessControl/Verification/ttsText?format=json
Query Parameter
None
Request Message


{
"TTSText": {
/*req, object*/
"enable": true,
/*req, bool, whether to enable, desc:true-enable, false-disable*/
"prefix": "name",
/*opt, enum, whether to play the audio with "user name" or "honorific and last name of the user" as the prefix, subType:string, desc:"name"-play the
audio with "user name" (e.g.,"Jack Smith" will be played), "lastname"-play the audio with "honorific and last name of the user" (e.g.,"Mr. Smith" will be
played), "none" (default)*/
"temperatureBroadcastEnabled": false,
/*opt, bool*/
"Success": [
/*opt, array, Succeeded., subType:object, range:[1,8]*/
{
"TimeSegment": {
/*opt, object, time period, desc:time period*/
"beginTime": "00:00:00",
/*req, string, start time, range:[1,32], desc:start time*/
"endTime": "00:00:00"
/*req, string, end time, range:[1,32], desc:end time*/
},
"language": "SimChinese",
/*opt, enum, language, subType:string, desc:“SimChinese”, “TraChinese”, “English”*/
"audioSourceType": "TTS",
/*opt, enum, subType:string*/
"text": "test",
/*req, string, text of the audio prompt, range:[1,32], dep:and,{$.TTSText.Success[*].audioSourceType,eq,TTS}, desc:text of the audio
prompt*/
"customFileID": 1
/*opt, int, dep:or,{$.TTSText.Success[*].audioSourceType,eq,customFile}*/
}
],
"Failure": [
/*opt, array, subType:object*/
{
"TimeSegment": {
/*opt, object, time period, desc:time period*/
"beginTime": "00:00:00",
/*req, string, start time, range:[1,32], desc:start time*/
"endTime": "00:00:00"
/*req, string, end time, range:[1,32], desc:end time*/
},
"language": "SimChinese",
/*opt, enum, language, subType:string, desc:language*/
"audioSourceType": "TTS",
/*opt, enum, subType:string*/
"text": "test",
/*req, string, text of the audio prompt, range:[1,32], dep:and,{$.TTSText.Success[*].audioSourceType,eq,TTS}, desc:text of the audio
prompt*/
"customFileID": 1
/*opt, int, dep:or,{$.TTSText.Success[*].audioSourceType,eq,customFile}*/
}
]
}
}
Response Message
{
"statusCode": 1,
/*ro, opt, int, status code, desc:1 (succeeded). It is required when an error occurred*/
"statusString": "ok",
/*ro, opt, string, status description, range:[1,64], desc:"ok" (succeeded). It is required when an error occurred*/
"subStatusCode": "ok",
/*ro, opt, string, sub status code, range:[1,64], desc:"ok" (succeeded). It is required when an error occurred*/
"errorCode": 1,
/*ro, opt, int, error code, desc:error code*/
"errorMsg": "ok"
/*ro, opt, string, error information, desc:error information*/
}
21.31.2 Get text parameters of the audio prompt
Request URL
GET /ISAPI/AccessControl/Verification/ttsText?format=json
Query Parameter
None
Request Message
None


Response Message
{
"TTSText": {
/*ro, req, object*/
"enable": true,
/*ro, req, bool, whether to enable, desc:true-enable, false-disable*/
"prefix": "name",
/*ro, opt, enum, whether to play the audio with "user name" or "honorific and last name of the user" as the prefix, subType:string, desc:"name"-play
the audio with "user name" (e.g.,"Jack Smith" will be played), "lastname"-play the audio with "honorific and last name of the user" (e.g.,"Mr. Smith" will
be played), "none" (default)*/
"temperatureBroadcastEnabled": false,
/*ro, opt, bool*/
"Success": [
/*ro, opt, array, succeeded, subType:object, range:[1,8]*/
{
"TimeSegment": {
/*ro, opt, object, time period, desc:time period*/
"beginTime": "00:00:00",
/*ro, req, string, start time, range:[1,32], desc:between 00:00:00 and 23:59:59*/
"endTime": "00:00:00"
/*ro, req, string, end time, range:[1,32], desc:between 00:00:00 and 23:59:59*/
},
"language": "SimChinese",
/*ro, opt, enum, language, subType:string, desc:SimChinese (default), TraChinese, English*/
"audioSourceType": "TTS",
/*ro, opt, enum, subType:string*/
"text": "test",
/*ro, req, string, text of the audio prompt, range:[1,32], dep:and,{$.TTSText.Success[*].audioSourceType,eq,TTS}, desc:text of the audio
prompt*/
"customFileID": 1
/*ro, opt, int, dep:or,{$.TTSText.Success[*].audioSourceType,eq,customFile}*/
}
],
"Failure": [
/*ro, opt, array, failed, subType:object*/
{
"TimeSegment": {
/*ro, opt, object, time period, desc:time period*/
"beginTime": "00:00:00",
/*ro, req, string, start time, range:[1,32], desc:between 00:00:00 and 23:59:59*/
"endTime": "00:00:00"
/*ro, req, string, end time, range:[1,32], desc:between 00:00:00 and 23:59:59*/
},
"language": "SimChinese",
/*ro, opt, enum, language, subType:string, desc:SimChinese, TraChinese, English;*/
"audioSourceType": "TTS",
/*ro, opt, enum, subType:string*/
"text": "test",
/*ro, req, string, text of the audio prompt, range:[1,32], dep:and,{$.TTSText.Success[*].audioSourceType,eq,TTS}, desc:text of the audio
prompt*/
"customFileID": 1
/*ro, opt, int, dep:or,{$.TTSText.Success[*].audioSourceType,eq,customFile}*/
}
]
}
}
21.31.3 Get the text configuration capability of the audio prompt for the authentication
results
Request URL
GET /ISAPI/AccessControl/Verification/ttsText/capabilities?format=json
Query Parameter
None
Request Message
None
Response Message
{
"TTSTextCap": {
/*ro, req, object*/
"enable": [true, false],
/*ro, req, array, whether to enable: true-enable,false-disable, subType:bool, desc:true (enable), false (disable)*/
"prefix": ["name", "lastname", "none"],
/*ro, opt, array, prefix, subType:string, desc:"name"-play the audio with "user name" (e.g.,"Jack Smith" will be played), "lastname"-play the audio
with "honorific and last name of the user" (e.g.,"Mr. Smith" will be played), "none" (default)*/
"temperatureBroadcastEnabled": {
/*ro, opt, object*/
"@opt": [true, false]
/*ro, opt, array, optional item, subType:bool*/


/*ro, opt, array, optional item, subType:bool*/
},
"Success": {
/*ro, opt, object, succeeded*/
"maxSize": 4,
/*ro, opt, int, range:[1,8]*/
"TimeSegment": {
/*ro, opt, object, time range*/
"beginTime": "00:00:00",
/*ro, opt, time, start time, desc:start time*/
"endTime": "00:00:00",
/*ro, opt, string, end time, desc:end time*/
"validUnit": "minute"
/*ro, opt, enum, time accuracy, subType:string, desc:time accuracy*/
},
"language": {
/*ro, opt, object, language*/
"@opt": ["SimChinese", "TraChinese", "English"]
/*ro, opt, array, optional item, subType:string*/
},
"audioSourceType": {
/*ro, opt, object*/
"@opt": ["TTS", "customFile"]
/*ro, opt, array, range, subType:string*/
},
"text": {
/*ro, req, object, text of the audio prompt*/
"@min": 1,
/*ro, opt, int, range, range:[1,128]*/
"@max": 128
/*ro, opt, int, range, range:[1,128]*/
},
"customFileID": {
/*ro, opt, object*/
"@min": 1,
/*ro, opt, int, range*/
"@max": 128
/*ro, opt, int, range*/
}
},
"Failure": {
/*ro, opt, object*/
"maxSize": 4,
/*ro, opt, int, range:[1,8]*/
"TimeSegment": {
/*ro, opt, object, time range*/
"beginTime": "00:00:00",
/*ro, opt, time, start time, desc:start time*/
"endTime": "00:00:00",
/*ro, opt, string, end time, desc:end time*/
"validUnit": "minute"
/*ro, opt, enum, time accuracy, subType:string, desc:time accuracy*/
},
"language": {
/*ro, opt, object, language*/
"@opt": ["SimChinese", "TraChinese", "English"]
/*ro, opt, array, optional item, subType:string*/
},
"audioSourceType": {
/*ro, opt, object*/
"@opt": ["TTS", "customFile"]
/*ro, opt, array, range, subType:string*/
},
"text": {
/*ro, req, object, text of the audio prompt*/
"@min": 1,
/*ro, opt, int, range, range:[1,128]*/
"@max": 128
/*ro, opt, int, range, range:[1,128]*/
},
"customFileID": {
/*ro, opt, object*/
"@min": 1,
/*ro, opt, int, range*/
"@max": 128
/*ro, opt, int, range*/
}
}
}
}
21.32 Temperature Measurement
21.32.1 Get the capability of actively searching for face temperature screening events
Request URL
GET /ISAPI/AccessControl/FaceTemperatureEvent/capabilities?format=json


Query Parameter
None
Request Message
None
Response Message
{
"FaceTemperatureEventCap": {
/*ro, req, object, capability of actively getting face temperature screening events*/
"FaceTemperatureEventCond": {
/*ro, opt, object, conditions of actively getting face temperature screening events*/
"searchID": {
/*ro, req, object, search ID, desc:which is used to check whether the current search requester is the same with the previous one. If it is the
same one, the search record will be stored in the device to speed up the next search*/
"@min": 1,
/*ro, opt, int, the minimum value*/
"@max": 1
/*ro, opt, int, the maximum value*/
},
"searchResultPosition": {
/*ro, req, object, the start position of search result in the result list, desc:in a single search, if you cannot get all the records in the
result list, you can mark the end position and get the following records after the marked position in the next search. If the maximum number of totalMatches
supported by the device is M and the number of totalMatches stored in the device now is N (N<=M), the valid range of this node is 0 to N-1*/
"@min": 1,
/*ro, opt, int, the minimum value*/
"@max": 1
/*ro, opt, int, the maximum value*/
},
"maxResults": {
/*ro, req, object, the maximum number of search results this time by calling this URL, desc:if maxResults value exceeds the range returned by
the device capability, the device will return the maximum number of search results according to the device capability and will not return error message*/
"@min": 1,
/*ro, opt, int, the minimum value*/
"@max": 1
/*ro, opt, int, the maximum value*/
},
"startTime": "1970-01-01T00:00:00+08:00",
/*ro, opt, datetime, start time (UTC time)*/
"endTime": "1970-01-01T00:00:00+08:00",
/*ro, opt, datetime, end time (UTC time)*/
"picEnable": {
/*ro, opt, object, whether to upload the picture along with the event information, desc:true (all matched events will be uploaded with pictures
if there is any), false (all matched events will be uploaded without pictures)*/
"@opt": [true, false]
/*ro, opt, array, options, subType:bool*/
},
"beginSerialNo": {
/*ro, opt, object, start serial No.*/
"@min": 1,
/*ro, opt, int, the minimum value*/
"@max": 1
/*ro, opt, int, the maximum value*/
},
"endSerialNo": {
/*ro, opt, object, end serial No.*/
"@min": 1,
/*ro, opt, int, the minimum value*/
"@max": 1
/*ro, opt, int, the maximum value*/
},
"isAbnomalTemperature": {
/*ro, opt, object, whether the skin-surface temperature is abnormal*/
"@opt": [true, false]
/*ro, opt, array, options, subType:bool, desc:true (yes), false (no)*/
}
},
"InfoList": {
/*ro, opt, object, event information*/
"deviceName": {
/*ro, opt, object, device name*/
"@min": 1,
/*ro, opt, int, the minimum value*/
"@max": 1
/*ro, opt, int, the maximum value*/
},
"serialNo": {
/*ro, opt, object, event serial No.*/
"@min": 1,
/*ro, opt, int, the minimum value*/
"@max": 1
/*ro, opt, int, the maximum value*/
},
"thermometryUnit": {
/*ro, req, object, temperature unit, desc:"celsius" (Celsius-default value), "fahrenheit" (Fahrenheit), "kelvin" (Kelvin)*/
"@opt": ["celsius", "fahrenheit", "kelvin"]
/*ro, opt, array, options, subType:string*/
},
"currTemperature": {


"currTemperature": {
/*ro, req, object, face temperature, desc:it should be accurate to one decimal place*/
"@min": 1.0,
/*ro, opt, float, the minimum value*/
"@max": 1.0
/*ro, opt, float, the maximum value*/
},
"isAbnomalTemperature": {
/*ro, opt, object, whether the face temperature is abnormal, desc:true (yes), false (no)*/
"@opt": [true, false]
/*ro, opt, array, options, subType:bool*/
},
"RegionCoordinates": {
/*ro, opt, object, face temperature's coordinates*/
"positionX": {
/*ro, opt, object, x-coordinate, desc:the value is normalized to a number between 0 and 1000*/
"@min": 1,
/*ro, opt, int, the minimum value*/
"@max": 1
/*ro, opt, int, the maximum value*/
},
"positionY": {
/*ro, opt, object, Y-coordinate, desc:the value is normalized to a number between 0 and 1000*/
"@min": 1,
/*ro, opt, int, the minimum value*/
"@max": 1
/*ro, opt, int, the maximum value*/
}
},
"mask": {
/*ro, opt, object, whether the person wears a mask: "unknown" (unknown), "yes" (wearing a mask), "no" (no mask), desc:"unknown" (unknown), "yes"
(wearing a mask), "no" (no mask)*/
"@opt": ["unknown", "yes", "no"]
/*ro, opt, array, options, subType:string*/
},
"capturePicUrl": {
/*ro, opt, object, URL of the captured picture*/
"@min": 1,
/*ro, opt, int, the minimum value*/
"@max": 1
/*ro, opt, int, the maximum value*/
},
"visibleLightPicUrl": {
/*ro, opt, object, URL of the visible light picture*/
"@min": 1,
/*ro, opt, int, the minimum value*/
"@max": 1
/*ro, opt, int, the maximum value*/
},
"thermalPicUrl": {
/*ro, opt, object, the URL of the thermal picture*/
"@min": 1,
/*ro, opt, int, the minimum value*/
"@max": 1
/*ro, opt, int, the maximum value*/
},
"helmet": {
/*ro, opt, object, whether the person wears a hard hat*/
"@opt": ["unknown", "yes", "no"]
/*ro, opt, array, options, subType:string*/
},
"dateTime": "1970-01-01T00:00:00+08:00",
/*ro, req, datetime, the time (UTC time) when the alarm is triggered, desc:the maximum size is 32*/
"FaceRect": {
/*ro, opt, object, rectangle frame for human face, desc:the origin is the upper-left corner of the screen*/
"height": {
/*ro, req, object, height*/
"@min": 0.000,
/*ro, opt, float, the minimum value*/
"@max": 1.000
/*ro, opt, float, the maximum value*/
},
"width": {
/*ro, req, object, width*/
"@min": 0.000,
/*ro, opt, float, the minimum value*/
"@max": 1.000
/*ro, opt, float, the maximum value*/
},
"x": {
/*ro, req, object, X-coordinate of the upper-left corner of the frame*/
"@min": 0.000,
/*ro, opt, float, the minimum value*/
"@max": 1.000
/*ro, opt, float, the maximum value*/
},
"y": {
/*ro, req, object, Y-coordinate of the upper-left corner of the frame*/
"@min": 0.000,
/*ro, opt, float, the minimum value*/
"@max": 1.000
/*ro, opt, float, the maximum value*/
}
}


}
}
}
}
21.32.2 Search for skin-surface temperature screening event
Request URL
POST /ISAPI/AccessControl/FaceTemperatureEvent?format=json
Query Parameter
None
Request Message
{
"FaceTemperatureEventCond": {
/*req, object, search conditions of skin-surface temperature screening events*/
"searchID": "test",
/*req, string, search ID, desc:which is used to check whether the current search requester is the same as the previous one. If they are the same,
the search record will be stored in the device to speed up the next search*/
"searchResultPosition": 0,
/*req, int, the start position of the search result in the result list, desc:In a single search, if you cannot get all the records in the result
list, you can mark the end position and get the following records after the marked position in the next search. If the maximum number of totalMatches
supported by the device is M and the number of totalMatches stored in the device now is N (N<=M), the valid range of this node is 0 to N-1*/
"maxResults": 30,
/*req, int, the maximum number of search results this time by calling this URL, desc:if maxResults exceeds the range returned by the device
capability, the device will return the maximum number of search results according to the device capability and will not return error message*/
"startTime": "1970-01-01T00:00:00+08:00",
/*opt, datetime, start time (UTC time)*/
"endTime": "1970-01-01T00:00:00+08:00",
/*opt, datetime, end time (UTC time)*/
"picEnable": true,
/*opt, bool, whether to upload the picture along with the event information*/
"beginSerialNo": 1,
/*opt, int, start serial No.*/
"endSerialNo": 1,
/*opt, int, end serial No.*/
"isAbnomalTemperature": true
/*opt, bool, whether the skin-surface temperature is abnormal*/
}
}
Response Message


{
"FaceTemperatureEvent": {
/*ro, req, object, skin-surface temperature screening event*/
"searchID": "test",
/*ro, req, string, search ID, desc:it is used to check whether the current search requester is the same as the previous one. If they are the same,
the search record will be stored in the device to speed up the next search*/
"responseStatusStrg": "OK",
/*ro, req, enum, searching status description, subType:string, desc:"OK" (searching completed), "MORE" (searching for more data), "NO MATCH" (no
matched data)*/
"numOfMatches": 1,
/*ro, req, int, number of results returned this time*/
"totalMatches": 1,
/*ro, req, int, total number of matched results*/
"InfoList": [
/*ro, opt, array, event information list, subType:object*/
{
"deviceName": "test",
/*ro, opt, string, device name*/
"serialNo": 1,
/*ro, opt, int, event serial No.*/
"thermometryUnit": "celsius",
/*ro, req, enum, temperature unit, subType:string, desc:"celsius" (Celsius, default value), "fahrenheit" (Fahrenheit), "kelvin" (Kelvin)*/
"currTemperature": 1.0,
/*ro, req, float, skin-surface temperature, desc:it should be accurate to one decimal place*/
"isAbnomalTemperature": true,
/*ro, opt, bool, whether the skin-surface temperature is abnormal, desc:true (yes), false (no)*/
"RegionCoordinates": {
/*ro, opt, object, coordinates of the skin-surface temperature*/
"positionX": 1,
/*ro, opt, int, X-coordinate, range:[0,1000], desc:the value is normalized to a number between 0 and 1000*/
"positionY": 1
/*ro, opt, int, Y-coordinate, range:[0,1000], desc:the value is normalized to a number between 0 and 1000*/
},
"mask": "unknown",
/*ro, opt, enum, whether the person wears a mask, subType:string, desc:"unknown" (unknown), "yes" (wearing a mask), "no" (no mask)*/
"capturePicUrl": "test",
/*ro, opt, string, URL of the captured picture*/
"visibleLightPicUrl": "test",
/*ro, opt, string, URL of the visible light picture*/
"thermalPicUrl": "test",
/*ro, opt, string, URL of the thermal imaging picture*/
"helmet": "unknown",
/*ro, opt, enum, whether the person is wearing hard hat, subType:string, desc:"unknown", "yes", "no"*/
"dateTime": "1970-01-01T00:00:00+08:00",
/*ro, req, datetime, alarm trigger time (UTC time), desc:the maximum size is 32 bytes*/
"FaceRect": {
/*ro, opt, object, rectangle frame for human face, desc:the origin is the upper-left corner of the screen*/
"height": 1.000,
/*ro, req, float, height, range:[0.000,1.000]*/
"width": 1.000,
/*ro, req, float, width, range:[0.000,1.000]*/
"x": 0.000,
/*ro, req, float, X-coordinate of the upper-left corner of the frame, range:[0.000,1.000]*/
"y": 0.000
/*ro, req, float, Y-coordinate of the upper-left corner of the frame, range:[0.000,1.000]*/
}
}
]
}
}
21.32.3 Set the temperature measurement parameters
Request URL
PUT /ISAPI/AccessControl/temperatureMeasureCfg?format=json
Query Parameter
None
Request Message


{
"showTemperatureInfo": true,
/*opt, bool, whether to display the temperature information, desc:true (yes), false (no)*/
"saveThermalPicture": true,
/*opt, bool, whether to save the thermal picture, desc:true (yes), false (no)*/
"uploadThermalPicture": true,
/*opt, bool, whether to upload the thermal picture, desc:true (yes), false (no)*/
"lowTemperatureEnabled": true,
/*opt, bool, whether to enable temperature measurement in the low-temperature environment, desc:true (enable), false (disable)*/
"distance": 0.3,
/*opt, float, unit:m*/
"temperatureMeasureMode": "auto"
/*opt, enum, temperature measurement mode, subType:string, desc:temperature measurement mode*/
}
Response Message
{
"statusCode": 1,
/*ro, opt, int, status code, desc:1 (succeeded). It is required when an error occurred*/
"statusString": "ok",
/*ro, opt, string, status description, range:[1,64], desc:"ok" (succeeded). It is required when an error occurred*/
"subStatusCode": "ok",
/*ro, opt, string, sub status code, range:[1,64], desc:"ok" (succeeded). It is required when an error occurred*/
"errorCode": 1,
/*ro, opt, int, error code, desc:it is required when the value of statusCode is not 1, it corresponds to subStatusCode*/
"errorMsg": "ok"
/*ro, opt, string, error description, desc:this field is required when the value of statusCode is not 1*/
}
21.32.4 Get the temperature measurement parameters
Request URL
GET /ISAPI/AccessControl/temperatureMeasureCfg?format=json
Query Parameter
None
Request Message
None
Response Message
{
"showTemperatureInfo": true,
/*ro, opt, bool, whether to display the temperature information, desc:true (yes), false (no)*/
"saveThermalPicture": true,
/*ro, opt, bool, whether to save the thermal picture, desc:true (yes), false (no)*/
"uploadThermalPicture": true,
/*ro, opt, bool, whether to upload the thermal picture, desc:true (yes), false (no)*/
"lowTemperatureEnabled": true,
/*ro, opt, bool, whether to enable temperature measurement in the low-temperature environment, desc:true (enable), false (disable)*/
"distance": 0.3,
/*ro, opt, float, face temperature screening distance, unit:m*/
"temperatureMeasureMode": "auto",
/*ro, opt, enum, temperature screening mode, subType:string, desc:"auto", "manual"*/
"thermometryModuleStatus": "online"
/*ro, opt, enum, subType:string, desc:"online", "offline"*/
}
21.32.5 Get the configuration capability of temperature measurement parameters
Request URL
GET /ISAPI/AccessControl/temperatureMeasureCfg/capabilities?format=json
Query Parameter
None
Request Message
None
Response Message


{
"showTemperatureInfo": {
/*ro, opt, object, whether to display the temperature information, desc:true (yes), false (no)*/
"@opt": [true, false]
/*ro, req, array, subType:bool*/
},
"saveThermalPicture": {
/*ro, opt, object, whether to save the thermal picture, desc:true (yes), false (no)*/
"@opt": [true, false]
/*ro, req, array, subType:bool*/
},
"uploadThermalPicture": {
/*ro, opt, object, whether to upload the thermal picture, desc:true (yes), false (no)*/
"@opt": [true, false]
/*ro, req, array, subType:bool*/
},
"lowTemperatureEnabled": {
/*ro, opt, object, whether to enable temperature measurement in the low-temperature environment, desc:when this function is enabled, if the face
temperature is lower than 36 °C, the measured temperature will be mapped to that higher than 36 °C; temperatures higher than 36 °C will not be mapped*/
"@opt": [true, false]
/*ro, req, array, subType:bool, desc:true (enable), false (disable)*/
},
"distance": {
/*ro, opt, object*/
"@min": 0.3,
/*ro, req, float*/
"@max": 2.0
/*ro, req, float*/
},
"temperatureMeasureMode": {
/*ro, opt, object*/
"@opt": ["auto", "manual"]
/*ro, opt, array, subType:string*/
},
"thermometryModuleStatus": {
/*ro, opt, object*/
"@opt": ["online", "offline"]
/*ro, req, array, subType:string*/
}
}
21.32.6 Get the configuration capability of the black body
Request URL
GET /ISAPI/AccessControl/blackObject/capabilities?format=json
Query Parameter
None
Request Message
None
Response Message


{
"enabled": {
/*ro, req, object, whether to enable the black body, desc:the black body is used to calibrate the temperature of the thermography module. You need to
put the black body with fixed temperature in front of the device and calibrate the temperature of the thermography module according to the black body in the
image*/
"@opt": [true, false]
/*ro, opt, array, options, subType:bool*/
},
"Position": {
/*ro, opt, object, black body position (coordinate), desc:the value is normalized to a number between 0 and 1000*/
"x": {
/*ro, opt, object, X-coordinate*/
"@min": 0,
/*ro, opt, int, the minimum value, range:[0,1000]*/
"@max": 1000
/*ro, opt, int, the maximum value, range:[0,1000]*/
},
"y": {
/*ro, opt, object, Y-coordinate*/
"@min": 0,
/*ro, opt, int, the minimum value, range:[0,1000]*/
"@max": 1000
/*ro, opt, int, the maximum value, range:[0,1000]*/
}
},
"distance": {
/*ro, opt, object, distance between the black body and the lens, desc:the value is accurate to one decimal place, unit: meter*/
"@min": 0.0,
/*ro, opt, float, the minimum value*/
"@max": 10.0
/*ro, opt, float, the maximum value*/
},
"emissivity": {
/*ro, opt, object, emissivity, desc:the value is accurate to two decimal places. The emissivity is applied from the system or platform to the device and
is transmitted to the thermography module by the device for temperature measurement*/
"@min": 0.00,
/*ro, opt, float, the minimum value*/
"@max": 1.00
/*ro, opt, float, the maximum value*/
},
"TemperatureList": [
/*ro, opt, array, temperature list of the black body, subType:object, desc:the second decimal place of the black body's temperature will be rounded to
eliminate the error. For example, 0.95 will be input as 1.0*/
{
"unit": "celsius",
/*ro, opt, enum, temperature unit, subType:string, desc:"celsius", "fahrenheit"*/
"temperature": {
/*ro, opt, object, black body temperature, desc:When the unit is "celsius", the value of this node is between 30.0 and 50.0; when the unit is
"fahrenheit", the value of this node is between 86.0 and 122.0*/
"@min": 30.0,
/*ro, opt, float, the minimum value*/
"@max": 50.0
/*ro, opt, float, the maximum value*/
}
}
]
}
21.32.7 Set the black body parameters
Request URL
PUT /ISAPI/AccessControl/blackObject?format=json
Query Parameter
None
Request Message


{
"enabled": true,
/*req, bool, whether to enable the black body*/
"Position": {
/*opt, object, black body position (coordinate), desc:black body position (coordinate)*/
"x": 1,
/*opt, int, X-coordinate, range:[0,1000]*/
"y": 1
/*opt, int, Y-coordinate, range:[0,1000]*/
},
"distance": 1.0,
/*opt, float, distance between the black body and the lens, range:[0.0,10.0], desc:unit: meter; the value is accurate to one decimal place*/
"emissivity": 0.10,
/*opt, float, emissivity, range:[0.00,1.00], desc:the value is accurate to two decimal places*/
"unit": "celsius",
/*opt, enum, unit, subType:string, desc:"celsius", "fahrenheit"*/
"temperature": 30.0
/*opt, float, black body temperature, range:[30.0,50.0],
desc:the value is accurate to one decimal place
when the value of the node unit is "celsius", the value of this node is between 30.0 and 50.0; when the value of the node unit is "fahrenheit", the
value of this node is between 86.0 and 122.0*/
}
Response Message
{
"statusCode": 1,
/*ro, opt, int, status code, desc:1 (succeeded). It is required when an error occurred*/
"statusString": "ok",
/*ro, opt, string, status description, range:[1,64], desc:"ok" (succeeded). It is required when an error occurred*/
"subStatusCode": "ok",
/*ro, opt, string, sub status code, range:[1,64], desc:"ok" (succeeded). It is required when an error occurred*/
"errorCode": 1,
/*ro, opt, int, error code, desc:when the value of statusCode is not 1, it corresponds to subStatusCode*/
"errorMsg": "ok"
/*ro, opt, string, error information, desc:this node is required when the value of statusCode is not 1*/
}
21.32.8 Get the black body parameters
Request URL
GET /ISAPI/AccessControl/blackObject?format=json
Query Parameter
None
Request Message
None
Response Message
{
"enabled": true,
/*ro, req, bool, whether to enable the black body*/
"Position": {
/*ro, opt, object, black body position (coordinate), desc:the value is normalized to a number between 0 and 1000. The origin is the upper-left corner of
the screen*/
"x": 1,
/*ro, opt, int, X-coordinate, range:[0,1000]*/
"y": 1
/*ro, opt, int, Y-coordinate, range:[0,1000]*/
},
"distance": 1.0,
/*ro, opt, float, distance between the black body and the lens, range:[0.0,10.0], desc:the value is accurate to one decimal place, unit: meter*/
"emissivity": 0.10,
/*ro, opt, float, emissivity, range:[0.00,1.00], desc:the value is accurate to two decimal places*/
"unit": "celsius",
/*ro, opt, enum, temperature unit, subType:string, desc:"celsius", "fahrenheit"*/
"temperature": 30.0
/*ro, opt, float, black body temperature, range:[30.0,50.0],
desc:the value is accurate to one decimal place
when the value of the node unit is "celsius", the value of this node is between 30.0 and 50.0; when the value of the node unit is "fahrenheit", the
value of this node is between 86.0 and 122.0*/
}
21.32.9 Get the calibration capability of the temperature measurement area
Request URL


GET /ISAPI/AccessControl/temperatureMeasureAreaCalibration/capabilities?format=json
Query Parameter
None
Request Message
None
Response Message
{
"enabled": {
/*ro, req, object, whether to enable the calibration function, desc:true (enable), false (disable)*/
"@opt": [true, false]
/*ro, opt, array, subType:bool*/
},
"FaceFrameCoordinate": {
/*ro, opt, object, coordinates of the face picture frame, desc:the origin is the upper-left corner of the screen*/
"height": {
/*ro, opt, object, height*/
"@min": 0,
/*ro, opt, int, range:[0,1000]*/
"@max": 1000
/*ro, opt, int, range:[0,1000]*/
},
"width": {
/*ro, opt, object, width*/
"@min": 0,
/*ro, opt, int, range:[0,1000]*/
"@max": 1000
/*ro, opt, int, range:[0,1000]*/
},
"x": {
/*ro, opt, object, X-coordinate*/
"@min": 0,
/*ro, opt, int, range:[0,1000]*/
"@max": 1000
/*ro, opt, int, range:[0,1000]*/
},
"y": {
/*ro, opt, object, Y-coordinate*/
"@min": 0,
/*ro, opt, int, range:[0,1000]*/
"@max": 1000
/*ro, opt, int, range:[0,1000]*/
}
}
}
21.32.10 Set the calibration parameters of the temperature measurement area
Request URL
PUT /ISAPI/AccessControl/temperatureMeasureAreaCalibration?format=json
Query Parameter
None
Request Message
{
"enabled": true,
/*req, bool, whether to enable calibration, desc:true (enable), false (disable)*/
"FaceFrameCoordinate": {
/*opt, object, coordinate of the face frame, desc:the value is normalized to a number between 0 and 1000*/
"height": 1,
/*opt, int, height, range:[0,1000]*/
"width": 2,
/*opt, int, width, range:[0,1000]*/
"x": 5,
/*opt, int, x-coordinate, range:[0,1000]*/
"y": 10
/*opt, int, y-coordinate, range:[0,1000]*/
}
}
Response Message


{
"statusCode": 1,
/*ro, opt, int, status code, desc:1 (succeeded). It is required when an error occurred*/
"statusString": "ok",
/*ro, opt, string, status description, range:[1,64], desc:"ok" (succeeded). It is required when an error occurred*/
"subStatusCode": "ok",
/*ro, opt, string, sub status code, range:[1,64], desc:"ok" (succeeded). It is required when an error occurred*/
"errorCode": 1,
/*ro, opt, int, error code, desc:it is required when the value of statusCode is not 1, it corresponds to subStatusCode*/
"errorMsg": "ok"
/*ro, opt, string, error description, desc:this field is required when the value of statusCode is not 1*/
}
21.32.11 Get the calibration parameters of the temperature measurement area
Request URL
GET /ISAPI/AccessControl/temperatureMeasureAreaCalibration?format=json
Query Parameter
None
Request Message
None
Response Message
{
"enabled": true,
/*ro, req, bool, whether to enable calibration, desc:true (enable), false (disable)*/
"FaceFrameCoordinate": {
/*ro, opt, object, coordinate of the face frame, desc:object,coordinate of the face frame,the value is normalized to a number between 0 and 1000*/
"height": 1,
/*ro, opt, int, height, range:[0,1000]*/
"width": 2,
/*ro, opt, int, width, range:[0,1000]*/
"x": 5,
/*ro, opt, int, X-coordinate, range:[0,1000]*/
"y": 10
/*ro, opt, int, Y-coordinate, range:[0,1000]*/
}
}
21.32.12 Get the configuration capability of temperature measurement parameters
Request URL
GET /ISAPI/AccessControl/temperatureMeasureAreaCfg/capabilities?format=json
Query Parameter
None
Request Message
None
Response Message


{
"uniqueItems": {
/*ro, req, object, range of the number of vertexes of the polygon*/
"@min": 3,
/*ro, opt, int, the minimum value*/
"@max": 10
/*ro, opt, int*/
},
"RegionCoordinate": {
/*ro, opt, object, coordinate of the vertexes of the polygon, desc:the origin is the upper-left corner of the screen*/
"x": {
/*ro, opt, object, X-coordinate*/
"@min": 0,
/*ro, opt, int, the minimum value, range:[0,1000]*/
"@max": 1000
/*ro, opt, int, range:[0,1000]*/
},
"y": {
/*ro, opt, object, Y-coordinate*/
"@min": 0,
/*ro, opt, int, the minimum value, range:[0,1000]*/
"@max": 1000
/*ro, opt, int, range:[0,1000]*/
}
}
}
21.32.13 Set the parameters of the temperature measurement area
Request URL
PUT /ISAPI/AccessControl/temperatureMeasureAreaCfg?format=json
Query Parameter
None
Request Message
{
"RegionCoordinate": [
/*req, array, coordinates of vertexes of the polygon, subType:object, range:[0,4], desc:coordinates of vertexes of the polygon*/
{
"x": 1,
/*opt, int, x-coordinate, range:[0,1000]*/
"y": 2
/*opt, int, y-coordinate, range:[0,1000]*/
}
]
}
Response Message
{
"statusCode": 1,
/*ro, opt, int, status code, desc:1 (succeeded). It is required when an error occurred*/
"statusString": "ok",
/*ro, opt, string, status description, range:[1,64], desc:"ok" (succeeded). It is required when an error occurred*/
"subStatusCode": "ok",
/*ro, opt, string, sub status code, range:[1,64], desc:"ok" (succeeded). It is required when an error occurred*/
"errorCode": 1,
/*ro, opt, int, error code, desc:it is required when the value of statusCode is not 1, it corresponds to subStatusCode*/
"errorMsg": "ok"
/*ro, opt, string, error description, desc:this field is required when the value of statusCode is not 1*/
}
21.32.14 Get the parameters of the temperature measurement area
Request URL
GET /ISAPI/AccessControl/temperatureMeasureAreaCfg?format=json
Query Parameter
None
Request Message
None


Response Message
{
"RegionCoordinate": [
/*ro, req, array, area point coordinates, subType:object, range:[0,4], desc:rectangle, the origin is the upper-left corner of the screen*/
{
"x": 1,
/*ro, opt, int, X-coordinate, range:[0,1000]*/
"y": 2
/*ro, opt, int, Y-coordinate, range:[0,1000]*/
}
]
}
21.32.15 Skin-surface temperature screening event
EventType:FaceTemperatureMeasurementEvent


{
"ipAddress": "172.6.64.7",
/*ro, req, string, IPv4 address of the device that triggers the alarm*/
"ipv6Address": "1080:0:0:0:8:800:200C:417A",
/*ro, opt, string, IPv6 address of the device that triggers the alarm*/
"portNo": 80,
/*ro, opt, int, communication port No. of the device that triggers the alarm*/
"protocol": "HTTP",
/*ro, opt, string, protocol type, desc:"HTTP", "HTTPS"*/
"macAddress": "01:17:24:45:D9:F4",
/*ro, opt, string, MAC address*/
"channelID": 1,
/*ro, opt, int, channel No. of the device that triggers the alarm*/
"dateTime": "2016-12-12T17:30:08+08:00",
/*ro, req, string, alarm trigger time*/
"activePostCount": 1,
/*ro, req, int, times that the same alarm has been uploaded*/
"eventType": "FaceTemperatureMeasurementEvent",
/*ro, req, string, triggered event type, desc:"FaceTemperatureMeasurementEvent" (skin-surface temperature screening event)*/
"eventState": "active",
/*ro, req, enum, event status, subType:string, desc:"active" (triggered), "inactive" (not triggered)*/
"eventDescription": "Face Temperature Measurement Event",
/*ro, req, string, event description, desc:skin-surface temperature screening event*/
"deviceID": "test0123",
/*ro, opt, string, device ID (PUID), desc:this node must be returned when ISAPI event information is transmitted via ISUP*/
"FaceTemperatureMeasurementEvent": {
/*ro, req, object, "FaceTemperatureMeasurementEvent" (skin-surface temperature screening event)*/
"deviceName": "test设备",
/*ro, opt, string, device name*/
"serialNo": 1,
/*ro, opt, int, event serial No.*/
"currentEvent": true,
/*ro, opt, bool, whether it is a real-time event, desc:true (yes), false (no)*/
"thermometryUnit": "celsius",
/*ro, req, enum, temperature unit, subType:string, desc:"celsius" (Celsius (default)), "fahrenheit" (Fahrenheit), "kelvin" (Kelvin)*/
"currTemperature": 36.1,
/*ro, req, float, skin-surface temperature, desc:it should be accurate to one decimal place*/
"isAbnomalTemperature": true,
/*ro, opt, bool, whether the skin-surface temperature is abnormal, desc:true (yes), false (no)*/
"RegionCoordinates": {
/*ro, opt, object, coordinates of the skin-surface temperature*/
"positionX": 1,
/*ro, opt, int, X-coordinate, range:[0,10000], desc:the value is normalized to a number between 0 and 1000*/
"positionY": 1
/*ro, opt, int, Y-coordinate, desc:the value is normalized to a number between 0 and 1000*/
},
"remoteCheck": false,
/*ro, opt, bool, whether remote verification is required, desc:true (yes), false (no, default)*/
"mask": "unknown",
/*ro, opt, enum, whether the person wears a mask, subType:string, desc:"unknown", "yes", "no"*/
"visibleLightURL": "xxxxxxx",
/*ro, opt, string, visible light picture URL of the thermal imaging camera*/
"thermalURL": "xxxxxxx",
/*ro, opt, string, URL of the thermal imaging picture*/
"pictureURL": "test",
/*ro, opt, string, URL of the captured picture*/
"helmet": "unknown",
/*ro, opt, enum, whether the person wears a hard hat, subType:string, desc:"unknown", "yes", "no"*/
"visibleLightContentID": "visibleLight_image",
/*ro, opt, string*/
"thermalContentID": "thermal_image",
/*ro, opt, string*/
"pictureContentID": "picture_image",
/*ro, opt, string*/
"FaceRect": {
/*ro, opt, object, rectangle frame for human face, desc:the origin is the upper-left corner of the screen*/
"height": 1.000,
/*ro, req, float, height, range:[0.000,1.000]*/
"width": 1.000,
/*ro, req, float, width, range:[0.000,1.000]*/
"x": 0.000,
/*ro, req, float, X-coordinate of the upper-left corner of the frame, range:[0.000,1.000]*/
"y": 0.000
/*ro, req, float, Y-coordinate of the upper-left corner of the frame, range:[0.000,1.000]*/
}
}
}


Parameter Name
Parameter
Value
Parameter
Type(ContentType)
Content-ID
FaceTemperatureMeasurementEvent
[报文内容] application/json -
VisibleLight
Thermal
Picture
[图片二进
制数据]
[图片二进
制数据]
[图片二进
制数据]
File Name
-
Description
-
image/jpeg
image/jpeg
image/jpeg
visibleLight_image VisibleLight.jpg -
thermal_image
picture_image
Thermal.jpg
Picture.jpg
-
-
Note： The protocol is transmitted in form format. See Chapter 4.5.1.4 for form framework description, as shown in
the instance below.
--<frontier>
Content-Disposition: form-data; name=Parameter Name;filename=File Name
Content-Type: Parameter Type
Content-Length: ****
Content-ID: Content ID
Parameter Value
Parameter Name: the name property of Content-Disposition in the header of form unit; it refers to the form unit
name.
Parameter Type (Content-Type): the Content-Type property in the header of form unit.
File Name (filename): the filename property of Content-Disposition of form unit Headers. It exists only when the
transmitted data of form unit is file, and it refers to the file name of form unit body.
Parameter Value: the body content of form unit.
21.33 Permission Schedules for Persons and Access Points
21.33.1 Get the holiday group configuration capability of the access permission control
Request URL
GET /ISAPI/AccessControl/UserRightHolidayGroupCfg/capabilities?format=json
Query Parameter
None
Request Message
None
Response Message


{
"UserRightHolidayGroupCfg": {
/*ro, req, object*/
"groupNo": {
/*ro, opt, object, holiday group No.*/
"@min": 1,
/*ro, opt, int, the minimum value*/
"@max": 16
/*ro, opt, int, the maximum value*/
},
"enable": "true,false",
/*ro, opt, string, whether it is enabled, desc:"true" (enabled), "false" (disabled)*/
"groupName": {
/*ro, opt, object, holiday group name*/
"@min": 1,
/*ro, opt, int, the minimum value*/
"@max": 32
/*ro, opt, int, the maximum value*/
},
"holidayPlanNo": {
/*ro, opt, object, holiday group schedule No.*/
"@min": 1,
/*ro, opt, int, the minimum value*/
"@max": 16
/*ro, opt, int, the maximum value*/
}
}
}
21.33.2 Get the schedule template configuration capability of the access permission control
Request URL
GET /ISAPI/AccessControl/UserRightPlanTemplate/capabilities?format=json
Query Parameter
None
Request Message
None
Response Message
{
"UserRightPlanTemplate": {
/*ro, opt, object*/
"templateNo": {
/*ro, opt, object, schedule template No.*/
"@min": 1,
/*ro, opt, int, the minimum value*/
"@max": 16
/*ro, opt, int, the maximum value*/
},
"enable": "true,false",
/*ro, opt, string, whether it is enabled, desc:"true" (enabled), "false" (disabled)*/
"templateName": {
/*ro, opt, object, template name*/
"@min": 1,
/*ro, opt, int, the minimum value*/
"@max": 32
/*ro, opt, int, the maximum value*/
},
"weekPlanNo": {
/*ro, opt, object, weekly schedule No.*/
"@min": 1,
/*ro, opt, int, the minimum value*/
"@max": 16
/*ro, opt, int, the maximum value*/
},
"holidayGroupNo": {
/*ro, opt, object, holiday group No.*/
"@min": 1,
/*ro, opt, int, the minimum value*/
"@max": 16
/*ro, opt, int, the maximum value*/
}
}
}
21.33.3 Get weekly schedule configuration parameters
Request URL


GET /ISAPI/AccessControl/UserRightWeekPlanCfg/<weekPlanID>?format=json
Query Parameter
Parameter Name Parameter Type Description
weekPlanID
string
Request Message
None
Response Message
{
"UserRightWeekPlanCfg": {
/*ro, opt, object, weekly schedule configuration parameters*/
"enable": true,
/*ro, req, bool, whether to enable, desc:true (enable), false (disable)*/
"WeekPlanCfg": [
/*ro, req, array, weekly schedule parameters, subType:object*/
{
"week": "Monday",
/*ro, req, enum, day of the week, subType:string, desc:"Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"*/
"id": 1,
/*ro, req, int, time period No., range:[1,8], desc:it is between 1 and 8*/
"enable": true,
/*ro, req, bool, whether to enable, desc:true (enable), false (disable)*/
"TimeSegment": {
/*ro, req, object, time period*/
"beginTime": "10:10:00",
/*ro, req, string, start time of the time period, desc:device local time*/
"endTime": "12:10:00"
/*ro, req, string, end time of the time period, desc:device local time*/
},
"authenticationTimesEnabled": true,
/*ro, opt, bool*/
"authenticationTimes": 10
/*ro, opt, int, range:[1,255], step:1*/
}
]
}
}
21.33.4 Get the weekly schedule configuration capability of the access permission control
Request URL
GET /ISAPI/AccessControl/UserRightWeekPlanCfg/capabilities?format=json
Query Parameter
None
Request Message
None
Response Message
-


{
"UserRightWeekPlanCfg": {
/*ro, opt, object*/
"planNo": {
/*ro, opt, object, weekly schedule No.*/
"@min": 1,
/*ro, opt, int, the minimum value*/
"@max": 16
/*ro, opt, int, the maximum value*/
},
"enable": "true,false",
/*ro, opt, string, whether it is enabled, desc:"true" (enabled), "false" (disabled)*/
"WeekPlanCfg": {
/*ro, opt, object, weekly schedule parameters*/
"maxSize": 56,
/*ro, opt, int, the maximum value*/
"week": {
/*ro, opt, object, week*/
"@opt": "Monday"
/*ro, opt, enum, days of the week, subType:string, desc:"Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"*/
},
"id": {
/*ro, opt, object*/
"@min": 1,
/*ro, opt, int, the minimum value*/
"@max": 8
/*ro, opt, int, the maximum value*/
},
"enable": "true,false",
/*ro, opt, string, whether it is enabled, desc:"true" (enabled), "false" (disabled)*/
"TimeSegment": {
/*ro, opt, object, time period*/
"beginTime": "test",
/*ro, opt, string, start time, desc:(device local time)*/
"endTime": "test",
/*ro, opt, string, end time, desc:(device local time)*/
"validUnit": "minute"
/*ro, opt, enum, time accuracy, subType:string, desc:"hour", "minute", "second". If this node is not returned, the default time accuracy is
"minute"*/
},
"authenticationTimesEnabled": {
/*ro, opt, object*/
"@opt": [true, false]
/*ro, req, array, subType:bool*/
},
"authenticationTimes": {
/*ro, opt, object*/
"@min": 1,
/*ro, req, int, range:[1,255], step:1*/
"@max": 255
/*ro, req, int, range:[1,255], step:1*/
}
}
}
}
21.33.5 Get the holiday schedule configuration capability of the access permission control
Request URL
GET /ISAPI/AccessControl/UserRightHolidayPlanCfg/capabilities?format=json
Query Parameter
None
Request Message
None
Response Message


{
"UserRightHolidayPlanCfg": {
/*ro, req, object*/
"planNo": {
/*ro, opt, object, holiday schedule No.*/
"@min": 1,
/*ro, opt, int, the minimum value*/
"@max": 16
/*ro, opt, int, the maximum value*/
},
"enable": "true,false",
/*ro, opt, string, whether it is enabled, desc:"true" (enabled), "false" (disabled)*/
"beginDate": "1970-01-01",
/*ro, opt, date, start date of the holiday, desc:(device local time)*/
"endDate": "1970-01-01",
/*ro, opt, date, end date of the holiday, desc:(device local time)*/
"HolidayPlanCfg": {
/*ro, opt, object, holiday schedule parameter*/
"maxSize": 8,
/*ro, opt, int, the maximum value*/
"id": {
/*ro, opt, object, time period No.*/
"@min": 1,
/*ro, opt, int, the minimum value*/
"@max": 8
/*ro, opt, int, the maximum value*/
},
"enable": "true,false",
/*ro, opt, string, whether it is enabled, desc:"true" (enabled), "false" (disabled)*/
"TimeSegment": {
/*ro, opt, object, time period*/
"beginTime": "00:00:00",
/*ro, opt, time, start time, desc:(device local time)*/
"endTime": "00:00:00",
/*ro, opt, time, end time, desc:(device local time)*/
"validUnit": "minute"
/*ro, opt, enum, time accuracy, subType:string, desc:"hour", "minute", "second". If this node is not returned, the default time accuracy is
"minute"*/
},
"authenticationTimesEnabled": {
/*ro, opt, object*/
"@opt": [true, false]
/*ro, req, array, subType:bool*/
},
"authenticationTimes": {
/*ro, opt, object*/
"@min": 1,
/*ro, req, int, range:[1,255], step:1*/
"@max": 255
/*ro, req, int, range:[1,255], step:1*/
}
}
}
}
21.33.6 Get holiday schedule configuration parameters
Request URL
GET /ISAPI/AccessControl/UserRightHolidayPlanCfg/<holidayPlanID>?format=json
Query Parameter
Parameter Name Parameter Type Description
holidayPlanID
string
Request Message
None
Response Message
-


{
"UserRightHolidayPlanCfg": {
/*ro, req, object, holiday schedule configuration parameters*/
"enable": true,
/*ro, req, bool, whether to enable, desc:true (enable), false (disable)*/
"beginDate": "1970-01-01",
/*ro, req, date, start date of the holiday, desc:device local time*/
"endDate": "1970-01-01",
/*ro, req, date, end date of the holiday, desc:device local time*/
"HolidayPlanCfg": [
/*ro, req, array, holiday schedule parameters, subType:object*/
{
"id": 1,
/*ro, req, int, time period No., range:[1,8], desc:it is between 1 and 8*/
"enable": true,
/*ro, req, bool, whether to enable, desc:true (enable), false (disable)*/
"TimeSegment": {
/*ro, req, object, time period*/
"beginTime": "00:00:00",
/*ro, req, time, start time of the time period, desc:device local time*/
"endTime": "00:00:00"
/*ro, req, time, end time of the time period, desc:device local time*/
},
"authenticationTimesEnabled": true,
/*ro, opt, bool*/
"authenticationTimes": 10
/*ro, opt, int, range:[1,255], step:1*/
}
]
}
}
21.33.7 Set the week schedule parameters of the access permission control
Request URL
PUT /ISAPI/AccessControl/UserRightWeekPlanCfg/<weekPlanID>?format=json
Query Parameter
Parameter Name Parameter Type Description
weekPlanID
string
Request Message
{
"UserRightWeekPlanCfg": {
/*opt, object, the week schedule parameters of the access permission control*/
"enable": true,
/*req, bool, whether to enable, desc:"true" (enable), "false" (disable)*/
"WeekPlanCfg": [
/*req, array, week schedule parameters, subType:object*/
{
"week": "Monday",
/*req, enum, days of the week, subType:string, desc:"Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"*/
"id": 1,
/*req, int, time period No., range:[1,8], desc:it is between 1 and 8*/
"enable": true,
/*req, bool, whether to enable, desc:"true" (enable), "false" (disable)*/
"TimeSegment": {
/*req, object, time period*/
"beginTime": "10:10:00",
/*req, string, start time of the time period, desc:(device local time)*/
"endTime": "12:10:00"
/*req, string, end time of the time period, desc:(device local time)*/
},
"authenticationTimesEnabled": true,
/*opt, bool*/
"authenticationTimes": 10
/*opt, int, range:[1,255], step:1*/
}
]
}
}
Response Message
-


{
"requestURL": "test",
/*ro, opt, string, URI*/
"statusCode": "test",
/*ro, opt, string, status code, desc:1 (succeeded). It is required when an error occurred*/
"statusString": "test",
/*ro, opt, string, status description, desc:"ok" (succeeded). It is required when an error occurred*/
"subStatusCode": "test",
/*ro, opt, string, sub status code, desc:"ok" (succeeded). It is required when an error occurred*/
"errorCode": 1,
/*ro, opt, int, error code, desc:it is required when the value of statusCode is not 1, and it corresponds to subStatusCode*/
"errorMsg": "ok"
/*ro, opt, string, error information, desc:this node is required when the value of statusCode is not 1*/
}
21.33.8 Set the holiday schedule parameters of the access permission control
Request URL
PUT /ISAPI/AccessControl/UserRightHolidayPlanCfg/<holidayPlanID>?format=json
Query Parameter
Parameter Name Parameter Type Description
holidayPlanID
string
Request Message
{
"UserRightHolidayPlanCfg": {
/*req, object, the holiday schedule parameters of the access permission control*/
"enable": true,
/*req, bool, whether to enable, desc:"true" (enable), "false" (disable)*/
"beginDate": "1970-01-01",
/*req, date, start date of the holiday, desc:device local time*/
"endDate": "1970-01-01",
/*req, date, end date of the holiday, desc:device local time*/
"HolidayPlanCfg": [
/*req, array, subType:object*/
{
"id": 1,
/*req, int, time period No., range:[1,8], desc:it is between 1 and 8*/
"enable": true,
/*req, bool, whether to enable, desc:"true" (enable), "false" (disable)*/
"TimeSegment": {
/*opt, object, time period*/
"beginTime": "00:00:00",
/*req, time, start time of the time period, desc:device local time*/
"endTime": "00:00:00"
/*req, time, end time of the time period, desc:device local time*/
},
"authenticationTimesEnabled": true,
/*opt, bool*/
"authenticationTimes": 10
/*opt, int, range:[1,255], step:1*/
}
]
}
}
Response Message
{
"requestURL": "test",
/*ro, opt, string, URI*/
"statusCode": "test",
/*ro, opt, string, status code, desc:1 (succeeded). It is required when an error occurred*/
"statusString": "test",
/*ro, opt, string, status description, desc:"ok" (succeeded). It is required when an error occurred*/
"subStatusCode": "test",
/*ro, opt, string, sub status code, desc:"ok" (succeeded). It is required when an error occurred*/
"errorCode": 1,
/*ro, opt, int, error code, desc:it is required when the value of statusCode is not 1, and it corresponds to subStatusCode*/
"errorMsg": "ok"
/*ro, opt, string, error information, desc:this node is required when the value of statusCode is not 1*/
}
21.33.9 Get the schedule template configuration parameters of the access permission control
-


Request URL
GET /ISAPI/AccessControl/UserRightPlanTemplate/<planTemplateID>?format=json
Query Parameter
Parameter Name Parameter Type Description
planTemplateID string
-
Request Message
None
Response Message
{
"UserRightPlanTemplate": {
/*ro, req, object*/
"enable": true,
/*ro, req, bool, whether to enable, desc:true (yes), false (no)*/
"templateName": "test",
/*ro, req, string, template name*/
"weekPlanNo": 1,
/*ro, req, int, week schedule No.*/
"holidayGroupNo": "1,3,5"
/*ro, req, string, holiday group No., desc:holiday group No.*/
}
}
21.33.10 Get the holiday group configuration parameters of the access permission control
schedule
Request URL
GET /ISAPI/AccessControl/UserRightHolidayGroupCfg/<holidayGroupID>?format=json
Query Parameter
Parameter Name Parameter Type Description
holidayGroupID string
-
Request Message
None
Response Message
{
"UserRightHolidayGroupCfg": {
/*ro, req, object*/
"enable": true,
/*ro, req, bool, whether to enable, desc:true (yes), false (no)*/
"groupName": "test",
/*ro, req, string, holiday group name*/
"holidayPlanNo": "1,3,5"
/*ro, req, string, holiday group schedule No., desc:holiday group schedule No.*/
}
}
21.33.11 Set the holiday group parameters of the access permission control schedule
Request URL
PUT /ISAPI/AccessControl/UserRightHolidayGroupCfg/<holidayGroupID>?format=json
Query Parameter
Parameter Name Parameter Type Description
holidayGroupID string
-
Request Message


{
"UserRightHolidayGroupCfg": {
/*req, object, the holiday group parameters of the access permission control schedule*/
"enable": true,
/*req, bool, whether to enable, desc:true (yes), false (no)*/
"groupName": "test",
/*req, string, holiday group name*/
"holidayPlanNo": "1,3,5",
/*req, string, holiday group schedule No., desc:holiday group schedule No.*/
"operateType": "byTerminal",
/*opt, enum, operation type, subType:string, desc:"byTerminal" (by terminal), "byOrg" (by organization), "byTerminalOrg" (by terminal
organization)*/
"terminalNoList": [1, 2, 3, 4],
/*opt, array, terminal ID list, subType:int, desc:this node is required when operation type is "byTerminal" or "byTerminalOrg"*/
"orgNoList": [1, 2, 3, 4]
/*opt, array, organization ID list, subType:int, desc:this node is required when operation type is "byOrg" or "byTerminalOrg"*/
}
}
Response Message
{
"requestURL": "test",
/*ro, opt, string, URI*/
"statusCode": "test",
/*ro, opt, string, status code, desc:1 (succeeded). It is required when an error occurred*/
"statusString": "test",
/*ro, opt, string, status description, desc:"ok" (succeeded). It is required when an error occurred*/
"subStatusCode": "test",
/*ro, opt, string, sub status code, desc:"ok" (succeeded). It is required when an error occurred*/
"errorCode": 1,
/*ro, req, int, error code, desc:it is required when the value of statusCode is not 1, and it corresponds to subStatusCode*/
"errorMsg": "ok"
/*ro, req, string, error information, desc:this node is required when the value of statusCode is not 1*/
}
21.33.12 Set the schedule template parameters of the access permission control
Request URL
PUT /ISAPI/AccessControl/UserRightPlanTemplate/<planTemplateID>?format=json
Query Parameter
Parameter Name Parameter Type Description
planTemplateID string
-
Request Message
{
"UserRightPlanTemplate": {
/*req, object, the schedule template of the access permission control*/
"enable": true,
/*req, bool, whether to enable, desc:true (yes), false (no)*/
"templateName": "test",
/*req, string, template name*/
"weekPlanNo": 1,
/*req, int, week schedule No.*/
"holidayGroupNo": "1,3,5",
/*req, string, holiday group No., desc:holiday group No.*/
"operateType": "byTerminal",
/*opt, enum, operation type, subType:string, desc:"byTerminal" (by terminal), "byOrg" (by organization), "byTerminalOrg" (by terminal
organization)*/
"terminalNoList": [1, 2, 3, 4],
/*opt, array, terminal ID list, subType:int, desc:this node is required when operation type is "byTerminal" or "byTerminalOrg"*/
"orgNoList": [1, 2, 3, 4]
/*opt, array, organization ID list, subType:int, desc:this node is required when operation type is "byOrg" or "byTerminalOrg"*/
}
}
Response Message


{
"requestURL": "test",
/*ro, opt, string, URI*/
"statusCode": "test",
/*ro, opt, string, status code, desc:1 (succeeded). It is required when an error occurred*/
"statusString": "test",
/*ro, opt, string, status description, desc:"ok" (succeeded). It is required when an error occurred*/
"subStatusCode": "test",
/*ro, opt, string, sub status code, desc:"ok" (succeeded). It is required when an error occurred*/
"errorCode": 1,
/*ro, req, int, error code, desc:it is required when the value of statusCode is not 1, and it corresponds to subStatusCode*/
"errorMsg": "ok"
/*ro, req, string, error information, desc:this node is required when the value of statusCode is not 1*/
}
21.34 Authentication Schedule Management
21.34.1 Get the holiday group configuration capability of the control schedule of the card
reader authentication mode
Request URL
GET /ISAPI/AccessControl/VerifyHolidayGroupCfg/capabilities?format=json
Query Parameter
None
Request Message
None
Response Message
{
"VerifyHolidayGroupCfg": {
/*ro, opt, object*/
"groupNo": {
/*ro, opt, object, holiday group No.*/
"@min": 1,
/*ro, opt, int, the minimum value*/
"@max": 16
/*ro, opt, int, the maximum value*/
},
"enable": "true,false",
/*ro, opt, string, whether to enable, desc:whether to enable: "true"-enable,"false"-disable*/
"groupName": {
/*ro, opt, object, length of holiday group name*/
"@min": 1,
/*ro, opt, int, the minimum length*/
"@max": 32
/*ro, opt, int, the maximum length*/
},
"holidayPlanNo": {
/*ro, opt, object, holiday group schedule No.*/
"@min": 1,
/*ro, opt, int, the minimum value*/
"@max": 16
/*ro, opt, int, the maximum value*/
}
}
}
21.34.2 Get the schedule template configuration capability of the card reader authentication
mode
Request URL
GET /ISAPI/AccessControl/VerifyPlanTemplate/capabilities?format=json
Query Parameter
None
Request Message
None
Response Message


{
"VerifyPlanTemplate": {
/*ro, opt, object*/
"templateNo": {
/*ro, opt, object, schedule template No.*/
"@min": 1,
/*ro, opt, int*/
"@max": 16
/*ro, opt, int*/
},
"enable": "true,false",
/*ro, opt, string, whether to enable, desc:true (yes), false (no)*/
"templateName": {
/*ro, opt, object, template name length*/
"@min": 1,
/*ro, opt, int*/
"@max": 32
/*ro, opt, int*/
},
"weekPlanNo": {
/*ro, opt, object, weekly schedule No.*/
"@min": 1,
/*ro, opt, int*/
"@max": 16
/*ro, opt, int*/
},
"holidayGroupNo": {
/*ro, opt, object, holiday group No.*/
"@min": 1,
/*ro, opt, int*/
"@max": 16
/*ro, opt, int*/
}
}
}
21.34.3 Get the control schedule configuration parameters of the card reader authentication
mode
Request URL
GET /ISAPI/AccessControl/CardReaderPlan/<cardReaderID>?format=json
Query Parameter
Parameter Name Parameter Type Description
cardReaderID
string
Request Message
None
Response Message
{
"CardReaderPlan": {
/*ro, req, object, schedule template structure*/
"templateNo": 1
/*ro, req, int, schedule template number, desc:0-cancel linking the template to the schedule and restore to the default status (normal status)*/
}
}
21.34.4 Set control schedule parameters of card reader authentication mode
Request URL
PUT /ISAPI/AccessControl/CardReaderPlan/<cardReaderID>?format=json
Query Parameter
Parameter Name Parameter Type Description
cardReaderID
string
Request Message
-
-


{
"CardReaderPlan": {
/*req, object*/
"templateNo": 1
/*req, int, schedule template No., desc:0-cancel linking the template to the schedule and restore to the default status (normal status)*/
}
}
Response Message
{
"statusCode": 1,
/*ro, opt, int, status code, desc:1 (succeeded); it is required when an error occurred*/
"statusString": "ok",
/*ro, opt, string, status description, range:[1,64], desc:"ok" (succeeded); it is required when an error occurred*/
"subStatusCode": "ok",
/*ro, opt, string, sub status code, range:[1,64], desc:"ok" (succeeded); it is required when an error occurred*/
"errorCode": 1,
/*ro, opt, int, error code, desc:when the value of statusCode is not 1, it corresponds to subStatusCode*/
"errorMsg": "ok"
/*ro, opt, string, error information, desc:this node must be returned when the value of statusCode is not 1*/
}
21.34.5 Get the control schedule configuration capability of the card reader authentication
mode
Request URL
GET /ISAPI/AccessControl/CardReaderPlan/capabilities?format=json
Query Parameter
None
Request Message
None
Response Message
{
"CardReaderPlan": {
/*ro, opt, object, card reader No. node*/
"cardReaderNo": {
/*ro, opt, object, card reader No.*/
"@min": 1,
/*ro, opt, int*/
"@max": 4
/*ro, opt, int*/
},
"templateNo": {
/*ro, opt, object, schedule template No. node*/
"@min": 1,
/*ro, opt, int*/
"@max": 16,
/*ro, opt, int*/
"@opt": [65535, 65534, 65533]
/*ro, opt, array, subType:int*/
},
"verifyMode": {
/*ro, opt, object, authentication mode, dep:and,{$.CardReaderPlan.templateNo.@opt[*],eq,65535}*/
"@opt":
"cardAndPw,card,cardOrPw,fp,fpAndPw,fpOrCard,fpAndCard,fpAndCardAndPw,faceOrFpOrCardOrPw,faceAndFp,faceAndPw,faceAndCard,face,employeeNoAndPw,fpOrPw,employe
eNoAndFp,employeeNoAndFpAndPw,faceAndFpAndCard,faceAndPwAndFp,employeeNoAndFace,faceOrfaceAndCard,fpOrface,cardOrfaceOrPw,cardOrFace,cardOrFaceOrFp,cardOrFp
OrPw,faceOrPw,employeeNoAndFaceAndPw,cardOrFaceOrFaceAndCard,iris,faceOrFpOrCardOrPwOrIris,faceOrCardOrPwOrIris,sleep,invalid"
/*ro, opt, string, desc:"cardAndPw” (card + password), "card” (card), "cardOrPw” (card or password), "fp” (fingerprint), "fpAndPw” (fingerprint
+ password), "fpOrCard” (fingerprint or card), "fpAndCard” (fingerprint + card), "fpAndCardAndPw” (fingerprint + card + password), "faceOrFpOrCardOrPw”
(face or fingerprint or card or password), "faceAndFp” (face + fingerprint), "faceAndPw” (face + password), "faceAndCard” (face + card), "face” (face),
"employeeNoAndPw” (employee No. + password), "fpOrPw” (fingerprint or password), "employeeNoAndFp” (employee No. + fingerprint), "employeeNoAndFpAndPw”
(employee No. + fingerprint + password), "faceAndFpAndCard” (face + fingerprint + card), "faceAndPwAndFp” (face + password + fingerprint),
"employeeNoAndFace” (employee No. + face), "faceOrfaceAndCard” (face or face + card), "fpOrface” (fingerprint or face), "cardOrfaceOrPw” (card or face or
password), "cardOrFace” (card or face), "cardOrFaceOrFp” (card or face or fingerprint), "cardOrFpOrPw” (card or fingerprint or password), "faceOrPw" (face
or password), "employeeNoAndFaceAndPw" (employee No. + face + card), "cardOrFaceOrFaceAndCard" (card or face or face + card), "iris",
"faceOrFpOrCardOrPwOrIris"(face or fingerprint or card or password or iris), "faceOrCardOrPwOrIris" (face or card or password or iris), "sleep",
"invalid"*/
}
}
}
21.34.6 Get holiday schedule parameters of the card reader authentication mode


Request URL
GET /ISAPI/AccessControl/VerifyHolidayPlanCfg/<holidayPlanID>?format=json
Query Parameter
Parameter Name Parameter Type Description
holidayPlanID
string
Request Message
None
Response Message
{
"VerifyHolidayPlanCfg": {
/*ro, opt, object, holiday schedule parameters of the card reader authentication mode*/
"enable": true,
/*ro, req, bool, whether to enable, desc:true (enable), false (disable)*/
"beginDate": "1970-01-01",
/*ro, req, date, start date of the holiday, desc:device local time*/
"endDate": "1970-01-02",
/*ro, req, date, end date of the holiday, desc:device local time*/
"HolidayPlanCfg": [
/*ro, req, array, holiday schedule parameters, subType:object*/
{
"id": 1,
/*ro, req, int, time period No., range:[1,8]*/
"enable": true,
/*ro, req, bool, whether to enable the holiday schedule, desc:true (enable), false (disable)*/
"verifyMode": "cardAndPw",
/*ro, req, enum, authentication mode, subType:string, desc:"cardAndPw"-card+password,"card","cardOrPw"-card or password,"fp"fingerprint,"fpAndPw"-fingerprint+password,"fpOrCard"-fingerprint
or card,"fpAndCard"-fingerprint+card,"fpAndCardAndPw"fingerprint+card+password,"faceOrFpOrCardOrPw"-face
or fingerprint or card or password,"faceAndFp"-face+fingerprint,"faceAndPw"-face+password,"faceAndCard"face+card,"face","employeeNoAndPw"-employee
No.+password,"fpOrPw"-fingerprint or password,"employeeNoAndFp"-employee No.+fingerprint,"employeeNoAndFpAndPw"employee
No.+fingerprint+password,"faceAndFpAndCard"-face+fingerprint+card,"faceAndPwAndFp"-face+password+fingerprint,"employeeNoAndFace"-employee
No.+face,"faceOrfaceAndCard"-face or face+card,"fpOrface"-fingerprint or face,"cardOrfaceOrPw"-card or face or password,"cardOrFace"-card or
face,"cardOrFaceOrFp"-card or face or fingerprint,"cardOrFpOrPw"-card or fingerprint or password,"sleep","invalid”*/
"TimeSegment": {
/*ro, opt, object*/
"beginTime": "00:00:00",
/*ro, req, time, start time of the time period, desc:device local time*/
"endTime": "10:00:00"
/*ro, req, time, end time of the time period, desc:device local time*/
}
}
]
}
}
21.34.7 Set holiday schedule parameters of card reader authentication mode
Request URL
PUT /ISAPI/AccessControl/VerifyHolidayPlanCfg/<holidayPlanID>?format=json
Query Parameter
Parameter Name Parameter Type Description
holidayPlanID
string
Request Message
-
-


{
"VerifyHolidayPlanCfg": {
/*opt, object, holiday schedule parameters of the card reader authentication mode*/
"enable": true,
/*req, bool, whether to enable, desc:"true"-enable, "false"-disable*/
"beginDate": "1970-01-01",
/*req, date, start date of the holiday, desc:device local time*/
"endDate": "1970-01-02",
/*req, date, end date of the holiday, desc:device local time*/
"HolidayPlanCfg": [
/*req, array, holiday schedule parameters, subType:object*/
{
"id": 1,
/*req, int, time period No., range:[1,8]*/
"enable": true,
/*req, bool, whether to enable, desc:"true"-enable, "false"-disable*/
"verifyMode": "cardAndPw",
/*req, enum, authentication mode, subType:string, desc:"cardAndPw"-card+password, "card", "cardOrPw"-card or password, "fp"-fingerprint,
"fpAndPw"-fingerprint+password, "fpOrCard"-fingerprint or card, "fpAndCard"-fingerprint+card, "fpAndCardAndPw"-fingerprint+card+password,
"faceOrFpOrCardOrPw"-face or fingerprint or card or password, "faceAndFp"-face+fingerprint, "faceAndPw"-face+password, "faceAndCard"-face+card, "face",
"employeeNoAndPw"-employee No.+password, "fpOrPw"-fingerprint or password, "employeeNoAndFp"-employee No.+fingerprint, "employeeNoAndFpAndPw"-employee
No.+fingerprint+password, "faceAndFpAndCard"-face+fingerprint+card, "faceAndPwAndFp"-face+password+fingerprint, "employeeNoAndFace"-employee No.+face,
"faceOrfaceAndCard"-face or face+card, "fpOrface"-fingerprint or face, "cardOrfaceOrPw"-card or face or password, "cardOrFace"-card or face,
"cardOrFaceOrFp"-card or face or fingerprint, "cardOrFpOrPw"-card or fingerprint or password, "sleep", "invalid”*/
"TimeSegment": {
/*opt, object, time*/
"beginTime": "00:00:00",
/*req, time, start time of the time period, desc:device local time*/
"endTime": "10:00:00"
/*req, time, end time of the time period, desc:device local time*/
}
}
]
}
}
Response Message
{
"statusCode": 1,
/*ro, opt, int, status code, desc:1 (succeeded); it is required when an error occurred*/
"statusString": "ok",
/*ro, opt, string, status description, range:[1,64], desc:"ok" (succeeded); it is required when an error occurred*/
"subStatusCode": "ok",
/*ro, opt, string, sub status code, range:[1,64], desc:"ok" (succeeded); it is required when an error occurred*/
"errorCode": 1,
/*ro, opt, int, error code, desc:when the value of statusCode is not 1, it corresponds to subStatusCode*/
"errorMsg": "ok"
/*ro, opt, string, error information, desc:this node must be returned when the value of statusCode is not 1*/
}
21.34.8 Get the week schedule configuration parameters of the card reader authentication
mode
Request URL
GET /ISAPI/AccessControl/VerifyWeekPlanCfg/<weekPlanID>?format=json
Query Parameter
Parameter Name Parameter Type Description
weekPlanID
string
Request Message
None
Response Message
-


{
"VerifyWeekPlanCfg": {
/*ro, opt, object, the week schedule configuration parameters of the card reader authentication mode*/
"enable": true,
/*ro, req, bool, whether to enable the week schedule configuration parameters of the card reader authentication mode, desc:true (enable), false
(disable)*/
"WeekPlanCfg": [
/*ro, req, array, week schedule parameters, subType:object*/
{
"week": "Monday",
/*ro, req, enum, day of a week, subType:string, desc:"Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"*/
"id": 1,
/*ro, req, int, time period No., range:[1,8]*/
"enable": true,
/*ro, req, bool, whether to enable week schedule*/
"verifyMode": "cardAndPw",
/*ro, req, enum, authentication mode, subType:string, desc:"cardAndPw" (card+password), "card" (card), "cardOrPw" (card or password), "fp"
(fingerprint), "fpAndPw" (fingerprint+password), "fpOrCard" (fingerprint or card), "fpAndCard" (fingerprint+card), "fpAndCardAndPw"
(fingerprint+card+password), "faceOrFpOrCardOrPw" (face or fingerprint or card or password), "faceAndFp" (face+fingerprint), "faceAndPw" (face+password),
"faceAndCard" (face+card), "face" (face), "employeeNoAndPw" (employee No.+password), "fpOrPw" (fingerprint or password), "employeeNoAndFp" (employee
No.+fingerprint), "employeeNoAndFpAndPw" (employee No.+fingerprint+password), "faceAndFpAndCard" (face+fingerprint+card), "faceAndPwAndFp"
(face+password+fingerprint), "employeeNoAndFace" (employee No.+face), "faceOrfaceAndCard" (face or face+card), "fpOrface" (fingerprint or face),
"cardOrfaceOrPw" (card or face or password), "cardOrFace" (card or face), "cardOrFaceOrFp" (card or face or fingerprint), "cardOrFpOrPw" (card or
fingerprint or password), "sleep", "invalid"*/
"TimeSegment": {
/*ro, req, object, time*/
"beginTime": "00:00:00",
/*ro, req, time, start time, desc:(device local time)*/
"endTime": "10:00:00"
/*ro, req, time, end time, desc:(device local time)*/
}
}
]
}
}
21.34.9 Set the week schedule parameters of the card reader authentication mode
Request URL
PUT /ISAPI/AccessControl/VerifyWeekPlanCfg/<weekPlanID>?format=json
Query Parameter
Parameter Name Parameter Type Description
weekPlanID
string
Request Message
-


{
"VerifyWeekPlanCfg": {
/*opt, object, the week schedule configuration parameters of the card reader authentication mode*/
"enable": true,
/*req, bool, whether to enable, desc:"true" (enable), "false" (disable)*/
"WeekPlanCfg": [
/*req, array, week schedule parameters, subType:object*/
{
"week": "Monday",
/*req, enum, days of the week, subType:string, desc:"Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"*/
"id": 1,
/*req, int, time period No., range:[1,8]*/
"enable": true,
/*req, bool, whether to enable week schedule*/
"verifyMode": "cardAndPw",
/*req, enum, authentication mode, subType:string, desc:"cardAndPw" (card+password), "card" (card), "cardOrPw" (card or password), "fp"
(fingerprint), "fpAndPw" (fingerprint+password), "fpOrCard" (fingerprint or card), "fpAndCard" (fingerprint+card), "fpAndCardAndPw"
(fingerprint+card+password), "faceOrFpOrCardOrPw" (face or fingerprint or card or password), "faceAndFp" (face+fingerprint), "faceAndPw" (face+password),
"faceAndCard" (face+card), "face" (face), "employeeNoAndPw" (employee No.+password), "fpOrPw" (fingerprint or password), "employeeNoAndFp" (employee
No.+fingerprint), "employeeNoAndFpAndPw" (employee No.+fingerprint+password), "faceAndFpAndCard" (face+fingerprint+card), "faceAndPwAndFp"
(face+password+fingerprint), "employeeNoAndFace" (employee No.+face), "faceOrfaceAndCard" (face or face+card), "fpOrface" (fingerprint or face),
"cardOrfaceOrPw" (card or face or password), "cardOrFace" (card or face), "cardOrFaceOrFp" (card or face or fingerprint), "cardOrFpOrPw" (card or
fingerprint or password), "sleep", "invalid"*/
"TimeSegment": {
/*req, object, time*/
"beginTime": "00:00:00",
/*req, time, start time of the time period, desc:device local time*/
"endTime": "10:00:00"
/*req, time, end time of the time period, desc:device local time*/
}
}
]
}
}
Response Message
{
"statusCode": 1,
/*ro, opt, int, status code, desc:1 (succeeded). It is required when an error occurred*/
"statusString": "ok",
/*ro, opt, string, status description, range:[1,64], desc:"ok" (succeeded). It is required when an error occurred*/
"subStatusCode": "ok",
/*ro, opt, string, sub status code, range:[1,64], desc:"ok" (succeeded). It is required when an error occurred*/
"errorCode": 1,
/*ro, opt, int, error code, desc:it is required when the value of statusCode is not 1, and it corresponds to subStatusCode*/
"errorMsg": "ok"
/*ro, opt, string, error information, desc:this field is required when the value of statusCode is not 1*/
}
21.34.10 Get the holiday schedule configuration capability of the card reader authentication
mode
Request URL
GET /ISAPI/AccessControl/VerifyHolidayPlanCfg/capabilities?format=json
Query Parameter
None
Request Message
None
Response Message


{
"VerifyHolidayPlanCfg": {
/*ro, opt, object*/
"planNo": {
/*ro, opt, object, holiday schedule template No.*/
"@min": 1,
/*ro, opt, int*/
"@max": 16
/*ro, opt, int*/
},
"enable": "true,false",
/*ro, opt, string, whether to enable, desc:true (enable), false (disable)*/
"beginDate": "1970-01-01",
/*ro, opt, date, start date of the holiday (device local time), desc:(device local time)*/
"endDate": "1970-01-02",
/*ro, opt, date, end date of the holiday (device local time), desc:(device local time)*/
"HolidayPlanCfg": {
/*ro, opt, object, holiday schedule parameters*/
"maxSize": 8,
/*ro, opt, int*/
"id": {
/*ro, opt, object, time period No.*/
"@min": 1,
/*ro, opt, int*/
"@max": 8
/*ro, opt, int*/
},
"enable": "true,false",
/*ro, opt, string, whether to enable, desc:true (enable), false (disable)*/
"verifyMode": {
/*ro, opt, object, authentication mode*/
"@opt":
"cardAndPw,card,cardOrPw,fp,fpAndPw,fpOrCard,fpAndCard,fpAndCardAndPw,faceOrFpOrCardOrPw,faceAndFp,faceAndPw,faceAndCard,face,employeeNoAndPw,fpOrPw,employe
eNoAndFp,employeeNoAndFpAndPw,faceAndFpAndCard,faceAndPwAndFp,employeeNoAndFace,faceOrfaceAndCard,fpOrface,cardOrfaceOrPw,cardOrFace,cardOrFaceOrFp,cardOrFp
OrPw,faceOrPw,employeeNoAndFaceAndPw,cardOrFaceOrFaceAndCard,faceOrFpOrPw,iris,faceOrFpOrCardOrPwOrIris,faceOrCardOrPwOrIris,sleep,invalid"
/*ro, opt, string, desc:"cardAndPw"-card+password, "card", "cardOrPw"-card or password, "fp"-fingerprint, "fpAndPw"-fingerprint+password,
"fpOrCard"-fingerprint or card, "fpAndCard"-fingerprint+card, "fpAndCardAndPw"-fingerprint+card+password, "faceOrFpOrCardOrPw"-face or fingerprint or card
or password, "faceAndFp"-face+fingerprint, "faceAndPw"-face+password, "faceAndCard"-face+card, "face", "employeeNoAndPw"-employee No.+password, "fpOrPw"fingerprint
or password, "employeeNoAndFp"-employee No.+fingerprint, "employeeNoAndFpAndPw"-employee No.+fingerprint+password, "faceAndFpAndCard"face+fingerprint+card,
"faceAndPwAndFp"-face+password+fingerprint, "employeeNoAndFace"-employee No.+face, "faceOrfaceAndCard"-face or face+card, "fpOrface"fingerprint
or face, "cardOrfaceOrPw"-card or face or password, "cardOrFace"-card or face, "cardOrFaceOrFp"-card or face or fingerprint, "cardOrFpOrPw"-card
or fingerprint or password, "sleep", "invalid”*/
},
"TimeSegment": {
/*ro, opt, object, time*/
"beginTime": "00:00:00",
/*ro, opt, time, start time, desc:(device local time)*/
"endTime": "10:00:00",
/*ro, opt, time, end time, desc:(device local time)*/
"validUnit": "minute"
/*ro, opt, enum, time accuracy, subType:string, desc:"hour", "minute", "second". If this node is not returned, the default time accuracy is
"minute"*/
}
}
}
}
21.34.11 Get the week schedule configuration capability of the card reader authentication
mode
Request URL
GET /ISAPI/AccessControl/VerifyWeekPlanCfg/capabilities?format=json
Query Parameter
None
Request Message
None
Response Message


{
"VerifyWeekPlanCfg": {
/*ro, opt, object*/
"planNo": {
/*ro, opt, object, week schedule No.*/
"@min": 1,
/*ro, opt, int*/
"@max": 16,
/*ro, opt, int*/
"@opt": [65535]
/*ro, opt, array, subType:int*/
},
"enable": "true,false",
/*ro, opt, string, whether to enable, desc:true (enable), false (disable)*/
"WeekPlanCfg": {
/*ro, opt, object, week schedule parameters*/
"maxSize": 56,
/*ro, opt, int*/
"week": {
/*ro, opt, object, day of a week*/
"@opt": "Monday,Tuesday,Wednesday,Thursday,Friday,Saturday,Sunday"
/*ro, opt, string, desc:"Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"*/
},
"id": {
/*ro, opt, object*/
"@min": 1,
/*ro, opt, int*/
"@max": 8
/*ro, opt, int*/
},
"enable": "true,false",
/*ro, opt, string, whether to enable, desc:true (enable), false (disable)*/
"verifyMode": {
/*ro, opt, object, authentication mode*/
"@opt":
"cardAndPw,card,cardOrPw,fp,fpAndPw,fpOrCard,fpAndCard,fpAndCardAndPw,faceOrFpOrCardOrPw,faceAndFp,faceAndPw,faceAndCard,face,employeeNoAndPw,fpOrPw,employe
eNoAndFp,employeeNoAndFpAndPw,faceAndFpAndCard,faceAndPwAndFp,employeeNoAndFace,faceOrfaceAndCard,fpOrface,cardOrfaceOrPw,cardOrFace,cardOrFaceOrFp,cardOrFp
OrPw,faceOrPw,employeeNoAndFaceAndPw,cardOrFaceOrFaceAndCard,faceOrFpOrPw,iris,faceOrFpOrCardOrPwOrIris,faceOrCardOrPwOrIris,sleep,invalid"
/*ro, opt, string, desc:"cardAndPw"-card+password, "card", "cardOrPw"-card or password, "fp"-fingerprint, "fpAndPw"-fingerprint+password,
"fpOrCard"-fingerprint or card, "fpAndCard"-fingerprint+card, "fpAndCardAndPw"-fingerprint+card+password, "faceOrFpOrCardOrPw"-face or fingerprint or card
or password, "faceAndFp"-face+fingerprint, "faceAndPw"-face+password, "faceAndCard"-face+card,"face", "employeeNoAndPw"-employee No.+password, "fpOrPw"fingerprint
or password, "employeeNoAndFp"-employee No.+fingerprint, "employeeNoAndFpAndPw"-employee No.+fingerprint+password, "faceAndFpAndCard"face+fingerprint+card,
"faceAndPwAndFp"-face+password+fingerprint, "employeeNoAndFace"-employee No.+face, "faceOrfaceAndCard"-face or face+card, "fpOrface"fingerprint
or face,"cardOrfaceOrPw"-card or face or password, "cardOrFace"-card or face, "cardOrFaceOrFp"-card or face or fingerprint, "cardOrFpOrPw"-card
or fingerprint or password, "sleep", "invalid"*/
},
"TimeSegment": {
/*ro, opt, object*/
"beginTime": "00:00:00",
/*ro, opt, time, start time, desc:start time of the time period (device local time)*/
"endTime": "10:00:00",
/*ro, opt, time, end time, desc:end time of the time period (device local time)*/
"validUnit": "minute"
/*ro, opt, enum, time accuracy, subType:string, desc:If this node is not returned, it indicates that the time accuracy is "minute". "hour",
"minute", "second"*/
}
}
}
}
21.34.12 Set holiday group parameters of control schedule of card reader authentication
mode
Request URL
PUT /ISAPI/AccessControl/VerifyHolidayGroupCfg/<holidayGroupID>?format=json
Query Parameter
Parameter Name Parameter Type Description
holidayGroupID string
-
Request Message


{
"VerifyHolidayGroupCfg": {
/*opt, object, holiday group parameters of control schedule of card reader authentication mode*/
"enable": true,
/*req, bool, whether to enable, desc:"true"-enable, "false"-disable*/
"groupName": "test",
/*req, string, holiday group name*/
"holidayPlanNo": "1,3,5"
/*opt, string, holiday group schedule No., desc:holiday group schedule No.*/
}
}
Response Message
{
"statusCode": 1,
/*ro, opt, int, status code, desc:1 (succeeded); it is required when an error occurred*/
"statusString": "ok",
/*ro, opt, string, status description, range:[1,64], desc:"ok" (succeeded); it is required when an error occurred*/
"subStatusCode": "ok",
/*ro, opt, string, sub status code, range:[1,64], desc:"ok" (succeeded); it is required when an error occurred*/
"errorCode": 1,
/*ro, opt, int, error code, desc:when the value of statusCode is not 1, it corresponds to subStatusCode*/
"errorMsg": "ok"
/*ro, opt, string, error information, desc:this node must be returned when the value of statusCode is not 1*/
}
21.34.13 Set the schedule template parameters of the card reader authentication mode
Request URL
PUT /ISAPI/AccessControl/VerifyPlanTemplate/<planTemplateID>?format=json
Query Parameter
Parameter Name Parameter Type Description
planTemplateID string
-
Request Message
{
"VerifyPlanTemplate": {
/*opt, object*/
"enable": true,
/*req, bool, whether to enable, desc:true (yes), false (no)*/
"templateName": "test",
/*req, string, template name*/
"weekPlanNo": 1,
/*req, int, week schedule No.*/
"holidayGroupNo": "1,3,5"
/*req, string, holiday group No., desc:holiday group No.*/
}
}
Response Message
{
"statusCode": 1,
/*ro, opt, int, status code, desc:1 (succeeded). It is required when an error occurred*/
"statusString": "ok",
/*ro, opt, string, status description, range:[1,64], desc:"ok" (succeeded). It is required when an error occurred*/
"subStatusCode": "ok",
/*ro, opt, string, sub status code, range:[1,64], desc:"ok" (succeeded). It is required when an error occurred*/
"errorCode": 1,
/*ro, opt, int, error code, desc:it is required when the value of statusCode is not 1, and it corresponds to subStatusCode*/
"errorMsg": "ok"
/*ro, opt, string, error information, desc:this field is required when the value of statusCode is not 1*/
}
21.34.14 Get the schedule template parameters of card reader authentication mode
Request URL
GET /ISAPI/AccessControl/VerifyPlanTemplate/<planTemplateID>?format=json


Query Parameter
Parameter Name Parameter Type Description
planTemplateID string
-
Request Message
None
Response Message
{
"VerifyPlanTemplate": {
/*ro, opt, object, the schedule template parameters of card reader authentication mode*/
"enable": true,
/*ro, req, bool, whether to enable, desc:"true"-enable, "false"-disable*/
"templateName": "test",
/*ro, req, string, template name*/
"weekPlanNo": 1,
/*ro, req, int, week schedule No.*/
"holidayGroupNo": "1,3,5"
/*ro, req, string, holiday group No., desc:holiday group No.*/
}
}
21.34.15 Get the holiday group configuration parameters of the control schedule of the card
reader authentication mode
Request URL
GET /ISAPI/AccessControl/VerifyHolidayGroupCfg/<holidayGroupID>?format=json
Query Parameter
Parameter Name Parameter Type Description
holidayGroupID string
-
Request Message
None
Response Message
{
"VerifyHolidayGroupCfg": {
/*ro, opt, object*/
"enable": true,
/*ro, req, bool, whether to enable, desc:true (yes), false-no (default)*/
"groupName": "test",
/*ro, req, string, holiday group name*/
"holidayPlanNo": "1,3,5"
/*ro, opt, string, holiday group schedule No., desc:holiday group schedule No.*/
}
}
21.35 Real-Time Collection
21.35.1 Get the capability of collecting face picture information.
Request URL
GET /ISAPI/AccessControl/CaptureFaceData/capabilities
Query Parameter
None
Request Message
None
Response Message


<?xml version="1.0" encoding="UTF-8"?>
<CaptureFaceData xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--ro, opt, object, capability of collecting face picture information, attr:version{req, string, protocolVersion}-->
<CaptureFaceDataCond>
<!--ro, req, bool, whether to collect the infrared face data-->true
<captureInfrared opt="true,false">
<!--ro, opt, bool, whether to collect the infrared face data, attr:opt{req, string}-->true
</captureInfrared>
<dataType opt="url,binary">
<!--ro, opt, enum, data type of collected face pictures, subType:string, attr:opt{req, string}, desc:url (URL, default),binary (binary)-->url
</dataType>
</CaptureFaceDataCond>
<faceDataUrl min="1" max="768">
<!--ro, opt, string, face data URL, range:[1,768], attr:min{req, int},max{req, int}-->1
</faceDataUrl>
<captureProgress min="1" max="10">
<!--ro, req, int, collection progress, range:[1,10], attr:min{req, int},max{req, int}-->1
</captureProgress>
<infraredFaceDataUrl min="1" max="100">
<!--ro, req, string, infrared picture URL, range:[1,100], attr:min{req, int},max{req, int}-->test
</infraredFaceDataUrl>
<modelData min="1" max="10">
<!--ro, opt, string, face modeling data encoded by Base64, attr:min{req, int},max{req, int}-->test
</modelData>
<score min="0" max="100">
<!--ro, opt, int, face score, range:[0,100], attr:min{req, int},max{req, int}-->80
</score>
<thermometryUnit opt="celsius,fahrenheit,kelvin">
<!--ro, opt, string, temperature unit: celsius (Celsius, default), attr:opt{req, string}-->test
</thermometryUnit>
<currTemperature min="0" max="10">
<!--ro, opt, float, face temperature which is accurate to one decimal place, attr:min{req, int},max{req, int}-->0.000
</currTemperature>
<visibleLightURL min="0" max="10">
<!--ro, opt, string, URL of the visible light picture captured by the thermal camera, attr:min{req, int},max{req, int}-->test
</visibleLightURL>
<thermalURL min="0" max="10">
<!--ro, opt, string, thermal picture URL, attr:min{req, int},max{req, int}-->test
</thermalURL>
<readerID min="1" max="8">
<!--ro, opt, int, range:[1,8], attr:min{req, int},max{req, int}-->1
</readerID>
</CaptureFaceData>
21.35.2 Get capability of getting face picture collection progress
Request URL
GET /ISAPI/AccessControl/CaptureFaceData/Progress/capabilities
Query Parameter
None
Request Message
None
Response Message


<?xml version="1.0" encoding="UTF-8"?>
<CaptureFaceData xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--ro, req, object, attr:version{req, string, protocolVersion}-->
<faceDataUrl min="0" max="10">
<!--ro, opt, string, face data URL, range:[1,32], attr:min{req, int},max{req, int}, desc:face data URL,if this node does not exist,it indicates that
there is no face data-->test
</faceDataUrl>
<captureProgress min="0" max="100">
<!--ro, req, int, collection progress, range:[0,100], attr:min{req, int},max{req, int}, desc:collection progress,which is between 0 and 100,0-no face
data collected,100-collected,the face data URL can be parsed only when the progress is 100-->1
</captureProgress>
<isCurRequestOver opt="true,false">
<!--ro, opt, bool, whether the current collection request is completed, attr:opt{req, string}-->true
</isCurRequestOver>
<infraredFaceDataUrl min="0" max="10">
<!--ro, opt, string, infrared face data URL, range:[1,32], attr:min{req, int},max{req, int}, desc:if this node does not exist, it indicates that there
is no infrared face data-->test
</infraredFaceDataUrl>
<readerID min="1" max="8">
<!--ro, opt, int, range:[1,8], attr:min{req, int},max{req, int}-->1
</readerID>
<requireReaderID>
<!--ro, opt, bool-->true
</requireReaderID>
</CaptureFaceData>
21.35.3 Get the progress of collecting face picture information
Request URL
GET /ISAPI/AccessControl/CaptureFaceData/Progress?readerID=<readerID>
Query Parameter
Parameter Name Parameter Type Description
readerID
string
Request Message
None
Response Message
<?xml version="1.0" encoding="UTF-8"?>
<CaptureFaceData xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--ro, opt, object, attr:version{req, string, protocolVersion}-->
<faceDataUrl>
<!--ro, opt, string, face data URL, range:[1,32]-->test
</faceDataUrl>
<captureProgress>
<!--ro, req, int, collection progress, range:[0,100], desc:collection progress,which is between 0 and 100,0-no face data collected,100-collected,the
face data URL can be parsed only when the progress is 100-->100
</captureProgress>
<isCurRequestOver>
<!--ro, opt, bool, whether the current collection request is completed, desc:whether the current collection request is completed: "true"-yes,"false"-no->true
</isCurRequestOver>
<infraredFaceDataUrl>
<!--ro,
opt, string, infrared face data URL, range:[1,32], desc:if this node does not exist, it indicates that there is no infrared face data-->test
</infraredFaceDataUrl>
</CaptureFaceData>
21.35.4 Collect face picture information
Request URL
POST /ISAPI/AccessControl/CaptureFaceData
Query Parameter
None
Request Message
-


<?xml version="1.0" encoding="UTF-8"?>
<CaptureFaceDataCond xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--req, object, attr:version{req, string, protocolVersion}-->
<captureInfrared>
<!--opt, bool, whether to collect infrared face pictures simultaneously, desc:"true"-yes, "false"-no-->true
</captureInfrared>
<dataType>
<!--opt, enum, data type of collected face pictures, subType:string, desc:"url" (default), "binary”-->url
</dataType>
<readerID>
<!--opt, int, range:[1,8]-->1
</readerID>
</CaptureFaceDataCond>
Response Message
<?xml version="1.0" encoding="UTF-8"?>
<CaptureFaceData xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--ro, req, object, attr:version{req, string, protocolVersion}-->
<CaptureFaceDataCond>
<!--ro, opt, object-->
<captureInfrared opt="true,false">
<!--ro, opt, bool, attr:opt{req, string}-->true
</captureInfrared>
<dataType opt="url,binary">
<!--ro, opt, enum, subType:string, attr:opt{req, string}-->url
</dataType>
</CaptureFaceDataCond>
<faceDataUrl min="1" max="768">
<!--ro, opt, string, face data URL, if this node does not exist, it indicates that there is no face data, attr:min{req, int},max{req, int}-->test
</faceDataUrl>
<captureProgress min="1" max="10">
<!--ro, opt, int, collection progress, range:[0,100], attr:min{req, int},max{req, int}-->1
</captureProgress>
<infraredFaceDataUrl min="1" max="100">
<!--ro, opt, string, infrared face data URL, if this node does not exist, it indicates that there is no infrared face data, attr:min{req, int},max{req,
int}-->test
</infraredFaceDataUrl>
<modelData>
<!--ro, opt, string-->test
</modelData>
<score>
<!--ro, opt, int, face score (face picture quality), range:[0,100]-->0
</score>
<thermometryUnit>
<!--ro, opt, string-->test
</thermometryUnit>
<currTemperature>
<!--ro, opt, float-->0.0
</currTemperature>
<visibleLightURL>
<!--ro, opt, string-->test
</visibleLightURL>
<thermalURL>
<!--ro, opt, string, thermal imaging picture URL-->test
</thermalURL>
</CaptureFaceData>
Parameter
Name
设备未实现
FaceData
InfraredFaceData
Parameter
Value
[报文内容]
[图片二进制数
据]
[图片二进制数
据]
Parameter Type(ContentType)
application/xml
image/jpeg
image/jpeg
ContentID
-
File
Name
-
FaceDatac
Description
-
-
InfraredFaceData.jpg -
Note： The protocol is transmitted in form format. See Chapter 4.5.1.4 for form framework description, as shown in
the instance below.


--<frontier>
Content-Disposition: form-data; name=Parameter Name;filename=File Name
Content-Type: Parameter Type
Content-Length: ****
Content-ID: Content ID
Parameter Value
Parameter Name: the name property of Content-Disposition in the header of form unit; it refers to the form unit
name.
Parameter Type (Content-Type): the Content-Type property in the header of form unit.
File Name (filename): the filename property of Content-Disposition of form unit Headers. It exists only when the
transmitted data of form unit is file, and it refers to the file name of form unit body.
Parameter Value: the body content of form unit.
21.36 Video Intercom Basic Configuration
21.36.1 Get the configuration capability of the video intercom device ID
Request URL
GET /ISAPI/VideoIntercom/deviceId/capabilities?unitType=<unitType>
Query Parameter
Parameter Name Parameter Type Description
unitType
enum
Request Message
None
Response Message
-


<?xml version="1.0" encoding="UTF-8"?>
<DeviceId xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--ro, opt, object, device No.: 0-main station, other value-sub station. The device will reboot no matter <deviceIndex> is changed from 0 to other value
or from other value to 0, attr:version{req, string, protocolVersion}-->
<unitType opt="villa,confirm,outdoor,fence,doorbell,manage,indoor,analogIndoor,decoder,netAudio,amplifier">
<!--ro, req, string, device type: “villa"-door station (V series), "confirm"-doorphone, "outdoor"-door station, "fence"-outer door station, "doorbell"doorbell,
"manage"-main station, "acs"-intelligent access control. If this node is set to "confirm", the following nodes do not need to be configured,
attr:opt{req, string}-->test
</unitType>
<periodNumber min="0" max="10">
<!--ro, opt, int, community number, attr:min{req, int},max{req, int}-->0
</periodNumber>
<buildingNumber min="0" max="10">
<!--ro, opt, int, building number, attr:min{req, int},max{req, int}-->0
</buildingNumber>
<unitNumber min="0" max="10">
<!--ro, opt, int, unit number, attr:min{req, int},max{req, int}-->0
</unitNumber>
<floorNumber min="0" max="10">
<!--ro, opt, int, floor No., attr:min{req, int},max{req, int}-->0
</floorNumber>
<roomNumber min="0" max="10">
<!--ro, opt, int, room No., attr:min{req, int},max{req, int}-->0
</roomNumber>
<deviceIndex min="0" max="10">
<!--ro, opt, int, device No., attr:min{req, int},max{req, int}-->0
</deviceIndex>
<readerDeviceIndex min="0" max="10">
<!--ro, opt, int, step:1, attr:min{req, int},max{req, int}-->0
</readerDeviceIndex>
<communityNumber min="0" max="10">
<!--ro, opt, string, community No., attr:min{req, int},max{req, int}-->test
</communityNumber>
<customDeviceId min="0" max="10">
<!--ro, opt, string, attr:min{req, int},max{req, int}-->test
</customDeviceId>
<periodNumberName min="0" max="32">
<!--ro, opt, string, range:[0,32], attr:min{req, int},max{req, int}-->test
</periodNumberName>
<buildingNumberName min="0" max="32">
<!--ro, opt, string, range:[0,32], attr:min{req, int},max{req, int}-->test
</buildingNumberName>
<unitNumberName min="0" max="32">
<!--ro, opt, string, range:[0,32], attr:min{req, int},max{req, int}-->test
</unitNumberName>
<floorNumberName min="0" max="32">
<!--ro, opt, string, range:[0,32], attr:min{req, int},max{req, int}-->test
</floorNumberName>
<roomNumberName min="0" max="32">
<!--ro, opt, string, range:[0,32], attr:min{req, int},max{req, int}-->test
</roomNumberName>
<deviceIndexName min="0" max="32">
<!--ro, opt, string, range:[0,32], attr:min{req, int},max{req, int}-->test
</deviceIndexName>
<communityNumberName min="0" max="32">
<!--ro, opt, string, range:[0,32], attr:min{req, int},max{req, int}-->test
</communityNumberName>
<enabled opt="true,false">
<!--ro, opt, bool, attr:opt{req, string}-->true
</enabled>
<industryType opt="builidings,prison,medicalTreatment,broadcasting">
<!--ro, opt, string, attr:opt{req, string}-->test
</industryType>
<readerID min="1" max="8">
<!--ro, opt, int, range:[1,8], attr:min{req, int, range:[1,8]},max{req, int, range:[1,8]}-->1
</readerID>
<requireReaderID>
<!--ro, opt, bool-->true
</requireReaderID>
</DeviceId>
21.36.2 Set the video intercom device ID
Request URL
PUT /ISAPI/VideoIntercom/deviceId?readerID=<readerID>
Query Parameter
Parameter Name Parameter Type Description
readerID
string
Request Message
-


<?xml version="1.0" encoding="UTF-8"?>
<DeviceId xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--req, object, device No., attr:version{req, string, protocolVersion}-->
<unitType>
<!--req, enum, device type, subType:string, desc:device type-->villa
</unitType>
<periodNumber>
<!--opt, int, community number-->0
</periodNumber>
<buildingNumber>
<!--opt, int, building number-->0
</buildingNumber>
<unitNumber>
<!--opt, int, unit number-->0
</unitNumber>
<floorNumber>
<!--opt, int, floor No., desc:floor No.-->0
</floorNumber>
<roomNumber>
<!--opt, int, room No.-->0
</roomNumber>
<deviceIndex>
<!--opt, int, device No.-->0
</deviceIndex>
<communityNumber>
<!--opt, string, community No.-->test
</communityNumber>
<customDeviceId>
<!--opt, string-->test
</customDeviceId>
<periodNumberName>
<!--opt, string, range:[0,32]-->test
</periodNumberName>
<buildingNumberName>
<!--opt, string, range:[0,32]-->test
</buildingNumberName>
<unitNumberName>
<!--opt, string, range:[0,32]-->test
</unitNumberName>
<floorNumberName>
<!--opt, string, range:[0,32]-->test
</floorNumberName>
<roomNumberName>
<!--opt, string, range:[0,32]-->test
</roomNumberName>
<deviceIndexName>
<!--opt, string, range:[0,32]-->test
</deviceIndexName>
<communityNumberName>
<!--opt, string, range:[0,128]-->test
</communityNumberName>
<enabled>
<!--opt, bool-->true
</enabled>
<industryType>
<!--opt, enum, subType:string-->builidings
</industryType>
</DeviceId>
Response Message
<?xml version="1.0" encoding="UTF-8"?>
<ResponseStatus xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--ro, req, object, response message, attr:version{ro, req, string, protocolVersion}-->
<requestURL>
<!--ro, req, string, request URL-->null
</requestURL>
<statusCode>
<!--ro, req, enum, status code, subType:int, desc:0 (OK), 1 (OK), 2 (Device Busy), 3 (Device Error), 4 (Invalid Operation), 5 (Invalid XML Format), 6
(Invalid XML Content), 7 (Reboot Required)-->0
</statusCode>
<statusString>
<!--ro, req, enum, status information, subType:string, desc:"OK" (succeeded), "Device Busy", "Device Error", "Invalid Operation", "Invalid XML Format",
"Invalid XML Content", "Reboot" (reboot device)-->OK
</statusString>
<subStatusCode>
<!--ro, req, string, sub status code, which describes the error in details, desc:sub status code, which describes the error in details-->OK
</subStatusCode>
</ResponseStatus>
21.36.3 Get the video intercom device ID
Request URL


GET /ISAPI/VideoIntercom/deviceId?readerID=<readerID>
Query Parameter
Parameter Name Parameter Type Description
readerID
string
Request Message
None
Response Message
<?xml version="1.0" encoding="UTF-8"?>
<DeviceId xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--ro, req, object, device No., attr:version{req, string, protocolVersion}-->
<unitType>
<!--ro, req, enum, device type, subType:string, desc:"villa"-door station (V series), "confirm"-doorphone, "outdoor"-door station, "fence"-outer door
station, "doorbell"-doorbell, "manage"-main station, "acs"-intelligent access control. If this node is set to "confirm", the following nodes do not need to
be configured-->villa
</unitType>
<periodNumber>
<!--ro, opt, int, community number-->0
</periodNumber>
<buildingNumber>
<!--ro, opt, int, building number-->0
</buildingNumber>
<unitNumber>
<!--ro, opt, int, unit number-->0
</unitNumber>
<floorNumber>
<!--ro, opt, int, floor No., it is between -10 and 10 and it cannot be 0, desc:floor No., it is between -10 and 10 and it cannot be 0-->0
</floorNumber>
<roomNumber>
<!--ro, opt, int, room No.-->0
</roomNumber>
<deviceIndex>
<!--ro, opt, int, device No., 0-main station, other value (from 0 to 99)-sub station. The device will reboot no matter <deviceIndex> is changed from 0
to other value or from other value to 0-->0
</deviceIndex>
<communityNumber>
<!--ro, opt, string, community No.-->test
</communityNumber>
<customDeviceId>
<!--ro, opt, string-->test
</customDeviceId>
<periodNumberName>
<!--ro, opt, string, range:[0,32]-->test
</periodNumberName>
<buildingNumberName>
<!--ro, opt, string, range:[0,32]-->test
</buildingNumberName>
<unitNumberName>
<!--ro, opt, string, range:[0,32]-->test
</unitNumberName>
<floorNumberName>
<!--ro, opt, string, range:[0,32]-->test
</floorNumberName>
<roomNumberName>
<!--ro, opt, string, range:[0,32]-->test
</roomNumberName>
<deviceIndexName>
<!--ro, opt, string, range:[0,32]-->test
</deviceIndexName>
<communityNumberName>
<!--ro, opt, string, range:[0,128]-->test
</communityNumberName>
<enabled>
<!--ro, opt, bool-->true
</enabled>
<industryType>
<!--ro, opt, enum, subType:string-->builidings
</industryType>
</DeviceId>
-
21.37 Interface Management
21.37.1 Get a specific page of a specific program
Request URL
GET /ISAPI/Publish/ProgramMgr/program/<programID>/page/<pageID>


Query Parameter
Parameter Name Parameter Type Description
programID
string
pageID
string
Request Message
None
Response Message
<?xml version="1.0" encoding="UTF-8"?>
<Page xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--ro, req, object, page, attr:version{req, string, protocolVersion}-->
<id>
<!--ro, req, int, ID-->1
</id>
<PageBasicInfo>
<!--ro, req, object, page information of application program-->
<pageName>
<!--ro, opt, string, page name-->test
</pageName>
<BackgroundColor>
<!--ro, opt, object, background color-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format,e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</BackgroundColor>
<playDurationMode>
<!--ro, opt, enum, playing time mode, subType:string, desc:page playing time mode: "selfDefine,auto". When the value of this node is selfDefine,the
node <playDuration> is valid; when the value is auto,it will be calculated according to the content playing time-->selfDefine
</playDurationMode>
<playDuration>
<!--ro, opt, int, playing duration, unit:s-->1
</playDuration>
<playCount>
<!--ro, opt, int-->1
</playCount>
<switchDuration>
<!--ro, opt, int, switch interval, unit:s-->1
</switchDuration>
<switchEffect>
<!--ro, opt, enum, switching effect, subType:string, desc:switching effect:
"none,random,boxShrink,boxSpread,cycleShrink,cycSpread,eraseUp,eraseDown,eraseLeft,eraseRight,verticalShelter,horizontalShelter,verticalChessboard,horizonta
lChessboard,dissolve,leftRightToCenter,ceterToLeftRight,upDownToCenter,centerToUpDown,drawOutLeftDown,drawOutLeftUp,drawOutRightDown,drawOutRightUp,vertical
Line,horizontalLine"-->none
</switchEffect>
<backgroundPic>
<!--ro, opt, int, background picture ID-->1
</backgroundPic>
<SignInCfg>
<!--ro, opt, object, check-in information-->
<VoiceBroadcast>
<!--ro, opt, object, audio prompt-->
<enabled>
<!--ro, opt, bool-->true
</enabled>
<broadcastSpeed>
<!--ro, opt, enum, subType:string-->slower
</broadcastSpeed>
<inLibVoice>
<!--ro, opt, string-->test
</inLibVoice>
<outLibVoice>
<!--ro, opt, string-->test
</outLibVoice>
<inLibAbnormalTemperatureVoice>
<!--ro, opt, string-->test
</inLibAbnormalTemperatureVoice>
<outLibAbnormalTemperatureVoice>
<!--ro, opt, string-->test
</outLibAbnormalTemperatureVoice>
</VoiceBroadcast>
<WelcomeWord>
<!--ro, opt, object, welcome words-->
<enabled>
<!--ro, opt, bool-->true
</enabled>
<inLibWord>
<!--ro, opt, string-->test
</inLibWord>
<outLibWord>
<!--ro, opt, string-->test
</outLibWord>
</WelcomeWord>
-
-


</WelcomeWord>
<SignCartoon>
<!--ro, opt, object-->
<signCartoonSpeed>
<!--ro, opt, enum, subType:string-->fast
</signCartoonSpeed>
</SignCartoon>
<backgroundSignEnabled>
<!--ro, opt, bool-->true
</backgroundSignEnabled>
<TemperatureDetection>
<!--ro, opt, object, screen temperature parameter-->
<enabled>
<!--ro, req, bool, whether to enable-->true
</enabled>
<threshold>
<!--ro, req, float-->0.000
</threshold>
</TemperatureDetection>
</SignInCfg>
</PageBasicInfo>
<characterMode>
<!--ro, opt, enum, welcome word mode on the page, subType:string, desc:mode1,mode2,mode3. For access control devices,the position of the welcome words
is fixed and can be in three modes-->mode1
</characterMode>
<WindowsList>
<!--ro, opt, array, window information list, subType:object-->
<Windows>
<!--ro, opt, object, window information-->
<id>
<!--ro, req, int, content No.-->1
</id>
<Position>
<!--ro, opt, object, content's position, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX>
<!--ro, req, int, X-coordinate-->1
</positionX>
<positionY>
<!--ro, req, int, Y-coordinate-->1
</positionY>
<height>
<!--ro, req, int, width-->1
</height>
<width>
<!--ro, req, int, height-->1
</width>
</Position>
<CornerRadius>
<!--ro, opt, object-->
<TopLeft>
<!--ro, opt, int-->1
</TopLeft>
<TopRight>
<!--ro, opt, int-->1
</TopRight>
<BottomLeft>
<!--ro, opt, int-->1
</BottomLeft>
<BottomRight>
<!--ro, opt, int-->1
</BottomRight>
</CornerRadius>
<layerNo>
<!--ro, req, int, layer No.-->1
</layerNo>
<WinMaterialInfo>
<!--ro, opt, object, window material information-->
<materialType>
<!--ro, req, enum, material type, subType:string, desc:“static” (static material), “dynamic” (dynamic material), “other” (other material)-->static
</materialType>
<staticMaterialType>
<!--ro, opt, enum, static material type, subType:string, desc:local material type. This node is valid when <materialType> is static-->picture
</staticMaterialType>
<dynamicType>
<!--ro, opt, enum, dynamic material type, subType:string, desc:dymanic window material type:
"web,socket,rss,call,dynamicPic,realStream,capturePic,character". This node is valid when <materialType> is dynamic-->web
</dynamicType>
<otherType>
<!--ro, opt, enum, other material type, subType:string, desc:“clock”, “weather”, “countdown”, “localInput” (local input), “hyperlinkBtn”
(hyperlink button), “callBtn” (calling button), “openDoorBtn” (door opening button), “QRCodeBtn” (QR code button), “authenticationSuccess" (authenticated),
“authenticationFail” (authentication failed), “statusBar”(status bar), “ExamTemplate”(exam template)-->clock
</otherType>
</WinMaterialInfo>
<TouchProperty>
<!--ro, opt, object, touching attributes-->
<windType>
<!--ro, opt, enum, Window Type, subType:string, desc:window type: pop-up window,page window-->popup
</windType>
<hyperlinkType>
<!--ro, opt, enum, hyperlink type, subType:string, desc:hyperlink type: "window,page". This node is valid when <windType> is popup-->window
</hyperlinkType>
<windowId>
<!--ro, opt, int, window No., desc:it is the window of current page. This node is valid when <hyperlinkType> is window-->1
</windowId>


<pageId>
<!--ro, opt, int, page No., desc:this node is valid when <hyperlinkType> is page-->1
</pageId>
</TouchProperty>
<PlayItemList>
<!--ro, opt, array, window playing list, subType:object-->
<PlayItem>
<!--ro, req, object-->
<id>
<!--ro, req, int, page No.-->1
</id>
<materialNo>
<!--ro, opt, int, material No.-->1
</materialNo>
<inputChannel>
<!--ro, opt, int, linked channel No. of the network camera-->1
</inputChannel>
<playEffect>
<!--ro, req, enum, playing effect, subType:string, desc:playing effect: none,scroller-->none
</playEffect>
<MarqueeInfo>
<!--ro, opt, object-->
<scrollType>
<!--ro, req, enum, marquee scrolling type, subType:string, desc:scroller scrolling type: not scroll,scroll circularly,scroll once,scroll
backwards and forwards-->none
</scrollType>
<scrollDeriction>
<!--ro, req, enum, marquee scrolling direction, subType:string, desc:scroller scrolling direction: none,from top to bottom,from bottom to
top,from left to right,from right to left-->none
</scrollDeriction>
<scrollSpeed>
<!--ro, req, int, marquee scrolling speed-->1
</scrollSpeed>
</MarqueeInfo>
<PlayDuration>
<!--ro, opt, object, material playing duration, desc:this node can be configured for local materials, live video, and network camera channels-->
<durationType>
<!--ro, req, enum, playing duration type,custom, subType:string, desc:playing duration type,custom-->selfDefine
</durationType>
<duration>
<!--ro, req, int, duration, unit:s-->1
</duration>
</PlayDuration>
<CharactersEffect>
<!--ro, opt, object, character display effect, desc:this node is valid when the material type is text or TXT file-->
<fontSize>
<!--ro, req, int, font size-->1
</fontSize>
<FontColor>
<!--ro, req, object, font color-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</FontColor>
<backgroundType>
<!--ro, opt, enum, subType:string-->color
</backgroundType>
<backPicId>
<!--ro, opt, int-->1
</backPicId>
<BackColor>
<!--ro, req, object, background color-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</BackColor>
<backTransparent>
<!--ro, req, int, background transparency-->1
</backTransparent>
<subtitlesEnabled>
<!--ro, req, bool, whether to enable character display mode-->true
</subtitlesEnabled>
<scrollDirection>
<!--ro, req, enum, character scrolling direction, subType:string, desc:character scrolling direction: "left,right,up,down"-->left
</scrollDirection>
<scrollSpeed>
<!--ro, req, int, character scrolling speed-->1
</scrollSpeed>
</CharactersEffect>
<switchEffect>
<!--ro, opt, enum, switching effect, subType:string, desc:switching effect:
"none,random,boxShrink,boxSpread,cycleShrink,cycSpread,eraseUp,eraseDown,eraseLeft,eraseRight,verticalShelter,horizontalShelter,verticalChessboard,horizonta
lChessboard,dissolve,leftRightToCenter,ceterToLeftRight,upDownToCenter,centerToUpDown,drawOutLeftDown,drawOutLeftUp,drawOutRightDown,drawOutRightUp,vertical
Line,horizontalLine"-->random
</switchEffect>
<pageTime>
<!--ro, opt, int, paging time, unit:s, desc:paging interval,unit: second. This node is valid when the material is a word,ppt,pdf,or excel file-
>1
</pageTime>
<scrollSpeed>
<!--ro, req, int, scrolling speed, desc:scroller scrolling speed-->1
</scrollSpeed>
<scaleType>
<!--ro, opt, enum, subType:string-->centerCrop


<!--ro, opt, enum, subType:string-->centerCrop
</scaleType>
<playType>
<!--ro, opt, enum, subType:string-->normal
</playType>
<CharactersAttribute>
<!--ro, opt, object, character attribute, desc:this node is valid when <dynamicType> is character-->
<fontSize>
<!--ro, req, int, font size-->1
</fontSize>
<FontColor>
<!--ro, req, object, font color-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</FontColor>
<backgroundType>
<!--ro, req, enum, subType:string-->color
</backgroundType>
<BackColor>
<!--ro, req, object, background color-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</BackColor>
<backTransparent>
<!--ro, opt, int, background transparency-->1
</backTransparent>
<alignType>
<!--ro, req, enum, aligment mode, subType:string, desc:aligment mode: "left,right,middle,top,bottom,verticalCenter,horizontallyCenter"-
>middle
</alignType>
<verticaAlignType>
<!--ro, req, enum, vertical aligment mode, subType:string-->top
</verticaAlignType>
<characterContent>
<!--ro, opt, string, text content, range:[0,512]-->test
</characterContent>
<backPicId>
<!--ro, opt, int, background picture ID-->1
</backPicId>
<characterStyle>
<!--ro, req, enum, subType:string-->normal
</characterStyle>
<characterType>
<!--ro, req, enum, font type, subType:string-->mainTitle
</characterType>
</CharactersAttribute>
<WebProperty>
<!--ro, opt, object-->
<webType>
<!--ro, opt, enum, subType:string-->desktop
</webType>
</WebProperty>
</PlayItem>
</PlayItemList>
<enabledAudio>
<!--ro, opt, bool, whether to enable audio-->true
</enabledAudio>
<enableHide>
<!--ro, opt, bool, whether to enable hiding-->true
</enableHide>
<enableLock>
<!--ro, opt, bool, whether to enable lock-->true
</enableLock>
<AppWindow>
<!--ro, opt, object-->
<WindowInfoList>
<!--ro, req, array, window information list, subType:object-->
<WindowInfo>
<!--ro, req, object, window information-->
<id>
<!--ro, req, int, ID-->1
</id>
<materialNo>
<!--ro, req, int, material No., desc:material index No.-->1
</materialNo>
<path>
<!--ro, opt, string, range:[0,1024]-->test
</path>
</WindowInfo>
</WindowInfoList>
</AppWindow>
<DataSource>
<!--ro, opt, object, data source, desc:data source. This node is valid when it is a calling or pop-up window-->
<materialNo>
<!--ro, req, int, material No.-->1
</materialNo>
</DataSource>
<Call>
<!--ro, opt, object, calling data-->
<materialNo>
<!--ro, req, int, material No.-->1
</materialNo>


<tableRow>
<!--ro, req, int, row of the table-->1
</tableRow>
<tableColumn>
<!--ro, req, int, column of the table-->1
</tableColumn>
<tableDirection>
<!--ro, req, enum, table direction, subType:string, desc:table direction: "vertical,horizontal"-->vertical
</tableDirection>
<tableType>
<!--ro, req, enum, table template, subType:string, desc:"template1,template2,template3,template4,template5,template6"-->template1
</tableType>
<backPicId>
<!--ro, opt, int, background picture No.-->1
</backPicId>
<alignType>
<!--ro, req, enum, alignment mode, subType:string, desc:aligment mode: "left,right,middle,top,bottom,verticalCenter,horizontallyCenter"-->left
</alignType>
<refreshDirection>
<!--ro, req, enum, refreshing direction, subType:string, desc:refreshing direction: "upTodown"-from top to bottom,"downToup"-from bottom to top-
>upTodown
</refreshDirection>
<HeadDataList>
<!--ro, opt, array, subType:object-->
<HeadData>
<!--ro, opt, object, table head data-->
<id>
<!--ro, req, int, page No.-->1
</id>
<data>
<!--ro, req, string, data-->test
</data>
</HeadData>
</HeadDataList>
<ItemStyleList>
<!--ro, opt, array, subType:object-->
<ItemStyle>
<!--ro, opt, object, style of the table's row or column-->
<id>
<!--ro, req, int, page No.-->1
</id>
<width>
<!--ro, req, int, width of the content's rectangle frame-->1
</width>
<fontSize>
<!--ro, req, int, font size-->1
</fontSize>
<FontColor>
<!--ro, req, object, font color-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</FontColor>
<BackColor>
<!--ro, req, object, background color-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</BackColor>
</ItemStyle>
</ItemStyleList>
</Call>
<DynamicPic>
<!--ro, opt, object, dynamic pop-up window parameters-->
<materialNo>
<!--ro, req, int, material No.-->1
</materialNo>
<backPicId>
<!--ro, opt, int, background picture ID-->1
</backPicId>
</DynamicPic>
<CapturePic>
<!--ro, opt, object, picture capturing parameters-->
<backPicId>
<!--ro, opt, int, background picture ID-->1
</backPicId>
<ipcMaterialNo>
<!--ro, req, int-->1
</ipcMaterialNo>
<cancelType>
<!--ro, req, enum, cancel mode, subType:string, desc:cancalling type: "auto,manual"-->manual
</cancelType>
<duration>
<!--ro, opt, int, duration, unit:s-->1
</duration>
</CapturePic>
<ClockParam>
<!--ro, opt, object, clock parameters-->
<backPicId>
<!--ro, opt, int, background picture ID-->1
</backPicId>
<ClockIcon>
<!--ro, req, object, clock icon paameters-->
<enabled>


<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<type>
<!--ro, opt, enum, clock type, subType:string, desc:"clock1", "clock2"-->clock1
</type>
<Position>
<!--ro, opt, object, position, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX>
<!--ro, req, int, X-coordinate-->1
</positionX>
<positionY>
<!--ro, req, int, Y-coordinate-->1
</positionY>
<height>
<!--ro, req, int, width-->1
</height>
<width>
<!--ro, req, int, height-->1
</width>
</Position>
</ClockIcon>
<YmdParam>
<!--ro, req, object, the parameters of year, month, and day in the clock-->
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<fontSize>
<!--ro, req, int, font size-->1
</fontSize>
<FontColor>
<!--ro, req, object, font color-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</FontColor>
<BackColor>
<!--ro, req, object, background color-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</BackColor>
<Position>
<!--ro, opt, object, position, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX>
<!--ro, req, int, X-coordinate-->1
</positionX>
<positionY>
<!--ro, req, int, Y-coordinate-->1
</positionY>
<height>
<!--ro, req, int, width-->1
</height>
<width>
<!--ro, req, int, height-->1
</width>
</Position>
</YmdParam>
<HmsParam>
<!--ro, req, object, the parameters of hour, minute, and second in the clock-->
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<fontSize>
<!--ro, req, int, font size-->1
</fontSize>
<FontColor>
<!--ro, req, object, font color-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</FontColor>
<BackColor>
<!--ro, req, object, background color-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</BackColor>
<Position>
<!--ro, opt, object, position, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX>
<!--ro, req, int, X-coordinate-->1
</positionX>
<positionY>
<!--ro, req, int, Y-coordinate-->1
</positionY>
<height>
<!--ro, req, int, width-->1
</height>
<width>
<!--ro, req, int, height-->1
</width>
</Position>
</HmsParam>


</HmsParam>
<WeekParam>
<!--ro, req, object, week parameters-->
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<fontSize>
<!--ro, req, int, font size-->1
</fontSize>
<FontColor>
<!--ro, req, object, font color-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</FontColor>
<BackColor>
<!--ro, req, object, background color-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</BackColor>
<Position>
<!--ro, opt, object, position, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX>
<!--ro, req, int, X-coordinate-->1
</positionX>
<positionY>
<!--ro, req, int, Y-coordinate-->1
</positionY>
<height>
<!--ro, req, int, width-->1
</height>
<width>
<!--ro, req, int, height-->1
</width>
</Position>
</WeekParam>
</ClockParam>
<WeatherParam>
<!--ro, opt, object, weather parameters-->
<backPicId>
<!--ro, opt, int, control's background picture-->1
</backPicId>
<WeatherIcon>
<!--ro, opt, object, weather icon parameters-->
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<Position>
<!--ro, opt, object, position, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX>
<!--ro, req, int, X-coordinate-->1
</positionX>
<positionY>
<!--ro, req, int, Y-coordinate-->1
</positionY>
<height>
<!--ro, req, int, width-->1
</height>
<width>
<!--ro, req, int, height-->1
</width>
</Position>
</WeatherIcon>
<Date>
<!--ro, opt, object, date parameters-->
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<fontSize>
<!--ro, req, int, font size-->1
</fontSize>
<FontColor>
<!--ro, req, object, font color-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</FontColor>
<BackColor>
<!--ro, req, object, background color-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</BackColor>
<Position>
<!--ro, opt, object, position, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX>
<!--ro, req, int, X-coordinate-->1
</positionX>
<positionY>
<!--ro, req, int, Y-coordinate-->1
</positionY>
<height>
<!--ro, req, int, width-->1
</height>


</height>
<width>
<!--ro, req, int, height-->1
</width>
</Position>
</Date>
<Temperature>
<!--ro, opt, object, temperature parameters-->
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<fontSize>
<!--ro, req, int, font size-->1
</fontSize>
<FontColor>
<!--ro, req, object, font color-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</FontColor>
<BackColor>
<!--ro, req, object, background color-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</BackColor>
<Position>
<!--ro, opt, object, position, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX>
<!--ro, req, int, X-coordinate-->1
</positionX>
<positionY>
<!--ro, req, int, Y-coordinate-->1
</positionY>
<height>
<!--ro, req, int, width-->1
</height>
<width>
<!--ro, req, int, height-->1
</width>
</Position>
</Temperature>
<WeatherContent>
<!--ro, opt, object, weather parameters-->
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<fontSize>
<!--ro, req, int, font size-->1
</fontSize>
<FontColor>
<!--ro, req, object, font color-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</FontColor>
<BackColor>
<!--ro, req, object, background color-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g., 16777215 indicates 0xFFFFFF-->1
</RGB>
</BackColor>
<Position>
<!--ro, opt, object, coordinates, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX>
<!--ro, req, int, X-coordinate-->1
</positionX>
<positionY>
<!--ro, req, int, Y-coordinate-->1
</positionY>
<height>
<!--ro, req, int, width-->1
</height>
<width>
<!--ro, req, int, height-->1
</width>
</Position>
</WeatherContent>
<City>
<!--ro, opt, object, city parameters-->
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<cityId>
<!--ro, req, string, city No.-->test
</cityId>
<cityName>
<!--ro, req, string, city name-->test
</cityName>
<fontSize>
<!--ro, req, int, font size-->1
</fontSize>
<FontColor>
<!--ro, req, object, font color-->


<!--ro, req, object, font color-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g., 16777215 indicates 0xFFFFFF-->1
</RGB>
</FontColor>
<BackColor>
<!--ro, req, object, background color-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g., 16777215 indicates 0xFFFFFF-->1
</RGB>
</BackColor>
<Position>
<!--ro, opt, object, coordinates, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX>
<!--ro, req, int, X-coordinate-->1
</positionX>
<positionY>
<!--ro, req, int, Y-coordinate-->1
</positionY>
<height>
<!--ro, req, int, width-->1
</height>
<width>
<!--ro, req, int, height-->1
</width>
</Position>
</City>
<Humidity>
<!--ro, opt, object, humidity parameters-->
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<fontSize>
<!--ro, req, int, font size-->1
</fontSize>
<FontColor>
<!--ro, req, object, font color-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g., 16777215 indicates 0xFFFFFF-->1
</RGB>
</FontColor>
<BackColor>
<!--ro, req, object, background color-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g., 16777215 indicates 0xFFFFFF-->1
</RGB>
</BackColor>
<Position>
<!--ro, opt, object, coordinates, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX>
<!--ro, req, int, X-coordinate-->1
</positionX>
<positionY>
<!--ro, req, int, Y-coordinate-->1
</positionY>
<height>
<!--ro, req, int, width-->1
</height>
<width>
<!--ro, req, int, height-->1
</width>
</Position>
</Humidity>
<AirQuality>
<!--ro, opt, object, air quality parameters-->
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<fontSize>
<!--ro, req, int, font size-->1
</fontSize>
<FontColor>
<!--ro, req, object, font color-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g., 16777215 indicates 0xFFFFFF-->1
</RGB>
</FontColor>
<BackColor>
<!--ro, req, object, background color-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g., 16777215 indicates 0xFFFFFF-->1
</RGB>
</BackColor>
<Position>
<!--ro, opt, object, coordinates, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX>
<!--ro, req, int, X-coordinate-->1
</positionX>
<positionY>
<!--ro, req, int, Y-coordinate-->1
</positionY>
<height>
<!--ro, req, int, width-->1
</height>


<width>
<!--ro, req, int, height-->1
</width>
</Position>
</AirQuality>
<UpdateTime>
<!--ro, opt, object, update time parameters-->
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<refreshTime>
<!--ro, req, string, refreshing time, desc:refreshing time in ISO8601 time format-->20200826T051500+08
</refreshTime>
<updateInterval>
<!--ro, req, int, refresh interval, unit:minute-->1
</updateInterval>
<fontSize>
<!--ro, req, int, font size-->1
</fontSize>
<FontColor>
<!--ro, req, object, font color-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</FontColor>
<BackColor>
<!--ro, req, object, background color-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g., 16777215 indicates 0xFFFFFF-->1
</RGB>
</BackColor>
<Position>
<!--ro, opt, object, coordinates, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX>
<!--ro, req, int, X-coordinate-->1
</positionX>
<positionY>
<!--ro, req, int, Y-coordinate-->1
</positionY>
<height>
<!--ro, req, int, width-->1
</height>
<width>
<!--ro, req, int, height-->1
</width>
</Position>
</UpdateTime>
<Wind>
<!--ro, opt, object, wind power parameters-->
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<fontSize>
<!--ro, req, int, font size-->1
</fontSize>
<FontColor>
<!--ro, req, object, font color-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g., 16777215 indicates 0xFFFFFF-->1
</RGB>
</FontColor>
<BackColor>
<!--ro, req, object, background color-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g., 16777215 indicates 0xFFFFFF-->1
</RGB>
</BackColor>
<Position>
<!--ro, opt, object, coordinates, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX>
<!--ro, req, int, X-coordinate-->1
</positionX>
<positionY>
<!--ro, req, int, Y-coordinate-->1
</positionY>
<height>
<!--ro, req, int, width-->1
</height>
<width>
<!--ro, req, int, height-->1
</width>
</Position>
</Wind>
</WeatherParam>
<Countdown>
<!--ro, opt, object, countdown material-->
<endTime>
<!--ro, req, string, countdown time, desc:countdown time in ISO8601 time format-->20200826T051500+08
</endTime>
<template>
<!--ro, req, enum, template, subType:string, desc:tempalte: "template1" (template 1),"template2..." (template 2)-->template1
</template>
<timeUnit>
<!--ro, req, enum, time unit, subType:string, desc:time unit: "year,month,day,week,hour,minute,second"-->year


<!--ro, req, enum, time unit, subType:string, desc:time unit: "year,month,day,week,hour,minute,second"-->year
</timeUnit>
<backPicId>
<!--ro, opt, int, background picture ID-->1
</backPicId>
<TimeFontCfg>
<!--ro, opt, object-->
<fontSize>
<!--ro, req, int, font size-->1
</fontSize>
<FontColor>
<!--ro, req, object, font color-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g., 16777215 indicates 0xFFFFFF-->1
</RGB>
</FontColor>
<Position>
<!--ro, opt, object, coordinates, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX>
<!--ro, req, int, X-coordinate-->1
</positionX>
<positionY>
<!--ro, req, int, Y-coordinate-->1
</positionY>
<height>
<!--ro, req, int, width-->1
</height>
<width>
<!--ro, req, int, height-->1
</width>
</Position>
</TimeFontCfg>
<timeUnitEnabled>
<!--ro, opt, bool-->true
</timeUnitEnabled>
<maxTimeUnit>
<!--ro, req, enum, subType:string-->year
</maxTimeUnit>
<ModuleInfoList>
<!--ro, opt, array, subType:object-->
<ModuleInfo>
<!--ro, opt, object-->
<moduleType>
<!--ro, req, enum, module type, subType:string-->second
</moduleType>
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<fontSize>
<!--ro, req, int, font size-->1
</fontSize>
<FontColor>
<!--ro, req, object, font color-->
<RGB>
<!--ro, opt, int, three primary colors in decimal format,e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</FontColor>
<text>
<!--ro, opt, string-->test
</text>
<Position>
<!--ro, opt, object, position, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX>
<!--ro, req, int, X-coordinate-->1
</positionX>
<positionY>
<!--ro, req, int, Y-coordinate-->1
</positionY>
<height>
<!--ro, req, int, width-->1
</height>
<width>
<!--ro, req, int, height-->1
</width>
</Position>
</ModuleInfo>
</ModuleInfoList>
</Countdown>
<localInputNo>
<!--ro, req, enum, local input No., subType:string, desc:local input No.-->VGA
</localInputNo>
<HyperlinkBtn>
<!--ro, opt, object-->
<backPicId>
<!--ro, opt, int, background picture ID-->1
</backPicId>
</HyperlinkBtn>
<CharactersAttribute>
<!--ro, opt, object, character attribute, desc:this node is valid when <dynamicType> is character-->
<fontSize>
<!--ro, req, int, font size-->1
</fontSize>
<FontColor>
<!--ro, req, object, font color-->


<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</FontColor>
<fontType>
<!--ro, opt, enum, font type, subType:string-->normal
</fontType>
<backgroundType>
<!--ro, req, enum, subType:string-->color
</backgroundType>
<BackColor>
<!--ro, req, object, Background Color-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
<fillEnabled>
<!--ro, opt, bool-->true
</fillEnabled>
</BackColor>
<backTransparent>
<!--ro, opt, int, background transparency-->1
</backTransparent>
<alignType>
<!--ro, req, enum, alignment mode, subType:string, desc:aligment mode: "left,right,middle,top,bottom,verticalCenter,horizontallyCenter"-->middle
</alignType>
<verticaAlignType>
<!--ro, req, enum, vertical alignment mode, subType:string-->top
</verticaAlignType>
<characterContent>
<!--ro, opt, string, text content, range:[0,512]-->test
</characterContent>
<backPicId>
<!--ro, opt, int, background picture ID-->1
</backPicId>
<characterStyle>
<!--ro, req, enum, subType:string-->normal
</characterStyle>
<characterType>
<!--ro, req, enum, font type, subType:string-->mainTitle
</characterType>
<scrollDirection>
<!--ro, opt, enum, character scrolling direction, subType:string, desc:character scrolling direction: "left,right,up,down"-->left
</scrollDirection>
<scrollSpeed>
<!--ro, opt, int, character scrolling speed, range:[1,10]-->1
</scrollSpeed>
</CharactersAttribute>
<SignIn>
<!--ro, opt, object-->
<backPicId>
<!--ro, opt, int, background picture ID-->1
</backPicId>
<ShowInfo>
<!--ro, opt, object-->
<row>
<!--ro, opt, int-->1
</row>
<column>
<!--ro, opt, int-->1
</column>
<Position>
<!--ro, opt, object, position, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX>
<!--ro, req, int, X-coordinate-->1
</positionX>
<positionY>
<!--ro, req, int, Y-coordinate-->1
</positionY>
<height>
<!--ro, req, int, width-->1
</height>
<width>
<!--ro, req, int, height-->1
</width>
</Position>
<inLib>
<!--ro, opt, object-->
<nameEnabled>
<!--ro, opt, bool-->true
</nameEnabled>
<genderEnabled>
<!--ro, opt, bool-->true
</genderEnabled>
<selfDefine1Enabled>
<!--ro, opt, bool-->true
</selfDefine1Enabled>
<selfDefine2Enabled>
<!--ro, opt, bool-->true
</selfDefine2Enabled>
<signInTimeEnabled>
<!--ro, opt, bool-->true
</signInTimeEnabled>
<temperatureEnabled>
<!--ro, opt, bool-->true


<!--ro, opt, bool-->true
</temperatureEnabled>
</inLib>
<outLib>
<!--ro, opt, object-->
<nameEnabled>
<!--ro, opt, bool-->true
</nameEnabled>
<name>
<!--ro, opt, string-->test
</name>
<genderEnabled>
<!--ro, opt, bool-->true
</genderEnabled>
<signInTimeEnabled>
<!--ro, opt, bool-->true
</signInTimeEnabled>
<temperatureEnabled>
<!--ro, opt, bool-->true
</temperatureEnabled>
</outLib>
<showDuration>
<!--ro, req, enum, subType:string-->always
</showDuration>
</ShowInfo>
<MainTitle>
<!--ro, opt, object-->
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<fontSize>
<!--ro, req, int, font size-->1
</fontSize>
<FontColor>
<!--ro, req, object, font color-->
<RGB>
<!--ro, opt, int, three primary colors in decimal format,e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</FontColor>
<Position>
<!--ro, opt, object, position, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX>
<!--ro, req, int, X-coordinate-->1
</positionX>
<positionY>
<!--ro, req, int, Y-coordinate-->1
</positionY>
<height>
<!--ro, req, int, width-->1
</height>
<width>
<!--ro, req, int, height-->1
</width>
</Position>
<text>
<!--ro, opt, string-->test
</text>
</MainTitle>
<SubTitle>
<!--ro, opt, object-->
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<fontSize>
<!--ro, req, int, font size-->1
</fontSize>
<FontColor>
<!--ro, req, object, font color-->
<RGB>
<!--ro, opt, int, three primary colors in decimal format,e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</FontColor>
<Position>
<!--ro, opt, object, position, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX>
<!--ro, req, int, X-coordinate-->1
</positionX>
<positionY>
<!--ro, req, int, Y-coordinate-->1
</positionY>
<height>
<!--ro, req, int, width-->1
</height>
<width>
<!--ro, req, int, height-->1
</width>
</Position>
<text>
<!--ro, opt, string-->test
</text>
</SubTitle>
<NormalTemperature>
<!--ro, opt, object-->
<PeopleNumber>


<PeopleNumber>
<!--ro, opt, object-->
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<fontSize>
<!--ro, req, int, font size-->1
</fontSize>
<FontColor>
<!--ro, req, object, font color-->
<RGB>
<!--ro, opt, int, three primary colors in decimal format,e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</FontColor>
<Position>
<!--ro, opt, object, position, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX>
<!--ro, req, int, X-coordinate-->1
</positionX>
<positionY>
<!--ro, req, int, Y-coordinate-->1
</positionY>
<height>
<!--ro, req, int, width-->1
</height>
<width>
<!--ro, req, int, height-->1
</width>
</Position>
<text>
<!--ro, opt, string-->test
</text>
</PeopleNumber>
<Icon>
<!--ro, opt, object-->
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<Position>
<!--ro, opt, object, position, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX>
<!--ro, req, int, X-coordinate-->1
</positionX>
<positionY>
<!--ro, req, int, Y-coordinate-->1
</positionY>
<height>
<!--ro, req, int, width-->1
</height>
<width>
<!--ro, req, int, height-->1
</width>
</Position>
<materialNo>
<!--ro, opt, int, material ID-->1
</materialNo>
</Icon>
</NormalTemperature>
<AbnormalTemperature>
<!--ro, opt, object-->
<PeopleNumber>
<!--ro, opt, object-->
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<fontSize>
<!--ro, req, int, font size-->1
</fontSize>
<FontColor>
<!--ro, req, object, font color-->
<RGB>
<!--ro, opt, int, three primary colors in decimal format,e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</FontColor>
<Position>
<!--ro, opt, object, position, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX>
<!--ro, req, int, X-coordinate-->1
</positionX>
<positionY>
<!--ro, req, int, Y-coordinate-->1
</positionY>
<height>
<!--ro, req, int, width-->1
</height>
<width>
<!--ro, req, int, height-->1
</width>
</Position>
<text>
<!--ro, opt, string-->test
</text>
</PeopleNumber>
<Icon>
<!--ro, opt, object-->


<!--ro, opt, object-->
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<Position>
<!--ro, opt, object, position, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX>
<!--ro, req, int, X-coordinate-->1
</positionX>
<positionY>
<!--ro, req, int, Y-coordinate-->1
</positionY>
<height>
<!--ro, req, int, width-->1
</height>
<width>
<!--ro, req, int, height-->1
</width>
</Position>
<materialNo>
<!--ro, opt, int, material ID-->1
</materialNo>
</Icon>
</AbnormalTemperature>
</SignIn>
<EventParam>
<!--ro, opt, object-->
<EventResourceList>
<!--ro, opt, array, subType:object-->
<EventResource>
<!--ro, opt, object-->
<ipVersion>
<!--ro, req, enum, subType:string-->v4
</ipVersion>
<ipAddress>
<!--ro, opt, string, IPv4 address-->test
</ipAddress>
<ipv6Address>
<!--ro, opt, string, IPv6 address-->test
</ipv6Address>
<portNo>
<!--ro, req, int, port No.-->1
</portNo>
<userName>
<!--ro, req, string, user name-->test
</userName>
<passWord>
<!--ro, req, string, password-->test
</passWord>
<channels>
<!--ro, opt, string, channel No.-->1,2
</channels>
</EventResource>
</EventResourceList>
<backPicId>
<!--ro, opt, int, background picture ID-->1
</backPicId>
<Title>
<!--ro, opt, object, Title-->
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<fontSize>
<!--ro, req, int, font size-->1
</fontSize>
<FontColor>
<!--ro, req, object, font color-->
<RGB>
<!--ro, opt, int, three primary colors in decimal format,e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</FontColor>
<Position>
<!--ro, opt, object, position, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX>
<!--ro, req, int, X-coordinate-->1
</positionX>
<positionY>
<!--ro, req, int, Y-coordinate-->1
</positionY>
<height>
<!--ro, req, int, width-->1
</height>
<width>
<!--ro, req, int, height-->1
</width>
</Position>
<text>
<!--ro, opt, string-->test
</text>
</Title>
<PeopleCounting>
<!--ro, opt, object-->
<maxPeopleNumber>
<!--ro, opt, int-->1


<!--ro, opt, int-->1
</maxPeopleNumber>
<unavailableBackPicId>
<!--ro, opt, int-->1
</unavailableBackPicId>
<supportChangeByPeople>
<!--ro, req, enum, subType:string-->prompt
</supportChangeByPeople>
<Prompt>
<!--ro, opt, object-->
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<fontSize>
<!--ro, req, int, font size-->1
</fontSize>
<Position>
<!--ro, opt, object, position, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX>
<!--ro, req, int, X-coordinate-->1
</positionX>
<positionY>
<!--ro, req, int, Y-coordinate-->1
</positionY>
<height>
<!--ro, req, int, width-->1
</height>
<width>
<!--ro, req, int, height-->1
</width>
</Position>
<text>
<!--ro, opt, string-->test
</text>
<FontColor>
<!--ro, opt, object, font color-->
<RGB>
<!--ro, opt, int, three primary colors in decimal format,e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</FontColor>
<unavailableText>
<!--ro, opt, string-->test
</unavailableText>
<UnavailableFontColor>
<!--ro, opt, object-->
<RGB>
<!--ro, opt, int, three primary colors in decimal format,e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</UnavailableFontColor>
</Prompt>
<PeopleIcon>
<!--ro, opt, object-->
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<Position>
<!--ro, opt, object, position, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX>
<!--ro, req, int, X-coordinate-->1
</positionX>
<positionY>
<!--ro, req, int, Y-coordinate-->1
</positionY>
<height>
<!--ro, req, int, width-->1
</height>
<width>
<!--ro, req, int, height-->1
</width>
</Position>
<materialNo>
<!--ro, opt, int, material ID-->1
</materialNo>
</PeopleIcon>
<InsidePeopleTitle>
<!--ro, opt, object-->
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<fontSize>
<!--ro, req, int, font size-->1
</fontSize>
<FontColor>
<!--ro, req, object, font color-->
<RGB>
<!--ro, opt, int, three primary colors in decimal format,e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</FontColor>
<Position>
<!--ro, opt, object, position, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX>
<!--ro, req, int, X-coordinate-->1
</positionX>
<positionY>


<!--ro, req, int, Y-coordinate-->1
</positionY>
<height>
<!--ro, req, int, width-->1
</height>
<width>
<!--ro, req, int, height-->1
</width>
</Position>
<text>
<!--ro, opt, string-->test
</text>
</InsidePeopleTitle>
<InsidePeopleNumber>
<!--ro, opt, object-->
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<fontSize>
<!--ro, req, int, font size-->1
</fontSize>
<FontColor>
<!--ro, req, object, font color-->
<RGB>
<!--ro, opt, int, three primary colors in decimal format,e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</FontColor>
<Position>
<!--ro, opt, object, position, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX>
<!--ro, req, int, X-coordinate-->1
</positionX>
<positionY>
<!--ro, req, int, Y-coordinate-->1
</positionY>
<height>
<!--ro, req, int, width-->1
</height>
<width>
<!--ro, req, int, height-->1
</width>
</Position>
</InsidePeopleNumber>
<AvailablePeopleTitle>
<!--ro, opt, object-->
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<fontSize>
<!--ro, req, int, font size-->1
</fontSize>
<FontColor>
<!--ro, req, object, font color-->
<RGB>
<!--ro, opt, int, three primary colors in decimal format,e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</FontColor>
<Position>
<!--ro, opt, object, position, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX>
<!--ro, req, int, X-coordinate-->1
</positionX>
<positionY>
<!--ro, req, int, Y-coordinate-->1
</positionY>
<height>
<!--ro, req, int, width-->1
</height>
<width>
<!--ro, req, int, Height-->1
</width>
</Position>
<text>
<!--ro, opt, string-->test
</text>
</AvailablePeopleTitle>
<AvailablePeopleNumber>
<!--ro, opt, object-->
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<fontSize>
<!--ro, req, int, font size-->1
</fontSize>
<Position>
<!--ro, opt, object, position, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX>
<!--ro, req, int, X-coordinate-->1
</positionX>
<positionY>
<!--ro, req, int, Y-coordinate-->1
</positionY>
<height>
<!--ro, req, int, width-->1


<!--ro, req, int, width-->1
</height>
<width>
<!--ro, req, int, height-->1
</width>
</Position>
<FontColor>
<!--ro, opt, object, font color-->
<RGB>
<!--ro, opt, int, three primary colors in decimal format,e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</FontColor>
<UnavailableFontColor>
<!--ro, opt, object-->
<RGB>
<!--ro, opt, int, three primary colors in decimal format,e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</UnavailableFontColor>
</AvailablePeopleNumber>
<UnavailablePeopleIcon>
<!--ro, opt, object-->
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<Position>
<!--ro, opt, object, position, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX>
<!--ro, req, int, X-coordinate-->1
</positionX>
<positionY>
<!--ro, req, int, Y-coordinate-->1
</positionY>
<height>
<!--ro, req, int, width-->1
</height>
<width>
<!--ro, req, int, height-->1
</width>
</Position>
<materialNo>
<!--ro, opt, int, material ID-->1
</materialNo>
</UnavailablePeopleIcon>
<AudioAlarm>
<!--ro, opt, object-->
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<materialNo>
<!--ro, opt, int, material index No.-->1
</materialNo>
</AudioAlarm>
</PeopleCounting>
<Mask>
<!--ro, opt, object-->
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<fontSize>
<!--ro, req, int, font size-->1
</fontSize>
<FontColor>
<!--ro, req, object, font color-->
<RGB>
<!--ro, opt, int, three primary colors in decimal format,e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</FontColor>
<BackColor>
<!--ro, req, object, background color-->
<RGB>
<!--ro, opt, int, three primary colors in decimal format,e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</BackColor>
<Position>
<!--ro, opt, object, position, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX>
<!--ro, req, int, X-coordinate-->1
</positionX>
<positionY>
<!--ro, req, int, Y-coordinate-->1
</positionY>
<height>
<!--ro, req, int, width-->1
</height>
<width>
<!--ro, req, int, height-->1
</width>
</Position>
<text>
<!--ro, opt, string-->test
</text>
<MaskIcon>
<!--ro, opt, object-->
<enabled>


<!--ro, req, bool, whether to enable the function-->true
</enabled>
<Position>
<!--ro, opt, object, position, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX>
<!--ro, req, int, X-coordinate-->1
</positionX>
<positionY>
<!--ro, req, int, Y-coordinate-->1
</positionY>
<height>
<!--ro, req, int, width-->1
</height>
<width>
<!--ro, req, int, height-->1
</width>
</Position>
<materialNo>
<!--ro, opt, int, material ID-->1
</materialNo>
</MaskIcon>
<AudioAlarm>
<!--ro, opt, object-->
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<materialNo>
<!--ro, opt, int, material index No.-->1
</materialNo>
</AudioAlarm>
</Mask>
<Temperature>
<!--ro, opt, object, temperature parameters-->
<Prompt>
<!--ro, opt, object-->
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<fontSize>
<!--ro, req, int, font size-->1
</fontSize>
<FontColor>
<!--ro, req, object, font color-->
<RGB>
<!--ro, opt, int, three primary colors in decimal format,e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</FontColor>
<BackColor>
<!--ro, req, object, background color-->
<RGB>
<!--ro, opt, int, three primary colors in decimal format,e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</BackColor>
<Position>
<!--ro, opt, object, position, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX>
<!--ro, req, int, X-coordinate-->1
</positionX>
<positionY>
<!--ro, req, int, Y-coordinate-->1
</positionY>
<height>
<!--ro, req, int, width-->1
</height>
<width>
<!--ro, req, int, height-->1
</width>
</Position>
<text>
<!--ro, opt, string-->test
</text>
</Prompt>
<TemperatureIcon>
<!--ro, opt, object-->
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<Position>
<!--ro, opt, object, position, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX>
<!--ro, req, int, X-coordinate-->1
</positionX>
<positionY>
<!--ro, req, int, Y-coordinate-->1
</positionY>
<height>
<!--ro, req, int, width-->1
</height>
<width>
<!--ro, req, int, height-->1
</width>
</Position>
<materialNo>
<!--ro, opt, int, material ID-->1


<!--ro, opt, int, material ID-->1
</materialNo>
</TemperatureIcon>
<AudioAlarm>
<!--ro, opt, object-->
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<materialNo>
<!--ro, opt, int, material index No.-->1
</materialNo>
</AudioAlarm>
<abnormalHighTemperature>
<!--ro, opt, float, unit:℃-->37.5
</abnormalHighTemperature>
</Temperature>
<WearMask>
<!--ro, opt, object-->
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<fontSize>
<!--ro, req, int, font size-->1
</fontSize>
<FontColor>
<!--ro, req, object, font color-->
<RGB>
<!--ro, opt, int, three primary colors in decimal format,e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</FontColor>
<BackColor>
<!--ro, req, object, background color-->
<RGB>
<!--ro, opt, int, three primary colors in decimal format,e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</BackColor>
<Position>
<!--ro, opt, object, position, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX>
<!--ro, req, int, X-coordinate-->1
</positionX>
<positionY>
<!--ro, req, int, Y-coordinate-->1
</positionY>
<height>
<!--ro, req, int, width-->1
</height>
<width>
<!--ro, req, int, height-->1
</width>
</Position>
<text>
<!--ro, opt, string-->test
</text>
<MaskIcon>
<!--ro, opt, object-->
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<Position>
<!--ro, opt, object, position, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX>
<!--ro, req, int, X-coordinate-->1
</positionX>
<positionY>
<!--ro, req, int, Y-coordinate-->1
</positionY>
<height>
<!--ro, req, int, width-->1
</height>
<width>
<!--ro, req, int, height-->1
</width>
</Position>
<materialNo>
<!--ro, opt, int, material ID-->1
</materialNo>
</MaskIcon>
</WearMask>
<NormalTemperature>
<!--ro, opt, object-->
<Prompt>
<!--ro, opt, object-->
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<fontSize>
<!--ro, req, int, font size-->1
</fontSize>
<FontColor>
<!--ro, req, object, font color-->
<RGB>
<!--ro, opt, int, three primary colors in decimal format,e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>


</RGB>
</FontColor>
<BackColor>
<!--ro, req, object, background color-->
<RGB>
<!--ro, opt, int, three primary colors in decimal format,e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</BackColor>
<Position>
<!--ro, opt, object, position, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX>
<!--ro, req, int, X-coordinate-->1
</positionX>
<positionY>
<!--ro, req, int, Y-coordinate-->1
</positionY>
<height>
<!--ro, req, int, width-->1
</height>
<width>
<!--ro, req, int, height-->1
</width>
</Position>
<text>
<!--ro, opt, string-->test
</text>
</Prompt>
<TemperatureIcon>
<!--ro, opt, object-->
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<Position>
<!--ro, opt, object, position, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX>
<!--ro, req, int, X-coordinate-->1
</positionX>
<positionY>
<!--ro, req, int, Y-coordinate-->1
</positionY>
<height>
<!--ro, req, int, width-->1
</height>
<width>
<!--ro, req, int, height-->1
</width>
</Position>
<materialNo>
<!--ro, opt, int, material ID-->1
</materialNo>
</TemperatureIcon>
</NormalTemperature>
<NormalStatusAudioAlarm>
<!--ro, opt, object-->
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<materialNo>
<!--ro, opt, int, material index No.-->1
</materialNo>
</NormalStatusAudioAlarm>
</EventParam>
<AlarmDataSourceProperty>
<!--ro, opt, object-->
<PictureProperty>
<!--ro, opt, object, Picture Property-->
<PictureSwitchEffect>
<!--ro, opt, enum, subType:string-->leftInRightOut
</PictureSwitchEffect>
<PictureScaleType>
<!--ro, opt, enum, subType:string-->fitCenter
</PictureScaleType>
</PictureProperty>
<AlarmDataSource>
<!--ro, opt, object, Data Source-->
<MaterialNo>
<!--ro, opt, int, material No.-->1
</MaterialNo>
<Name>
<!--ro, opt, string, material name-->test
</Name>
<Address>
<!--ro, opt, string-->test
</Address>
<WebProperty>
<!--ro, opt, object-->
<webType>
<!--ro, opt, enum, subType:string-->desktop
</webType>
</WebProperty>
</AlarmDataSource>
</AlarmDataSourceProperty>
<ConferenceParam>
<!--ro, opt, object, Meeting Information-->
<backPicId>


<backPicId>
<!--ro, opt, int, background picture ID-->1
</backPicId>
<Title>
<!--ro, opt, object-->
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<fontSize>
<!--ro, req, int, font size-->1
</fontSize>
<FontColor>
<!--ro, req, object, font color-->
<RGB>
<!--ro, opt, int, three primary colors in decimal format,e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</FontColor>
<BackColor>
<!--ro, req, object, background color-->
<RGB>
<!--ro, opt, int, three primary colors in decimal format,e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</BackColor>
<Position>
<!--ro, opt, object, position, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX>
<!--ro, req, int, X-coordinate-->1
</positionX>
<positionY>
<!--ro, req, int, Y-coordinate-->1
</positionY>
<height>
<!--ro, req, int, width-->1
</height>
<width>
<!--ro, req, int, height-->1
</width>
</Position>
<alignType>
<!--ro, req, enum, alignment mode, subType:string-->middle
</alignType>
</Title>
<VoiceBroadcast>
<!--ro, opt, object, Audio Prompt-->
<enabled>
<!--ro, opt, bool-->true
</enabled>
<broadcastSpeed>
<!--ro, opt, enum, subType:string-->slower
</broadcastSpeed>
<inLibVoice>
<!--ro, opt, string, Voice Prompt Content of People in Database-->test
</inLibVoice>
<outLibVoice>
<!--ro, opt, string-->test
</outLibVoice>
</VoiceBroadcast>
<WelcomeWord>
<!--ro, opt, object, Welcome Words-->
<enabled>
<!--ro, opt, bool-->true
</enabled>
<inLibWord>
<!--ro, opt, string, range:[1,128]-->test
</inLibWord>
<outLibWord>
<!--ro, opt, string, range:[1,128]-->test
</outLibWord>
</WelcomeWord>
<ShowInfo>
<!--ro, opt, object-->
<row>
<!--ro, opt, int-->1
</row>
<column>
<!--ro, opt, int-->1
</column>
<Position>
<!--ro, opt, object, position, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX>
<!--ro, req, int, X-coordinate-->1
</positionX>
<positionY>
<!--ro, req, int, Y-coordinate-->1
</positionY>
<height>
<!--ro, req, int, width-->1
</height>
<width>
<!--ro, req, int, height-->1
</width>
</Position>
<inLib>
<!--ro, opt, object-->


<!--ro, opt, object-->
<nameEnabled>
<!--ro, opt, bool-->true
</nameEnabled>
</inLib>
<defaultShowInfoEnabled>
<!--ro, opt, bool-->true
</defaultShowInfoEnabled>
</ShowInfo>
<ModuleInfoList>
<!--ro, opt, array, subType:object-->
<ModuleInfo>
<!--ro, opt, object-->
<moduleType>
<!--ro, req, enum, module type, subType:string-->conferenceTime
</moduleType>
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<fontSize>
<!--ro, req, int, font size-->1
</fontSize>
<FontColor>
<!--ro, req, object, font color-->
<RGB>
<!--ro, opt, int, three primary colors in decimal format,e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</FontColor>
<BackColor>
<!--ro, opt, object, background color-->
<RGB>
<!--ro, opt, int, three primary colors in decimal format,e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</BackColor>
<backPicId>
<!--ro, opt, int, background picture ID, desc:control's background picture-->1
</backPicId>
<Position>
<!--ro, opt, object, position, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX>
<!--ro, req, int, X-coordinate-->1
</positionX>
<positionY>
<!--ro, req, int, Y-coordinate-->1
</positionY>
<height>
<!--ro, req, int, width-->1
</height>
<width>
<!--ro, req, int, height-->1
</width>
</Position>
<alignType>
<!--ro, req, enum, alignment mode, subType:string-->middle
</alignType>
<CustomKey>
<!--ro, opt, object-->
<key>
<!--ro, opt, string-->test
</key>
<associateProtocolURL>
<!--ro, opt, string-->test
</associateProtocolURL>
</CustomKey>
</ModuleInfo>
</ModuleInfoList>
<conferenceStatus>
<!--ro, opt, enum, subType:string-->idle
</conferenceStatus>
<BackColor>
<!--ro, opt, object, background color-->
<RGB>
<!--ro, opt, int, three primary colors in decimal format,e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</BackColor>
</ConferenceParam>
<CallBtn>
<!--ro, opt, object-->
<backPicId>
<!--ro, opt, int, background picture ID-->1
</backPicId>
</CallBtn>
<OpenDoorBtn>
<!--ro, opt, object-->
<backPicId>
<!--ro, opt, int, background picture ID-->1
</backPicId>
</OpenDoorBtn>
<QRCodeBtn>
<!--ro, opt, object-->
<backPicId>
<!--ro, opt, int, background picture ID-->1
</backPicId>
</QRCodeBtn>


<AuthenticationSuccess>
<!--ro, opt, object-->
<BackColor>
<!--ro, opt, object, background color-->
<RGB>
<!--ro, opt, int, three primary colors in decimal format,e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</BackColor>
<backPicId>
<!--ro, opt, int, background picture ID, desc:control's background picture-->1
</backPicId>
<SubWindowList>
<!--ro, opt, object-->
<SubWindow>
<!--ro, opt, object-->
<subWindowType>
<!--ro, req, enum, subType:string-->temperature
</subWindowType>
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<fontSize>
<!--ro, opt, int, font size, unit:px-->1
</fontSize>
<fontColor>
<!--ro, opt, int, font color-->1
</fontColor>
<fontStyle>
<!--ro, opt, string, font style-->bold,italic,underline,strikeout
</fontStyle>
<Position>
<!--ro, opt, object, position, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX>
<!--ro, req, int, X-coordinate-->1
</positionX>
<positionY>
<!--ro, req, int, Y-coordinate-->1
</positionY>
<height>
<!--ro, req, int, width-->1
</height>
<width>
<!--ro, req, int, height-->1
</width>
</Position>
</SubWindow>
</SubWindowList>
</AuthenticationSuccess>
<AuthenticationFail>
<!--ro, opt, object-->
<BackColor>
<!--ro, opt, object, background color-->
<RGB>
<!--ro, opt, int, three primary colors in decimal format,e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</BackColor>
<backPicId>
<!--ro, opt, int, background picture ID, desc:control's background picture-->1
</backPicId>
<SubWindowList>
<!--ro, opt, object-->
<SubWindow>
<!--ro, opt, object-->
<subWindowType>
<!--ro, req, enum, subType:string-->temperature
</subWindowType>
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<fontSize>
<!--ro, opt, int, font size, unit:px-->1
</fontSize>
<fontColor>
<!--ro, opt, int, font color-->1
</fontColor>
<fontStyle>
<!--ro, opt, string, font style-->bold,italic,underline,strikeout
</fontStyle>
<Position>
<!--ro, opt, object, position, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX>
<!--ro, req, int, X-coordinate-->1
</positionX>
<positionY>
<!--ro, req, int, Y-coordinate-->1
</positionY>
<height>
<!--ro, req, int, width-->1
</height>
<width>
<!--ro, req, int, height-->1
</width>
</Position>
<facePicID>


<facePicID>
<!--ro, opt, int, step:1, dep:and,
{$.PageList.Page.WindowsList[*].Windows.AuthenticationFail.SubWindowList.SubWindow.subWindowType,eq,facePic}-->1
</facePicID>
</SubWindow>
</SubWindowList>
</AuthenticationFail>
<StatusBar>
<!--ro, opt, object, status bar-->
<backPicId>
<!--ro, opt, int, background picture ID, desc:control's background picture-->1
</backPicId>
<statusBarType>
<!--ro, req, enum, subType:string-->fixed
</statusBarType>
<SubStatusList>
<!--ro, opt, object-->
<SubStatus>
<!--ro, opt, object, sub status-->
<statusType>
<!--ro, req, enum, sub status, subType:string-->dial
</statusType>
<enabled>
<!--ro, req, bool-->true
</enabled>
</SubStatus>
</SubStatusList>
</StatusBar>
<ExamTemplate>
<!--ro, opt, object-->
<examTemplateID>
<!--ro, opt, string, template ID-->test
</examTemplateID>
<backPicURL>
<!--ro, opt, string, background picture URL, range:[1,1024]-->test
</backPicURL>
<backgroundDirection>
<!--ro, opt, enum, subType:string-->horizontal
</backgroundDirection>
<ModuleInfoList>
<!--ro, opt, array, subType:object-->
<ModuleInfo>
<!--ro, opt, object-->
<moduleType>
<!--ro, opt, enum, module type, subType:string-->schoolName
</moduleType>
<enabled>
<!--ro, opt, bool, whether to enable the function-->true
</enabled>
<Position>
<!--ro, opt, object, position-->
<positionX>
<!--ro, req, int, X-coordinate-->1
</positionX>
<positionY>
<!--ro, req, int, Y-coordinate-->1
</positionY>
<height>
<!--ro, req, int, height-->1
</height>
<width>
<!--ro, req, int, width-->1
</width>
</Position>
<fontSize>
<!--ro, opt, int, font size-->1
</fontSize>
<fontStyleList>
<!--ro, opt, array, subType:object-->
<fontStyle>
<!--ro, opt, enum, font style, subType:string-->bold
</fontStyle>
</fontStyleList>
<fontType>
<!--ro, opt, enum, font type, subType:string-->custom
</fontType>
<FontColor>
<!--ro, opt, object, font color-->
<RGB>
<!--ro, opt, int, three primary colors in decimal format,e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</FontColor>
<fontTransparent>
<!--ro, opt, int-->1
</fontTransparent>
<alignType>
<!--ro, opt, enum, subType:string-->middle
</alignType>
<characterSpacing>
<!--ro, opt, int, character pitch-->1
</characterSpacing>
<lineSpacing>
<!--ro, opt, int, row height-->1
</lineSpacing>


<layerNo>
<!--ro, opt, int, layer No.-->1
</layerNo>
</ModuleInfo>
</ModuleInfoList>
</ExamTemplate>
</Windows>
</WindowsList>
</Page>
21.37.2 Get the page configuration capability
Request URL
GET /ISAPI/Publish/ProgramMgr/program/<programID>/page/<pageID>/capabilities
Query Parameter
Parameter Name Parameter Type Description
programID
string
pageID
string
Request Message
None
Response Message
<?xml version="1.0" encoding="UTF-8"?>
<Page xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--ro, req, object, page, attr:version{req, string, protocolVersion}-->
<id>
<!--ro, req, int, index-->1
</id>
<PageBasicInfo>
<!--ro, req, object, basic page information-->
<pageName max="10">
<!--ro, opt, string, page name, attr:max{req, int}-->test
</pageName>
<BackgroundColor>
<!--ro, opt, object, background color-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g., 16777215 indicates 0xFFFFFF-->1
</RGB>
</BackgroundColor>
<playDurationMode opt="selfDefine,auto,loop">
<!--ro, opt, enum, page playing time mode, subType:string, attr:opt{req, string}, desc:"selfDefine, auto, loop"-->selfDefine
</playDurationMode>
<playDuration min="1" max="10" default="null">
<!--ro, opt, int, playing duration, unit:s, attr:min{req, int},max{req, int},default{opt, string}-->1
</playDuration>
<playCount min="1" max="10">
<!--ro, opt, int, playing times, attr:min{req, int},max{req, int}-->1
</playCount>
<switchDuration min="1" max="10">
<!--ro, opt, int, switch interval, unit:s, attr:min{req, int},max{req, int}-->1
</switchDuration>
<switchEffect
opt="none,random,boxShrink,boxSpread,cycleShrink,cycSpread,eraseUp,eraseDown,eraseLeft,eraseRight,verticalShelter,horizontalShelter,verticalChessboard,horiz
ontalChessboard,dissolve,leftRightToCenter,ceterToLeftRight,upDownToCenter,centerToUpDown,drawOutLeftDown,drawOutLeftUp,drawOutRightDown,drawOutRightUp,vert
icalLine,horizontalLine">
<!--ro, opt, enum, switching effect:, subType:string, attr:opt{req, string}, desc:"none, random, boxShrink, boxSpread, cycleShrink, cycSpread,
eraseUp, eraseDown, eraseLeft, eraseRight, verticalShelter, horizontalShelter, verticalChessboard, horizontalChessboard, dissolve,leftRightToCenter,
ceterToLeftRight, upDownToCenter, centerToUpDown, drawOutLeftDown, drawOutLeftUp, drawOutRightDown, drawOutRightUp, verticalLine, horizontalLine"-->none
</switchEffect>
<backgroundPic>
<!--ro, opt, int, background picture ID-->1
</backgroundPic>
<SignInCfg>
<!--ro, opt, object, check-in information, desc:check-in information-->
<VoiceBroadcast>
<!--ro, opt, object, audio prompt-->
<enabled opt="true,false">
<!--ro, opt, bool, whether to enable audio prompt, attr:opt{req, string}-->true
</enabled>
<broadcastSpeed opt="slower,slow,medium,fast,faster">
<!--ro, opt, enum, subType:string, attr:opt{req, string}-->slower
</broadcastSpeed>
<inLibVoice min="1" max="10">
<!--ro, opt, string, voice prompt of normal skin-surface temperature of people in database, attr:min{req, int},max{req, int}-->test
</inLibVoice>
<outLibVoice min="1" max="10">
<!--ro, opt, string, attr:min{req, int},max{req, int}-->test
-
-


<!--ro, opt, string, attr:min{req, int},max{req, int}-->test
</outLibVoice>
<inLibAbnormalTemperatureVoice min="1" max="10">
<!--ro, opt, string, voice prompt of abnormal skin-surface temperature of people in database, attr:min{req, int},max{req, int}-->test
</inLibAbnormalTemperatureVoice>
<outLibAbnormalTemperatureVoice min="1" max="10">
<!--ro, opt, string, attr:min{req, int},max{req, int}-->test
</outLibAbnormalTemperatureVoice>
</VoiceBroadcast>
<WelcomeWord>
<!--ro, opt, object, welcome words-->
<enabled opt="true,false">
<!--ro, opt, bool, whether to enable welcome words, attr:opt{req, string}-->true
</enabled>
<inLibWord min="1" max="10">
<!--ro, opt, string, attr:min{req, int},max{req, int}-->test
</inLibWord>
<outLibWord min="1" max="10">
<!--ro, opt, string, attr:min{req, int},max{req, int}-->test
</outLibWord>
</WelcomeWord>
<SignCartoon>
<!--ro, opt, object-->
<signCartoonSpeed opt="fast,medium,slow">
<!--ro, opt, enum, "fast", "medium", "slow", subType:string, attr:opt{req, string}, desc:"fast", "medium", "slow"-->fast
</signCartoonSpeed>
</SignCartoon>
<backgroundSignEnabled opt="true,false">
<!--ro, opt, bool, attr:opt{req, string}-->true
</backgroundSignEnabled>
<TemperatureDetection>
<!--ro, opt, object, screen temperature parameter-->
<enabled opt="true,false">
<!--ro, req, bool, whether to enable the function, attr:opt{req, string}-->true
</enabled>
<threshold min="1" max="10">
<!--ro, req, float, normal temperature, attr:min{req, int},max{req, int}-->0.000
</threshold>
</TemperatureDetection>
</SignInCfg>
</PageBasicInfo>
<characterMode opt="mode1,mode2,mode3">
<!--ro, opt, enum, welcome word mode on the page, subType:string, attr:opt{req, string}, desc:mode1, mode2, mode3. For access control devices, the
position of the welcome words is fixed and can be in three modes-->mode1
</characterMode>
<WindowsList size="10">
<!--ro, opt, array, window information list, subType:object, attr:size{req, int}-->
<Windows>
<!--ro, opt, object, window information-->
<id>
<!--ro, req, int, page No.-->1
</id>
<Position>
<!--ro, opt, object, content position, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX min="1" max="10">
<!--ro, req, int, X-coordinate of upper-left corner of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</positionX>
<positionY min="1" max="10">
<!--ro, req, int, Y-coordinate of upper-left corner of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</positionY>
<height min="1" max="10">
<!--ro, req, int, width of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</height>
<width min="1" max="10">
<!--ro, req, int, height of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</width>
</Position>
<CornerRadius>
<!--ro, opt, object-->
<TopLeft min="1" max="10">
<!--ro, opt, int, attr:min{req, int},max{req, int}-->1
</TopLeft>
<TopRight min="1" max="10">
<!--ro, opt, int, attr:min{req, int},max{req, int}-->1
</TopRight>
<BottomLeft min="1" max="10">
<!--ro, opt, int, attr:min{req, int},max{req, int}-->1
</BottomLeft>
<BottomRight min="1" max="10">
<!--ro, opt, int, attr:min{req, int},max{req, int}-->1
</BottomRight>
</CornerRadius>
<layerNo min="1" max="10">
<!--ro, req, int, layer No., attr:min{req, int},max{req, int}-->1
</layerNo>
<WinMaterialInfo>
<!--ro, opt, object, window material information-->
<materialType opt="static,dynamic,other">
<!--ro, req, enum, material type, subType:string, attr:opt{req, string}, desc:"static" (static material), "dynamic" (dynamic material), "other"
(other material)-->static
</materialType>
<staticMaterialType opt="picture,flash,audio,video,document,ppt,doc,excel,pdf,web,app,signIn,conference">
<!--ro, opt, enum, static material type, subType:string, attr:opt{req, string}, desc:"picture, flash, audio, video, document, ppt, doc, excel,
pdf, web, app, signIn, conference "-->picture
</staticMaterialType>


</staticMaterialType>
<dynamicType opt="web,socket,rss,call,dynamicPic,realStream,capturePic,character,chart">
<!--ro, opt, enum, dynamic window material type, subType:string, attr:opt{req, string}, desc:"web, socket, rss, call, dynamicPic, realStream,
capturePic, character"-->web
</dynamicType>
<otherType
opt="clock,weather,countdown,localInput,hyperlinkBtn,event,callBtn,openDoorBtn,QRCodeBtn,authenticationSuccess,authenticationFail,statusBar">
<!--ro, opt, enum, other material type, subType:string, attr:opt{req, string}, desc:"clock, weather, countdown, localInput, hyperlinkBtn, event,
callBtn, openDoorBtn, QRCodeBtn, authenticationSuccess, authenticationFail, statusBar"-->clock
</otherType>
</WinMaterialInfo>
<TouchProperty>
<!--ro, opt, object, touching attributes-->
<windType opt="popup,page">
<!--ro, opt, enum, window type, subType:string, attr:opt{req, string}, desc:"pop-up, page"-->popup
</windType>
<hyperlinkType opt="window,page">
<!--ro, opt, enum, hyperlink type, subType:string, attr:opt{req, string}, desc:"window, page"-->window
</hyperlinkType>
<windowId>
<!--ro, opt, int, window No., desc:it is the window of current page. This node is valid when <hyperlinkType> is window-->1
</windowId>
<pageId>
<!--ro, opt, int, page No., desc:this node is valid when <hyperlinkType> is page-->1
</pageId>
</TouchProperty>
<PlayItemList size="10">
<!--ro, opt, array, window playing list, subType:object, attr:size{req, int}-->
<PlayItem>
<!--ro, req, object, window playing information-->
<id>
<!--ro, req, int, playing No.-->1
</id>
<materialNo>
<!--ro, opt, int, material No.-->1
</materialNo>
<inputChannel min="1" max="10">
<!--ro, opt, int, linked channel No. of the network camera, attr:min{req, int},max{req, int}-->1
</inputChannel>
<playEffect opt="none,marquee">
<!--ro, req, enum, playing effect, subType:string, attr:opt{req, string}, desc:"none, scroller"-->none
</playEffect>
<MarqueeInfo>
<!--ro, opt, object-->
<scrollType opt="none,loops,once,backAndForth">
<!--ro, req, enum, marquee scrolling type, subType:string, attr:opt{req, string}, desc:"none" (not scroll), "loops" (scroll circularly),
"once" (scroll once), "backAndForth" (scroll backwards and forwards)-->none
</scrollType>
<scrollDeriction opt="none,up,down,left,right">
<!--ro, req, enum, marquee scrolling direction, subType:string, attr:opt{req, string}, desc:scroller scrolling direction: none,from top to
bottom,from bottom to top,from left to right,from right to left-->none
</scrollDeriction>
<scrollSpeed min="1" max="10">
<!--ro, req, int, scroller scrolling speed, attr:min{req, int},max{req, int}-->1
</scrollSpeed>
</MarqueeInfo>
<PlayDuration>
<!--ro, opt, object, material playing duration, desc:this node can be configured for local materials, live video, and network camera channels-->
<durationType opt="materialTime,selfDefine,unlimited">
<!--ro, req, enum, playing duration type, subType:string, attr:opt{req, string}, desc:playing duration type,custom-->selfDefine
</durationType>
<duration min="1" max="10" default="null">
<!--ro, req, int, material playing duration, unit:s, attr:min{req, int},max{req, int},default{opt, string}-->1
</duration>
</PlayDuration>
<CharactersEffect>
<!--ro, opt, object, character display effect, desc:this node is valid when the material type is text or TXT file-->
<fontSize min="1" max="10">
<!--ro, req, int, font size, attr:min{req, int},max{req, int}-->1
</fontSize>
<FontColor>
<!--ro, req, object, font color-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g., 16777215 indicates 0xFFFFFF-->1
</RGB>
</FontColor>
<backgroundType opt="color,picture">
<!--ro, opt, enum, subType:string, attr:opt{req, string}-->color
</backgroundType>
<backPicId min="1" max="1000">
<!--ro, opt, int, background picture ID, attr:min{req, int},max{req, int}-->1
</backPicId>
<BackColor>
<!--ro, req, object, background color-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g., 16777215 indicates 0xFFFFFF-->1
</RGB>
</BackColor>
<backTransparent min="1" max="10">
<!--ro, req, int, background transparency, attr:min{req, int},max{req, int}-->1
</backTransparent>
<subtitlesEnabled>
<!--ro, req, bool, whether to enable character display mode-->true
</subtitlesEnabled>


</subtitlesEnabled>
<scrollDirection opt="left,right,up,down">
<!--ro, req, enum, character scrolling direction, subType:string, attr:opt{req, string}, desc:"left, right, up, down"-->left
</scrollDirection>
<scrollSpeed min="1" max="10">
<!--ro, req, int, character scrolling speed, attr:min{req, int},max{req, int}-->1
</scrollSpeed>
</CharactersEffect>
<switchEffect
opt="none,random,rightInLeftOut,leftInRightOut,bottomInTopOut,topInBottomOut,fadeInFadeOut,middleExit,topPop,rightBottomIn,leftTopIn">
<!--ro, opt, enum, switching effect, subType:string, attr:opt{req, string}, desc:"none, random, boxShrink, boxSpread, cycleShrink, cycSpread,
eraseUp, eraseDown, eraseLeft, eraseRight, verticalShelter, horizontalShelter, verticalChessboard, horizontalChessboard, dissolve, leftRightToCenter,
ceterToLeftRight, upDownToCenter, centerToUpDown, drawOutLeftDown, drawOutLeftUp, drawOutRightDown, drawOutRightUp, verticalLine, horizontalLine"-->random
</switchEffect>
<pageTime min="1" max="10">
<!--ro, opt, int, paging interval, unit:s, attr:min{req, int},max{req, int}, desc:this node is valid when the material is a word, ppt, pdf, or
excel file-->1
</pageTime>
<scrollSpeed min="1" max="10">
<!--ro, req, int, scrolling speed, attr:min{req, int},max{req, int}, desc:this node is valid when the material is static web-->1
</scrollSpeed>
<scaleType opt="fitXY,fitCenter,centerCrop,originalScale">
<!--ro, opt, enum, subType:string, attr:opt{req, string}-->centerCrop
</scaleType>
<playType opt="normal,faceAttendance,PeopleCounting,temperature,conference">
<!--ro, opt, enum, subType:string, attr:opt{req, string}-->normal
</playType>
<WebProperty>
<!--ro, opt, object, web attributes-->
<webType opt="desktop,mobile">
<!--ro, opt, enum, web type, subType:string, attr:opt{req, string}, desc:web type-->desktop
</webType>
</WebProperty>
</PlayItem>
</PlayItemList>
<enabledAudio opt="true,false">
<!--ro, opt, bool, whether to enable the audio, attr:opt{req, string}-->true
</enabledAudio>
<enableHide opt="true,false">
<!--ro, opt, bool, whether to enable hiding, attr:opt{req, string}-->true
</enableHide>
<enableLock opt="true,false">
<!--ro, opt, bool, whether to enable lock, attr:opt{req, string}-->true
</enableLock>
<AppWindow>
<!--ro, opt, object, App window information-->
<WindowInfoList size="10">
<!--ro, req, array, window information list, subType:object, attr:size{req, int}-->
<WindowInfo>
<!--ro, req, object, window information-->
<id>
<!--ro, req, int, index-->1
</id>
<materialNo>
<!--ro, req, int, material No., desc:material index No.-->1
</materialNo>
<path min="0" max="1024">
<!--ro, opt, string, App path, range:[0,1024], attr:min{req, int},max{req, int}, desc:App path-->test
</path>
</WindowInfo>
</WindowInfoList>
</AppWindow>
<DataSource>
<!--ro, opt, object, data source, desc:this node is valid when it is a calling or pop-up window-->
<materialNo>
<!--ro, req, int, material No.-->1
</materialNo>
<dataSourceUUID min="1" max="32">
<!--ro, opt, string, attr:min{req, int},max{req, int}-->1
</dataSourceUUID>
</DataSource>
<Call>
<!--ro, opt, object, calling data-->
<materialNo>
<!--ro, req, int, material No.-->1
</materialNo>
<tableRow min="1" max="10">
<!--ro, req, int, row of the table, attr:min{req, int},max{req, int}-->1
</tableRow>
<tableColumn min="1" max="10">
<!--ro, req, int, column of the table, attr:min{req, int},max{req, int}-->1
</tableColumn>
<tableDirection opt="vertical,horizontal">
<!--ro, req, enum, table direction, subType:string, attr:opt{req, string}, desc:"vertical, horizontal"-->vertical
</tableDirection>
<tableType opt="template1,template2,template3,template4,template5,template6">
<!--ro, req, enum, table template, subType:string, attr:opt{req, string}, desc:"template1, template2, template3, template4, template5, template6"->template1
</tableType>
<backPicId>
<!--ro,
opt, int, control's background picture-->1
</backPicId>
<alignType opt="left,right,middle">
<!--ro, req, enum, alignment mode, subType:string, attr:opt{req, string}, desc:"left, right, middle-->left
</alignType>


</alignType>
<refreshDirection opt="upTodown,downToup ,leftToright,rightToleft">
<!--ro, req, enum, refreshing direction, subType:string, attr:opt{req, string}, desc:"upTodown" (from top to bottom), "downToup" (from bottom to
top), "leftToright" (from left to right), "rightToleft" (from right to left)-->upTodown
</refreshDirection>
<HeadDataList size="10">
<!--ro, opt, array, list of table head data, subType:object, attr:size{req, int}-->
<HeadData>
<!--ro, opt, object, table head data (calling data)-->
<id>
<!--ro, req, int, index-->1
</id>
<data min="1" max="10">
<!--ro, req, string, data, attr:min{req, int},max{req, int}-->test
</data>
</HeadData>
</HeadDataList>
<ItemStyleList size="10">
<!--ro, opt, array, list of style of the table's row or column, subType:object, attr:size{req, int}-->
<ItemStyle>
<!--ro, opt, object, style of the table's row or column-->
<id>
<!--ro, req, int, index-->1
</id>
<width min="1" max="10">
<!--ro, req, int, width of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</width>
<fontSize min="1" max="10">
<!--ro, req, int, font size, attr:min{req, int},max{req, int}-->1
</fontSize>
<FontColor>
<!--ro, req, object, font color-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g., 16777215 indicates 0xFFFFFF-->1
</RGB>
</FontColor>
<BackColor>
<!--ro, req, object, background color-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g., 16777215 indicates 0xFFFFFF-->1
</RGB>
</BackColor>
</ItemStyle>
</ItemStyleList>
<playType opt="roll,flipOver">
<!--ro, opt, enum, Data Display Method, subType:string, attr:opt{req, string}-->roll
</playType>
</Call>
<DynamicPic>
<!--ro, opt, object, dynamic pop-up window parameters-->
<materialNo>
<!--ro, req, int, material No.-->1
</materialNo>
<backPicId>
<!--ro, opt, int, background picture ID-->1
</backPicId>
</DynamicPic>
<CapturePic>
<!--ro, opt, object, picture capturing parameters-->
<backPicId>
<!--ro, opt, int, background picture ID-->1
</backPicId>
<ipcMaterialNo>
<!--ro, req, int, IPC material No.-->1
</ipcMaterialNo>
<cancelType opt="auto,manual">
<!--ro, req, enum, cancel mode, subType:string, attr:opt{req, string}, desc:"auto", "manual"-->manual
</cancelType>
<duration min="1" max="10" default="null">
<!--ro, opt, int, duration, unit:s, attr:min{req, int},max{req, int},default{opt, string}-->1
</duration>
</CapturePic>
<ClockParam>
<!--ro, opt, object, clock parameters-->
<backPicId>
<!--ro, opt, int, background picture ID-->1
</backPicId>
<ClockIcon>
<!--ro, req, object, clock icon parameters-->
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<type opt="clock1,clock2">
<!--ro, opt, enum, clock type, subType:string, attr:opt{req, string}, desc:"clock1", "clock2"-->clock1
</type>
<Position>
<!--ro, opt, object, content's position, desc:the origin is the upper-left corner of the screen. The value range equals to the device
resolution-->
<positionX min="1" max="10">
<!--ro, req, int, X-coordinate of upper-left corner of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</positionX>
<positionY min="1" max="10">
<!--ro, req, int, Y-coordinate of upper-left corner of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</positionY>


</positionY>
<height min="1" max="10">
<!--ro, req, int, width of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</height>
<width min="1" max="10">
<!--ro, req, int, height of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</width>
</Position>
</ClockIcon>
<YmdParam>
<!--ro, req, object, parameters of year, month, and day in the clock-->
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<fontSize min="1" max="10">
<!--ro, req, int, font size, attr:min{req, int},max{req, int}-->1
</fontSize>
<FontColor>
<!--ro, req, object, font color-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g., 16777215 indicates 0xFFFFFF-->1
</RGB>
</FontColor>
<BackColor>
<!--ro, req, object, background color-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g., 16777215 indicates 0xFFFFFF-->1
</RGB>
</BackColor>
<Position>
<!--ro, opt, object, position, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX min="1" max="10">
<!--ro, req, int, X-coordinate of upper-left corner of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</positionX>
<positionY min="1" max="10">
<!--ro, req, int, Y-coordinate of upper-left corner of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</positionY>
<height min="1" max="10">
<!--ro, req, int, width of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</height>
<width min="1" max="10">
<!--ro, req, int, height of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</width>
</Position>
</YmdParam>
<HmsParam>
<!--ro, req, object, the parameters of hour, minute, and second in the clock-->
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<fontSize min="1" max="10">
<!--ro, req, int, font size, attr:min{req, int},max{req, int}-->1
</fontSize>
<FontColor>
<!--ro, req, object, font color-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g., 16777215 indicates 0xFFFFFF-->1
</RGB>
</FontColor>
<BackColor>
<!--ro, req, object, background color-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g., 16777215 indicates 0xFFFFFF-->1
</RGB>
</BackColor>
<Position>
<!--ro, opt, object, position, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX min="1" max="10">
<!--ro, req, int, X-coordinate of upper-left corner of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</positionX>
<positionY min="1" max="10">
<!--ro, req, int, Y-coordinate of upper-left corner of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</positionY>
<height min="1" max="10">
<!--ro, req, int, width of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</height>
<width min="1" max="10">
<!--ro, req, int, height of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</width>
</Position>
</HmsParam>
<WeekParam>
<!--ro, req, object, week parameters-->
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<fontSize min="1" max="10">
<!--ro, req, int, font size, attr:min{req, int},max{req, int}-->1
</fontSize>
<FontColor>
<!--ro, req, object, font color-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g., 16777215 indicates 0xFFFFFF-->1
</RGB>


</FontColor>
<BackColor>
<!--ro, req, object, background color-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g., 16777215 indicates 0xFFFFFF-->1
</RGB>
</BackColor>
<Position>
<!--ro, opt, object, position, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX min="1" max="10">
<!--ro, req, int, X-coordinate of upper-left corner of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</positionX>
<positionY min="1" max="10">
<!--ro, req, int, Y-coordinate of upper-left corner of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</positionY>
<height min="1" max="10">
<!--ro, req, int, height of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</height>
<width min="1" max="10">
<!--ro, req, int, width of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</width>
</Position>
</WeekParam>
</ClockParam>
<WeatherParam>
<!--ro, opt, object, weather parameters-->
<backPicId>
<!--ro, opt, int, control's background picture-->1
</backPicId>
<WeatherIcon>
<!--ro, opt, object, weather icon parameters-->
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<Position>
<!--ro, opt, object, position, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX min="1" max="10">
<!--ro, req, int, X-coordinate of upper-left corner of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</positionX>
<positionY min="1" max="10">
<!--ro, req, int, Y-coordinate of upper-left corner of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</positionY>
<height min="1" max="10">
<!--ro, req, int, height of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</height>
<width min="1" max="10">
<!--ro, req, int, width of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</width>
</Position>
</WeatherIcon>
<Date>
<!--ro, opt, object, date parameters-->
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<fontSize min="1" max="10">
<!--ro, req, int, font size, attr:min{req, int},max{req, int}-->1
</fontSize>
<FontColor>
<!--ro, req, object, font color-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g., 16777215 indicates 0xFFFFFF-->1
</RGB>
</FontColor>
<BackColor>
<!--ro, req, object, background color-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g., 16777215 indicates 0xFFFFFF-->1
</RGB>
</BackColor>
<Position>
<!--ro, opt, object, position, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX min="1" max="10">
<!--ro, req, int, X-coordinate of upper-left corner of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</positionX>
<positionY min="1" max="10">
<!--ro, req, int, Y-coordinate of upper-left corner of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</positionY>
<height min="1" max="10">
<!--ro, req, int, width of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</height>
<width min="1" max="10">
<!--ro, req, int, height of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</width>
</Position>
</Date>
<Temperature>
<!--ro, opt, object, temperature parameters-->
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<fontSize min="1" max="10">
<!--ro, req, int, font size, attr:min{req, int},max{req, int}-->1
</fontSize>


</fontSize>
<FontColor>
<!--ro, req, object, font color-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g., 16777215 indicates 0xFFFFFF-->1
</RGB>
</FontColor>
<BackColor>
<!--ro, req, object, background color-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g., 16777215 indicates 0xFFFFFF-->1
</RGB>
</BackColor>
<Position>
<!--ro, opt, object, position, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX min="1" max="10">
<!--ro, req, int, X-coordinate of upper-left corner of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</positionX>
<positionY min="1" max="10">
<!--ro, req, int, Y-coordinate of upper-left corner of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</positionY>
<height min="1" max="10">
<!--ro, req, int, width of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</height>
<width min="1" max="10">
<!--ro, req, int, height of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</width>
</Position>
</Temperature>
<WeatherContent>
<!--ro, opt, object, weather parameters-->
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<fontSize min="1" max="10">
<!--ro, req, int, font size, attr:min{req, int},max{req, int}-->1
</fontSize>
<FontColor>
<!--ro, req, object, font color-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g., 16777215 indicates 0xFFFFFF-->1
</RGB>
</FontColor>
<BackColor>
<!--ro, req, object, background color-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g., 16777215 indicates 0xFFFFFF-->1
</RGB>
</BackColor>
<Position>
<!--ro, opt, object, position, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX min="1" max="10">
<!--ro, req, int, X-coordinate of upper-left corner of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</positionX>
<positionY min="1" max="10">
<!--ro, req, int, Y-coordinate of upper-left corner of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</positionY>
<height min="1" max="10">
<!--ro, req, int, width of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</height>
<width min="1" max="10">
<!--ro, req, int, height of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</width>
</Position>
</WeatherContent>
<City>
<!--ro, opt, object, city parameters-->
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<cityId min="1" max="10">
<!--ro, req, string, city No., attr:min{req, int},max{req, int}-->test
</cityId>
<cityName min="1" max="10">
<!--ro, req, string, city name, attr:min{req, int},max{req, int}-->test
</cityName>
<fontSize min="1" max="10">
<!--ro, req, int, font size, attr:min{req, int},max{req, int}-->1
</fontSize>
<FontColor>
<!--ro, req, object, font color-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g., 16777215 indicates 0xFFFFFF-->1
</RGB>
</FontColor>
<BackColor>
<!--ro, req, object, background color-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g., 16777215 indicates 0xFFFFFF-->1
</RGB>
</BackColor>
<Position>
<!--ro, opt, object, content's position, desc:the origin is the upper-left corner of the screen. The value range equals to the device
resolution-->


resolution-->
<positionX min="1" max="10">
<!--ro, req, int, X-coordinate of upper-left corner of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</positionX>
<positionY min="1" max="10">
<!--ro, req, int, Y-coordinate of upper-left corner of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</positionY>
<height min="1" max="10">
<!--ro, req, int, width of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</height>
<width min="1" max="10">
<!--ro, req, int, height of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</width>
</Position>
</City>
<Humidity>
<!--ro, opt, object, humidity parameters-->
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<fontSize min="1" max="10">
<!--ro, req, int, font size, attr:min{req, int},max{req, int}-->1
</fontSize>
<FontColor>
<!--ro, req, object, font color-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g., 16777215 indicates 0xFFFFFF-->1
</RGB>
</FontColor>
<BackColor>
<!--ro, req, object, background color-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g., 16777215 indicates 0xFFFFFF-->1
</RGB>
</BackColor>
<Position>
<!--ro, opt, object, content's position, desc:the origin is the upper-left corner of the screen. The value range equals to the device
resolution-->
<positionX min="1" max="10">
<!--ro, req, int, X-coordinate of upper-left corner of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</positionX>
<positionY min="1" max="10">
<!--ro, req, int, Y-coordinate of upper-left corner of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</positionY>
<height min="1" max="10">
<!--ro, req, int, width of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</height>
<width min="1" max="10">
<!--ro, req, int, height of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</width>
</Position>
</Humidity>
<AirQuality>
<!--ro, opt, object, air quality parameters-->
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<fontSize min="1" max="10">
<!--ro, req, int, font size, attr:min{req, int},max{req, int}-->1
</fontSize>
<FontColor>
<!--ro, req, object, font color-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g., 16777215 indicates 0xFFFFFF-->1
</RGB>
</FontColor>
<BackColor>
<!--ro, req, object, background color-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g., 16777215 indicates 0xFFFFFF-->1
</RGB>
</BackColor>
<Position>
<!--ro, opt, object, position, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX min="1" max="10">
<!--ro, req, int, X-coordinate of upper-left corner of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</positionX>
<positionY min="1" max="10">
<!--ro, req, int, Y-coordinate of upper-left corner of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</positionY>
<height min="1" max="10">
<!--ro, req, int, width of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</height>
<width min="1" max="10">
<!--ro, req, int, height of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</width>
</Position>
</AirQuality>
<UpdateTime>
<!--ro, opt, object, update time parameters-->
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<refreshTime>
<!--ro, req, string, refreshing time, desc:refreshing time in ISO8601 time format-->20200826T051500+08


<!--ro, req, string, refreshing time, desc:refreshing time in ISO8601 time format-->20200826T051500+08
</refreshTime>
<updateInterval min="1" max="10">
<!--ro, req, int, refresh interval, unit:minute, attr:min{req, int},max{req, int}-->1
</updateInterval>
<fontSize min="1" max="10">
<!--ro, req, int, font size, attr:min{req, int},max{req, int}-->1
</fontSize>
<FontColor>
<!--ro, req, object, font color-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g., 16777215 indicates 0xFFFFFF-->1
</RGB>
</FontColor>
<BackColor>
<!--ro, req, object, background color-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g., 16777215 indicates 0xFFFFFF-->1
</RGB>
</BackColor>
<Position>
<!--ro, opt, object, position, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX min="1" max="10">
<!--ro, req, int, X-coordinate of upper-left corner of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</positionX>
<positionY min="1" max="10">
<!--ro, req, int, Y-coordinate of upper-left corner of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</positionY>
<height min="1" max="10">
<!--ro, req, int, width of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</height>
<width min="1" max="10">
<!--ro, req, int, height of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</width>
</Position>
</UpdateTime>
<Wind>
<!--ro, opt, object, wind power parameters-->
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<fontSize min="1" max="10">
<!--ro, req, int, font size, attr:min{req, int},max{req, int}-->1
</fontSize>
<FontColor>
<!--ro, req, object, font color-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g., 16777215 indicates 0xFFFFFF-->1
</RGB>
</FontColor>
<BackColor>
<!--ro, req, object, background color-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g., 16777215 indicates 0xFFFFFF-->1
</RGB>
</BackColor>
<Position>
<!--ro, opt, object, content's position, desc:the origin is the upper-left corner of the screen. The value range equals to the device
resolution-->
<positionX min="1" max="10">
<!--ro, req, int, X-coordinate of upper-left corner of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</positionX>
<positionY min="1" max="10">
<!--ro, req, int, Y-coordinate of upper-left corner of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</positionY>
<height min="1" max="10">
<!--ro, req, int, width of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</height>
<width min="1" max="10">
<!--ro, req, int, height of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</width>
</Position>
</Wind>
</WeatherParam>
<Countdown>
<!--ro, opt, object, countdown material-->
<endTime>
<!--ro, req, string, countdown time, desc:countdown time in ISO8601 time format-->20200826T051500+08
</endTime>
<template
opt="template1,template2,openingActivity1,openingActivity2,commercialActivity1,commercialActivity2,salesPromotion,collegeEntranceExam,overseasTimeFormat">
<!--ro, req, enum, template, subType:string, attr:opt{req, string}, desc:tempalte: "template1" (template 1),"template2..." (template 2)-
>template1
</template>
<timeUnit opt="year,month,day,week,hour,minute,second">
<!--ro, req, enum, time unit, subType:string, attr:opt{req, string}, desc:"year, month, day, week, hour, minute, second"-->year
</timeUnit>
<backPicId>
<!--ro, opt, int, background picture ID-->1
</backPicId>
<TimeFontCfg>
<!--ro, opt, object-->
<fontSize min="1" max="10">
<!--ro, req, int, font size, attr:min{req, int},max{req, int}-->1


<!--ro, req, int, font size, attr:min{req, int},max{req, int}-->1
</fontSize>
<FontColor>
<!--ro, req, object, font color-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g., 16777215 indicates 0xFFFFFF-->1
</RGB>
</FontColor>
<Position>
<!--ro, opt, object, position, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX min="1" max="10">
<!--ro, req, int, X-coordinate of upper-left corner of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</positionX>
<positionY min="1" max="10">
<!--ro, req, int, Y-coordinate of upper-left corner of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</positionY>
<height min="1" max="10">
<!--ro, req, int, height of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</height>
<width min="1" max="10">
<!--ro, req, int, width of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</width>
</Position>
</TimeFontCfg>
<timeUnitEnabled opt="true,false">
<!--ro, opt, bool, attr:opt{req, string}-->true
</timeUnitEnabled>
<maxTimeUnit opt="year,month,day,week,hour,minute,second,week">
<!--ro, opt, enum, subType:string, attr:opt{req, string}-->year
</maxTimeUnit>
<ModuleInfoList>
<!--ro, opt, array, subType:object-->
<ModuleInfo>
<!--ro, opt, object-->
<moduleType opt="year,month,day,hour,minute,second,week,text">
<!--ro, req, enum, module type, subType:string, attr:opt{req, string}, desc:module type-->second
</moduleType>
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<fontSize min="1" max="10">
<!--ro, req, int, font size, attr:min{req, int},max{req, int}-->1
</fontSize>
<FontColor>
<!--ro, req, object, font color-->
<RGB>
<!--ro, opt, int, three primary colors in decimal format,e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</FontColor>
<text min="1" max="256">
<!--ro, opt, string, attr:min{req, int},max{req, int}-->test
</text>
<Position>
<!--ro, opt, object, position, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX min="1" max="10">
<!--ro, req, int, X-coordinate of upper-left corner of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</positionX>
<positionY min="1" max="10">
<!--ro, req, int, Y-coordinate of upper-left corner of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</positionY>
<height min="1" max="10">
<!--ro, req, int, width of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</height>
<width min="1" max="10">
<!--ro, req, int, height of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</width>
</Position>
</ModuleInfo>
</ModuleInfoList>
</Countdown>
<localInputNo opt="VGA,HDMI">
<!--ro, req, enum, local input type, subType:string, attr:opt{req, string}, desc:local input No.-->VGA
</localInputNo>
<HyperlinkBtn>
<!--ro, opt, object, hyperlink button-->
<backPicId>
<!--ro, opt, int, background picture ID-->1
</backPicId>
</HyperlinkBtn>
<CharactersAttribute>
<!--ro, opt, object, character attribute, desc:this node is valid when <dynamicType> is character-->
<fontSize min="1" max="10">
<!--ro, req, int, font size, attr:min{req, int},max{req, int}-->1
</fontSize>
<FontColor>
<!--ro, req, object, font color-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g., 16777215 indicates 0xFFFFFF-->1
</RGB>
</FontColor>
<backgroundType opt="color,picture">
<!--ro, req, enum, background type, subType:string, attr:opt{req, string}, desc:background type-->color
</backgroundType>
<BackColor>
<!--ro, req, object, background color-->


<!--ro, req, object, background color-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g., 16777215 indicates 0xFFFFFF-->1
</RGB>
<fillEnabled opt="true,false">
<!--ro, opt, bool, attr:opt{req, string}-->true
</fillEnabled>
</BackColor>
<backTransparent min="1" max="10">
<!--ro, opt, int, background transparency, attr:min{req, int},max{req, int}-->1
</backTransparent>
<alignType opt="left,right,middle">
<!--ro, req, enum, alignment mode, subType:string, attr:opt{req, string}, desc:"left, right, middle"-->middle
</alignType>
<verticaAlignType opt="top,bottom,verticalCenter">
<!--ro, req, enum, vertical alignment mode, subType:string, attr:opt{req, string}, desc:"top, bottom, verticalCenter"-->top
</verticaAlignType>
<characterContent min="1" max="512">
<!--ro, opt, string, text content, range:[0,512], attr:min{req, int},max{req, int}-->test
</characterContent>
<backPicId min="1" max="10">
<!--ro, opt, int, background picture ID, attr:min{req, int},max{req, int}-->1
</backPicId>
<characterStyle opt="normal,bold">
<!--ro, req, enum, "normal, bold", subType:string, attr:opt{req, string}, desc:"normal, bold"-->normal
</characterStyle>
<characterType opt="mainTitle,subTitle,subTitle2">
<!--ro, req, enum, font type, subType:string, attr:opt{req, string}, desc:font type-->mainTitle
</characterType>
</CharactersAttribute>
<SignIn>
<!--ro, opt, object-->
<backPicId>
<!--ro, opt, int, control's background picture-->1
</backPicId>
<ShowInfo>
<!--ro, opt, object-->
<row min="1" max="10">
<!--ro, opt, int, attr:min{req, int},max{req, int}-->1
</row>
<column min="1" max="10">
<!--ro, opt, int, attr:min{req, int},max{req, int}-->1
</column>
<Position>
<!--ro, opt, object, position, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX min="1" max="10">
<!--ro, req, int, X-coordinate of upper-left corner of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</positionX>
<positionY min="1" max="10">
<!--ro, req, int, Y-coordinate of upper-left corner of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</positionY>
<height min="1" max="10">
<!--ro, req, int, width of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</height>
<width min="1" max="10">
<!--ro, req, int, height of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</width>
</Position>
<inLib>
<!--ro, opt, object-->
<nameEnabled opt="true,false">
<!--ro, opt, bool, attr:opt{req, string}-->true
</nameEnabled>
<genderEnabled opt="true,false">
<!--ro, opt, bool, attr:opt{req, string}-->true
</genderEnabled>
<selfDefine1Enabled opt="true,false">
<!--ro, opt, bool, attr:opt{req, string}-->true
</selfDefine1Enabled>
<selfDefine2Enabled opt="true,false">
<!--ro, opt, bool, attr:opt{req, string}-->true
</selfDefine2Enabled>
<signInTimeEnabled opt="true,false">
<!--ro, opt, bool, attr:opt{req, string}-->true
</signInTimeEnabled>
<temperatureEnabled opt="true,false">
<!--ro, opt, bool, attr:opt{req, string}-->true
</temperatureEnabled>
</inLib>
<outLib>
<!--ro, opt, object-->
<nameEnabled opt="true,false">
<!--ro, opt, bool, attr:opt{req, string}-->true
</nameEnabled>
<name min="1" max="10">
<!--ro, opt, string, attr:min{req, int},max{req, int}-->test
</name>
<genderEnabled opt="true,false">
<!--ro, opt, bool, attr:opt{req, string}-->true
</genderEnabled>
<signInTimeEnabled opt="true,false">
<!--ro, opt, bool, attr:opt{req, string}-->true
</signInTimeEnabled>
<temperatureEnabled opt="true,false">


<temperatureEnabled opt="true,false">
<!--ro, opt, bool, attr:opt{req, string}-->true
</temperatureEnabled>
</outLib>
<showDuration opt="always,10s,20s,30s,no">
<!--ro, req, enum, subType:string, attr:opt{req, string}-->always
</showDuration>
</ShowInfo>
<MainTitle>
<!--ro, opt, object-->
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<fontSize min="1" max="10">
<!--ro, req, int, font size, attr:min{req, int},max{req, int}-->1
</fontSize>
<FontColor>
<!--ro, req, object, font color-->
<RGB>
<!--ro, opt, int, three primary colors in decimal format-->1
</RGB>
</FontColor>
<Position>
<!--ro, opt, object, content's position, desc:the origin is the upper-left corner of the screen. The value range equals to the device
resolution-->
<positionX min="1" max="10">
<!--ro, req, int, X-coordinate of upper-left corner of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</positionX>
<positionY min="1" max="10">
<!--ro, req, int, Y-coordinate of upper-left corner of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</positionY>
<height min="1" max="10">
<!--ro, req, int, width of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</height>
<width min="1" max="10">
<!--ro, req, int, height of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</width>
</Position>
<text min="1" max="10">
<!--ro, opt, string, attr:min{req, int},max{req, int}-->test
</text>
</MainTitle>
<SubTitle>
<!--ro, opt, object-->
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<fontSize min="1" max="10">
<!--ro, req, int, font size, attr:min{req, int},max{req, int}-->1
</fontSize>
<FontColor>
<!--ro, req, object, font color-->
<RGB>
<!--ro, opt, int, three primary colors in decimal format-->1
</RGB>
</FontColor>
<Position>
<!--ro, opt, object, content's position, desc:the origin is the upper-left corner of the screen. The value range equals to the device
resolution-->
<positionX min="1" max="10">
<!--ro, req, int, X-coordinate of upper-left corner of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</positionX>
<positionY min="1" max="10">
<!--ro, req, int, Y-coordinate of upper-left corner of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</positionY>
<height min="1" max="10">
<!--ro, req, int, width of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</height>
<width min="1" max="10">
<!--ro, req, int, height of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</width>
</Position>
<text min="1" max="10">
<!--ro, opt, string, attr:min{req, int},max{req, int}-->test
</text>
</SubTitle>
<NormalTemperature>
<!--ro, opt, object-->
<PeopleNumber>
<!--ro, opt, object-->
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<fontSize min="1" max="10">
<!--ro, req, int, font size, attr:min{req, int},max{req, int}-->1
</fontSize>
<FontColor>
<!--ro, req, object, font color-->
<RGB>
<!--ro, opt, int, three primary colors in decimal format-->1
</RGB>
</FontColor>
<Position>
<!--ro, opt, object, position, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->


<positionX min="1" max="10">
<!--ro, req, int, X-coordinate of upper-left corner of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</positionX>
<positionY min="1" max="10">
<!--ro, req, int, Y-coordinate of upper-left corner of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</positionY>
<height min="1" max="10">
<!--ro, req, int, width of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</height>
<width min="1" max="10">
<!--ro, req, int, height of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</width>
</Position>
<text min="1" max="10">
<!--ro, opt, string, attr:min{req, int},max{req, int}-->test
</text>
</PeopleNumber>
<Icon>
<!--ro, opt, object-->
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<Position>
<!--ro, opt, object, position, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX min="1" max="10">
<!--ro, req, int, X-coordinate of upper-left corner of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</positionX>
<positionY min="1" max="10">
<!--ro, req, int, Y-coordinate of upper-left corner of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</positionY>
<height min="1" max="10">
<!--ro, req, int, width of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</height>
<width min="1" max="10">
<!--ro, req, int, height of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</width>
</Position>
<materialNo min="1" max="10">
<!--ro, opt, int, material ID, attr:min{req, int},max{req, int}-->1
</materialNo>
</Icon>
</NormalTemperature>
<AbnormalTemperature>
<!--ro, opt, object-->
<PeopleNumber>
<!--ro, opt, object-->
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<fontSize min="1" max="10">
<!--ro, req, int, font size, attr:min{req, int},max{req, int}-->1
</fontSize>
<FontColor>
<!--ro, req, object, font color-->
<RGB>
<!--ro, opt, int, three primary colors in decimal format-->1
</RGB>
</FontColor>
<Position>
<!--ro, opt, object, position, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX min="1" max="10">
<!--ro, req, int, X-coordinate of upper-left corner of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</positionX>
<positionY min="1" max="10">
<!--ro, req, int, Y-coordinate of upper-left corner of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</positionY>
<height min="1" max="10">
<!--ro, req, int, width of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</height>
<width min="1" max="10">
<!--ro, req, int, height of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</width>
</Position>
<text min="1" max="10">
<!--ro, opt, string, attr:min{req, int},max{req, int}-->test
</text>
</PeopleNumber>
<Icon>
<!--ro, opt, object-->
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<Position>
<!--ro, opt, object, position, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX min="1" max="10">
<!--ro, req, int, X-coordinate of upper-left corner of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</positionX>
<positionY min="1" max="10">
<!--ro, req, int, Y-coordinate of upper-left corner of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</positionY>
<height min="1" max="10">
<!--ro, req, int, width of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</height>
<width min="1" max="10">


<width min="1" max="10">
<!--ro, req, int, height of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</width>
</Position>
<materialNo min="1" max="10">
<!--ro, opt, int, material ID, attr:min{req, int},max{req, int}-->1
</materialNo>
</Icon>
</AbnormalTemperature>
</SignIn>
<EventParam>
<!--ro, opt, object, event parameters-->
<EventResourceList size="10">
<!--ro, opt, array, list of event source information, subType:object, attr:size{req, int}-->
<EventResource>
<!--ro, opt, object, event source information-->
<ipVersion opt="v4,v6,dual">
<!--ro, req, enum, IP address version, subType:string, attr:opt{req, string}, desc:IP address version-->v4
</ipVersion>
<ipAddress>
<!--ro, opt, string, IPv4 address-->test
</ipAddress>
<ipv6Address>
<!--ro, opt, string, IPv6 address-->test
</ipv6Address>
<portNo>
<!--ro, req, int, port No.-->1
</portNo>
<userName min="1" max="10">
<!--ro, req, string, user name, attr:min{req, int},max{req, int}-->test
</userName>
<passWord min="1" max="10">
<!--ro, req, string, password, attr:min{req, int},max{req, int}-->test
</passWord>
<BindIPC>
<!--ro, opt, string, channel No., desc:multiple channels are separated by commas-->1,2
</BindIPC>
</EventResource>
</EventResourceList>
<backPicId>
<!--ro, opt, int, background picture ID-->1
</backPicId>
<Title>
<!--ro, opt, object, title-->
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<fontSize min="1" max="10">
<!--ro, req, int, font size, attr:min{req, int},max{req, int}-->1
</fontSize>
<FontColor>
<!--ro, req, object, font color-->
<RGB>
<!--ro, opt, int, three primary colors in decimal format-->1
</RGB>
</FontColor>
<Position>
<!--ro, opt, object, position, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX min="1" max="10">
<!--ro, req, int, X-coordinate of upper-left corner of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</positionX>
<positionY min="1" max="10">
<!--ro, req, int, Y-coordinate of upper-left corner of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</positionY>
<height min="1" max="10">
<!--ro, req, int, width of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</height>
<width min="1" max="10">
<!--ro, req, int, height of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</width>
</Position>
<text min="1" max="10">
<!--ro, opt, string, attr:min{req, int},max{req, int}-->test
</text>
</Title>
<PeopleCounting>
<!--ro, opt, object-->
<maxPeopleNumber min="1" max="10">
<!--ro, opt, int, attr:min{req, int},max{req, int}-->1
</maxPeopleNumber>
<unavailableBackPicId>
<!--ro, opt, int-->1
</unavailableBackPicId>
<supportChangeByPeople opt="prompt,peopleIcon,availablePeopleNumber">
<!--ro, req, enum, subType:string, attr:opt{req, string}-->prompt
</supportChangeByPeople>
<Prompt>
<!--ro, opt, object, prompt information-->
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<fontSize min="1" max="10">
<!--ro, req, int, font size, attr:min{req, int},max{req, int}-->1
</fontSize>


</fontSize>
<Position>
<!--ro, opt, object, position, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX min="1" max="10">
<!--ro, req, int, X-coordinate of upper-left corner of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</positionX>
<positionY min="1" max="10">
<!--ro, req, int, Y-coordinate of upper-left corner of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</positionY>
<height min="1" max="10">
<!--ro, req, int, width of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</height>
<width min="1" max="10">
<!--ro, req, int, height of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</width>
</Position>
<text min="1" max="10">
<!--ro, opt, string, attr:min{req, int},max{req, int}-->test
</text>
<FontColor>
<!--ro, opt, object, font color-->
<RGB>
<!--ro, opt, int, three primary colors in decimal format-->1
</RGB>
</FontColor>
<unavailableText min="1" max="10">
<!--ro, opt, string, attr:min{req, int},max{req, int}-->test
</unavailableText>
<UnavailableFontColor>
<!--ro, opt, object-->
<RGB>
<!--ro, opt, int, three primary colors in decimal format-->1
</RGB>
</UnavailableFontColor>
</Prompt>
<PeopleIcon>
<!--ro, opt, object-->
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<Position>
<!--ro, opt, object, position, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX min="1" max="10">
<!--ro, req, int, X-coordinate of upper-left corner of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</positionX>
<positionY min="1" max="10">
<!--ro, req, int, Y-coordinate of upper-left corner of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</positionY>
<height min="1" max="10">
<!--ro, req, int, width of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</height>
<width min="1" max="10">
<!--ro, req, int, height of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</width>
</Position>
<materialNo min="1" max="10">
<!--ro, opt, int, material ID, attr:min{req, int},max{req, int}-->1
</materialNo>
</PeopleIcon>
<InsidePeopleTitle>
<!--ro, opt, object-->
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<fontSize min="1" max="10">
<!--ro, req, int, font size, attr:min{req, int},max{req, int}-->1
</fontSize>
<FontColor>
<!--ro, req, object, font color-->
<RGB>
<!--ro, opt, int, three primary colors in decimal format-->1
</RGB>
</FontColor>
<Position>
<!--ro, opt, object, position, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX min="1" max="10">
<!--ro, req, int, X-coordinate of upper-left corner of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</positionX>
<positionY min="1" max="10">
<!--ro, req, int, Y-coordinate of upper-left corner of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</positionY>
<height min="1" max="10">
<!--ro, req, int, width of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</height>
<width min="1" max="10">
<!--ro, req, int, height of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</width>
</Position>
<text min="1" max="10">
<!--ro, opt, string, attr:min{req, int},max{req, int}-->test
</text>
</InsidePeopleTitle>
<InsidePeopleNumber>
<!--ro, opt, object-->
<enabled>


<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<fontSize min="1" max="10">
<!--ro, req, int, font size, attr:min{req, int},max{req, int}-->1
</fontSize>
<FontColor>
<!--ro, req, object, font color-->
<RGB>
<!--ro, opt, int, three primary colors in decimal format-->1
</RGB>
</FontColor>
<Position>
<!--ro, opt, object, position, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX min="1" max="10">
<!--ro, req, int, X-coordinate of upper-left corner of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</positionX>
<positionY min="1" max="10">
<!--ro, req, int, Y-coordinate of upper-left corner of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</positionY>
<height min="1" max="10">
<!--ro, req, int, width of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</height>
<width min="1" max="10">
<!--ro, req, int, height of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</width>
</Position>
</InsidePeopleNumber>
<AvailablePeopleTitle>
<!--ro, opt, object-->
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<fontSize min="1" max="10">
<!--ro, req, int, font size, attr:min{req, int},max{req, int}-->1
</fontSize>
<FontColor>
<!--ro, req, object, font color-->
<RGB>
<!--ro, opt, int, three primary colors in decimal format-->1
</RGB>
</FontColor>
<Position>
<!--ro, opt, object, position, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX min="1" max="10">
<!--ro, req, int, X-coordinate of upper-left corner of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</positionX>
<positionY min="1" max="10">
<!--ro, req, int, Y-coordinate of upper-left corner of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</positionY>
<height min="1" max="10">
<!--ro, req, int, width of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</height>
<width min="1" max="10">
<!--ro, req, int, height of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</width>
</Position>
<text min="1" max="10">
<!--ro, opt, string, attr:min{req, int},max{req, int}-->test
</text>
</AvailablePeopleTitle>
<AvailablePeopleNumber>
<!--ro, opt, object-->
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<fontSize min="1" max="10">
<!--ro, req, int, font size, attr:min{req, int},max{req, int}-->1
</fontSize>
<Position>
<!--ro, opt, object, position, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX min="1" max="10">
<!--ro, req, int, X-coordinate of upper-left corner of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</positionX>
<positionY min="1" max="10">
<!--ro, req, int, Y-coordinate of upper-left corner of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</positionY>
<height min="1" max="10">
<!--ro, req, int, width of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</height>
<width min="1" max="10">
<!--ro, req, int, height of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</width>
</Position>
<FontColor>
<!--ro, opt, object, font color-->
<RGB>
<!--ro, opt, int, three primary colors in decimal format-->1
</RGB>
</FontColor>
<UnavailableFontColor>
<!--ro, opt, object-->
<RGB>
<!--ro, opt, int, three primary colors in decimal format-->1


<!--ro, opt, int, three primary colors in decimal format-->1
</RGB>
</UnavailableFontColor>
</AvailablePeopleNumber>
<UnavailablePeopleIcon>
<!--ro, opt, object-->
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<Position>
<!--ro, opt, object, position, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX min="1" max="10">
<!--ro, req, int, X-coordinate of upper-left corner of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</positionX>
<positionY min="1" max="10">
<!--ro, req, int, Y-coordinate of upper-left corner of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</positionY>
<height min="1" max="10">
<!--ro, req, int, width of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</height>
<width min="1" max="10">
<!--ro, req, int, height of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</width>
</Position>
<materialNo min="1" max="10">
<!--ro, opt, int, material ID, attr:min{req, int},max{req, int}-->1
</materialNo>
</UnavailablePeopleIcon>
<AudioAlarm>
<!--ro, opt, object-->
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<materialNo min="1" max="10">
<!--ro, opt, int, material index No., attr:min{req, int},max{req, int}-->1
</materialNo>
</AudioAlarm>
</PeopleCounting>
<Mask>
<!--ro, opt, object-->
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<fontSize min="1" max="10">
<!--ro, req, int, font size, attr:min{req, int},max{req, int}-->1
</fontSize>
<FontColor>
<!--ro, req, object, font color-->
<RGB>
<!--ro, opt, int, three primary colors in decimal format-->1
</RGB>
</FontColor>
<BackColor>
<!--ro, req, object, background color-->
<RGB>
<!--ro, opt, int, three primary colors in decimal format-->1
</RGB>
</BackColor>
<Position>
<!--ro, opt, object, position, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX min="1" max="10">/Authentication
<!--ro, req, int, X-coordinate of upper-left corner of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</positionX>
<positionY min="1" max="10">
<!--ro, req, int, Y-coordinate of upper-left corner of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</positionY>
<height min="1" max="10">
<!--ro, req, int, width of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</height>
<width min="1" max="10">
<!--ro, req, int, height of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</width>
</Position>
<text min="1" max="10">
<!--ro, opt, string, attr:min{req, int},max{req, int}-->test
</text>
<MaskIcon>
<!--ro, opt, object-->
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<Position>
<!--ro, opt, object, position, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX min="1" max="10">
<!--ro, req, int, X-coordinate of upper-left corner of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</positionX>
<positionY min="1" max="10">
<!--ro, req, int, Y-coordinate of upper-left corner of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</positionY>
<height min="1" max="10">
<!--ro, req, int, width of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</height>
<width min="1" max="10">
<!--ro, req, int, height of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</width>


</width>
</Position>
<materialNo min="1" max="10">
<!--ro, opt, int, material ID, attr:min{req, int},max{req, int}-->1
</materialNo>
</MaskIcon>
<AudioAlarm>
<!--ro, opt, object-->
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<materialNo min="1" max="10">
<!--ro, opt, int, material index No., attr:min{req, int},max{req, int}-->1
</materialNo>
</AudioAlarm>
</Mask>
<Temperature>
<!--ro, opt, object, temperature parameters-->
<Prompt>
<!--ro, opt, object, prompt information-->
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<fontSize min="1" max="10">
<!--ro, req, int, font size, attr:min{req, int},max{req, int}-->1
</fontSize>
<FontColor>
<!--ro, req, object, font color-->
<RGB>
<!--ro, opt, int, three primary colors in decimal format-->1
</RGB>
</FontColor>
<BackColor>
<!--ro, req, object, background color-->
<RGB>
<!--ro, opt, int, three primary colors in decimal format-->1
</RGB>
</BackColor>
<Position>
<!--ro, opt, object, position, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX min="1" max="10">
<!--ro, req, int, X-coordinate of upper-left corner of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</positionX>
<positionY min="1" max="10">
<!--ro, req, int, Y-coordinate of upper-left corner of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</positionY>
<height min="1" max="10">
<!--ro, req, int, width of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</height>
<width min="1" max="10">
<!--ro, req, int, height of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</width>
</Position>
<text min="1" max="10">
<!--ro, opt, string, attr:min{req, int},max{req, int}-->test
</text>
</Prompt>
<TemperatureIcon>
<!--ro, opt, object-->
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<Position>
<!--ro, opt, object, position, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX min="1" max="10">
<!--ro, req, int, X-coordinate of upper-left corner of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</positionX>
<positionY min="1" max="10">
<!--ro, req, int, Y-coordinate of upper-left corner of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</positionY>
<height min="1" max="10">
<!--ro, req, int, width of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</height>
<width min="1" max="10">
<!--ro, req, int, height of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</width>
</Position>
<materialNo min="1" max="10">
<!--ro, opt, int, material ID, attr:min{req, int},max{req, int}-->1
</materialNo>
</TemperatureIcon>
<AudioAlarm>
<!--ro, opt, object, audio alarm information-->
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<materialNo min="1" max="10">
<!--ro, opt, int, material index No., attr:min{req, int},max{req, int}-->1
</materialNo>
</AudioAlarm>
<abnormalHighTemperature min="1" max="10">
<!--ro, opt, float, corrects to one decimal place, unit:℃, attr:min{req, int},max{req, int}, desc:corrects to one decimal place-->37.5
</abnormalHighTemperature>
</Temperature>


</Temperature>
<WearMask>
<!--ro, opt, object-->
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<fontSize min="1" max="10">
<!--ro, req, int, font size, attr:min{req, int},max{req, int}-->1
</fontSize>
<FontColor>
<!--ro, req, object, font color-->
<RGB>
<!--ro, opt, int, three primary colors in decimal format-->1
</RGB>
</FontColor>
<BackColor>
<!--ro, req, object, background color-->
<RGB>
<!--ro, opt, int, three primary colors in decimal format-->1
</RGB>
</BackColor>
<Position>
<!--ro, opt, object, position, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX min="1" max="10">
<!--ro, req, int, X-coordinate of upper-left corner of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</positionX>
<positionY min="1" max="10">
<!--ro, req, int, Y-coordinate of upper-left corner of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</positionY>
<height min="1" max="10">
<!--ro, req, int, width of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</height>
<width min="1" max="10">
<!--ro, req, int, height of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</width>
</Position>
<text min="1" max="10">
<!--ro, opt, string, attr:min{req, int},max{req, int}-->test
</text>
<MaskIcon>
<!--ro, opt, object-->
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<Position>
<!--ro, opt, object, position, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX min="1" max="10">
<!--ro, req, int, X-coordinate of upper-left corner of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</positionX>
<positionY min="1" max="10">
<!--ro, req, int, Y-coordinate of upper-left corner of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</positionY>
<height min="1" max="10">
<!--ro, req, int, width of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</height>
<width min="1" max="10">
<!--ro, req, int, height of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</width>
</Position>
<materialNo min="1" max="10">
<!--ro, opt, int, material index No., attr:min{req, int},max{req, int}-->1
</materialNo>
</MaskIcon>
</WearMask>
<NormalTemperature>
<!--ro, opt, object-->
<Prompt>
<!--ro, opt, object, prompt information-->
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<fontSize min="1" max="10">
<!--ro, req, int, font size, attr:min{req, int},max{req, int}-->1
</fontSize>
<FontColor>
<!--ro, req, object, font color-->
<RGB>
<!--ro, opt, int, three primary colors in decimal format-->1
</RGB>
</FontColor>
<BackColor>
<!--ro, req, object, background color-->
<RGB>
<!--ro, opt, int, three primary colors in decimal format-->1
</RGB>
</BackColor>
<Position>
<!--ro, opt, object, position, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX min="1" max="10">
<!--ro, req, int, X-coordinate of upper-left corner of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</positionX>
<positionY min="1" max="10">
<!--ro, req, int, Y-coordinate of upper-left corner of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</positionY>


<height min="1" max="10">
<!--ro, req, int, width of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</height>
<width min="1" max="10">
<!--ro, req, int, height of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</width>
</Position>
<text min="1" max="10">
<!--ro, opt, string, attr:min{req, int},max{req, int}-->test
</text>
</Prompt>
<TemperatureIcon>
<!--ro, opt, object-->
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<Position>
<!--ro, opt, object, position, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX min="1" max="10">
<!--ro, req, int, X-coordinate of upper-left corner of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</positionX>
<positionY min="1" max="10">
<!--ro, req, int, Y-coordinate of upper-left corner of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</positionY>
<height min="1" max="10">
<!--ro, req, int, width of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</height>
<width min="1" max="10">
<!--ro, req, int, height of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</width>
</Position>
<materialNo min="1" max="10">
<!--ro, opt, int, material ID, attr:min{req, int},max{req, int}-->1
</materialNo>
</TemperatureIcon>
</NormalTemperature>
<NormalStatusAudioAlarm>
<!--ro, opt, object-->
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<materialNo min="1" max="10">
<!--ro, opt, int, material index No., attr:min{req, int},max{req, int}-->1
</materialNo>
</NormalStatusAudioAlarm>
</EventParam>
<ConferenceParam>
<!--ro, opt, object, meeting information, desc:meeting information-->
<backPicId>
<!--ro, opt, int, background picture ID-->1
</backPicId>
<Title>
<!--ro, opt, object-->
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<fontSize min="1" max="10">
<!--ro, req, int, font size, attr:min{req, int},max{req, int}-->1
</fontSize>
<FontColor>
<!--ro, req, object, font color-->
<RGB>
<!--ro, opt, int, three primary colors in decimal format-->1
</RGB>
</FontColor>
<BackColor>
<!--ro, req, object, background color-->
<RGB>
<!--ro, opt, int, three primary colors in decimal format-->1
</RGB>
</BackColor>
<Position>
<!--ro, opt, object, position, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX min="1" max="10">
<!--ro, req, int, X-coordinate of upper-left corner of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</positionX>
<positionY min="1" max="10">
<!--ro, req, int, Y-coordinate of upper-left corner of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</positionY>
<height min="1" max="10">
<!--ro, req, int, width of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</height>
<width min="1" max="10">
<!--ro, req, int, height of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</width>
</Position>
</Title>
<VoiceBroadcast>
<!--ro, opt, object, audio prompt-->
<enabled opt="true,false">
<!--ro, opt, bool, whether to enable audio prompt, attr:opt{req, string}-->true
</enabled>
<broadcastSpeed opt="slower,slow,medium,fast,faster">
<!--ro, opt, enum, subType:string, attr:opt{req, string}-->slower


<!--ro, opt, enum, subType:string, attr:opt{req, string}-->slower
</broadcastSpeed>
<inLibVoice min="1" max="10">
<!--ro, opt, string, audio prompt content of people in database, attr:min{req, int},max{req, int}-->test
</inLibVoice>
<outLibVoice min="1" max="10">
<!--ro, opt, string, attr:min{req, int},max{req, int}-->test
</outLibVoice>
</VoiceBroadcast>
<WelcomeWord>
<!--ro, opt, object, welcome words-->
<enabled opt="true,false">
<!--ro, opt, bool, whether to enable welcome words, attr:opt{req, string}-->true
</enabled>
<inLibWord min="1" max="128">
<!--ro, opt, string, range:[1,128], attr:min{req, int},max{req, int}-->test
</inLibWord>
<outLibWord min="1" max="128">
<!--ro, opt, string, range:[1,128], attr:min{req, int},max{req, int}-->test
</outLibWord>
</WelcomeWord>
<ShowInfo>
<!--ro, opt, object-->
<row min="1" max="10">
<!--ro, opt, int, attr:min{req, int},max{req, int}-->1
</row>
<column min="1" max="10">
<!--ro, opt, int, attr:min{req, int},max{req, int}-->1
</column>
<Position>
<!--ro, opt, object, position, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX min="1" max="10">
<!--ro, req, int, X-coordinate of upper-left corner of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</positionX>
<positionY min="1" max="10">
<!--ro, req, int, Y-coordinate of upper-left corner of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</positionY>
<height min="1" max="10">
<!--ro, req, int, width of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</height>
<width min="1" max="10">
<!--ro, req, int, height of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</width>
</Position>
<inLib>
<!--ro, opt, object-->
<nameEnabled opt="true,false">
<!--ro, opt, bool, attr:opt{req, string}-->true
</nameEnabled>
</inLib>
</ShowInfo>
<ModuleInfoList>
<!--ro, opt, array, subType:object-->
<ModuleInfo>
<!--ro, opt, object-->
<moduleType
opt="conferenceTime,conferenceSite,conferenceStatus,signInPersonNum,totalPersonNum,unSignInPersonNum,signInAndTotalPersonNum,QRCode,meetingHostName,employee
No,customKey,nextMeeting">
<!--ro, req, enum, module type, subType:string, attr:opt{req, string}, desc:module type-->conferenceTime
</moduleType>
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<fontSize min="1" max="10">
<!--ro, req, int, font size, attr:min{req, int},max{req, int}-->1
</fontSize>
<FontColor>
<!--ro, req, object, font color-->
<RGB>
<!--ro, opt, int, three primary colors in decimal format-->1
</RGB>
</FontColor>
<BackColor>
<!--ro, opt, object, background color-->
<RGB>
<!--ro, opt, int, three primary colors in decimal format-->1
</RGB>
</BackColor>
<backPicId>
<!--ro, opt, int, background picture ID, desc:control's background picture-->1
</backPicId>
<Position>
<!--ro, opt, object, position, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX min="1" max="10">
<!--ro, req, int, X-coordinate of upper-left corner of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</positionX>
<positionY min="1" max="10">
<!--ro, req, int, Y-coordinate of upper-left corner of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</positionY>
<height min="1" max="10">
<!--ro, req, int, width of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</height>
<width min="1" max="10">
<!--ro, req, int, height of the content's rectangle frame, attr:min{req, int},max{req, int}-->1


<!--ro, req, int, height of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</width>
</Position>
</ModuleInfo>
</ModuleInfoList>
</ConferenceParam>
<CallBtn>
<!--ro, opt, object-->
<backPicId min="0" max="10">
<!--ro, opt, int, background picture ID, attr:min{req, int},max{req, int}-->1
</backPicId>
</CallBtn>
<OpenDoorBtn>
<!--ro, opt, object-->
<backPicId min="0" max="10">
<!--ro, opt, int, background picture ID, attr:min{req, int},max{req, int}-->1
</backPicId>
</OpenDoorBtn>
<QRCodeBtn>
<!--ro, opt, object-->
<backPicId min="0" max="10">
<!--ro, opt, int, background picture ID, attr:min{req, int},max{req, int}-->1
</backPicId>
</QRCodeBtn>
<AuthenticationSuccess>
<!--ro, opt, object-->
<BackColor>
<!--ro, opt, object, background color-->
<RGB>
<!--ro, opt, int, three primary colors in decimal format-->1
</RGB>
</BackColor>
<backPicId min="0" max="10">
<!--ro, opt, int, background picture ID, attr:min{req, int},max{req, int}, desc:control's background picture-->1
</backPicId>
<SubWindowList>
<!--ro, opt, object, sub-window list-->
<SubWindow>
<!--ro, opt, object, sub-window-->
<subWindowType opt="temperature,facePic,name,employeeNo,group,tips">
<!--ro, req, enum, sub-window type, subType:string, attr:opt{req, string}, desc:sub-window type-->temperature
</subWindowType>
<enabled opt="true,false">
<!--ro, req, bool, whether to enable the function, attr:opt{req, string}-->true
</enabled>
<fontSize min="6" max="72">
<!--ro, opt, int, font size, unit:px, attr:min{req, int},max{req, int}-->1
</fontSize>
<fontColor>
<!--ro, opt, int, font color-->1
</fontColor>
<fontStyle opt="bold,italic,underline,strikeout">
<!--ro, opt, string, font style, attr:opt{req, string}, desc:font style-->bold,italic,underline,strikeout
</fontStyle>
<Position>
<!--ro, opt, object, position, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX min="1" max="10">
<!--ro, req, int, X-coordinate of upper-left corner of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</positionX>
<positionY min="1" max="10">
<!--ro, req, int, Y-coordinate of upper-left corner of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</positionY>
<height min="1" max="10">
<!--ro, req, int, width of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</height>
<width min="1" max="10">
<!--ro, req, int, height of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</width>
</Position>
</SubWindow>
</SubWindowList>
</AuthenticationSuccess>
<AuthenticationFail>
<!--ro, opt, object-->
<BackColor>
<!--ro, opt, object, background color-->
<RGB>
<!--ro, opt, int, three primary colors in decimal format-->1
</RGB>
</BackColor>
<backPicId min="0" max="10">
<!--ro, opt, int, background picture ID, attr:min{req, int},max{req, int}, desc:control's background picture-->1
</backPicId>
<SubWindowList>
<!--ro, opt, object, sub-window list-->
<SubWindow>
<!--ro, opt, object, sub-window-->
<subWindowType opt="temperature,facePic,name,employeeNo,group,tips">
<!--ro, req, enum, sub-window type, subType:string, attr:opt{req, string}, desc:sub-window type-->temperature
</subWindowType>
<enabled opt="true,false">
<!--ro, req, bool, whether to enable the function, attr:opt{req, string}-->true
</enabled>
<fontSize min="6" max="72">
<!--ro, opt, int, font size, unit:px, attr:min{req, int},max{req, int}-->1


<!--ro, opt, int, font size, unit:px, attr:min{req, int},max{req, int}-->1
</fontSize>
<fontColor>
<!--ro, opt, int, font color-->1
</fontColor>
<fontStyle opt="bold,italic,underline,strikeout">
<!--ro, opt, string, font style, attr:opt{req, string}, desc:font style-->bold,italic,underline,strikeout
</fontStyle>
<Position>
<!--ro, opt, object, position, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX min="1" max="10">
<!--ro, req, int, X-coordinate of upper-left corner of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</positionX>
<positionY min="1" max="10">
<!--ro, req, int, Y-coordinate of upper-left corner of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</positionY>
<height min="1" max="10">
<!--ro, req, int, width of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</height>
<width min="1" max="10">
<!--ro, req, int, height of the content's rectangle frame, attr:min{req, int},max{req, int}-->1
</width>
</Position>
<facePicID min="1" max="100">
<!--ro, opt, int, step:1, dep:and,
{$.PageList.Page.WindowsList[*].Windows.AuthenticationFail.SubWindowList.SubWindow.subWindowType,eq,facePic}, attr:min{req, int},max{req, int}-->1
</facePicID>
</SubWindow>
</SubWindowList>
</AuthenticationFail>
<StatusBar>
<!--ro, opt, object, status bar, desc:status bar-->
<backPicId min="0" max="10">
<!--ro, opt, int, background picture ID, attr:min{req, int},max{req, int}, desc:control's background picture-->1
</backPicId>
<statusBarType opt="fixed">
<!--ro, req, enum, status bar type, subType:string, attr:opt{req, string}, desc:status bar type-->fixed
</statusBarType>
<SubStatusList size="5">
<!--ro, opt, object, sub status list, attr:size{req, int}-->
<SubStatus>
<!--ro, opt, object, sub status-->
<statusType opt="dial,wifi,EZVIZ,wiredNetwork,deploy,temperature">
<!--ro, req, enum, sub status, subType:string, attr:opt{req, string}, desc:sub status-->dial
</statusType>
<enabled opt="true,false">
<!--ro, req, bool, attr:opt{req, string}-->true
</enabled>
</SubStatus>
</SubStatusList>
</StatusBar>
<ExamTemplate>
<!--ro, opt, object-->
<examTemplateID max="100">
<!--ro, opt, string, template ID, attr:max{req, int}-->test
</examTemplateID>
<backPicURL max="1024">
<!--ro, opt, string, background picture URL, range:[1,1024], attr:max{req, int}-->test
</backPicURL>
<backgroundDirection opt="horizontal,vertical">
<!--ro, opt, enum, "horizontal", "vertical", subType:string, attr:opt{req, string}, desc:"horizontal", "vertical"-->horizontal
</backgroundDirection>
<ModuleInfoList size="50">
<!--ro, opt, array, subType:object, attr:size{req, int}-->
<ModuleInfo>
<!--ro, opt, object-->
<moduleType
opt="schoolName,currentTime,examinationPlanLable,examinationPlanName,examRoomNumberLable,examRoomNumber,examRoomAddress,examRoomAddressLable,examDescription
Lable,examDescription,examSubjectLable,examSubject,examTimeLable,examTime,teacherLable,teacher,examNumberRangeLable,examNumberRange">
<!--ro, opt, enum, module type, subType:string, attr:opt{req, string}, desc:module type-->schoolName
</moduleType>
<enabled opt="true,false">
<!--ro, opt, bool, whether to enable the function, attr:opt{req, string}-->true
</enabled>
<Position>
<!--ro, opt, object, position, desc:the origin is the upper-left corner of the screen-->
<positionX min="0" max="2000">
<!--ro, req, int, X-coordinate, attr:min{req, int},max{req, int}-->1
</positionX>
<positionY min="0" max="1000">
<!--ro, req, int, Y-coordinate, attr:min{req, int},max{req, int}-->1
</positionY>
<height min="0" max="2000">
<!--ro, req, int, height, attr:min{req, int},max{req, int}-->1
</height>
<width min="0" max="1000">
<!--ro, req, int, width, attr:min{req, int},max{req, int}-->1
</width>
</Position>
<fontSize min="1" max="100">
<!--ro, opt, int, font size, attr:min{req, int},max{req, int}-->1
</fontSize>
<fontStyleList size="10">
<!--ro, opt, array, list of font style, subType:object, attr:size{req, int}-->


<!--ro, opt, array, list of font style, subType:object, attr:size{req, int}-->
<fontStyle opt="bold,italic,regular,strikethrough,underline">
<!--ro, opt, enum, font style, subType:string, attr:opt{req, string}, desc:font style-->bold
</fontStyle>
</fontStyleList>
<fontType opt="custom,default,kaiTi,simHei,simSun">
<!--ro, opt, enum, font type, subType:string, attr:opt{req, string}, desc:font type-->custom
</fontType>
<FontColor>
<!--ro, opt, object, font color-->
<RGB min="0" max="20000000">
<!--ro, opt, int, three primary colors in decimal format, attr:min{req, int},max{req, int}-->1
</RGB>
</FontColor>
<fontTransparent min="0.0" max="1.0">
<!--ro, opt, float, attr:min{req, float},max{req, float}-->1.0
</fontTransparent>
<alignType opt="left,right,middle">
<!--ro, opt, enum, subType:string, attr:opt{req, string}-->middle
</alignType>
<characterSpacing min="1" max="100">
<!--ro, opt, int, character pitch, attr:min{req, int},max{req, int}-->1
</characterSpacing>
<lineSpacing min="0.0" max="10">
<!--ro, opt, float, row height, attr:min{req, float},max{req, int}-->1.0
</lineSpacing>
<layerNo min="10" max="100">
<!--ro, opt, int, layer No., attr:min{req, int},max{req, int}, desc:layer No.-->1
</layerNo>
</ModuleInfo>
</ModuleInfoList>
</ExamTemplate>
<ChartData>
<!--ro, opt, object-->
<materialNo min="1" max="100">
<!--ro, req, int, material No., attr:min{req, int},max{req, int}-->1
</materialNo>
<chartType opt="histogram,pieChart">
<!--ro, opt, enum, subType:string, attr:opt{req, string}-->histogram
</chartType>
<backPicId min="1" max="100">
<!--ro, opt, int, background picture No., attr:min{req, int},max{req, int}-->1
</backPicId>
<HeadDataList>
<!--ro, opt, array, subType:object-->
<HeadData>
<!--ro, opt, object, table head data-->
<id min="1" max="100">
<!--ro, req, int, attr:min{req, int},max{req, int}-->1
</id>
<data min="1" max="100">
<!--ro, req, string, data, attr:min{req, int},max{req, int}-->test
</data>
<headType opt="axis,value">
<!--ro, opt, enum, subType:string, attr:opt{req, string}-->axis
</headType>
</HeadData>
</HeadDataList>
</ChartData>
</Windows>
</WindowsList>
</Page>
21.37.3 Set the parameters of a specific page
Request URL
PUT /ISAPI/Publish/ProgramMgr/program/<programID>/page/<pageID>
Query Parameter
Parameter Name Parameter Type Description
programID
string
pageID
Request Message
<?xml version="1.0" encoding="UTF-8"?>
<Page xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--req, object, page, attr:version{req, string, protocolVersion}-->
<id>
<!--req, int, page No.-->1
</id>
<PageBasicInfo>
string
-
-


<!--req, object, basic page information-->
<pageName>
<!--opt, string, page name-->test
</pageName>
<BackgroundColor>
<!--opt, object, background color-->
<RGB>
<!--opt, int, three primary colors in decimal format,e.g.,16777215 indicates 0xFFFFFF, desc:three primary colors in decimal format, e.g.,16777215
indicates 0xFFFFFF-->1
</RGB>
</BackgroundColor>
<playDurationMode>
<!--opt, enum, page playing time mode, subType:string, desc:When the value of this node is selfDefine, the node <playDuration> is valid; when the
value is auto, it will be calculated according to the content playing time. "selfDefine”, “auto", “loop”-->selfDefine
</playDurationMode>
<playDuration>
<!--opt, int, playing duration, unit:s-->1
</playDuration>
<playCount>
<!--opt, int-->1
</playCount>
<switchDuration>
<!--opt, int, switch interval, unit:s-->1
</switchDuration>
<switchEffect>
<!--opt, enum, switch effect, subType:string, desc:switching effect:
"none,random,boxShrink,boxSpread,cycleShrink,cycSpread,eraseUp,eraseDown,eraseLeft,eraseRight,verticalShelter,horizontalShelter,verticalChessboard,horizonta
lChessboard,dissolve,leftRightToCenter,ceterToLeftRight,upDownToCenter,centerToUpDown,drawOutLeftDown,drawOutLeftUp,drawOutRightDown,drawOutRightUp,vertical
Line,horizontalLine"-->none
</switchEffect>
<backgroundPic>
<!--opt, int, background picture which is the picture material ID-->1
</backgroundPic>
<SignInCfg>
<!--opt, object, check-in information-->
<VoiceBroadcast>
<!--opt, object, audio prompt-->
<enabled>
<!--opt, bool-->true
</enabled>
<broadcastSpeed>
<!--opt, enum, subType:string-->slower
</broadcastSpeed>
<inLibVoice>
<!--opt, string-->test
</inLibVoice>
<outLibVoice>
<!--opt, string-->test
</outLibVoice>
<inLibAbnormalTemperatureVoice>
<!--opt, string-->test
</inLibAbnormalTemperatureVoice>
<outLibAbnormalTemperatureVoice>
<!--opt, string-->test
</outLibAbnormalTemperatureVoice>
</VoiceBroadcast>
<WelcomeWord>
<!--opt, object, welcome words-->
<enabled>
<!--opt, bool-->true
</enabled>
<inLibWord>
<!--opt, string-->test
</inLibWord>
<outLibWord>
<!--opt, string-->test
</outLibWord>
</WelcomeWord>
<SignCartoon>
<!--opt, object-->
<signCartoonSpeed>
<!--opt, enum, subType:string-->fast
</signCartoonSpeed>
</SignCartoon>
<backgroundSignEnabled>
<!--opt, bool-->true
</backgroundSignEnabled>
<TemperatureDetection>
<!--opt, object, screen temperature parameter-->
<enabled>
<!--req, bool-->true
</enabled>
<threshold>
<!--req, float-->0.000
</threshold>
</TemperatureDetection>
</SignInCfg>
</PageBasicInfo>
<characterMode>
<!--opt, enum, welcome word mode on the page, subType:string, desc:“mode1”, “mode2”, “mode3” for access control devices, the position of the welcome
words is fixed and can be in three modes-->mode1
</characterMode>
<WindowsList>
<!--opt, array, window information list, subType:object-->


<!--opt, array, window information list, subType:object-->
<Windows>
<!--opt, object, window information-->
<id>
<!--req, int, page No.-->1
</id>
<Position>
<!--opt, object, content's position, desc:the upper-left corner is the origin, and the size of the full screen is 1920*1920-->
<positionX>
<!--req, int, X-coordinate-->1
</positionX>
<positionY>
<!--req, int, Y-coordinate-->1
</positionY>
<height>
<!--req, int, width-->1
</height>
<width>
<!--req, int, height-->1
</width>
</Position>
<CornerRadius>
<!--opt, object-->
<TopLeft>
<!--opt, int-->1
</TopLeft>
<TopRight>
<!--opt, int-->1
</TopRight>
<BottomLeft>
<!--opt, int-->1
</BottomLeft>
<BottomRight>
<!--opt, int-->1
</BottomRight>
</CornerRadius>
<layerNo>
<!--req, int, layer No.-->1
</layerNo>
<WinMaterialInfo>
<!--opt, object, window material information-->
<materialType>
<!--req, enum, window material type, subType:string, desc:“static” (static material), “dynamic” (dynamic material), “other” (other material)-
>static
</materialType>
<staticMaterialType>
<!--opt, enum, static material type, subType:string, desc:local material type. This node is valid when <materialType> is static-->picture
</staticMaterialType>
<dynamicType>
<!--opt, enum, dynamic material type, subType:string, desc:dymanic window material type:
"web,socket,rss,call,dynamicPic,realStream,capturePic,character". This node is valid when <materialType> is dynamic-->web
</dynamicType>
<otherType>
<!--opt, enum, other material type, subType:string, desc:hyperlinkBtn"string,other type: "clock,weather,countdown,localInput,hyperlinkBtn"-->clock
</otherType>
</WinMaterialInfo>
<TouchProperty>
<!--opt, object, touching attributes-->
<windType>
<!--opt, enum, window type, subType:string, desc:window type: pop-up window,page window-->popup
</windType>
<hyperlinkType>
<!--opt, enum, hyperlink type, subType:string, desc:"window,page" this node is valid when <windType> is popup-->window
</hyperlinkType>
<windowId>
<!--opt, int, window No., desc:window No. (window of current page). This node is valid when <hyperlinkType> is window-->1
</windowId>
<pageId>
<!--opt, int, page No., desc:this node is valid when <hyperlinkType> is page-->1
</pageId>
</TouchProperty>
<PlayItemList>
<!--opt, array, window playing list, subType:object-->
<PlayItem>
<!--req, object-->
<id>
<!--req, int, page No.-->1
</id>
<materialNo>
<!--opt, int, material index No.-->1
</materialNo>
<inputChannel>
<!--opt, int, linked channel No. of the network camera-->1
</inputChannel>
<playEffect>
<!--req, enum, playing effect, subType:string, desc:playing effect: none,scroller-->none
</playEffect>
<MarqueeInfo>
<!--opt, object-->
<scrollType>
<!--req, enum, scroller scrolling type:, subType:string, desc:“none” (not scroll), “loops” (scroll circularly), “once” (scroll once),
“backAndForth” (scroll backwards and forwards)-->none
</scrollType>
<scrollDeriction>


<scrollDeriction>
<!--req, enum, scroller scrolling direction, subType:string, desc:“none”, “from top to bottom”, “from bottom to top”, “from left to right”,
“from right to left”-->none
</scrollDeriction>
<scrollSpeed>
<!--req, int, scroller scrolling speed-->1
</scrollSpeed>
</MarqueeInfo>
<PlayDuration>
<!--opt, object, material playing duration, desc:this node can be configured for local materials, live video, and network camera channels-->
<durationType>
<!--req, enum, playing duration type,, subType:string, desc:playing duration type,custom-->selfDefine
</durationType>
<duration>
<!--req, int, material playing duration, unit:s-->1
</duration>
</PlayDuration>
<CharactersEffect>
<!--opt, object, character display effect, desc:this node is valid when the material type is text or TXT file-->
<fontSize>
<!--req, int, font size-->1
</fontSize>
<FontColor>
<!--req, object, font color-->
<RGB>
<!--opt, int, three primary colors in decimal format,e.g.,16777215 indicates 0xFFFFFF, desc:three primary colors in decimal format,
e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</FontColor>
<backgroundType>
<!--opt, enum, subType:string-->color
</backgroundType>
<backPicId>
<!--opt, int-->1
</backPicId>
<BackColor>
<!--req, object, background color-->
<RGB>
<!--opt, int, three primary colors in decimal format,e.g.,16777215 indicates 0xFFFFFF, desc:three primary colors in decimal format,
e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</BackColor>
<backTransparent>
<!--req, int, background transparency-->1
</backTransparent>
<subtitlesEnabled>
<!--req, bool, whether to enable character display mode-->true
</subtitlesEnabled>
<scrollDirection>
<!--req, enum, character scrolling direction, subType:string, desc:"left”, “right”, “up”, “down"-->left
</scrollDirection>
<scrollSpeed>
<!--req, int, scroller scrolling speed-->1
</scrollSpeed>
</CharactersEffect>
<switchEffect>
<!--opt, enum, switching effect, subType:string,
desc:"none,random,boxShrink,boxSpread,cycleShrink,cycSpread,eraseUp,eraseDown,eraseLeft,eraseRight,verticalShelter,horizontalShelter,verticalChessboard,hori
zontalChessboard,dissolve,leftRightToCenter,ceterToLeftRight,upDownToCenter,centerToUpDown,drawOutLeftDown,drawOutLeftUp,drawOutRightDown,drawOutRightUp,ver
ticalLine,horizontalLine"-->random
</switchEffect>
<pageTime>
<!--opt, int, paging time, unit:s, desc:paging interval,unit: second. This node is valid when the material is a word,ppt,pdf,or excel file-->1
</pageTime>
<scrollSpeed>
<!--req, int, scroller scrolling speed, desc:scroller scrolling speed-->1
</scrollSpeed>
<scaleType>
<!--opt, enum, subType:string-->centerCrop
</scaleType>
<playType>
<!--opt, enum, subType:string-->normal
</playType>
<CharactersAttribute>
<!--opt, object, character attribute, desc:this node is valid when <dynamicType> is character-->
<fontSize>
<!--req, int, font size-->1
</fontSize>
<FontColor>
<!--req, object, font color-->
<RGB>
<!--opt, int, three primary colors in decimal format,e.g.,16777215 indicates 0xFFFFFF, desc:three primary colors in decimal format,
e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</FontColor>
<backgroundType>
<!--req, enum, subType:string-->color
</backgroundType>
<BackColor>
<!--req, object, background color-->
<RGB>
<!--opt, int, three primary colors in decimal format,e.g.,16777215 indicates 0xFFFFFF, desc:three primary colors in decimal format,
e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</BackColor>


</BackColor>
<backTransparent>
<!--opt, int, background transparency-->1
</backTransparent>
<alignType>
<!--req, enum, aligment mode, subType:string, desc:"left,right,middle,top,bottom,verticalCenter,horizontallyCenter"-->middle
</alignType>
<verticaAlignType>
<!--req, enum, subType:string-->top
</verticaAlignType>
<characterContent>
<!--opt, string, text content, range:[0,512]-->test
</characterContent>
<backPicId>
<!--opt, int, control's background picture-->1
</backPicId>
<characterStyle>
<!--req, enum, subType:string-->normal
</characterStyle>
<characterType>
<!--req, enum, font type, subType:string-->mainTitle
</characterType>
</CharactersAttribute>
<WebProperty>
<!--opt, object-->
<webType>
<!--opt, enum, subType:string-->desktop
</webType>
</WebProperty>
</PlayItem>
</PlayItemList>
<enabledAudio>
<!--opt, bool, whether to enable the audio-->true
</enabledAudio>
<enableHide>
<!--opt, bool, whether to enable hiding-->true
</enableHide>
<enableLock>
<!--opt, bool, whether to enable the clock-->true
</enableLock>
<AppWindow>
<!--opt, object-->
<WindowInfoList>
<!--req, array, window information list, subType:object-->
<WindowInfo>
<!--req, object, window information-->
<id>
<!--req, int, page No.-->1
</id>
<materialNo>
<!--req, int, material No., desc:material index No.-->1
</materialNo>
<path>
<!--opt, string, range:[0,1024]-->test
</path>
</WindowInfo>
</WindowInfoList>
</AppWindow>
<DataSource>
<!--opt, object, data source, desc:data source. This node is valid when it is a calling or pop-up window-->
<materialNo>
<!--req, int, material No.-->1
</materialNo>
</DataSource>
<Call>
<!--opt, object, calling data-->
<materialNo>
<!--req, int, material No.-->1
</materialNo>
<tableRow>
<!--req, int, row of the table-->1
</tableRow>
<tableColumn>
<!--req, int, column of the table-->1
</tableColumn>
<tableDirection>
<!--req, enum, table direction, subType:string, desc:table direction: "vertical,horizontal"-->vertical
</tableDirection>
<tableType>
<!--req, enum, table template, subType:string, desc:"template1, template2, template3, template4, template5, template6"-->template1
</tableType>
<backPicId>
<!--opt, int, control's background picture-->1
</backPicId>
<alignType>
<!--req, enum, alignment mode, subType:string, desc:"left, right, middle, top, bottom, verticalCenter, horizontallyCenter"-->left
</alignType>
<refreshDirection>
<!--req, enum, refreshing direction, subType:string, desc:refreshing direction: "upTodown"-from top to bottom,"downToup"-from bottom to top-
>upTodown
</refreshDirection>
<HeadDataList>
<!--opt, array, subType:object-->
<HeadData>


<HeadData>
<!--opt, object, table head data (calling data)-->
<id>
<!--req, int, page No.-->1
</id>
<data>
<!--req, string, data-->test
</data>
</HeadData>
</HeadDataList>
<ItemStyleList>
<!--opt, array, subType:object-->
<ItemStyle>
<!--opt, object, style of the table's row or column-->
<id>
<!--req, int, page No.-->1
</id>
<width>
<!--req, int, width of the content's rectangle frame-->1
</width>
<fontSize>
<!--req, int, font size-->1
</fontSize>
<FontColor>
<!--req, object, font color-->
<RGB>
<!--opt, int, three primary colors in decimal format,e.g.,16777215 indicates 0xFFFFFF, desc:three primary colors in decimal format,
e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</FontColor>
<BackColor>
<!--req, object, background color-->
<RGB>
<!--opt, int, three primary colors in decimal format,e.g.,16777215 indicates 0xFFFFFF, desc:three primary colors in decimal format,
e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</BackColor>
</ItemStyle>
</ItemStyleList>
</Call>
<DynamicPic>
<!--opt, object, dynamic pop-up window parameters-->
<materialNo>
<!--req, int, material No.-->1
</materialNo>
<backPicId>
<!--opt, int, control's background picture-->1
</backPicId>
</DynamicPic>
<CapturePic>
<!--opt, object, picture capturing parameters-->
<backPicId>
<!--opt, int, control's background picture-->1
</backPicId>
<ipcMaterialNo>
<!--req, int-->1
</ipcMaterialNo>
<cancelType>
<!--req, enum, cancel mode, subType:string, desc:cancalling type: "auto,manual"-->manual
</cancelType>
<duration>
<!--opt, int, material playing duration, unit:s-->1
</duration>
</CapturePic>
<ClockParam>
<!--opt, object, clock parameters-->
<backPicId>
<!--opt, int, control's background picture-->1
</backPicId>
<ClockIcon>
<!--req, object, clock icon parameters-->
<enabled>
<!--req, bool, whether to enable the function-->true
</enabled>
<type>
<!--opt, enum, clock type, subType:string, desc:type: "clock1,clock2,..."-->clock1
</type>
<Position>
<!--opt, object, content's position, desc:the upper-left corner is the origin, and the size of the full screen is 1920*1920-->
<positionX>
<!--req, int, X-coordinate-->1
</positionX>
<positionY>
<!--req, int, Y-coordinate-->1
</positionY>
<height>
<!--req, int, width-->1
</height>
<width>
<!--req, int, height-->1
</width>
</Position>
</ClockIcon>
<YmdParam>


<!--req, object, the parameters of year, month, and day in the clock-->
<enabled>
<!--req, bool, whether to enable the function-->true
</enabled>
<fontSize>
<!--req, int, font size-->1
</fontSize>
<FontColor>
<!--req, object, font color-->
<RGB>
<!--opt, int, three primary colors in decimal format,e.g.,16777215 indicates 0xFFFFFF, desc:three primary colors in decimal format,
e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</FontColor>
<BackColor>
<!--req, object, background color-->
<RGB>
<!--opt, int, three primary colors in decimal format,e.g.,16777215 indicates 0xFFFFFF, desc:three primary colors in decimal format,
e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</BackColor>
<Position>
<!--opt, object, content's position, desc:the upper-left corner is the origin, and the size of the full screen is 1920*1920-->
<positionX>
<!--req, int, X-coordinate-->1
</positionX>
<positionY>
<!--req, int, Y-coordinate-->1
</positionY>
<height>
<!--req, int, width-->1
</height>
<width>
<!--req, int, height-->1
</width>
</Position>
</YmdParam>
<HmsParam>
<!--req, object, the parameters of hour, minute, and second in the clock-->
<enabled>
<!--req, bool, whether to enable the function-->true
</enabled>
<fontSize>
<!--req, int, font size-->1
</fontSize>
<FontColor>
<!--req, object, font color-->
<RGB>
<!--opt, int, three primary colors in decimal format,e.g.,16777215 indicates 0xFFFFFF, desc:three primary colors in decimal format,
e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</FontColor>
<BackColor>
<!--req, object, background color-->
<RGB>
<!--opt, int, three primary colors in decimal format,e.g.,16777215 indicates 0xFFFFFF, desc:three primary colors in decimal format,
e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</BackColor>
<Position>
<!--opt, object, content's position, desc:the upper-left corner is the origin, and the size of the full screen is 1920*1920-->
<positionX>
<!--req, int, X-coordinate-->1
</positionX>
<positionY>
<!--req, int, Y-coordinate-->1
</positionY>
<height>
<!--req, int, width-->1
</height>
<width>
<!--req, int, height-->1
</width>
</Position>
</HmsParam>
<WeekParam>
<!--req, object, week parameters-->
<enabled>
<!--req, bool, whether to enable the function-->true
</enabled>
<fontSize>
<!--req, int, font size-->1
</fontSize>
<FontColor>
<!--req, object, font color-->
<RGB>
<!--opt, int, three primary colors in decimal format,e.g.,16777215 indicates 0xFFFFFF, desc:three primary colors in decimal format,
e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</FontColor>
<BackColor>
<!--req, object, background color-->
<RGB>
<!--opt, int, three primary colors in decimal format,e.g.,16777215 indicates 0xFFFFFF, desc:three primary colors in decimal format,


<!--opt, int, three primary colors in decimal format,e.g.,16777215 indicates 0xFFFFFF, desc:three primary colors in decimal format,
e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</BackColor>
<Position>
<!--opt, object, content's position, desc:the upper-left corner is the origin, and the size of the full screen is 1920*1920-->
<positionX>
<!--req, int, X-coordinate-->1
</positionX>
<positionY>
<!--req, int, Y-coordinate-->1
</positionY>
<height>
<!--req, int, width-->1
</height>
<width>
<!--req, int, height-->1
</width>
</Position>
</WeekParam>
</ClockParam>
<WeatherParam>
<!--opt, object, weather parameters-->
<backPicId>
<!--opt, int, control's background picture-->1
</backPicId>
<WeatherIcon>
<!--opt, object, weather icon parameters-->
<enabled>
<!--req, bool-->true
</enabled>
<Position>
<!--opt, object, content's position, desc:the upper-left corner is the origin, and the size of the full screen is 1920*1920-->
<positionX>
<!--req, int, X-coordinate-->1
</positionX>
<positionY>
<!--req, int, Y-coordinate-->1
</positionY>
<height>
<!--req, int, width-->1
</height>
<width>
<!--req, int, height-->1
</width>
</Position>
</WeatherIcon>
<Date>
<!--opt, object, date parameters-->
<enabled>
<!--req, bool-->true
</enabled>
<fontSize>
<!--req, int, font size-->1
</fontSize>
<FontColor>
<!--req, object, font color-->
<RGB>
<!--opt, int, three primary colors in decimal format,e.g.,16777215 indicates 0xFFFFFF, desc:three primary colors in decimal format,
e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</FontColor>
<BackColor>
<!--req, object, background color-->
<RGB>
<!--opt, int, three primary colors in decimal format,e.g.,16777215 indicates 0xFFFFFF, desc:three primary colors in decimal format,
e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</BackColor>
<Position>
<!--opt, object, content's position, desc:the upper-left corner is the origin, and the size of the full screen is 1920*1920-->
<positionX>
<!--req, int, X-coordinate-->1
</positionX>
<positionY>
<!--req, int, Y-coordinate-->1
</positionY>
<height>
<!--req, int, width-->1
</height>
<width>
<!--req, int, height-->1
</width>
</Position>
</Date>
<Temperature>
<!--opt, object, temperature parameters-->
<enabled>
<!--req, bool-->true
</enabled>
<fontSize>
<!--req, int, font size-->1
</fontSize>
<FontColor>


<!--req, object, font color-->
<RGB>
<!--opt, int, three primary colors in decimal format,e.g.,16777215 indicates 0xFFFFFF, desc:three primary colors in decimal format,
e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</FontColor>
<BackColor>
<!--req, object, background color-->
<RGB>
<!--opt, int, three primary colors in decimal format,e.g.,16777215 indicates 0xFFFFFF, desc:three primary colors in decimal format,
e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</BackColor>
<Position>
<!--opt, object, content's position., desc:the upper-left corner is the origin, and the size of the full screen is 1920*1920-->
<positionX>
<!--req, int, X-coordinate-->1
</positionX>
<positionY>
<!--req, int, Y-coordinate-->1
</positionY>
<height>
<!--req, int, width-->1
</height>
<width>
<!--req, int, height-->1
</width>
</Position>
</Temperature>
<WeatherContent>
<!--opt, object, weather parameters-->
<enabled>
<!--req, bool, whether to enable the function-->true
</enabled>
<fontSize>
<!--req, int, font size-->1
</fontSize>
<FontColor>
<!--req, object, font color-->
<RGB>
<!--opt, int, three primary colors in decimal format,e.g.,16777215 indicates 0xFFFFFF, desc:three primary colors in decimal format,
e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</FontColor>
<BackColor>
<!--req, object, background color-->
<RGB>
<!--opt, int, three primary colors in decimal format,e.g.,16777215 indicates 0xFFFFFF, desc:three primary colors in decimal format,
e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</BackColor>
<Position>
<!--opt, object, content's position, desc:the upper-left corner is the origin,and the size of the full screen is 1920*1920-->
<positionX>
<!--req, int, X-coordinate-->1
</positionX>
<positionY>
<!--req, int, Y-coordinate-->1
</positionY>
<height>
<!--req, int, width-->1
</height>
<width>
<!--req, int, height-->1
</width>
</Position>
</WeatherContent>
<City>
<!--opt, object, city parameters-->
<enabled>
<!--req, bool-->true
</enabled>
<cityId>
<!--req, string, city No.-->test
</cityId>
<cityName>
<!--req, string, city name-->test
</cityName>
<fontSize>
<!--req, int, font size-->1
</fontSize>
<FontColor>
<!--req, object, font color-->
<RGB>
<!--opt, int, three primary colors in decimal format,e.g.,16777215 indicates 0xFFFFFF, desc:three primary colors in decimal format,
e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</FontColor>
<BackColor>
<!--req, object, background color-->
<RGB>
<!--opt, int, three primary colors in decimal format,e.g.,16777215 indicates 0xFFFFFF, desc:three primary colors in decimal format,
e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>


</RGB>
</BackColor>
<Position>
<!--opt, object, content's position, desc:the upper-left corner is the origin, and the size of the full screen is 1920*1920-->
<positionX>
<!--req, int, X-coordinate-->1
</positionX>
<positionY>
<!--req, int, Y-coordinate-->1
</positionY>
<height>
<!--req, int, width-->1
</height>
<width>
<!--req, int, height-->1
</width>
</Position>
</City>
<Humidity>
<!--opt, object, humidity parameters-->
<enabled>
<!--req, bool-->true
</enabled>
<fontSize>
<!--req, int, font size-->1
</fontSize>
<FontColor>
<!--req, object, font color-->
<RGB>
<!--opt, int, three primary colors in decimal format,e.g.,16777215 indicates 0xFFFFFF, desc:three primary colors in decimal format,
e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</FontColor>
<BackColor>
<!--req, object, background color-->
<RGB>
<!--opt, int, three primary colors in decimal format,e.g.,16777215 indicates 0xFFFFFF, desc:three primary colors in decimal format,
e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</BackColor>
<Position>
<!--opt, object, content's position, desc:the upper-left corner is the origin, and the size of the full screen is 1920*1920-->
<positionX>
<!--req, int, X-coordinate-->1
</positionX>
<positionY>
<!--req, int, Y-coordinate-->1
</positionY>
<height>
<!--req, int, width-->1
</height>
<width>
<!--req, int, height-->1
</width>
</Position>
</Humidity>
<AirQuality>
<!--opt, object, air quality parameters-->
<enabled>
<!--req, bool-->true
</enabled>
<fontSize>
<!--req, int, font size-->1
</fontSize>
<FontColor>
<!--req, object, font color-->
<RGB>
<!--opt, int, three primary colors in decimal format,e.g.,16777215 indicates 0xFFFFFF, desc:three primary colors in decimal format,
e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</FontColor>
<BackColor>
<!--req, object, background color-->
<RGB>
<!--opt, int, three primary colors in decimal format,e.g.,16777215 indicates 0xFFFFFF, desc:three primary colors in decimal format,
e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</BackColor>
<Position>
<!--opt, object, content's position, desc:the upper-left corner is the origin, and the size of the full screen is 1920*1920-->
<positionX>
<!--req, int, X-coordinate-->1
</positionX>
<positionY>
<!--req, int, Y-coordinate-->1
</positionY>
<height>
<!--req, int, width-->1
</height>
<width>
<!--req, int, height-->1
</width>
</Position>
</AirQuality>


</AirQuality>
<UpdateTime>
<!--opt, object, update time parameters-->
<enabled>
<!--req, bool-->true
</enabled>
<refreshTime>
<!--req, string, refreshing time in ISO8601 time format, desc:refreshing time in ISO8601 time format-->20200826T051500+08
</refreshTime>
<updateInterval>
<!--req, int, refresh interval, unit:minute-->1
</updateInterval>
<fontSize>
<!--req, int, font size-->1
</fontSize>
<FontColor>
<!--req, object, font color-->
<RGB>
<!--opt, int, three primary colors in decimal format,e.g.,16777215 indicates 0xFFFFFF, desc:three primary colors in decimal format,
e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</FontColor>
<BackColor>
<!--req, object, background color-->
<RGB>
<!--opt, int, three primary colors in decimal format,e.g.,16777215 indicates 0xFFFFFF, desc:three primary colors in decimal format,
e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</BackColor>
<Position>
<!--opt, object, content's position., desc:the upper-left corner is the origin, and the size of the full screen is 1920*1920-->
<positionX>
<!--req, int, X-coordinate-->1
</positionX>
<positionY>
<!--req, int, Y-coordinate-->1
</positionY>
<height>
<!--req, int, width-->1
</height>
<width>
<!--req, int, height-->1
</width>
</Position>
</UpdateTime>
<Wind>
<!--opt, object, wind power parameters-->
<enabled>
<!--req, bool-->true
</enabled>
<fontSize>
<!--req, int, font size-->1
</fontSize>
<FontColor>
<!--req, object, font color-->
<RGB>
<!--opt, int, three primary colors in decimal format,e.g.,16777215 indicates 0xFFFFFF, desc:three primary colors in decimal format,
e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</FontColor>
<BackColor>
<!--req, object, background color-->
<RGB>
<!--opt, int, three primary colors in decimal format,e.g.,16777215 indicates 0xFFFFFF, desc:three primary colors in decimal format,
e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</BackColor>
<Position>
<!--opt, object, content's position, desc:the upper-left corner is the origin, and the size of the full screen is 1920*1920-->
<positionX>
<!--req, int, X-coordinate-->1
</positionX>
<positionY>
<!--req, int, Y-coordinate-->1
</positionY>
<height>
<!--req, int, width-->1
</height>
<width>
<!--req, int, height-->1
</width>
</Position>
</Wind>
</WeatherParam>
<Countdown>
<!--opt, object, countdown material-->
<endTime>
<!--req, string, countdown time, desc:countdown time in ISO8601 time format-->20200826T051500+08
</endTime>
<template>
<!--req, enum, template type, subType:string, desc:tempalte: "template1" (template 1),"template2..." (template 2)-->template1
</template>
<timeUnit>
<!--req, enum, time unit, subType:string, desc:time unit: "year,month,day,week,hour,minute,second"-->year
</timeUnit>


</timeUnit>
<backPicId>
<!--opt, int, control's background picture-->1
</backPicId>
<TimeFontCfg>
<!--opt, object-->
<fontSize>
<!--req, int, font size-->1
</fontSize>
<FontColor>
<!--req, object, font color-->
<RGB>
<!--opt, int, three primary colors in decimal format,e.g.,16777215 indicates 0xFFFFFF, desc:three primary colors in decimal format,
e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</FontColor>
<Position>
<!--opt, object, content's position, desc:the upper-left corner is the origin, and the size of the full screen is 1920*1920-->
<positionX>
<!--req, int, X-coordinate-->1
</positionX>
<positionY>
<!--req, int, Y-coordinate-->1
</positionY>
<height>
<!--req, int, width-->1
</height>
<width>
<!--req, int, height-->1
</width>
</Position>
</TimeFontCfg>
<timeUnitEnabled>
<!--opt, bool-->true
</timeUnitEnabled>
<maxTimeUnit>
<!--req, enum, subType:string-->year
</maxTimeUnit>
<ModuleInfoList>
<!--opt, array, subType:object-->
<ModuleInfo>
<!--opt, object-->
<moduleType>
<!--req, enum, module type, subType:string-->second
</moduleType>
<enabled>
<!--req, bool-->true
</enabled>
<fontSize>
<!--req, int, font size-->1
</fontSize>
<FontColor>
<!--req, object, font color-->
<RGB>
<!--opt, int, three primary colors in decimal format-->1
</RGB>
</FontColor>
<text>
<!--opt, string-->test
</text>
<Position>
<!--opt, object, content's position, desc:the upper-left corner is the origin, and the size of the full screen is 1920*1920-->
<positionX>
<!--req, int, X-coordinate-->1
</positionX>
<positionY>
<!--req, int, Y-coordinate-->1
</positionY>
<height>
<!--req, int, width-->1
</height>
<width>
<!--req, int, height-->1
</width>
</Position>
</ModuleInfo>
</ModuleInfoList>
</Countdown>
<localInputNo>
<!--req, enum, local input No., subType:string, desc:local input No.-->VGA
</localInputNo>
<HyperlinkBtn>
<!--opt, object-->
<backPicId>
<!--opt, int, control's background picture-->1
</backPicId>
</HyperlinkBtn>
<CharactersAttribute>
<!--opt, object, character attribute, desc:this node is valid when <dynamicType> is character-->
<fontSize>
<!--req, int, font size-->1
</fontSize>
<FontColor>
<!--req, object, font color-->


<!--req, object, font color-->
<RGB>
<!--opt, int, three primary colors in decimal format,e.g.,16777215 indicates 0xFFFFFF, desc:three primary colors in decimal format,
e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</FontColor>
<fontType>
<!--opt, enum, subType:string-->normal
</fontType>
<backgroundType>
<!--req, enum, subType:string-->color
</backgroundType>
<BackColor>
<!--req, object, background color-->
<RGB>
<!--opt, int, three primary colors in decimal format,e.g.,16777215 indicates 0xFFFFFF, desc:three primary colors in decimal format,
e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
<fillEnabled>
<!--opt, bool-->true
</fillEnabled>
</BackColor>
<backTransparent>
<!--opt, int, background transparency-->1
</backTransparent>
<alignType>
<!--req, enum, alignment mode, subType:string, desc:"left,right,middle”-->middle
</alignType>
<verticaAlignType>
<!--req, enum, subType:string-->top
</verticaAlignType>
<characterContent>
<!--opt, string, text content, range:[0,512]-->test
</characterContent>
<backPicId>
<!--opt, int, control's background picture-->1
</backPicId>
<characterStyle>
<!--req, enum, subType:string-->normal
</characterStyle>
<characterType>
<!--req, enum, font type, subType:string-->mainTitle
</characterType>
<scrollDirection>
<!--opt, enum, character scrolling direction, subType:string, desc:"left,right,up,down"-->left
</scrollDirection>
<scrollSpeed>
<!--opt, int, scroller scrolling speed, range:[1,10]-->1
</scrollSpeed>
</CharactersAttribute>
<SignIn>
<!--opt, object-->
<backPicId>
<!--opt, int, control's background picture-->1
</backPicId>
<ShowInfo>
<!--opt, object-->
<row>
<!--opt, int-->1
</row>
<column>
<!--opt, int-->1
</column>
<Position>
<!--opt, object, position, desc:the upper-left corner is the origin, and the size of the full screen is 1920*1920-->
<positionX>
<!--req, int, X-coordinate-->1
</positionX>
<positionY>
<!--req, int, Y-coordinate-->1
</positionY>
<height>
<!--req, int, width-->1
</height>
<width>
<!--req, int, height-->1
</width>
</Position>
<inLib>
<!--opt, object-->
<nameEnabled>
<!--opt, bool-->true
</nameEnabled>
<genderEnabled>
<!--opt, bool-->true
</genderEnabled>
<selfDefine1Enabled>
<!--opt, bool-->true
</selfDefine1Enabled>
<selfDefine2Enabled>
<!--opt, bool-->true
</selfDefine2Enabled>
<signInTimeEnabled>
<!--opt, bool-->true


</signInTimeEnabled>
<temperatureEnabled>
<!--opt, bool-->true
</temperatureEnabled>
</inLib>
<outLib>
<!--opt, object-->
<nameEnabled>
<!--opt, bool-->true
</nameEnabled>
<name>
<!--opt, string-->test
</name>
<genderEnabled>
<!--opt, bool-->true
</genderEnabled>
<signInTimeEnabled>
<!--opt, bool-->true
</signInTimeEnabled>
<temperatureEnabled>
<!--opt, bool-->true
</temperatureEnabled>
</outLib>
<showDuration>
<!--req, enum, subType:string-->always
</showDuration>
</ShowInfo>
<MainTitle>
<!--opt, object-->
<enabled>
<!--req, bool-->true
</enabled>
<fontSize>
<!--req, int, font size-->1
</fontSize>
<FontColor>
<!--req, object, font color-->
<RGB>
<!--opt, int, three primary colors in decimal format-->1
</RGB>
</FontColor>
<Position>
<!--opt, object, position, desc:the upper-left corner is the origin, and the size of the full screen is 1920*1920-->
<positionX>
<!--req, int, X-coordinate-->1
</positionX>
<positionY>
<!--req, int, Y-coordinate-->1
</positionY>
<height>
<!--req, int, width-->1
</height>
<width>
<!--req, int, height-->1
</width>
</Position>
<text>
<!--opt, string-->test
</text>
</MainTitle>
<SubTitle>
<!--opt, object-->
<enabled>
<!--req, bool, whether to enable the function-->true
</enabled>
<fontSize>
<!--req, int, font size-->1
</fontSize>
<FontColor>
<!--req, object, font color-->
<RGB>
<!--opt, int, three primary colors in decimal format-->1
</RGB>
</FontColor>
<Position>
<!--opt, object, content's position, desc:the upper-left corner is the origin, and the size of the full screen is 1920*1920-->
<positionX>
<!--req, int, X-coordinate-->1
</positionX>
<positionY>
<!--req, int, Y-coordinate-->1
</positionY>
<height>
<!--req, int, width-->1
</height>
<width>
<!--req, int, height-->1
</width>
</Position>
<text>
<!--opt, string-->test
</text>
</SubTitle>
<NormalTemperature>


<NormalTemperature>
<!--opt, object-->
<PeopleNumber>
<!--opt, object-->
<enabled>
<!--req, bool-->true
</enabled>
<fontSize>
<!--req, int, font size-->1
</fontSize>
<FontColor>
<!--req, object, font color-->
<RGB>
<!--opt, int, three primary colors in decimal format-->1
</RGB>
</FontColor>
<Position>
<!--opt, object, position, desc:the upper-left corner is the origin, and the size of the full screen is 1920*1920-->
<positionX>
<!--req, int, X-coordinate-->1
</positionX>
<positionY>
<!--req, int, Y-coordinate-->1
</positionY>
<height>
<!--req, int, width-->1
</height>
<width>
<!--req, int, height-->1
</width>
</Position>
<text>
<!--opt, string-->test
</text>
</PeopleNumber>
<Icon>
<!--opt, object-->
<enabled>
<!--req, bool-->true
</enabled>
<Position>
<!--opt, object, position, desc:the upper-left corner is the origin, and the size of the full screen is 1920*1920-->
<positionX>
<!--req, int, X-coordinate-->1
</positionX>
<positionY>
<!--req, int, Y-coordinate-->1
</positionY>
<height>
<!--req, int, width-->1
</height>
<width>
<!--req, int, height-->1
</width>
</Position>
<materialNo>
<!--opt, int, material ID-->1
</materialNo>
</Icon>
</NormalTemperature>
<AbnormalTemperature>
<!--opt, object-->
<PeopleNumber>
<!--opt, object-->
<enabled>
<!--req, bool-->true
</enabled>
<fontSize>
<!--req, int, font size-->1
</fontSize>
<FontColor>
<!--req, object, font color-->
<RGB>
<!--opt, int, three primary colors in decimal format-->1
</RGB>
</FontColor>
<Position>
<!--opt, object, content's position, desc:the upper-left corner is the origin, and the size of the full screen is 1920*1920-->
<positionX>
<!--req, int, X-coordinate-->1
</positionX>
<positionY>
<!--req, int, Y-coordinate-->1
</positionY>
<height>
<!--req, int, width-->1
</height>
<width>
<!--req, int, height-->1
</width>
</Position>
<text>
<!--opt, string-->test
</text>


</PeopleNumber>
<Icon>
<!--opt, object-->
<enabled>
<!--req, bool-->true
</enabled>
<Position>
<!--opt, object, position, desc:the upper-left corner is the origin, and the size of the full screen is 1920*1920-->
<positionX>
<!--req, int, X-coordinate-->1
</positionX>
<positionY>
<!--req, int, Y-coordinate-->1
</positionY>
<height>
<!--req, int, width-->1
</height>
<width>
<!--req, int, height-->1
</width>
</Position>
<materialNo>
<!--opt, int, material ID-->1
</materialNo>
</Icon>
</AbnormalTemperature>
</SignIn>
<EventParam>
<!--opt, object-->
<EventResourceList>
<!--opt, array, subType:object-->
<EventResource>
<!--opt, object-->
<ipVersion>
<!--req, enum, subType:string-->v4
</ipVersion>
<ipAddress>
<!--opt, string, IPv4 address-->test
</ipAddress>
<ipv6Address>
<!--opt, string-->test
</ipv6Address>
<portNo>
<!--req, int-->1
</portNo>
<userName>
<!--req, string-->test
</userName>
<passWord>
<!--req, string-->test
</passWord>
<channels>
<!--opt, string-->1,2
</channels>
</EventResource>
</EventResourceList>
<backPicId>
<!--opt, int, control's background picture-->1
</backPicId>
<Title>
<!--opt, object, title-->
<enabled>
<!--req, bool-->true
</enabled>
<fontSize>
<!--req, int, font size-->1
</fontSize>
<FontColor>
<!--req, object, font color-->
<RGB>
<!--opt, int, three primary colors in decimal format-->1
</RGB>
</FontColor>
<Position>
<!--opt, object, position, desc:the upper-left corner is the origin, and the size of the full screen is 1920*1920-->
<positionX>
<!--req, int, X-coordinate-->1
</positionX>
<positionY>
<!--req, int, Y-coordinate-->1
</positionY>
<height>
<!--req, int, width-->1
</height>
<width>
<!--req, int, height-->1
</width>
</Position>
<text>
<!--opt, string-->test
</text>
</Title>
<PeopleCounting>
<!--opt, object-->


<!--opt, object-->
<maxPeopleNumber>
<!--opt, int-->1
</maxPeopleNumber>
<unavailableBackPicId>
<!--opt, int-->1
</unavailableBackPicId>
<supportChangeByPeople>
<!--req, enum, subType:string-->prompt
</supportChangeByPeople>
<Prompt>
<!--opt, object-->
<enabled>
<!--req, bool-->true
</enabled>
<fontSize>
<!--req, int, font size-->1
</fontSize>
<Position>
<!--opt, object, position, desc:the upper-left corner is the origin, and the size of the full screen is 1920*1920-->
<positionX>
<!--req, int, X-coordinate-->1
</positionX>
<positionY>
<!--req, int, Y-coordinate-->1
</positionY>
<height>
<!--req, int, width-->1
</height>
<width>
<!--req, int, height-->1
</width>
</Position>
<text>
<!--opt, string-->test
</text>
<FontColor>
<!--opt, object, font color-->
<RGB>
<!--opt, int, three primary colors in decimal format-->1
</RGB>
</FontColor>
<unavailableText>
<!--opt, string-->test
</unavailableText>
<UnavailableFontColor>
<!--opt, object-->
<RGB>
<!--opt, int, three primary colors in decimal format-->1
</RGB>
</UnavailableFontColor>
</Prompt>
<PeopleIcon>
<!--opt, object-->
<enabled>
<!--req, bool-->true
</enabled>
<Position>
<!--opt, object, position, desc:the upper-left corner is the origin, and the size of the full screen is 1920*1920-->
<positionX>
<!--req, int, X-coordinate-->1
</positionX>
<positionY>
<!--req, int, Y-coordinate-->1
</positionY>
<height>
<!--req, int, width-->1
</height>
<width>
<!--req, int, height-->1
</width>
</Position>
<materialNo>
<!--opt, int, material ID-->1
</materialNo>
</PeopleIcon>
<InsidePeopleTitle>
<!--opt, object-->
<enabled>
<!--req, bool-->true
</enabled>
<fontSize>
<!--req, int, font size-->1
</fontSize>
<FontColor>
<!--req, object, font color-->
<RGB>
<!--opt, int, three primary colors in decimal format-->1
</RGB>
</FontColor>
<Position>
<!--opt, object, position, desc:the upper-left corner is the origin, and the size of the full screen is 1920*1920-->
<positionX>
<!--req, int, X-coordinate-->1


<!--req, int, X-coordinate-->1
</positionX>
<positionY>
<!--req, int, Y-coordinate-->1
</positionY>
<height>
<!--req, int, width-->1
</height>
<width>
<!--req, int, height-->1
</width>
</Position>
<text>
<!--opt, string-->test
</text>
</InsidePeopleTitle>
<InsidePeopleNumber>
<!--opt, object-->
<enabled>
<!--req, bool-->true
</enabled>
<fontSize>
<!--req, int, font size-->1
</fontSize>
<FontColor>
<!--req, object, font color-->
<RGB>
<!--opt, int, three primary colors in decimal format-->1
</RGB>
</FontColor>
<Position>
<!--opt, object, position, desc:the upper-left corner is the origin, and the size of the full screen is 1920*1920-->
<positionX>
<!--req, int, X-coordinate-->1
</positionX>
<positionY>
<!--req, int, Y-coordinate-->1
</positionY>
<height>
<!--req, int, width-->1
</height>
<width>
<!--req, int, height-->1
</width>
</Position>
</InsidePeopleNumber>
<AvailablePeopleTitle>
<!--opt, object-->
<enabled>
<!--req, bool-->true
</enabled>
<fontSize>
<!--req, int, font size-->1
</fontSize>
<FontColor>
<!--req, object, font color-->
<RGB>
<!--opt, int, three primary colors in decimal format-->1
</RGB>
</FontColor>
<Position>
<!--opt, object, position, desc:the upper-left corner is the origin, and the size of the full screen is 1920*1920-->
<positionX>
<!--req, int, X-coordinate-->1
</positionX>
<positionY>
<!--req, int, Y-coordinate-->1
</positionY>
<height>
<!--req, int, width-->1
</height>
<width>
<!--req, int, height-->1
</width>
</Position>
<text>
<!--opt, string-->test
</text>
</AvailablePeopleTitle>
<AvailablePeopleNumber>
<!--opt, object-->
<enabled>
<!--req, bool-->true
</enabled>
<fontSize>
<!--req, int, font size-->1
</fontSize>
<Position>
<!--opt, object, position, desc:the upper-left corner is the origin, and the size of the full screen is 1920*1920-->
<positionX>
<!--req, int, X-coordinate-->1
</positionX>
<positionY>
<!--req, int, Y-coordinate-->1
</positionY>


</positionY>
<height>
<!--req, int, width-->1
</height>
<width>
<!--req, int, height-->1
</width>
</Position>
<FontColor>
<!--opt, object, font color-->
<RGB>
<!--opt, int, three primary colors in decimal format-->1
</RGB>
</FontColor>
<UnavailableFontColor>
<!--opt, object-->
<RGB>
<!--opt, int, three primary colors in decimal format-->1
</RGB>
</UnavailableFontColor>
</AvailablePeopleNumber>
<UnavailablePeopleIcon>
<!--opt, object-->
<enabled>
<!--req, bool-->true
</enabled>
<Position>
<!--opt, object, position, desc:the upper-left corner is the origin, and the size of the full screen is 1920*1920-->
<positionX>
<!--req, int, X-coordinate-->1
</positionX>
<positionY>
<!--req, int, Y-coordinate-->1
</positionY>
<height>
<!--req, int, width-->1
</height>
<width>
<!--req, int, height-->1
</width>
</Position>
<materialNo>
<!--opt, int, material ID-->1
</materialNo>
</UnavailablePeopleIcon>
<AudioAlarm>
<!--opt, object-->
<enabled>
<!--req, bool-->true
</enabled>
<materialNo>
<!--opt, int, material index No.-->1
</materialNo>
</AudioAlarm>
</PeopleCounting>
<Mask>
<!--opt, object-->
<enabled>
<!--req, bool-->true
</enabled>
<fontSize>
<!--req, int, font size-->1
</fontSize>
<FontColor>
<!--req, object, font color-->
<RGB>
<!--opt, int, three primary colors in decimal format-->1
</RGB>
</FontColor>
<BackColor>
<!--req, object, background color-->
<RGB>
<!--opt, int, three primary colors in decimal format-->1
</RGB>
</BackColor>
<Position>
<!--opt, object, position, desc:the upper-left corner is the origin, and the size of the full screen is 1920*1920-->
<positionX>
<!--req, int, X-coordinate-->1
</positionX>
<positionY>
<!--req, int, Y-coordinate-->1
</positionY>
<height>
<!--req, int, width-->1
</height>
<width>
<!--req, int, height-->1
</width>
</Position>
<text>
<!--opt, string-->test
</text>
<MaskIcon>


<MaskIcon>
<!--opt, object-->
<enabled>
<!--req, bool-->true
</enabled>
<Position>
<!--opt, object, position, desc:the upper-left corner is the origin, and the size of the full screen is 1920*1920-->
<positionX>
<!--req, int, X-coordinate-->1
</positionX>
<positionY>
<!--req, int, Y-coordinate-->1
</positionY>
<height>
<!--req, int, width-->1
</height>
<width>
<!--req, int, height-->1
</width>
</Position>
<materialNo>
<!--opt, int, material ID-->1
</materialNo>
</MaskIcon>
<AudioAlarm>
<!--opt, object-->
<enabled>
<!--req, bool-->true
</enabled>
<materialNo>
<!--opt, int, material index No.-->1
</materialNo>
</AudioAlarm>
</Mask>
<Temperature>
<!--opt, object, temperature parameters-->
<Prompt>
<!--opt, object-->
<enabled>
<!--req, bool-->true
</enabled>
<fontSize>
<!--req, int, font size-->1
</fontSize>
<FontColor>
<!--req, object, font color-->
<RGB>
<!--opt, int, three primary colors in decimal format-->1
</RGB>
</FontColor>
<BackColor>
<!--req, object, Background Color-->
<RGB>
<!--opt, int, three primary colors in decimal format-->1
</RGB>
</BackColor>
<Position>
<!--opt, object, position, desc:the upper-left corner is the origin, and the size of the full screen is 1920*1920-->
<positionX>
<!--req, int, X-coordinate-->1
</positionX>
<positionY>
<!--req, int, Y-coordinate-->1
</positionY>
<height>
<!--req, int, width-->1
</height>
<width>
<!--req, int, height-->1
</width>
</Position>
<text>
<!--opt, string-->test
</text>
</Prompt>
<TemperatureIcon>
<!--opt, object-->
<enabled>
<!--req, bool-->true
</enabled>
<Position>
<!--opt, object, position, desc:the upper-left corner is the origin, and the size of the full screen is 1920*1920-->
<positionX>
<!--req, int, X-coordinate-->1
</positionX>
<positionY>
<!--req, int, Y-coordinate-->1
</positionY>
<height>
<!--req, int, width-->1
</height>
<width>
<!--req, int, height-->1
</width>


</Position>
<materialNo>
<!--opt, int, material ID-->1
</materialNo>
</TemperatureIcon>
<AudioAlarm>
<!--opt, object-->
<enabled>
<!--req, bool-->true
</enabled>
<materialNo>
<!--opt, int, material index No.-->1
</materialNo>
</AudioAlarm>
<abnormalHighTemperature>
<!--opt, float, unit:℃-->37.5
</abnormalHighTemperature>
</Temperature>
<WearMask>
<!--opt, object-->
<enabled>
<!--req, bool-->true
</enabled>
<fontSize>
<!--req, int, font size-->1
</fontSize>
<FontColor>
<!--req, object, font color-->
<RGB>
<!--opt, int, three primary colors in decimal format-->1
</RGB>
</FontColor>
<BackColor>
<!--req, object, background color-->
<RGB>
<!--opt, int, three primary colors in decimal format-->1
</RGB>
</BackColor>
<Position>
<!--opt, object, position, desc:the upper-left corner is the origin, and the size of the full screen is 1920*1920-->
<positionX>
<!--req, int, X-coordinate-->1
</positionX>
<positionY>
<!--req, int, Y-coordinate-->1
</positionY>
<height>
<!--req, int, width-->1
</height>
<width>
<!--req, int, height-->1
</width>
</Position>
<text>
<!--opt, string-->test
</text>
<MaskIcon>
<!--opt, object-->
<enabled>
<!--req, bool-->true
</enabled>
<Position>
<!--opt, object, position, desc:the upper-left corner is the origin, and the size of the full screen is 1920*1920-->
<positionX>
<!--req, int, X-coordinate-->1
</positionX>
<positionY>
<!--req, int, Y-coordinate-->1
</positionY>
<height>
<!--req, int, width-->1
</height>
<width>
<!--req, int, height-->1
</width>
</Position>
<materialNo>
<!--opt, int, material ID-->1
</materialNo>
</MaskIcon>
</WearMask>
<NormalTemperature>
<!--opt, object-->
<Prompt>
<!--opt, object-->
<enabled>
<!--req, bool-->true
</enabled>
<fontSize>
<!--req, int, font size-->1
</fontSize>
<FontColor>
<!--req, object, font color-->
<RGB>


<RGB>
<!--opt, int, three primary colors in decimal format-->1
</RGB>
</FontColor>
<BackColor>
<!--req, object, background color-->
<RGB>
<!--opt, int, three primary colors in decimal format-->1
</RGB>
</BackColor>
<Position>
<!--opt, object, position, desc:the upper-left corner is the origin, and the size of the full screen is 1920*1920-->
<positionX>
<!--req, int, X-coordinate-->1
</positionX>
<positionY>
<!--req, int, Y-coordinate-->1
</positionY>
<height>
<!--req, int, width-->1
</height>
<width>
<!--req, int, height-->1
</width>
</Position>
<text>
<!--opt, string-->test
</text>
</Prompt>
<TemperatureIcon>
<!--opt, object-->
<enabled>
<!--req, bool-->true
</enabled>
<Position>
<!--opt, object, position, desc:the upper-left corner is the origin, and the size of the full screen is 1920*1920-->
<positionX>
<!--req, int, X-coordinate-->1
</positionX>
<positionY>
<!--req, int, Y-coordinate-->1
</positionY>
<height>
<!--req, int, width-->1
</height>
<width>
<!--req, int, height-->1
</width>
</Position>
<materialNo>
<!--opt, int, material ID-->1
</materialNo>
</TemperatureIcon>
</NormalTemperature>
<NormalStatusAudioAlarm>
<!--opt, object-->
<enabled>
<!--req, bool-->true
</enabled>
<materialNo>
<!--opt, int, material index No.-->1
</materialNo>
</NormalStatusAudioAlarm>
</EventParam>
<AlarmDataSourceProperty>
<!--opt, object-->
<PictureProperty>
<!--opt, object-->
<PictureSwitchEffect>
<!--opt, enum, subType:string-->leftInRightOut
</PictureSwitchEffect>
<PictureScaleType>
<!--opt, enum, subType:string-->fitCenter
</PictureScaleType>
</PictureProperty>
<AlarmDataSource>
<!--opt, object, data source-->
<MaterialNo>
<!--opt, int, material No.-->1
</MaterialNo>
<Name>
<!--opt, string, material name-->test
</Name>
<Address>
<!--opt, string-->test
</Address>
<WebProperty>
<!--opt, object-->
<webType>
<!--opt, enum, subType:string-->desktop
</webType>
</WebProperty>
</AlarmDataSource>
</AlarmDataSourceProperty>


<ConferenceParam>
<!--opt, object, meeting information-->
<backPicId>
<!--opt, int, control's background picture-->1
</backPicId>
<Title>
<!--opt, object-->
<enabled>
<!--req, bool-->true
</enabled>
<fontSize>
<!--req, int, font size-->1
</fontSize>
<FontColor>
<!--req, object, font color-->
<RGB>
<!--opt, int, three primary colors in decimal format-->1
</RGB>
</FontColor>
<BackColor>
<!--req, object, background color-->
<RGB>
<!--opt, int, three primary colors in decimal format-->1
</RGB>
</BackColor>
<Position>
<!--opt, object, position, desc:the upper-left corner is the origin, and the size of the full screen is 1920*1920-->
<positionX>
<!--req, int, X-coordinate-->1
</positionX>
<positionY>
<!--req, int, Y-coordinate-->1
</positionY>
<height>
<!--req, int, width-->1
</height>
<width>
<!--req, int, height-->1
</width>
</Position>
<alignType>
<!--req, enum, subType:string-->middle
</alignType>
</Title>
<VoiceBroadcast>
<!--opt, object-->
<enabled>
<!--opt, bool-->true
</enabled>
<broadcastSpeed>
<!--opt, enum, subType:string-->slower
</broadcastSpeed>
<inLibVoice>
<!--opt, string-->test
</inLibVoice>
<outLibVoice>
<!--opt, string-->test
</outLibVoice>
</VoiceBroadcast>
<WelcomeWord>
<!--opt, object, welcome words-->
<enabled>
<!--opt, bool-->true
</enabled>
<inLibWord>
<!--opt, string, range:[1,128]-->test
</inLibWord>
<outLibWord>
<!--opt, string, range:[1,128]-->test
</outLibWord>
</WelcomeWord>
<ShowInfo>
<!--opt, object-->
<row>
<!--opt, int-->1
</row>
<column>
<!--opt, int-->1
</column>
<Position>
<!--opt, object, position, desc:the upper-left corner is the origin, and the size of the full screen is 1920*1920-->
<positionX>
<!--req, int, X-coordinate-->1
</positionX>
<positionY>
<!--req, int, Y-coordinate-->1
</positionY>
<height>
<!--req, int, width-->1
</height>
<width>
<!--req, int, height-->1
</width>
</Position>


</Position>
<inLib>
<!--opt, object-->
<nameEnabled>
<!--opt, bool-->true
</nameEnabled>
</inLib>
<defaultShowInfoEnabled>
<!--opt, bool-->true
</defaultShowInfoEnabled>
</ShowInfo>
<ModuleInfoList>
<!--opt, array, subType:object-->
<ModuleInfo>
<!--opt, object-->
<moduleType>
<!--req, enum, module type, subType:string-->conferenceTime
</moduleType>
<enabled>
<!--req, bool-->true
</enabled>
<fontSize>
<!--req, int, font size-->1
</fontSize>
<FontColor>
<!--req, object, font color-->
<RGB>
<!--opt, int, three primary colors in decimal format-->1
</RGB>
</FontColor>
<BackColor>
<!--opt, object, background color-->
<RGB>
<!--opt, int, three primary colors in decimal format-->1
</RGB>
</BackColor>
<backPicId>
<!--opt, int, control's background picture, desc:control's background picture-->1
</backPicId>
<Position>
<!--opt, object, position, desc:the upper-left corner is the origin, and the size of the full screen is 1920*1920-->
<positionX>
<!--req, int, X-coordinate-->1
</positionX>
<positionY>
<!--req, int, Y-coordinate-->1
</positionY>
<height>
<!--req, int, width-->1
</height>
<width>
<!--req, int, height-->1
</width>
</Position>
<alignType>
<!--req, enum, subType:string-->middle
</alignType>
<CustomKey>
<!--opt, object-->
<key>
<!--opt, string-->test
</key>
<associateProtocolURL>
<!--opt, string-->test
</associateProtocolURL>
</CustomKey>
</ModuleInfo>
</ModuleInfoList>
<conferenceStatus>
<!--opt, enum, subType:string-->idle
</conferenceStatus>
<BackColor>
<!--opt, object, background color-->
<RGB>
<!--opt, int, three primary colors in decimal format-->1
</RGB>
</BackColor>
</ConferenceParam>
<CallBtn>
<!--opt, object-->
<backPicId>
<!--opt, int, background picture ID-->1
</backPicId>
</CallBtn>
<OpenDoorBtn>
<!--opt, object-->
<backPicId>
<!--opt, int, background picture ID-->1
</backPicId>
</OpenDoorBtn>
<QRCodeBtn>
<!--opt, object-->
<backPicId>
<!--opt, int, background picture ID-->1


<!--opt, int, background picture ID-->1
</backPicId>
</QRCodeBtn>
<AuthenticationSuccess>
<!--opt, object-->
<BackColor>
<!--opt, object, background color-->
<RGB>
<!--opt, int, three primary colors in decimal format-->1
</RGB>
</BackColor>
<backPicId>
<!--opt, int, background picture ID, desc:control's background picture-->1
</backPicId>
<SubWindowList>
<!--opt, object-->
<SubWindow>
<!--opt, object-->
<subWindowType>
<!--req, enum, subType:string-->temperature
</subWindowType>
<enabled>
<!--req, bool-->true
</enabled>
<fontSize>
<!--opt, int, font size, unit:px-->1
</fontSize>
<fontColor>
<!--opt, int, font color-->1
</fontColor>
<fontStyle>
<!--opt, string, font style-->bold,italic,underline,strikeout
</fontStyle>
<Position>
<!--opt, object, position, desc:the upper-left corner is the origin, and the size of the full screen is 1920*1920-->
<positionX>
<!--req, int, X-coordinate-->1
</positionX>
<positionY>
<!--req, int, Y-coordinate-->1
</positionY>
<height>
<!--req, int, width-->1
</height>
<width>
<!--req, int, height-->1
</width>
</Position>
</SubWindow>
</SubWindowList>
</AuthenticationSuccess>
<AuthenticationFail>
<!--opt, object-->
<BackColor>
<!--opt, object, background color-->
<RGB>
<!--opt, int, three primary colors in decimal format-->1
</RGB>
</BackColor>
<backPicId>
<!--opt, int, control's background picture, desc:control's background picture-->1
</backPicId>
<SubWindowList>
<!--opt, object-->
<SubWindow>
<!--opt, object-->
<subWindowType>
<!--req, enum, subType:string-->temperature
</subWindowType>
<enabled>
<!--req, bool-->true
</enabled>
<fontSize>
<!--opt, int, font size, unit:px-->1
</fontSize>
<fontColor>
<!--opt, int, font color-->1
</fontColor>
<fontStyle>
<!--opt, string, font style-->bold,italic,underline,strikeout
</fontStyle>
<Position>
<!--opt, object, position, desc:the upper-left corner is the origin, and the size of the full screen is 1920*1920-->
<positionX>
<!--req, int, X-coordinate-->1
</positionX>
<positionY>
<!--req, int, Y-coordinate-->1
</positionY>
<height>
<!--req, int, width-->1
</height>
<width>
<!--req, int, height-->1
</width>


</width>
</Position>
<facePicID>
<!--ro, opt, int, step:1, dep:and,
{$.PageList.Page.WindowsList[*].Windows.AuthenticationFail.SubWindowList.SubWindow.subWindowType,eq,facePic}-->1
</facePicID>
</SubWindow>
</SubWindowList>
</AuthenticationFail>
<StatusBar>
<!--opt, object-->
<backPicId>
<!--opt, int, background picture ID, desc:control's background picture-->1
</backPicId>
<statusBarType>
<!--req, enum, subType:string-->fixed
</statusBarType>
<SubStatusList>
<!--opt, object-->
<SubStatus>
<!--opt, object, sub status-->
<statusType>
<!--req, enum, sub status, subType:string-->dial
</statusType>
<enabled>
<!--req, bool-->true
</enabled>
</SubStatus>
</SubStatusList>
</StatusBar>
<ExamTemplate>
<!--opt, object-->
<examTemplateID>
<!--opt, string, template ID-->test
</examTemplateID>
<backPicURL>
<!--opt, string, range:[1,1024]-->test
</backPicURL>
<backgroundDirection>
<!--opt, enum, subType:string-->horizontal
</backgroundDirection>
<ModuleInfoList>
<!--opt, array, subType:object-->
<ModuleInfo>
<!--opt, object-->
<moduleType>
<!--opt, enum, module type, subType:string-->schoolName
</moduleType>
<enabled>
<!--opt, bool, whether to enable the function-->true
</enabled>
<Position>
<!--opt, object, position-->
<positionX>
<!--req, int, X-coordinate-->1
</positionX>
<positionY>
<!--req, int, Y-coordinate-->1
</positionY>
<height>
<!--req, int, height-->1
</height>
<width>
<!--req, int, width-->1
</width>
</Position>
<fontSize>
<!--opt, int, font size-->1
</fontSize>
<fontStyleList>
<!--opt, array, subType:object-->
<fontStyle>
<!--opt, enum, font style, subType:string-->bold
</fontStyle>
</fontStyleList>
<fontType>
<!--opt, enum, font type, subType:string-->custom
</fontType>
<FontColor>
<!--opt, object, font color-->
<RGB>
<!--opt, int-->1
</RGB>
</FontColor>
<fontTransparent>
<!--opt, int, background transparency-->1
</fontTransparent>
<alignType>
<!--opt, enum, subType:string-->middle
</alignType>
<characterSpacing>
<!--opt, int-->1
</characterSpacing>
<lineSpacing>


<lineSpacing>
<!--opt, int, row height-->1
</lineSpacing>
<layerNo>
<!--opt, int, layer No.-->1
</layerNo>
</ModuleInfo>
</ModuleInfoList>
</ExamTemplate>
</Windows>
</WindowsList>
</Page>
Response Message
<?xml version="1.0" encoding="UTF-8"?>
<ResponseStatus xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--ro, req, object, response message, attr:version{ro, req, string, protocolVersion}-->
<requestURL>
<!--ro, req, string, request URL-->null
</requestURL>
<statusCode>
<!--ro, req, enum, status code, subType:int, desc:0 (OK), 1 (OK), 2 (Device Busy), 3 (Device Error), 4 (Invalid Operation), 5 (Invalid XML Format), 6
(Invalid XML Content), 7 (Reboot Required)-->0
</statusCode>
<statusString>
<!--ro, req, enum, status description, subType:string, desc:“OK” (succeeded), “Device Busy”, “Device Error”, “Invalid Operation”, “Invalid XML Format”,
“Invalid XML Content”, “Reboot” (reboot device)-->OK
</statusString>
<subStatusCode>
<!--ro, req, string, sub status code, desc:sub status code-->OK
</subStatusCode>
</ResponseStatus>
21.37.4 Delete a page
Request URL
DELETE /ISAPI/Publish/ProgramMgr/program/<programID>/page/<pageID>
Query Parameter
Parameter Name Parameter Type Description
programID
string
pageID
string
Request Message
None
Response Message
<?xml version="1.0" encoding="UTF-8"?>
<ResponseStatus xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--ro, req, object, response message, attr:version{ro, req, string, protocolVersion}-->
<requestURL>
<!--ro, req, string, request URL-->null
</requestURL>
<statusCode>
<!--ro, req, enum, status code, subType:int, desc:0 (OK), 1 (OK), 2 (Device Busy), 3 (Device Error), 4 (Invalid Operation), 5 (Invalid XML Format), 6
(Invalid XML Content), 7 (Reboot Required)-->0
</statusCode>
<statusString>
<!--ro, req, enum, status information, subType:string, desc:"OK" (succeeded), "Device Busy", "Device Error", "Invalid Operation", "Invalid XML Format",
"Invalid XML Content", "Reboot" (reboot device)-->OK
</statusString>
<subStatusCode>
<!--ro, req, string, sub status code, which describes the error in details, desc:sub status code, which describes the error in details-->OK
</subStatusCode>
</ResponseStatus>
-
-
21.38 Schedule Management
21.38.1 Add a new program schedule


Request URL
POST /ISAPI/Publish/ScheduleMgr/playSchedule
Query Parameter
None
Request Message
<?xml version="1.0" encoding="UTF-8"?>
<PlaySchedule xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--opt, object, attr:version{req, string, protocolVersion}-->
<id>
<!--req, int, schedule No.-->1
</id>
<scheduleName>
<!--req, string, schedule name-->test
</scheduleName>
<scheduleRemarks>
<!--opt, string, schedule description-->test
</scheduleRemarks>
<approveState>
<!--opt, enum, approval status, subType:string, desc:"approved" (approved), "notPass" (not approved), "notApprove" (not reviewed)-->approved
</approveState>
<approveRemarks>
<!--opt, string, approval remarks-->test
</approveRemarks>
<scheduleMode>
<!--opt, enum, schedule mode, subType:string, desc:program schedule mode: mormal,decode and touch-->normal
</scheduleMode>
<orgNo>
<!--opt, int, organization No.-->1
</orgNo>
<scheduleType>
<!--opt, enum, schedule type, subType:string, desc:"selfDefine” (custom schedule), "daily” (daily schedule), "weekly” (weekly schedule), "loop” (loop
schedule), "defaultSchedule” (default schedule)-->selfDefine
</scheduleType>
<shareProperty>
<!--opt, enum, shared property: public,private, subType:string, desc:shared property: public,private-->public
</shareProperty>
<DailySchedule>
<!--opt, object, daily schedule-->
<PlaySpanList>
<!--req, array, subType:object-->
<PlaySpan>
<!--opt, object, playing schedule-->
<id>
<!--req, int, time period ID-->1
</id>
<programNo>
<!--req, int, program ID-->1
</programNo>
<programUUID>
<!--ro, opt, string, range:[1,32]-->test
</programUUID>
<TimeRange>
<!--req, object, program duration-->
<beginTime>
<!--req, string, start time, desc:start time (ISO 8601 format)-->test
</beginTime>
<endTime>
<!--req, string, end time, desc:end time (ISO 8601 format)-->test
</endTime>
</TimeRange>
</PlaySpan>
</PlaySpanList>
<PlaySpanSecondList>
<!--opt, array, subType:object-->
<PlaySpanSecond>
<!--opt, object-->
<id>
<!--req, int, time period ID-->1
</id>
<programNo>
<!--req, int, program ID-->1
</programNo>
<programUUID>
<!--ro, opt, string, range:[1,32]-->test
</programUUID>
<TimeRange>
<!--req, object, program duration-->
<beginTime>
<!--req, string, start time, desc:start time (ISO 8601 format)-->test
</beginTime>
<endTime>
<!--req, string, end time, desc:end time (ISO 8601 format)-->test
</endTime>
</TimeRange>
</PlaySpanSecond>
</PlaySpanSecondList>


</PlaySpanSecondList>
</DailySchedule>
<WeeklySchedule>
<!--opt, array, weekly schedule, subType:object-->
<DayList>
<!--req, object-->
<Day>
<!--opt, object-->
<id>
<!--req, int, program schedule No.-->1
</id>
<dayOfWeek>
<!--req, enum, day of a week, subType:string, desc:“monday”, “tuesday”, “wednesday”, “thursday”, “friday”, “saturday”, “sunday”-->monday
</dayOfWeek>
<PlaySpanList>
<!--req, array, subType:object-->
<PlaySpan>
<!--opt, object, playing schedule-->
<id>
<!--req, int, time period ID-->1
</id>
<programNo>
<!--req, int, program ID-->1
</programNo>
<programUUID>
<!--ro, opt, string, range:[1,32]-->test
</programUUID>
<TimeRange>
<!--req, object, program duration-->
<beginTime>
<!--req, string, start time, desc:start time (ISO 8601 format)-->test
</beginTime>
<endTime>
<!--req, string, end time, desc:end time (ISO 8601 format)-->test
</endTime>
</TimeRange>
</PlaySpan>
</PlaySpanList>
<PlaySpanSecondList>
<!--opt, array, subType:object-->
<PlaySpanSecond>
<!--opt, object-->
<id>
<!--req, int, time period ID-->1
</id>
<programNo>
<!--req, int, program ID-->1
</programNo>
<programUUID>
<!--ro, opt, string, range:[1,32]-->test
</programUUID>
<TimeRange>
<!--req, object, program duration-->
<beginTime>
<!--req, string, start time, desc:start time (ISO 8601 format)-->test
</beginTime>
<endTime>
<!--req, string, end time, desc:end time (ISO 8601 format)-->test
</endTime>
</TimeRange>
</PlaySpanSecond>
</PlaySpanSecondList>
</Day>
</DayList>
</WeeklySchedule>
<LoopSchedule>
<!--opt, object, loop schedule-->
<ProgramList>
<!--opt, object-->
<program>
<!--opt, object-->
<id>
<!--req, int-->08
</id>
<programNo>
<!--req, int-->1
</programNo>
<programUUID>
<!--ro, opt, string, range:[1,32]-->test
</programUUID>
</program>
</ProgramList>
<ProgramNoList>
<!--req, array, list of programs for loop schedule, subType:object, desc:list of loop programs,normal mode-->
<programNo>
<!--opt, int, program ID-->1
</programNo>
</ProgramNoList>
<ProgramNoSecondList>
<!--req, array, subType:object-->
<programNoSecond>
<!--opt, int, program ID-->1
</programNoSecond>
</ProgramNoSecondList>


</ProgramNoSecondList>
<ProgramSecondList>
<!--opt, object-->
<program>
<!--opt, object-->
<id>
<!--req, int-->08
</id>
<programNo>
<!--req, int-->1
</programNo>
<programUUID>
<!--ro, opt, string, range:[1,32]-->test
</programUUID>
</program>
</ProgramSecondList>
<LoopTimeSpanList>
<!--opt, array, subType:object-->
<LoopTimeSpan>
<!--opt, object-->
<TimeRange>
<!--req, object, program duration-->
<beginTime>
<!--req, string, start time, desc:start time (ISO 8601 format)-->test
</beginTime>
<endTime>
<!--req, string, end time, desc:end time (ISO 8601 format)-->test
</endTime>
</TimeRange>
<ProgramNoList>
<!--req, array, program ID list, subType:object-->
<programNo>
<!--opt, int, program ID-->1
</programNo>
</ProgramNoList>
<ProgramList>
<!--opt, object-->
<program>
<!--opt, object-->
<id>
<!--req, int-->08
</id>
<programNo>
<!--req, int-->1
</programNo>
<programUUID>
<!--ro, opt, string, range:[1,32]-->test
</programUUID>
</program>
</ProgramList>
</LoopTimeSpan>
</LoopTimeSpanList>
<LoopTimeSpanSecondList>
<!--opt, array, subType:object-->
<LoopTimeSpanSecond>
<!--opt, object-->
<TimeRange>
<!--req, object, program duration-->
<beginTime>
<!--req, string, start time, desc:start time (ISO 8601 format)-->test
</beginTime>
<endTime>
<!--req, string, end time, desc:end time (ISO 8601 format)-->test
</endTime>
</TimeRange>
<ProgramNoSecondList>
<!--req, array, program ID list, subType:object-->
<programNoSecond>
<!--opt, int, program ID-->1
</programNoSecond>
</ProgramNoSecondList>
<ProgramSecondList>
<!--opt, object-->
<program>
<!--opt, object-->
<id>
<!--req, int-->08
</id>
<programNo>
<!--req, int-->1
</programNo>
<programUUID>
<!--ro, opt, string, range:[1,32]-->test
</programUUID>
</program>
</ProgramSecondList>
</LoopTimeSpanSecond>
</LoopTimeSpanSecondList>
</LoopSchedule>
<SelfDefineSchedule>
<!--opt, object-->
<SelfDefineList>
<!--req, array, subType:object-->
<SelfDefine>


<!--opt, object, custom period-->
<id>
<!--req, int, time period ID-->1
</id>
<programNo>
<!--req, int, program ID-->1
</programNo>
<programUUID>
<!--ro, opt, string, range:[1,32]-->test
</programUUID>
<TimeRange>
<!--req, object, program duration-->
<beginTime>
<!--req, string, start time, desc:start time (ISO 8601 format)-->test
</beginTime>
<endTime>
<!--req, string, end time, desc:end time (ISO 8601 format)-->test
</endTime>
</TimeRange>
</SelfDefine>
</SelfDefineList>
<SelfDefineSecondList>
<!--opt, array, subType:object-->
<SelfDefineSecond>
<!--opt, object-->
<id>
<!--req, int, time period ID-->1
</id>
<programNoSecond>
<!--req, int, program ID-->1
</programNoSecond>
<programUUIDSecond>
<!--ro, opt, string, range:[1,32]-->test
</programUUIDSecond>
<TimeRange>
<!--req, object, program duration-->
<beginTime>
<!--req, string, start time, desc:start time (ISO 8601 format)-->test
</beginTime>
<endTime>
<!--req, string, end time, desc:end time (ISO 8601 format)-->test
</endTime>
</TimeRange>
</SelfDefineSecond>
</SelfDefineSecondList>
</SelfDefineSchedule>
<DefaultSchedule>
<!--opt, object, default program schedule-->
<programNo>
<!--req, int, default program-->1
</programNo>
<programUUID>
<!--ro, opt, string, range:[1,32]-->test
</programUUID>
<programNoSecond>
<!--opt, int-->1
</programNoSecond>
<programUUIDSecond>
<!--ro, opt, string, range:[1,32]-->test
</programUUIDSecond>
</DefaultSchedule>
<HolidaySchedule>
<!--opt, object, holiday schedule, desc:holiday schedule-->
<PlaySpanList>
<!--req, array, subType:object-->
<PlaySpan>
<!--opt, object, Playing Schedule-->
<id>
<!--req, int, time period No.-->1
</id>
<programNo>
<!--req, int, program ID-->1
</programNo>
<programUUID>
<!--ro, opt, string, range:[1,32]-->test
</programUUID>
<TimeRange>
<!--req, object, program duration-->
<beginTime>
<!--req, string, start time, desc:start time (ISO 8601 format)-->test
</beginTime>
<endTime>
<!--req, string, end time, desc:end time (ISO 8601 format)-->test
</endTime>
</TimeRange>
</PlaySpan>
</PlaySpanList>
</HolidaySchedule>
<scheduleUUID>
<!--ro, opt, string, range:[1,32]-->test
</scheduleUUID>
<EmergencySchedule>
<!--opt, object-->
<ProgramNoList>


<ProgramNoList>
<!--req, array, subType:object-->
<programNo>
<!--opt, int-->1
</programNo>
<programUUID>
<!--ro, opt, string, range:[1,32]-->test
</programUUID>
</ProgramNoList>
<ProgramNoSecondList>
<!--req, array, subType:object-->
<programNoSecond>
<!--opt, int-->1
</programNoSecond>
<programUUID>
<!--ro, opt, string, range:[1,32]-->test
</programUUID>
</ProgramNoSecondList>
</EmergencySchedule>
</PlaySchedule>
Response Message
<?xml version="1.0" encoding="UTF-8"?>
<ResponseStatus xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--ro, req, object, response message, attr:version{ro, req, string, protocolVersion}-->
<requestURL>
<!--ro, req, string, request URL-->null
</requestURL>
<statusCode>
<!--ro, req, enum, status code, subType:int, desc:read-only,status code: 0,1-OK,2-Device Busy,3-Device Error,4-Invalid Operation,5-Invalid XML Format,6Invalid
XML Content,7-Reboot Required,9-Additional Error-->0
</statusCode>
<statusString>
<!--ro, req, enum, status description, subType:string, desc:read-only,status description: OK,Device Busy,Device Error,Invalid Operation,Invalid XML
Format,Invalid XML Content,Reboot,Additional Error-->OK
</statusString>
<subStatusCode>
<!--ro, req, string, read-only,describe the error reason in detail, desc:read-only,describe the error reason in detail-->OK
</subStatusCode>
<ID>
<!--ro, opt, string-->test
</ID>
</ResponseStatus>
21.38.2 Get a specific program schedule
Request URL
GET /ISAPI/Publish/ScheduleMgr/playSchedule/<scheduleID>
Query Parameter
Parameter Name Parameter Type Description
scheduleID
string
Request Message
None
Response Message
<?xml version="1.0" encoding="UTF-8"?>
<PlaySchedule xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--ro, opt, object, attr:version{req, string, protocolVersion}-->
<id>
<!--ro, req, int, schedule No.-->1
</id>
<scheduleName>
<!--ro, req, string, schedule name-->test
</scheduleName>
<scheduleRemarks>
<!--ro, opt, string, schedule description-->test
</scheduleRemarks>
<approveState>
<!--ro, opt, enum, approval status, subType:string, desc:"approved" (pass), "notPass" (deny), "notApprove" (not approved)-->approved
</approveState>
<approveRemarks>
<!--ro, opt, string, approval remarks-->test
</approveRemarks>
<scheduleMode>
<!--ro, opt, enum, schedule mode, subType:string, desc:program schedule mode: mormal,decode and touch-->normal
-


<!--ro, opt, enum, schedule mode, subType:string, desc:program schedule mode: mormal,decode and touch-->normal
</scheduleMode>
<orgNo>
<!--ro, opt, int, organization No.-->1
</orgNo>
<scheduleType>
<!--ro, opt, enum, schedule type, subType:string, desc:"daily"-daily schedule,"weekly"-weekly schedule,"selfDefine"-custom schedule,"loop"-loop
schedule,"defaultSchedule"-default schedule-->selfDefine
</scheduleType>
<shareProperty>
<!--ro, opt, enum, sharing property, subType:string, desc:"public", "private"-->public
</shareProperty>
<DailySchedule>
<!--ro, opt, object, daily schedule-->
<PlaySpanList>
<!--ro, req, array, subType:object-->
<PlaySpan>
<!--ro, opt, object-->
<id>
<!--ro, req, int, time period No.-->1
</id>
<programNo>
<!--ro, req, int, No. of the shown program-->1
</programNo>
<programUUID>
<!--ro, opt, string, range:[1,32]-->test
</programUUID>
<TimeRange>
<!--ro, req, object, start and end time of the time period-->
<beginTime>
<!--ro, req, string, start time, desc:start time (ISO 8601 format)-->test
</beginTime>
<endTime>
<!--ro, req, string, end time, desc:end time (ISO 8601 format)-->test
</endTime>
</TimeRange>
</PlaySpan>
</PlaySpanList>
<PlaySpanSecondList>
<!--ro, opt, array, subType:object-->
<PlaySpanSecond>
<!--ro, opt, object-->
<id>
<!--ro, req, int, time period No.-->1
</id>
<programNo>
<!--ro, req, int, No. of the shown program-->1
</programNo>
<programUUID>
<!--ro, opt, string, range:[1,32]-->test
</programUUID>
<TimeRange>
<!--ro, req, object, start and end time of the time period-->
<beginTime>
<!--ro, req, string, start time, desc:start time (ISO 8601 format)-->test
</beginTime>
<endTime>
<!--ro, req, string, end time, desc:end time (ISO 8601 format)-->test
</endTime>
</TimeRange>
</PlaySpanSecond>
</PlaySpanSecondList>
</DailySchedule>
<WeeklySchedule>
<!--ro, opt, array, weekly schedule, subType:object-->
<DayList>
<!--ro, req, object-->
<Day>
<!--ro, opt, object, daily information-->
<id>
<!--ro, req, int, day No.-->1
</id>
<dayOfWeek>
<!--ro, req, enum, week, subType:string, desc:“monday”, “tuesday”, “wednesday”, “thursday”, “friday”, “saturday”, “sunday”-->monday
</dayOfWeek>
<PlaySpanList>
<!--ro, req, array, subType:object-->
<PlaySpan>
<!--ro, opt, object-->
<id>
<!--ro, req, int, time period No.-->1
</id>
<programNo>
<!--ro, req, int, No. of the shown program-->1
</programNo>
<programUUID>
<!--ro, opt, string, program UUID, range:[1,32]-->test
</programUUID>
<TimeRange>
<!--ro, req, object, start and end time of the time period-->
<beginTime>
<!--ro, req, string, start time, desc:start time (ISO 8601 format)-->test
</beginTime>
<endTime>


<endTime>
<!--ro, req, string, end time, desc:end time (ISO 8601 format)-->test
</endTime>
</TimeRange>
</PlaySpan>
</PlaySpanList>
<PlaySpanSecondList>
<!--ro, opt, array, subType:object-->
<PlaySpanSecond>
<!--ro, opt, object-->
<id>
<!--ro, req, int, time period No.-->1
</id>
<programNo>
<!--ro, req, int, No. of the shown program-->1
</programNo>
<programUUID>
<!--ro, opt, string, program UUID, range:[1,32]-->test
</programUUID>
<TimeRange>
<!--ro, req, object, start and end time of the time period-->
<beginTime>
<!--ro, req, string, start time, desc:start time (ISO 8601 format)-->test
</beginTime>
<endTime>
<!--ro, req, string, end time, desc:end time (ISO 8601 format)-->test
</endTime>
</TimeRange>
</PlaySpanSecond>
</PlaySpanSecondList>
</Day>
</DayList>
</WeeklySchedule>
<LoopSchedule>
<!--ro, opt, object, loop schedule-->
<ProgramNoList>
<!--ro, req, array, list of loop programs, subType:object, desc:normal mode-->
<programNo>
<!--ro, opt, int, program No.-->1
</programNo>
<programUUID>
<!--ro, opt, string, program UUID, range:[1,32]-->test
</programUUID>
</ProgramNoList>
<ProgramNoSecondList>
<!--ro, req, array, subType:object-->
<programNoSecond>
<!--ro, opt, int-->1
</programNoSecond>
</ProgramNoSecondList>
<LoopTimeSpanList>
<!--ro, opt, array, subType:object-->
<LoopTimeSpan>
<!--ro, opt, object-->
<TimeRange>
<!--ro, req, object, start and end time of the time period-->
<beginTime>
<!--ro, req, string, start time, desc:start time (ISO 8601 format)-->test
</beginTime>
<endTime>
<!--ro, req, string, end time, desc:end time (ISO 8601 format)-->test
</endTime>
</TimeRange>
<ProgramNoList>
<!--ro, req, array, program No. list, subType:object-->
<programNo>
<!--ro, opt, int, program No.-->1
</programNo>
<programUUID>
<!--ro, opt, string, program UUID, range:[1,32]-->test
</programUUID>
</ProgramNoList>
</LoopTimeSpan>
</LoopTimeSpanList>
<LoopTimeSpanSecondList>
<!--ro, opt, array, subType:object-->
<LoopTimeSpanSecond>
<!--ro, opt, object-->
<TimeRange>
<!--ro, req, object, start and end time of the time period-->
<beginTime>
<!--ro, req, string, start time, desc:start time (ISO 8601 format)-->test
</beginTime>
<endTime>
<!--ro, req, string, end time, desc:end time (ISO 8601 format)-->test
</endTime>
</TimeRange>
<ProgramNoSecondList>
<!--ro, req, array, program No. list, subType:object-->
<programNoSecond>
<!--ro, opt, int, program No.-->1
</programNoSecond>
</ProgramNoSecondList>
</LoopTimeSpanSecond>


</LoopTimeSpanSecondList>
</LoopSchedule>
<SelfDefineSchedule>
<!--ro, opt, object-->
<SelfDefineList>
<!--ro, req, array, subType:object-->
<SelfDefine>
<!--ro, opt, object, custom schedule-->
<id>
<!--ro, req, int, custom time period No.-->1
</id>
<programNo>
<!--ro, req, int, program No.-->1
</programNo>
<programUUID>
<!--ro, opt, string, program UUID, range:[1,32]-->test
</programUUID>
<TimeRange>
<!--ro, req, object, start and end time of the time period-->
<beginTime>
<!--ro, req, string, start time, desc:start time (ISO 8601 format)-->test
</beginTime>
<endTime>
<!--ro, req, string, end time, desc:end time (ISO 8601 format)-->test
</endTime>
</TimeRange>
</SelfDefine>
</SelfDefineList>
<SelfDefineSecondList>
<!--ro, opt, array, subType:object-->
<SelfDefineSecond>
<!--ro, opt, object-->
<id>
<!--ro, req, int, custom time period No.-->1
</id>
<programNoSecond>
<!--ro, req, int, program No.-->1
</programNoSecond>
<TimeRange>
<!--ro, req, object, start and end time of the time period-->
<beginTime>
<!--ro, req, string, start time, desc:start time (ISO 8601 format)-->test
</beginTime>
<endTime>
<!--ro, req, string, end time, desc:end time (ISO 8601 format)-->test
</endTime>
</TimeRange>
</SelfDefineSecond>
</SelfDefineSecondList>
</SelfDefineSchedule>
<DefaultSchedule>
<!--ro, opt, object, default schedule-->
<programNo>
<!--ro, req, int, No. of the shown program-->1
</programNo>
<programUUID>
<!--ro, opt, string, program UUID, range:[1,32]-->test
</programUUID>
<programNoSecond>
<!--ro, opt, int-->1
</programNoSecond>
</DefaultSchedule>
<HolidaySchedule>
<!--ro, opt, object, holiday schedule information, desc:holiday schedule-->
<PlaySpanList>
<!--ro, req, array, subType:object-->
<PlaySpan>
<!--ro, opt, object-->
<id>
<!--ro, req, int, time period No.-->1
</id>
<programNo>
<!--ro, req, int, program ID-->1
</programNo>
<programUUID>
<!--ro, opt, string, program UUID, range:[1,32]-->test
</programUUID>
<TimeRange>
<!--ro, req, object, start and end time of the time period-->
<beginTime>
<!--ro, req, string, start time, desc:start time (ISO 8601 format)-->test
</beginTime>
<endTime>
<!--ro, req, string, end time, desc:end time (ISO 8601 format)-->test
</endTime>
</TimeRange>
</PlaySpan>
</PlaySpanList>
</HolidaySchedule>
<scheduleUUID>
<!--ro, opt, string, schedule UUID, range:[1,32]-->test
</scheduleUUID>
<EmergencySchedule>
<!--ro, opt, object-->


<!--ro, opt, object-->
<ProgramNoList>
<!--ro, req, array, subType:object-->
<programNo>
<!--ro, opt, int-->1
</programNo>
<programUUID>
<!--ro, opt, string, range:[1,32]-->test
</programUUID>
</ProgramNoList>
<ProgramNoSecondList>
<!--ro, req, array, subType:object-->
<programNoSecond>
<!--ro, opt, int-->1
</programNoSecond>
<programUUID>
<!--ro, opt, string, range:[1,32]-->test
</programUUID>
</ProgramNoSecondList>
</EmergencySchedule>
</PlaySchedule>
21.38.3 Get the parameters of all program schedules
Request URL
GET /ISAPI/Publish/ScheduleMgr/playSchedule
Query Parameter
None
Request Message
None
Response Message
<?xml version="1.0" encoding="UTF-8"?>
<PlayScheduleList xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--ro, opt, array, list of program schedules, subType:object, attr:version{req, string, protocolVersion}-->
<PlaySchedule>
<!--ro, opt, object-->
<id>
<!--ro, req, int-->1
</id>
<scheduleName>
<!--ro, req, string, schedule name-->test
</scheduleName>
<scheduleRemarks>
<!--ro, opt, string, schedule description-->test
</scheduleRemarks>
<approveState>
<!--ro, opt, enum, approval status, subType:string, desc:"approved" (pass), "notPass" (deny), "notApprove" (not approved)-->approved
</approveState>
<approveRemarks>
<!--ro, opt, string, approval remarks-->test
</approveRemarks>
<scheduleMode>
<!--ro, opt, enum, schedule mode, subType:string-->normal
</scheduleMode>
<orgNo>
<!--ro, opt, int, organization No.-->1
</orgNo>
<scheduleType>
<!--ro, opt, enum, schedule type, subType:string, desc:"selfDefine"-custom schedule, "daily"-daily schedule, "weekly"-weekly schedule, "loop"-loop
schedule, "defaultSchedule"-default schedule-->selfDefine
</scheduleType>
<shareProperty>
<!--ro, opt, enum, shared property, subType:string-->public
</shareProperty>
<DailySchedule>
<!--ro, opt, object, daily schedule-->
<PlaySpanList>
<!--ro, req, array, subType:object-->
<PlaySpan>
<!--ro, opt, object-->
<id>
<!--ro, req, int, time period ID-->1
</id>
<programNo>
<!--ro, req, int, program ID-->1
</programNo>
<TimeRange>
<!--ro, req, object, program duration-->
<beginTime>
<!--ro, req, string, start time-->test
</beginTime>


<endTime>
<!--ro, req, string, end time-->test
</endTime>
</TimeRange>
</PlaySpan>
</PlaySpanList>
<PlaySpanSecondList>
<!--ro, opt, array, subType:object-->
<PlaySpanSecond>
<!--ro, opt, object-->
<id>
<!--ro, req, int, time period ID-->1
</id>
<programNo>
<!--ro, req, int, program ID-->1
</programNo>
<TimeRange>
<!--ro, req, object, program duration-->
<beginTime>
<!--ro, req, string, start time-->test
</beginTime>
<endTime>
<!--ro, req, string, end time-->test
</endTime>
</TimeRange>
</PlaySpanSecond>
</PlaySpanSecondList>
</DailySchedule>
<WeeklySchedule>
<!--ro, opt, array, subType:object-->
<DayList>
<!--ro, req, object-->
<Day>
<!--ro, opt, object, daily information-->
<id>
<!--ro, req, int-->1
</id>
<dayOfWeek>
<!--ro, req, enum, day of the week, subType:string, desc:“monday”, “tuesday”, “wednesday”, “thursday”, “friday”, “saturday”, “sunday”-->monday
</dayOfWeek>
<PlaySpanList>
<!--ro, req, array, subType:object-->
<PlaySpan>
<!--ro, opt, object, playing schedule-->
<id>
<!--ro, req, int, time period ID-->1
</id>
<programNo>
<!--ro, req, int, program ID-->1
</programNo>
<TimeRange>
<!--ro, req, object, program duration-->
<beginTime>
<!--ro, req, string, start time-->test
</beginTime>
<endTime>
<!--ro, req, string, end time-->test
</endTime>
</TimeRange>
</PlaySpan>
</PlaySpanList>
<PlaySpanSecondList>
<!--ro, opt, array, subType:object-->
<PlaySpanSecond>
<!--ro, opt, object-->
<id>
<!--ro, req, int, time period ID-->1
</id>
<programNo>
<!--ro, req, int, program ID-->1
</programNo>
<TimeRange>
<!--ro, req, object, program duration-->
<beginTime>
<!--ro, req, string, start time-->test
</beginTime>
<endTime>
<!--ro, req, string, end time-->test
</endTime>
</TimeRange>
</PlaySpanSecond>
</PlaySpanSecondList>
</Day>
</DayList>
</WeeklySchedule>
<LoopSchedule>
<!--ro, opt, object-->
<ProgramNoList>
<!--ro, req, array, list of programs for loop schedule, subType:object-->
<programNo>
<!--ro, opt, int, program ID-->1
</programNo>
</ProgramNoList>
<ProgramNoSecondList>


<ProgramNoSecondList>
<!--ro, req, array, subType:object-->
<programNoSecond>
<!--ro, opt, int, program ID-->1
</programNoSecond>
</ProgramNoSecondList>
<LoopTimeSpanList>
<!--ro, opt, array, subType:object-->
<LoopTimeSpan>
<!--ro, opt, object-->
<TimeRange>
<!--ro, req, object, program duration-->
<beginTime>
<!--ro, req, string, start time-->test
</beginTime>
<endTime>
<!--ro, req, string, end time-->test
</endTime>
</TimeRange>
<ProgramNoList>
<!--ro, req, array, program ID list, subType:object-->
<programNo>
<!--ro, opt, int, program ID-->1
</programNo>
</ProgramNoList>
</LoopTimeSpan>
</LoopTimeSpanList>
<LoopTimeSpanSecondList>
<!--ro, opt, array, subType:object-->
<LoopTimeSpanSecond>
<!--ro, opt, object-->
<TimeRange>
<!--ro, req, object, program duration-->
<beginTime>
<!--ro, req, string, start time-->test
</beginTime>
<endTime>
<!--ro, req, string, end time-->test
</endTime>
</TimeRange>
<ProgramNoSecondList>
<!--ro, req, array, program ID list, subType:object-->
<programNoSecond>
<!--ro, opt, int, program ID-->1
</programNoSecond>
</ProgramNoSecondList>
</LoopTimeSpanSecond>
</LoopTimeSpanSecondList>
</LoopSchedule>
<SelfDefineSchedule>
<!--ro, opt, object-->
<SelfDefineList>
<!--ro, req, array, subType:object-->
<SelfDefine>
<!--ro, opt, object-->
<id>
<!--ro, req, int, time period ID-->1
</id>
<programNo>
<!--ro, req, int, program ID-->1
</programNo>
<TimeRange>
<!--ro, req, object, program duration-->
<beginTime>
<!--ro, req, string, start time-->test
</beginTime>
<endTime>
<!--ro, req, string, end time-->test
</endTime>
</TimeRange>
</SelfDefine>
</SelfDefineList>
<SelfDefineSecondList>
<!--ro, opt, array, subType:object-->
<SelfDefineSecond>
<!--ro, opt, object-->
<id>
<!--ro, req, int, time period ID-->1
</id>
<programNoSecond>
<!--ro, req, int, program ID-->1
</programNoSecond>
<TimeRange>
<!--ro, req, object, program duration-->
<beginTime>
<!--ro, req, string, start time-->test
</beginTime>
<endTime>
<!--ro, req, string, end time-->test
</endTime>
</TimeRange>
</SelfDefineSecond>
</SelfDefineSecondList>
</SelfDefineSchedule>


</SelfDefineSchedule>
<DefaultSchedule>
<!--ro, opt, object, default program schedule-->
<programNo>
<!--ro, req, int, default program-->1
</programNo>
<programNoSecond>
<!--ro, opt, int-->1
</programNoSecond>
</DefaultSchedule>
<HolidaySchedule>
<!--ro, opt, object-->
<PlaySpanList>
<!--ro, req, array, subType:object-->
<PlaySpan>
<!--ro, opt, object-->
<id>
<!--ro, req, int, time period No.-->1
</id>
<programNo>
<!--ro, req, int, program ID-->1
</programNo>
<TimeRange>
<!--ro, req, object, program duration-->
<beginTime>
<!--ro, req, string, start time-->test
</beginTime>
<endTime>
<!--ro, req, string, end time-->test
</endTime>
</TimeRange>
</PlaySpan>
</PlaySpanList>
</HolidaySchedule>
<scheduleUUID>
<!--ro, opt, string, range:[1,32]-->test
</scheduleUUID>
<EmergencySchedule>
<!--ro, opt, object-->
<ProgramNoList>
<!--ro, req, array, subType:object-->
<programNo>
<!--ro, opt, int-->1
</programNo>
<programUUID>
<!--ro, opt, string, range:[1,32]-->test
</programUUID>
</ProgramNoList>
<ProgramNoSecondList>
<!--ro, req, array, subType:object-->
<programNoSecond>
<!--ro, opt, int-->1
</programNoSecond>
<programUUID>
<!--ro, opt, string, range:[1,32]-->test
</programUUID>
</ProgramNoSecondList>
</EmergencySchedule>
</PlaySchedule>
</PlayScheduleList>
21.38.4 Set a specific program schedule
Request URL
PUT /ISAPI/Publish/ScheduleMgr/playSchedule/<scheduleID>
Query Parameter
Parameter Name Parameter Type Description
scheduleID
string
Request Message
<?xml version="1.0" encoding="UTF-8"?>
<PlaySchedule xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--opt, object, attr:version{req, string, protocolVersion}-->
<id>
<!--req, int, program schedule No.-->1
</id>
<scheduleName>
<!--req, string, program schedule name-->test
</scheduleName>
<scheduleRemarks>
<!--opt, string, schedule description-->test
</scheduleRemarks>
-


</scheduleRemarks>
<approveState>
<!--opt, enum, approval status, subType:string, desc:"approved" (pass), "notPass" (deny), "notApprove" (not approved)-->approved
</approveState>
<approveRemarks>
<!--opt, string, approval remarks-->test
</approveRemarks>
<scheduleMode>
<!--opt, enum, schedule mode, subType:string, desc:program schedule mode: mormal,decode and touch-->normal
</scheduleMode>
<orgNo>
<!--opt, int, organization No.-->1
</orgNo>
<scheduleType>
<!--opt, enum, program schedule type, subType:string, desc:"selfDefine"-custom schedule, "daily"-daily schedule, "weekly"-weekly schedule, "loop"-loop
schedule, "defaultSchedule"-default schedule-->selfDefine
</scheduleType>
<shareProperty>
<!--opt, enum, sharing property, subType:string, desc:shared property: public,private-->public
</shareProperty>
<DailySchedule>
<!--opt, object, daily schedule-->
<PlaySpanList>
<!--req, array, subType:object-->
<PlaySpan>
<!--opt, object, Playing Schedule-->
<id>
<!--req, int, program schedule No.-->1
</id>
<programNo>
<!--req, int, No. of the shown program-->1
</programNo>
<TimeRange>
<!--req, object, play duration-->
<beginTime>
<!--req, string, start time, desc:start time (ISO 8601 format)-->test
</beginTime>
<endTime>
<!--req, string, end time, desc:end time (ISO 8601 format)-->test
</endTime>
</TimeRange>
</PlaySpan>
</PlaySpanList>
<PlaySpanSecondList>
<!--opt, array, subType:object-->
<PlaySpanSecond>
<!--opt, object-->
<id>
<!--req, int, program schedule No.-->1
</id>
<programNo>
<!--req, int, No. of the shown program-->1
</programNo>
<TimeRange>
<!--req, object, play duration-->
<beginTime>
<!--req, string, start time, desc:start time (ISO 8601 format)-->test
</beginTime>
<endTime>
<!--req, string, end time, desc:end time (ISO 8601 format)-->test
</endTime>
</TimeRange>
</PlaySpanSecond>
</PlaySpanSecondList>
</DailySchedule>
<WeeklySchedule>
<!--opt, array, weekly schedule, subType:object-->
<DayList>
<!--req, object-->
<Day>
<!--opt, object, daily information-->
<id>
<!--req, int, program schedule No.-->1
</id>
<dayOfWeek>
<!--req, enum, day of the week, subType:string, desc:“monday”, “tuesday”, “wednesday”, “thursday”, “friday”, “saturday”, “sunday”-->monday
</dayOfWeek>
<PlaySpanList>
<!--req, array, subType:object-->
<PlaySpan>
<!--opt, object, Playing Schedule-->
<id>
<!--req, int, program schedule No.-->1
</id>
<programNo>
<!--req, int, No. of the shown program-->1
</programNo>
<TimeRange>
<!--req, object, play duration-->
<beginTime>
<!--req, string, start time, desc:start time (ISO 8601 format)-->test
</beginTime>
<endTime>
<!--req, string, end time, desc:end time (ISO 8601 format)-->test
</endTime>


</endTime>
</TimeRange>
</PlaySpan>
</PlaySpanList>
<PlaySpanSecondList>
<!--opt, array, subType:object-->
<PlaySpanSecond>
<!--opt, object-->
<id>
<!--req, int, program schedule No.-->1
</id>
<programNo>
<!--req, int, No. of the shown program-->1
</programNo>
<TimeRange>
<!--req, object, play duration-->
<beginTime>
<!--req, string, start time, desc:start time (ISO 8601 format)-->test
</beginTime>
<endTime>
<!--req, string, end time, desc:end time (ISO 8601 format)-->test
</endTime>
</TimeRange>
</PlaySpanSecond>
</PlaySpanSecondList>
</Day>
</DayList>
</WeeklySchedule>
<LoopSchedule>
<!--opt, object, loop schedule-->
<ProgramNoList>
<!--req, array, list of loop programs,normal mode, subType:object, desc:list of loop programs,normal mode-->
<programNo>
<!--opt, int, program No.-->1
</programNo>
</ProgramNoList>
<ProgramNoSecondList>
<!--req, array, subType:object-->
<programNoSecond>
<!--opt, int, program No.-->1
</programNoSecond>
</ProgramNoSecondList>
<LoopTimeSpanList>
<!--opt, array, subType:object-->
<LoopTimeSpan>
<!--opt, object-->
<TimeRange>
<!--req, object, play duration-->
<beginTime>
<!--req, string, start time, desc:start time (ISO 8601 format)-->test
</beginTime>
<endTime>
<!--req, string, end time, desc:end time (ISO 8601 format)-->test
</endTime>
</TimeRange>
<ProgramNoList>
<!--req, array, list of loop programs, subType:object-->
<programNo>
<!--opt, int, program No.-->1
</programNo>
</ProgramNoList>
</LoopTimeSpan>
</LoopTimeSpanList>
<LoopTimeSpanSecondList>
<!--opt, array, subType:object-->
<LoopTimeSpanSecond>
<!--opt, object-->
<TimeRange>
<!--req, object, play duration-->
<beginTime>
<!--req, string, start time, desc:start time (ISO 8601 format)-->test
</beginTime>
<endTime>
<!--req, string, end time, desc:end time (ISO 8601 format)-->test
</endTime>
</TimeRange>
<ProgramNoSecondList>
<!--req, array, subType:object-->
<programNoSecond>
<!--opt, int, program No.-->1
</programNoSecond>
</ProgramNoSecondList>
</LoopTimeSpanSecond>
</LoopTimeSpanSecondList>
</LoopSchedule>
<SelfDefineSchedule>
<!--opt, object-->
<SelfDefineList>
<!--req, array, subType:object-->
<SelfDefine>
<!--opt, object, custom schedule-->
<id>
<!--req, int, program schedule No.-->1
</id>


</id>
<programNo>
<!--req, int, program No.-->1
</programNo>
<TimeRange>
<!--req, object, play duration-->
<beginTime>
<!--req, string, start time, desc:start time (ISO 8601 format)-->test
</beginTime>
<endTime>
<!--req, string, end time, desc:end time (ISO 8601 format)-->test
</endTime>
</TimeRange>
</SelfDefine>
</SelfDefineList>
<SelfDefineSecondList>
<!--opt, array, subType:object-->
<SelfDefineSecond>
<!--opt, object-->
<id>
<!--req, int, program schedule No.-->1
</id>
<programNoSecond>
<!--req, int, program No.-->1
</programNoSecond>
<TimeRange>
<!--req, object, play duration-->
<beginTime>
<!--req, string, start time, desc:start time (ISO 8601 format)-->test
</beginTime>
<endTime>
<!--req, string, end time, desc:end time (ISO 8601 format)-->test
</endTime>
</TimeRange>
</SelfDefineSecond>
</SelfDefineSecondList>
</SelfDefineSchedule>
<DefaultSchedule>
<!--opt, object, default program schedule-->
<programNo>
<!--req, int, No. of the shown program-->1
</programNo>
<programNoSecond>
<!--opt, int-->1
</programNoSecond>
</DefaultSchedule>
<HolidaySchedule>
<!--opt, object, holiday schedule, desc:holiday schedule-->
<PlaySpanList>
<!--req, array, subType:object-->
<PlaySpan>
<!--opt, object, Playing Schedule-->
<id>
<!--req, int, program schedule No.-->1
</id>
<programNo>
<!--req, int, program ID-->1
</programNo>
<TimeRange>
<!--req, object, play duration-->
<beginTime>
<!--req, string, start time, desc:start time (ISO 8601 format)-->test
</beginTime>
<endTime>
<!--req, string, end time, desc:end time (ISO 8601 format)-->test
</endTime>
</TimeRange>
</PlaySpan>
</PlaySpanList>
</HolidaySchedule>
<scheduleUUID>
<!--opt, string, range:[1,32]-->test
</scheduleUUID>
<EmergencySchedule>
<!--opt, object-->
<ProgramNoList>
<!--req, array, subType:object-->
<programNo>
<!--opt, int-->1
</programNo>
<programUUID>
<!--ro, opt, string, range:[1,32]-->test
</programUUID>
</ProgramNoList>
<ProgramNoSecondList>
<!--req, array, subType:object-->
<programNoSecond>
<!--opt, int-->1
</programNoSecond>
<programUUID>
<!--ro, opt, string, range:[1,32]-->test
</programUUID>
</ProgramNoSecondList>
</EmergencySchedule>


</PlaySchedule>
Response Message
<?xml version="1.0" encoding="UTF-8"?>
<ResponseStatus xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--ro, req, object, response message, attr:version{ro, req, string, protocolVersion}-->
<requestURL>
<!--ro, req, string, request URL-->null
</requestURL>
<statusCode>
<!--ro, req, enum, status code, subType:int, desc:0 (OK), 1 (OK), 2 (Device Busy), 3 (Device Error), 4 (Invalid Operation), 5 (Invalid XML Format), 6
(Invalid XML Content), 7 (Reboot Required)-->0
</statusCode>
<statusString>
<!--ro, req, enum, status description, subType:string, desc:“OK” (succeeded), “Device Busy”, “Device Error”, “Invalid Operation”, “Invalid XML Format”,
“Invalid XML Content”, “Reboot” (reboot device)-->OK
</statusString>
<subStatusCode>
<!--ro, req, string, sub status code, desc:sub status code-->OK
</subStatusCode>
</ResponseStatus>
21.38.5 Get the configuration capability of the program schedules
Request URL
GET /ISAPI/Publish/ScheduleMgr/playSchedule/<scheduleID>/capabilities
Query Parameter
Parameter Name Parameter Type Description
scheduleID
string
Request Message
None
Response Message
<?xml version="1.0" encoding="UTF-8"?>
<PlaySchedule xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--ro, opt, object, attr:version{req, string, protocolVersion}-->
<id>
<!--ro, req, int, schedule ID-->1
</id>
<scheduleName max="10">
<!--ro, req, string, schedule name, attr:max{req, int}-->test
</scheduleName>
<scheduleRemarks max="10">
<!--ro, opt, string, schedule description, attr:max{req, int}-->test
</scheduleRemarks>
<approveState opt="approved,notPass,notApprove">
<!--ro, opt, enum, approval status, subType:string, attr:opt{req, string}, desc:"approved" (pass), "notPass" (deny), "notApprove" (not approved)-
>approved
</approveState>
<approveRemarks max="10">
<!--ro, opt, string, approval remarks, attr:max{req, int}-->test
</approveRemarks>
<scheduleMode opt="normal,decode,touch,decodeTouch">
<!--ro, opt, enum, schedule mode, subType:string, attr:opt{req, string}, desc:program schedule mode: mormal,decode and touch-->normal
</scheduleMode>
<orgNo>
<!--ro, opt, int, organization No.-->1
</orgNo>
<scheduleType opt="selfDefine,daily,weekly,loop,defaultSchedule">
<!--ro, opt, enum, schedule type, subType:string, attr:opt{req, string}, desc:"selfDefine"-custom schedule, "daily"-daily schedule, "weekly"-weekly
schedule, "loop"-loop schedule, "defaultSchedule"-default schedule-->selfDefine
</scheduleType>
<shareProperty opt="static,dynamic">
<!--ro, opt, enum, shared property, subType:string, attr:opt{req, string}, desc:shared property: public,private-->public
</shareProperty>
<DailySchedule>
<!--ro, opt, object, daily schedule-->
<PlaySpanList size="10">
<!--ro, req, array, subType:object, attr:size{req, int}-->
<PlaySpan>
<!--ro, opt, object-->
<id>
<!--ro, req, int, time period ID-->1
</id>
-


</id>
<programNo>
<!--ro, req, int, program ID-->1
</programNo>
<TimeRange>
<!--ro, req, object, program duration-->
<beginTime>
<!--ro, req, string, start time, desc:start time (ISO 8601 format)-->test
</beginTime>
<endTime>
<!--ro, req, string, end time, desc:end time (ISO 8601 format)-->test
</endTime>
</TimeRange>
</PlaySpan>
</PlaySpanList>
<PlaySpanSecondList size="10">
<!--ro, opt, array, subType:object, attr:size{req, int}-->
<PlaySpanSecond>
<!--ro, opt, object-->
<id>
<!--ro, req, int, time period ID-->1
</id>
<programNo>
<!--ro, req, int, program ID-->1
</programNo>
<TimeRange>
<!--ro, req, object, program duration-->
<beginTime>
<!--ro, req, string, start time, desc:start time (ISO 8601 format)-->test
</beginTime>
<endTime>
<!--ro, req, string, end time, desc:end time (ISO 8601 format)-->test
</endTime>
</TimeRange>
</PlaySpanSecond>
</PlaySpanSecondList>
</DailySchedule>
<WeeklySchedule>
<!--ro, opt, array, weekly schedule, subType:object-->
<DayList size="10">
<!--ro, req, object, attr:size{req, int}-->
<Day>
<!--ro, opt, object-->
<id>
<!--ro, req, int, day ID-->1
</id>
<dayOfWeek opt="monday,tuesday,tuesday,wednesday,thursday,friday,saturday,sunday">
<!--ro, req, enum, day of the week, subType:string, attr:opt{req, string}, desc:day of a week-->monday
</dayOfWeek>
<PlaySpanList size="10">
<!--ro, req, array, subType:object, attr:size{req, int}-->
<PlaySpan>
<!--ro, opt, object-->
<id>
<!--ro, req, int, time period ID-->1
</id>
<programNo>
<!--ro, req, int, program ID-->1
</programNo>
<TimeRange>
<!--ro, req, object, program duration-->
<beginTime>
<!--ro, req, string, start time, desc:start time (ISO 8601 format)-->test
</beginTime>
<endTime>
<!--ro, req, string, end time, desc:end time (ISO 8601 format)-->test
</endTime>
</TimeRange>
</PlaySpan>
</PlaySpanList>
<PlaySpanSecondList size="10">
<!--ro, opt, array, subType:object, attr:size{req, int}-->
<PlaySpanSecond>
<!--ro, opt, object-->
<id>
<!--ro, req, int, time period ID-->1
</id>
<programNo>
<!--ro, req, int, program ID-->1
</programNo>
<TimeRange>
<!--ro, req, object, program duration-->
<beginTime>
<!--ro, req, string, start time, desc:start time (ISO 8601 format)-->test
</beginTime>
<endTime>
<!--ro, req, string, end time, desc:end time (ISO 8601 format)-->test
</endTime>
</TimeRange>
</PlaySpanSecond>
</PlaySpanSecondList>
</Day>
</DayList>
</WeeklySchedule>
<LoopSchedule>


<LoopSchedule>
<!--ro, opt, object, loop schedule-->
<ProgramNoList size="10">
<!--ro, req, array, list of programs for loop schedule, subType:object, attr:size{req, int}, desc:list of looping programs,normal mode-->
<programNo>
<!--ro, opt, int, program ID-->1
</programNo>
</ProgramNoList>
<ProgramNoSecondList size="10">
<!--ro, req, array, subType:object, attr:size{req, int}-->
<programNoSecond>
<!--ro, opt, int, program ID-->1
</programNoSecond>
</ProgramNoSecondList>
<LoopTimeSpanList size="10">
<!--ro, opt, array, subType:object, attr:size{req, int}-->
<LoopTimeSpan>
<!--ro, opt, object-->
<TimeRange>
<!--ro, req, object, program duration-->
<beginTime>
<!--ro, req, string, start time, desc:start time (ISO 8601 format)-->test
</beginTime>
<endTime>
<!--ro, req, string, end time, desc:end time (ISO 8601 format)-->test
</endTime>
</TimeRange>
<ProgramNoList size="10">
<!--ro, req, array, program ID list, subType:object, attr:size{req, int}-->
<programNo>
<!--ro, opt, int, program ID-->1
</programNo>
</ProgramNoList>
</LoopTimeSpan>
</LoopTimeSpanList>
<LoopTimeSpanSecondList size="10">
<!--ro, opt, array, subType:object, attr:size{req, int}-->
<LoopTimeSpanSecond>
<!--ro, opt, object-->
<TimeRange>
<!--ro, req, object, program duration-->
<beginTime>
<!--ro, req, string, start time, desc:start time (ISO 8601 format)-->test
</beginTime>
<endTime>
<!--ro, req, string, end time, desc:end time (ISO 8601 format)-->test
</endTime>
</TimeRange>
<ProgramNoSecondList size="10">
<!--ro, req, array, program ID list, subType:object, attr:size{req, int}-->
<programNoSecond>
<!--ro, opt, int, program ID-->1
</programNoSecond>
</ProgramNoSecondList>
</LoopTimeSpanSecond>
</LoopTimeSpanSecondList>
</LoopSchedule>
<SelfDefineSchedule>
<!--ro, opt, object-->
<SelfDefineList size="10">
<!--ro, req, array, subType:object, attr:size{req, int}-->
<SelfDefine>
<!--ro, opt, object, custom play duration-->
<id>
<!--ro, req, int, time period ID-->1
</id>
<programNo>
<!--ro, req, int, program ID-->1
</programNo>
<TimeRange>
<!--ro, req, object, program duration-->
<beginTime>
<!--ro, req, string, start time, desc:start time (ISO 8601 format)-->test
</beginTime>
<endTime>
<!--ro, req, string, end time, desc:end time (ISO 8601 format)-->test
</endTime>
</TimeRange>
</SelfDefine>
</SelfDefineList>
<SelfDefineSecondList size="10">
<!--ro, opt, array, subType:object, attr:size{req, int}-->
<SelfDefineSecond>
<!--ro, opt, object-->
<id>
<!--ro, req, int, time period ID-->1
</id>
<programNoSecond>
<!--ro, req, int, program ID-->1
</programNoSecond>
<TimeRange>
<!--ro, req, object, program duration-->
<beginTime>
<!--ro, req, string, start time, desc:start time (ISO 8601 format)-->test


<!--ro, req, string, start time, desc:start time (ISO 8601 format)-->test
</beginTime>
<endTime>
<!--ro, req, string, end time, desc:end time (ISO 8601 format)-->test
</endTime>
</TimeRange>
</SelfDefineSecond>
</SelfDefineSecondList>
</SelfDefineSchedule>
<DefaultSchedule>
<!--ro, opt, object, default program schedule-->
<programNo>
<!--ro, req, int, default program-->1
</programNo>
<programNoSecond>
<!--ro, opt, int-->1
</programNoSecond>
</DefaultSchedule>
<HolidaySchedule>
<!--ro, opt, object, holiday schedule, desc:it can be attached to the daily or weekly schedule-->
<PlaySpanList>
<!--ro, req, array, subType:object-->
<PlaySpan>
<!--ro, opt, object-->
<id>
<!--ro, req, int, time period No.-->1
</id>
<programNo>
<!--ro, req, int, program ID-->1
</programNo>
<TimeRange>
<!--ro, req, object, program duration-->
<beginTime>
<!--ro, req, string, start time, desc:start time (ISO 8601 format)-->test
</beginTime>
<endTime>
<!--ro, req, string, end time, desc:end time (ISO 8601 format)-->test
</endTime>
</TimeRange>
</PlaySpan>
</PlaySpanList>
</HolidaySchedule>
</PlaySchedule>
21.38.6 Delete a specific program schedule
Request URL
DELETE /ISAPI/Publish/ScheduleMgr/playSchedule/<scheduleID>
Query Parameter
Parameter Name Parameter Type Description
scheduleID
string
Request Message
None
Response Message
<?xml version="1.0" encoding="UTF-8"?>
<ResponseStatus xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--ro, req, object, response message, attr:version{ro, req, string, protocolVersion}-->
<requestURL>
<!--ro, req, string, request URL-->null
</requestURL>
<statusCode>
<!--ro, req, enum, status code, subType:int, desc:0-OK, 1-OK, 2-Device Busy, 3-Device Error, 4-Invalid Operation, 5-Invalid XML Format, 6-Invalid XML
Content, 7-Reboot Required-->0
</statusCode>
<statusString>
<!--ro, req, enum, status description, subType:string, desc:“OK” (succeeded), “Device Busy”, “Device Error”, “Invalid Operation”, “Invalid XML Format”,
“Invalid XML Content”, “Reboot” (reboot device)-->OK
</statusString>
<subStatusCode>
<!--ro, req, string, sub status code, desc:sub status code-->OK
</subStatusCode>
</ResponseStatus>
-
21.38.7 Get the schedule management capability set


Request URL
GET /ISAPI/Publish/ScheduleMgr/capabilities?format=json
Query Parameter
None
Request Message
None
Response Message
{
"ScheduleMgrCap": {
/*ro, opt, object*/
"isSupportPostSchedule": true
/*ro, opt, bool, whether it supports releasing program schedules*/
}
}
21.39 Material Management
21.39.1 Get capability of getting material management parameters
Request URL
GET /ISAPI/Publish/material/<materialID>/capabilities
Query Parameter
Parameter Name Parameter Type Description
materialID
string
Request Message
None
Response Message
<?xml version="1.0" encoding="UTF-8"?>
<Material xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--ro, opt, object, attr:version{req, string, protocolVersion}-->
<id>
<!--ro, req, int, material ID-->1
</id>
<seq min="1" max="10">
<!--ro, opt, int, material serial No., attr:min{req, int},max{req, int}, desc:it changes every time when the material is modified. This field is valid
only on the server-to-terminal link-->1
</seq>
<materialName max="10">
<!--ro, req, string, material name, attr:max{req, int}-->test
</materialName>
<materialRemarks max="10">
<!--ro, req, string, material description, attr:max{req, int}-->test
</materialRemarks>
<materialType opt="static,dynamic">
<!--ro, req, enum, material type, subType:string, attr:opt{req, string}, desc:"static" (static material), "dynamic" (dynamic material)-->static
</materialType>
<approveState opt="approved,notPass,notApprove">
<!--ro, opt, enum, approval status, subType:string, attr:opt{req, string}, desc:"approved" (pass), "notPass" (deny), "notApprove" (not approved)-
>approved
</approveState>
<approveRemarks max="10">
<!--ro, opt, string, approval remarks, attr:max{req, int}-->test
</approveRemarks>
<shareProperty opt="static,dynamic">
<!--ro, opt, enum, sharing property, subType:string, attr:opt{req, string}, desc:public, private-->public
</shareProperty>
<uploadUser max="10">
<!--ro, req, string, uploader, attr:max{req, int}-->test
</uploadUser>
<uploadTime>
<!--ro, req, datetime, uploading time-->1970-01-01T00:00:00+08:00
</uploadTime>
<materialEncrypt min="1" max="10">
<!--ro, opt, string, material verification code, attr:min{req, int},max{req, int}, desc:it can be used to verify the correctness of materials. This
field is valid only on the server-to-terminal link-->JjEmNTA3NDg5NCY0JjI3OTM5MjAmYWEmMzYyOTM5OCZhMCY0MjAzMDQwJmI1JjQzMzc3ODgmNDg=
</materialEncrypt>
<orgNo>
-


<orgNo>
<!--ro, opt, int, organization No.-->1
</orgNo>
<orgName>
<!--ro, opt, string, organization name-->test
</orgName>
<replaceTerminal opt="true,false">
<!--ro, opt, bool, whether to update the material to the terminal, attr:opt{req, string}, desc:this field is valid only when replacing materials-->true
</replaceTerminal>
<StorageInfo>
<!--ro, opt, object, material server information, desc:this field is valid only when the materials are saved on the storage server-->
<storageType min="1" max="10">
<!--ro, opt, enum, storage server type, subType:string, attr:min{req, int},max{req, int}, desc:"fms", "kms", "cloud", "minio"-->cloud
</storageType>
<host min="1" max="10">
<!--ro, opt, string, storage mode,https://[ip]:[port][coded string], attr:min{req, int},max{req, int}-->https://10.11.5.222:4433
</host>
<accountName min="1" max="10">
<!--ro, opt, string, account name, attr:min{req, int},max{req, int}-->test
</accountName>
<accountPasswd min="1" max="10">
<!--ro, opt, string, account password, attr:min{req, int},max{req, int}-->test
</accountPasswd>
<bucket min="1" max="10">
<!--ro, opt, string, bucket, dep:and,{$.Material.StorageInfo.storageType,eq,minio}, attr:min{req, int},max{req, int}-->test
</bucket>
</StorageInfo>
<StaticMaterial>
<!--ro, opt, object-->
<staticMaterialType opt="picture,flash,audio,video,document,ppt,doc,excel,pdf,web">
<!--ro, opt, enum, static material type, subType:string, attr:opt{req, string}, desc:local material type-->picture
</staticMaterialType>
<picFormat opt="gif,bmp,jpg,png">
<!--ro, opt, enum, picture format, subType:string, attr:opt{req, string}, desc:"gif", "bmp", "jpg", "png"-->png
</picFormat>
<picResolution>
<!--ro, opt, object, picture resolution limitation-->
<height min="0" max="10">
<!--ro, opt, int, height, attr:min{req, int},max{req, int}-->0
</height>
<width min="0" max="10">
<!--ro, opt, int, width, attr:min{req, int},max{req, int}-->0
</width>
</picResolution>
<flashFormat opt="swf">
<!--ro, opt, enum, flash format, subType:string, attr:opt{req, string}, desc:"swf"-->swf
</flashFormat>
<audioFormat opt="mp3,wav,wma">
<!--ro, opt, enum, audio format, subType:string, attr:opt{req, string}, desc:"mp3", "wav", "wma"-->wma
</audioFormat>
<videoFormat opt="rm,rmvb,asf,avi,mpg,3gp,mov,mkv,wmv,flv,mp4,hkps">
<!--ro, opt, enum, video format, subType:string, attr:opt{req, string}, desc:"rm", "rmvb", "asf", "avi", "mpg", "3gp", "mov", "mkv", "wmv", "flv",
"mp4"-->mp4
</videoFormat>
<documentFormat opt="txt">
<!--ro, opt, enum, document format, subType:string, attr:opt{req, string}, desc:"txt"-->txt
</documentFormat>
<pptFormat opt="ppt,pptx">
<!--ro, opt, enum, slide format, subType:string, attr:opt{req, string}, desc:"ppt", "pptx"-->ppt
</pptFormat>
<docFormat opt="doc,docx">
<!--ro, opt, enum, word document format, subType:string, attr:opt{req, string}, desc:"doc", "docx"-->doc
</docFormat>
<excelFormat opt="xls,xlsx">
<!--ro, opt, enum, excel format, subType:string, attr:opt{req, string}, desc:"xls", "xlsx"-->xlsx
</excelFormat>
<pdfFormat opt="pdf">
<!--ro, opt, enum, PDF format, subType:string, attr:opt{req, string}, desc:"pdf"-->pdf
</pdfFormat>
<webFormat opt="html,htm">
<!--ro, opt, enum, web file format, subType:string, attr:opt{req, string}, desc:"html", "htm"-->htm
</webFormat>
<fileSize max="10">
<!--ro, req, int, file size, unit:Byte, attr:max{req, int}-->1
</fileSize>
<duration max="10">
<!--ro, opt, int, duration, unit:s, dep:and,{$.Material.StaticMaterial.staticMaterialType,eq,flash},
{$.Material.StaticMaterial.staticMaterialType,eq,video}, attr:max{req, int}-->1
</duration>
<uuid min="1" max="10">
<!--ro, opt, string, UUID provided by the server to identify the material, attr:min{req, int},max{req, int}, desc:this field is valid only when
StorageInfo exists; only 8520 platform saves materials on the storage server-->test
</uuid>
<staticMaterialurl min="1" max="10">
<!--ro, opt, string, attr:min{req, int},max{req, int}-->test
</staticMaterialurl>
<materialUrl max="10">
<!--ro, opt, string, material URL, attr:max{req, int}-->test
</materialUrl>
<StorageInfo>
<!--ro, opt, object, storage information-->
<addressingFormatType opt="ipaddress,hostname">
<!--ro, req, enum, subType:string, attr:opt{req, string}, desc:"ipaddress", "hostname"-->ipaddress
</addressingFormatType>


<hostName min="1" max="10">
<!--ro, opt, string, host name, dep:and,{$.Material.StaticMaterial.StorageInfo.addressingFormatType,eq,hostname}, attr:min{req, int},max{req, int}-
>test
</hostName>
<ipAddress min="1" max="10">
<!--ro, opt, string, IPv4 address, dep:and,{$.Material.StaticMaterial.StorageInfo.addressingFormatType,eq,ipaddress}, attr:min{req, int},max{req,
int}-->test
</ipAddress>
<ipv6Address min="1" max="10">
<!--ro, opt, string, IPv6 address, dep:and,{$.Material.StaticMaterial.StorageInfo.addressingFormatType,eq,ipaddress}, attr:min{req, int},max{req,
int}-->test
</ipv6Address>
<port min="1" max="10">
<!--ro, req, int, port No., attr:min{req, int},max{req, int}-->1
</port>
<accessKey min="1" max="10">
<!--ro, opt, string, password, attr:min{req, int},max{req, int}-->test
</accessKey>
<secretKey min="1" max="10">
<!--ro, opt, string, attr:min{req, int},max{req, int}-->test
</secretKey>
<bucket min="1" max="10">
<!--ro, opt, string, bucket, attr:min{req, int},max{req, int}, desc:bucket,this field is valid only when storageType is "minio"-->test
</bucket>
</StorageInfo>
<videoFileSize max="10">
<!--ro, opt, int, video file size, unit:Byte, attr:max{req, int}-->0
</videoFileSize>
<picFileSize max="10">
<!--ro, opt, int, picture file size, unit:Byte, attr:max{req, int}-->0
</picFileSize>
<materialURL max="10">
<!--ro, opt, string, material URL, attr:max{req, int}-->test
</materialURL>
</StaticMaterial>
<DynamicMaterial>
<!--ro, opt, object, dynamic material-->
<dynamicMaterialType opt="web,socket,rss,realStream,generalData,picUrl,dataSource">
<!--ro, opt, enum, dynamic material type, subType:string, attr:opt{req, string}, desc:"web", "socket", "rss", "realStream", "generalData", "picUrl",
"dataSource"-->dataSource
</dynamicMaterialType>
<webUrl>
<!--ro, opt, string, material address of web page content-->test
</webUrl>
<rssUrl>
<!--ro, opt, string, RSS URL-->test
</rssUrl>
<picUrl>
<!--ro, opt, string, picture URL-->test
</picUrl>
<RealStream>
<!--ro, opt, object, real stream material-->
<destionType opt="streamMedia,normalIPC">
<!--ro, req, enum, streaming terminal type, subType:string, attr:opt{req, string}, desc:streamMedia (stream media server), normalIPC (normal network
camera)-->streamMedia
</destionType>
<streamMediaUrl>
<!--ro, opt, string, streaming media server URL-->test
</streamMediaUrl>
<NormalIPC>
<!--ro, opt, object, network camera information-->
<IpAddress>
<!--ro, opt, object, IP address-->
<ipVersion opt="v4,v6,dual">
<!--ro, req, enum, IP address version, subType:string, attr:opt{req, string}, desc:"v4" (IPv4), "v6" (IPv6), "dual" (IPv4 and IPv6)-->v4
</ipVersion>
<ipAddress>
<!--ro, opt, string, IPv4 address-->test
</ipAddress>
<ipv6Address>
<!--ro, opt, string, IPv6 address-->test
</ipv6Address>
</IpAddress>
<portNo>
<!--ro, req, int, port No.-->1
</portNo>
<channelNo>
<!--ro, req, int, channel No.-->1
</channelNo>
<userName min="1" max="10">
<!--ro, req, string, device login user name, attr:min{req, int},max{req, int}, desc:it must be encrypted when transmitting-->test
</userName>
<passWord min="1" max="10">
<!--ro, req, string, login password, attr:min{req, int},max{req, int}, desc:it must be encrypted when transmitting-->test
</passWord>
<transmitProtocol opt="tcp,udp,mcast">
<!--ro, opt, enum, transmission protocol, subType:string, attr:opt{req, string}, desc:transmission protocol-->tcp
</transmitProtocol>
<streamType opt="main,sub,third">
<!--ro, opt, enum, stream type, subType:string, attr:opt{req, string}, desc:stream type-->main
</streamType>
</NormalIPC>
<dataType opt="capture,liveVideo">
<!--ro, opt, enum, data type, subType:string, attr:opt{req, string}, desc:"capture" (captured pictures), "liveVideo" (live video)-->capture


<!--ro, opt, enum, data type, subType:string, attr:opt{req, string}, desc:"capture" (captured pictures), "liveVideo" (live video)-->capture
</dataType>
</RealStream>
<GeneralData>
<!--ro, opt, object, third-party data-->
<SrcAddress>
<!--ro, opt, object, IP address of data source-->
<ipVersion opt="v4,v6,dual">
<!--ro, req, enum, IP address version, subType:string, attr:opt{req, string}, desc:"v4" (IPv4), "v6" (IPv6), "dual" (IPv4 and IPv6)-->v4
</ipVersion>
<ipAddress>
<!--ro, opt, string, IPv4 address-->test
</ipAddress>
<ipv6Address>
<!--ro, opt, string, IPv6 address-->test
</ipv6Address>
</SrcAddress>
<dataType opt="popPic,call">
<!--ro, opt, enum, data type, subType:string, attr:opt{req, string}, desc:data type: capture,"liveVideo"-live video-->popPic
</dataType>
</GeneralData>
<dataSourceUrl min="1" max="10">
<!--ro, opt, string, data source URL, attr:min{req, int},max{req, int}, desc:this field is valid only when dynamicMaterialType is "dataSource" and
StorageInfo exists; only 8520 platform saves materials on the storage server-->test
</dataSourceUrl>
</DynamicMaterial>
</Material>
21.39.2 Add a material
Request URL
POST /ISAPI/Publish/MaterialMgr/material?security=<security>&iv=<iv>
Query Parameter
Parameter Name Parameter Type Description
security
string
iv
Request Message
<?xml version="1.0" encoding="UTF-8"?>
<Material xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--req, object, attr:version{req, string, protocolVersion}-->
<id>
<!--req, int, material ID-->1
</id>
<materialName>
<!--req, string, material name-->test
</materialName>
<materialRemarks>
<!--req, string, material description-->test
</materialRemarks>
<materialType>
<!--req, enum, material type, subType:string, desc:"static" (static material), "dynamic" (dynamic material)-->static
</materialType>
<approveState>
<!--opt, enum, approval status, subType:string, desc:"approved" (pass), "notPass" (deny), "notApprove" (not approved)-->approved
</approveState>
<approveRemarks>
<!--opt, string, approval remarks-->test
</approveRemarks>
<shareProperty>
<!--opt, enum, shared property, subType:string, desc:"public", "private"-->public
</shareProperty>
<uploadUser>
<!--req, string, uploader-->test
</uploadUser>
<uploadTime>
<!--req, datetime, uploading time-->1970-01-01T00:00:00+08:00
</uploadTime>
<materialEncrypt>
<!--opt, string, material verification code, desc:it can be used to verify the correctness of materials. This field is valid only on the server-toterminal
link-->JjEmNTA3NDg5NCY0JjI3OTM5MjAmYWEmMzYyOTM5OCZhMCY0MjAzMDQwJmI1JjQzMzc3ODgmNDg=
</materialEncrypt>
<orgNo>
<!--opt, int, organization No.-->1
</orgNo>
<replaceTerminal>
<!--opt, bool, whether the material is updated to the terminal, desc:this field is valid only when replacing materials-->true
</replaceTerminal>
<StaticMaterial>
<!--opt, object, static material, dep:and,{$.Material.materialType,eq,static}, desc:this node is valid when materialType is "static"-->
string
-
-


<!--opt, object, static material, dep:and,{$.Material.materialType,eq,static}, desc:this node is valid when materialType is "static"-->
<staticMaterialType>
<!--opt, enum, static material type, subType:string, dep:and,{$.Material.StaticMaterial,eq,true}, desc:this node is valid when StaticMaterial exists-
>picture
</staticMaterialType>
<picFormat>
<!--opt, enum, picture format, subType:string, dep:and,{$.Material.StaticMaterial.staticMaterialType,eq,picture}, desc:"gif", "bmp", "jpg", "png"-
>png
</picFormat>
<flashFormat>
<!--opt, enum, flash format, subType:string, desc:"swf"-->swf
</flashFormat>
<audioFormat>
<!--opt, enum, audio format, subType:string, desc:"mp3", "wav", "wma"-->wma
</audioFormat>
<videoFormat>
<!--opt, enum, video format, subType:string, desc:"rm", "rmvb", "asf", "avi", "mpg", "3gp", "mov", "mkv", "wmv", "flv", "mp4"-->mp4
</videoFormat>
<documentFormat>
<!--opt, enum, document format, subType:string, desc:"txt"-->txt
</documentFormat>
<pptFormat>
<!--opt, enum, slide format, subType:string, desc:"ppt", "pptx"-->ppt
</pptFormat>
<docFormat>
<!--opt, enum, word document format, subType:string, desc:"doc", "docx"-->doc
</docFormat>
<excelFormat>
<!--opt, enum, excel format, subType:string, desc:"xls", "xlsx"-->xlsx
</excelFormat>
<pdfFormat>
<!--opt, enum, PDF format, subType:string, desc:"pdf"-->pdf
</pdfFormat>
<webFormat>
<!--opt, enum, web file format, subType:string, desc:"html", "htm"-->htm
</webFormat>
<appFormat>
<!--opt, enum, application format, subType:string, desc:"apk"-->apk
</appFormat>
<fileSize>
<!--req, int, file size, unit:Byte-->1
</fileSize>
<duration>
<!--opt, int, duration, unit:s, dep:and,{$.Material.StaticMaterial.staticMaterialType,eq,flash},
{$.Material.StaticMaterial.staticMaterialType,eq,video}, desc:this filed is valid only when the material is a video or flash file-->1
</duration>
<staticMaterialurl>
<!--opt, string-->test
</staticMaterialurl>
<materialURL>
<!--opt, string-->test
</materialURL>
<StorageInfo>
<!--opt, object-->
<addressingFormatType>
<!--req, enum, address type, subType:string, desc:"ipaddress", "hostname"-->ipaddress
</addressingFormatType>
<hostName>
<!--opt, string, dep:and,{$.Material.StaticMaterial.StorageInfo.addressingFormatType,eq,hostname}-->test
</hostName>
<ipAddress>
<!--opt, string, IPv4 address, dep:and,{$.Material.StaticMaterial.StorageInfo.addressingFormatType,eq,ipaddress}-->test
</ipAddress>
<ipv6Address>
<!--opt, string, IPv6 address, dep:and,{$.Material.StaticMaterial.StorageInfo.addressingFormatType,eq,ipaddress}-->test
</ipv6Address>
<port>
<!--req, int, port No.-->1
</port>
<accessKey>
<!--opt, string, password-->test
</accessKey>
<secretKey>
<!--opt, string-->test
</secretKey>
<bucket>
<!--opt, string-->test
</bucket>
</StorageInfo>
</StaticMaterial>
<DynamicMaterial>
<!--opt, object, dynamic material-->
<dynamicMaterialType>
<!--opt, enum, dynamic material type, subType:string, desc:dynamic material type-->dataSource
</dynamicMaterialType>
<webUrl>
<!--opt, string, material address of web page content, desc:web URL-->test
</webUrl>
<rssUrl>
<!--opt, string, RSS URL, desc:RSS URL-->test
</rssUrl>
<picUrl>
<!--opt, string, picture URL, desc:picture URL-->test
</picUrl>


<RealStream>
<!--opt, object, real stream material, desc:real-time stream-->
<destionType>
<!--req, enum, streaming terminal type, subType:string, desc:"streamMedia" (stream media server), "normalIPC" (normal network camera)-->streamMedia
</destionType>
<streamMediaUrl>
<!--opt, string, streaming media server URL, desc:streaming server URL-->test
</streamMediaUrl>
<NormalIPC>
<!--opt, object-->
<IpAddress>
<!--opt, object-->
<ipVersion>
<!--req, enum, IP address version, subType:string, desc:"v4" (IPv4), "v6" (IPv6), "dual" (IPv4 and IPv6)-->v4
</ipVersion>
<ipAddress>
<!--opt, string, IPv4 address-->test
</ipAddress>
<ipv6Address>
<!--opt, string, IPv6 address-->test
</ipv6Address>
</IpAddress>
<portNo>
<!--req, int, port No.-->1
</portNo>
<channelNo>
<!--req, int, channel No.-->1
</channelNo>
<userName>
<!--req, string, device login user name, desc:it must be encrypted when transmitting-->test
</userName>
<passWord>
<!--req, string, device login password, desc:it must be encrypted when transmitting-->test
</passWord>
<transmitProtocol>
<!--opt, enum, transmission protocol, subType:string, desc:transmission protocol-->tcp
</transmitProtocol>
<streamType>
<!--opt, enum, stream type, subType:string, desc:stream type-->main
</streamType>
<iv>
<!--opt, string, vector-->test
</iv>
<secretKey>
<!--opt, string-->test
</secretKey>
</NormalIPC>
<dataType>
<!--opt, enum, data type, subType:string, desc:"capture" (captured pictures), "liveVideo" (live video)-->capture
</dataType>
</RealStream>
<GeneralData>
<!--opt, object, third-party data, desc:third-party data-->
<SrcAddress>
<!--opt, object, IP address of data source, desc:IP address of data source-->
<ipVersion>
<!--req, enum, IP address version, subType:string-->v4
</ipVersion>
<ipAddress>
<!--opt, string, IPv4 address-->test
</ipAddress>
<ipv6Address>
<!--opt, string, IPv6 address-->test
</ipv6Address>
</SrcAddress>
<dataType>
<!--opt, enum, data type, subType:string, desc:data type: capture,"liveVideo"-live video-->popPic
</dataType>
</GeneralData>
</DynamicMaterial>
</Material>
Response Message


<?xml version="1.0" encoding="UTF-8"?>
<ResponseStatus xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--ro, req, object, response message, attr:version{ro, req, string, protocolVersion}-->
<requestURL>
<!--ro, req, string, request URL-->null
</requestURL>
<statusCode>
<!--ro, req, enum, status code, subType:int, desc:0 (OK), 1 (OK), 2 (Device Busy), 3 (Device Error), 4 (Invalid Operation), 5 (Invalid XML Format), 6
(Invalid XML Content), 7 (Reboot Required)-->0
</statusCode>
<statusString>
<!--ro, req, enum, status description, subType:string, desc:"OK", "Device Busy", "Device Error", "Invalid Operation", "Invalid XML Format", "Invalid XML
Content", "Reboot"-->OK
</statusString>
<subStatusCode>
<!--ro, req, string, sub status code, desc:read-only,describe the error reason in detail-->OK
</subStatusCode>
<ID>
<!--ro, opt, string-->test
</ID>
</ResponseStatus>
21.39.3 Delete a specific material
Request URL
DELETE /ISAPI/Publish/MaterialMgr/material/<materialID>
Query Parameter
Parameter Name Parameter Type Description
materialID
string
Request Message
None
Response Message
<?xml version="1.0" encoding="UTF-8"?>
<ResponseStatus xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--ro, req, object, response message, attr:version{ro, req, string, protocolVersion}-->
<requestURL>
<!--ro, req, string, request URL-->null
</requestURL>
<statusCode>
<!--ro, req, enum, status code, subType:int, desc:0 (OK), 1 (OK), 2 (Device Busy), 3 (Device Error), 4 (Invalid Operation), 5 (Invalid XML Format), 6
(Invalid XML Content), 7 (Reboot Required)-->0
</statusCode>
<statusString>
<!--ro, req, enum, status information, subType:string, desc:"OK" (succeeded), "Device Busy", "Device Error", "Invalid Operation", "Invalid XML Format",
"Invalid XML Content", "Reboot" (reboot device)-->OK
</statusString>
<subStatusCode>
<!--ro, req, string, sub status code, which describes the error in details, desc:sub status code, which describes the error in details-->OK
</subStatusCode>
</ResponseStatus>
-
21.40 Program Management
21.40.1 Get program parameter capabilities
Request URL
GET /ISAPI/Publish/ProgramMgr/program/<programID>/capabilities
Query Parameter
Parameter Name Parameter Type Description
programID
string
Request Message
-


None
Response Message
<?xml version="1.0" encoding="UTF-8"?>
<Program xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--ro, req, object, page list, attr:version{req, string, protocolVersion}-->
<id>
<!--ro, req, int, program ID-->1
</id>
<programName max="10">
<!--ro, req, string, program name, attr:max{req, int}-->test
</programName>
<programRemarks max="10">
<!--ro, req, string, program description, attr:max{req, int}-->test
</programRemarks>
<shareProperty opt="static,dynamic">
<!--ro, opt, enum, shared property: public,private, subType:string, attr:opt{req, string}, desc:shared property: public,private-->public
</shareProperty>
<approveState opt="approved,notPass,notApprove">
<!--ro, opt, enum, approval status, subType:string, attr:opt{req, string}, desc:"approved" (pass), "notPass" (deny), "notApprove" (not approved)-
>approved
</approveState>
<approveRemarks max="10">
<!--ro, opt, string, approval remarks, attr:max{req, int}-->test
</approveRemarks>
<programType opt="normal,decode,touch,decodeTouch,doubleSide,conference,screensaver,character,mainInterface,idleScreen,txt">
<!--ro, opt, enum, program type, subType:string, attr:opt{req, string}, desc:program type: normal,decode,touch,"decodeTouch"-decode and touch,character
(welcome words,which is used for access control devices)-->normal
</programType>
<orgNo>
<!--ro, opt, int, organization No.-->1
</orgNo>
<Resolution>
<!--ro, req, object, resolution-->
<resolutionName opt="1920*1080,1080*1920,3840*2160,2160*3840,selfDefine">
<!--ro, opt, string, resolution name, attr:opt{req, string}-->test
</resolutionName>
<imageWidth min="1" max="10">
<!--ro, req, int, resolution (width), attr:min{req, int},max{req, int}-->1
</imageWidth>
<imageHeight min="1" max="10">
<!--ro, req, int, resolution (height), attr:min{req, int},max{req, int}-->1
</imageHeight>
</Resolution>
<PageList size="10">
<!--ro, opt, array, page list, subType:object, attr:size{req, int}-->
<Page>
<!--ro, opt, object, page-->
<id>
<!--ro, req, int, ID-->1
</id>
<PageBasicInfo>
<!--ro, req, object, page information of application program-->
<pageName max="10">
<!--ro, opt, string, page name, attr:max{req, int}-->test
</pageName>
<BackgroundColor>
<!--ro, opt, object, background color-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g., 16777215 indicates 0xFFFFFF-->1
</RGB>
</BackgroundColor>
<playDurationMode opt="selfDefine,auto,loop">
<!--ro, opt, enum, playing time mode, subType:string, attr:opt{req, string}, desc:playing time mode-->selfDefine
</playDurationMode>
<playDuration min="1" max="10" default="null">
<!--ro, opt, int, playing duration, unit:s, attr:min{req, int},max{req, int},default{opt, string}-->1
</playDuration>
<playCount min="1" max="10">
<!--ro, opt, int, playback times, attr:min{req, int},max{req, int}-->1
</playCount>
<switchDuration min="1" max="10">
<!--ro, req, int, switch interval, unit:s, attr:min{req, int},max{req, int}-->1
</switchDuration>
<switchEffect
opt="none,random,boxShrink,boxSpread,cycleShrink,cycSpread,eraseUp,eraseDown,eraseLeft,eraseRight,verticalShelter,horizontalShelter,verticalChessboard,horiz
ontalChessboard,dissolve,leftRightToCenter,ceterToLeftRight,upDownToCenter,centerToUpDown,drawOutLeftDown,drawOutLeftUp,drawOutRightDown,drawOutRightUp,vert
icalLine,horizontalLine">
<!--ro, req, enum, switching effect, subType:string, attr:opt{req, string}, desc:switching effect-->none
</switchEffect>
<backgroundPic>
<!--ro, opt, int, background picture ID-->1
</backgroundPic>
<SignInCfg>
<!--ro, opt, object, check-in information, desc:check-in information-->
<VoiceBroadcast>
<!--ro, opt, object, audio prompt-->
<enabled opt="true,false">
<!--ro, opt, bool, attr:opt{req, string}-->true
</enabled>


</enabled>
<broadcastSpeed opt="slower,slow,medium,fast,faster">
<!--ro, opt, enum, subType:string, attr:opt{req, string}-->slower
</broadcastSpeed>
<inLibVoice min="1" max="10">
<!--ro, opt, string, voice prompt content of people in database, attr:min{req, int},max{req, int}-->test
</inLibVoice>
<outLibVoice min="1" max="10">
<!--ro, opt, string, attr:min{req, int},max{req, int}-->test
</outLibVoice>
</VoiceBroadcast>
<WelcomeWord>
<!--ro, opt, object, welcome words-->
<enabled opt="true,false">
<!--ro, opt, bool, attr:opt{req, string}-->true
</enabled>
<inLibWord min="1" max="10">
<!--ro, opt, string, attr:min{req, int},max{req, int}-->test
</inLibWord>
<outLibWord min="1" max="10">
<!--ro, opt, string, attr:min{req, int},max{req, int}-->test
</outLibWord>
</WelcomeWord>
<SignCartoon>
<!--ro, opt, object-->
<signCartoonSpeed opt="fast,medium,slow">
<!--ro, opt, enum, subType:string, attr:opt{req, string}-->fast
</signCartoonSpeed>
</SignCartoon>
<backgroundSignEnabled opt="true,false">
<!--ro, opt, bool, attr:opt{req, string}-->true
</backgroundSignEnabled>
<TemperatureDetection>
<!--ro, opt, object, screen temperature parameter-->
<enabled opt="true,false">
<!--ro, req, bool, whether to enable, attr:opt{req, string}-->true
</enabled>
<threshold min="1" max="10">
<!--ro, req, float, attr:min{req, int},max{req, int}-->0.000
</threshold>
</TemperatureDetection>
</SignInCfg>
</PageBasicInfo>
<characterMode opt="mode1,mode2,mode3">
<!--ro, opt, enum, welcome word mode on the page, subType:string, attr:opt{req, string}, desc:for access control devices, the position of the
welcome words is fixed and can be in three modes: “mode1”, “mode2”, “mode3”.-->mode1
</characterMode>
<WindowsSplitMode opt="SLIP1,SLIP2,SLIP4,SLIP6,SLIP9">
<!--ro, opt, enum, subType:string, attr:opt{req, string}-->SLIP4
</WindowsSplitMode>
<WindowsList size="10">
<!--ro, opt, array, subType:object, attr:size{req, int}-->
<Windows>
<!--ro, opt, object, window information-->
<id>
<!--ro, req, int, content No.-->1
</id>
<Position>
<!--ro, opt, object, content position, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-
>
<positionX min="1" max="10">
<!--ro, req, int, X-coordinate, attr:min{req, int},max{req, int}-->1
</positionX>
<positionY min="1" max="10">
<!--ro, req, int, Y-coordinate, attr:min{req, int},max{req, int}-->1
</positionY>
<height min="1" max="10">
<!--ro, req, int, width, attr:min{req, int},max{req, int}-->1
</height>
<width min="1" max="10">
<!--ro, req, int, height, attr:min{req, int},max{req, int}-->1
</width>
</Position>
<CornerRadius>
<!--ro, opt, object-->
<TopLeft min="1" max="10">
<!--ro, opt, int, attr:min{req, int},max{req, int}-->1
</TopLeft>
<TopRight min="1" max="10">
<!--ro, opt, int, attr:min{req, int},max{req, int}-->1
</TopRight>
<BottomLeft min="1" max="10">
<!--ro, opt, int, attr:min{req, int},max{req, int}-->1
</BottomLeft>
<BottomRight min="1" max="10">
<!--ro, opt, int, attr:min{req, int},max{req, int}-->1
</BottomRight>
</CornerRadius>
<layerNo min="1" max="10">
<!--ro, req, int, attr:min{req, int},max{req, int}-->1
</layerNo>
<WinMaterialInfo>
<!--ro, opt, object, window material information-->
<materialType opt="static,dynamic,other">


<!--ro, req, enum, material type, subType:string, attr:opt{req, string}, desc:“static” (static material), “dynamic” (dynamic material),
“other” (other material)-->static
</materialType>
<staticMaterialType opt="picture,flash,audio,video,document,ppt,doc,excel,pdf,web,app,signIn,conference">
<!--ro, opt, enum, static material type, subType:string, attr:opt{req, string}, desc:static material type-->picture
</staticMaterialType>
<dynamicType opt="web,socket,rss,call,dynamicPic,realStream,capturePic,character">
<!--ro, opt, enum, dynamic material type, subType:string, attr:opt{req, string}, desc:dynamic material type-->web
</dynamicType>
<otherType
opt="clock,weather,countdown,localInput,hyperlinkBtn,event,callBtn,openDoorBtn,QRCodeBtn,authenticationSuccess,authenticationFail,statusBar">
<!--ro, opt, enum, other material type, subType:string, attr:opt{req, string}, desc:other material type-->clock
</otherType>
</WinMaterialInfo>
<TouchProperty>
<!--ro, opt, object, touching attributes-->
<windType opt="popup,page">
<!--ro, opt, enum, window type, subType:string, attr:opt{req, string}-->popup
</windType>
<hyperlinkType opt="window,page">
<!--ro, opt, enum, hyperlink type, subType:string, attr:opt{req, string}, desc:hyperlink type-->window
</hyperlinkType>
<windowId>
<!--ro, opt, int, it is the window of current page. This node is valid when <hyperlinkType> is window, desc:it is the window of current page.
This node is valid when <hyperlinkType> is window-->1
</windowId>
<pageId>
<!--ro, opt, int, page No., desc:this node is valid when <hyperlinkType> is page-->1
</pageId>
</TouchProperty>
<PlayItemList size="10">
<!--ro, opt, array, window playing list, subType:object, attr:size{req, int}-->
<PlayItem>
<!--ro, req, object-->
<id>
<!--ro, req, int, program ID-->1
</id>
<materialNo>
<!--ro, opt, int, material No.-->1
</materialNo>
<inputChannel min="1" max="10">
<!--ro, opt, int, linked channel No. of the network camera, attr:min{req, int},max{req, int}-->1
</inputChannel>
<playEffect opt="none,marquee">
<!--ro, req, enum, playing effect, subType:string, attr:opt{req, string}, desc:playing effect-->none
</playEffect>
<MarqueeInfo>
<!--ro, opt, object-->
<scrollType opt="none,loops,once,backAndForth">
<!--ro, req, enum, marquee scrolling type, subType:string, attr:opt{req, string}, desc:marquee scrolling type-->none
</scrollType>
<scrollDeriction opt="none,up,down,left,right">
<!--ro, req, enum, marquee scrolling direction, subType:string, attr:opt{req, string}, desc:marquee scrolling direction-->none
</scrollDeriction>
<scrollSpeed min="1" max="10">
<!--ro, req, int, marquee scrolling speed, attr:min{req, int},max{req, int}-->1
</scrollSpeed>
</MarqueeInfo>
<PlayDuration>
<!--ro, opt, object, this node can be configured for local materials, live video, and network camera channels, desc:this node can be
configured for local materials, live video, and network camera channels-->
<durationType opt="materialTime,selfDefine">
<!--ro, req, enum, subType:string, attr:opt{req, string}-->selfDefine
</durationType>
<duration min="1" max="10" default="null">
<!--ro, req, int, duration, unit:s, attr:min{req, int},max{req, int},default{opt, string}-->1
</duration>
</PlayDuration>
<CharactersEffect>
<!--ro, opt, object, character display effect, desc:this node is valid when the material type is text or TXT file-->
<fontSize min="1" max="10">
<!--ro, req, int, font size, attr:min{req, int},max{req, int}-->1
</fontSize>
<FontColor>
<!--ro, req, object, font color-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g., 16777215 indicates 0xFFFFFF-->1
</RGB>
</FontColor>
<backgroundType opt="color,picture">
<!--ro, opt, enum, subType:string, attr:opt{req, string}-->color
</backgroundType>
<backPicId min="1" max="1000">
<!--ro, opt, int, background picture ID, attr:min{req, int},max{req, int}-->1
</backPicId>
<BackColor>
<!--ro, req, object, background color-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g., 16777215 indicates 0xFFFFFF-->1
</RGB>
</BackColor>
<backTransparent min="1" max="10">
<!--ro, req, int, background transparency, attr:min{req, int},max{req, int}-->1
</backTransparent>


</backTransparent>
<subtitlesEnabled>
<!--ro, req, bool-->true
</subtitlesEnabled>
<scrollDirection opt="left,right,up,down">
<!--ro, req, enum, character scrolling direction, subType:string, attr:opt{req, string}, desc:character scrolling direction-->left
</scrollDirection>
<scrollSpeed min="1" max="10">
<!--ro, req, int, character scrolling speed, attr:min{req, int},max{req, int}-->1
</scrollSpeed>
</CharactersEffect>
<switchEffect
opt="none,random,rightInLeftOut,leftInRightOut,bottomInTopOut,topInBottomOut,fadeInFadeOut,middleExit,topPop,rightBottomIn,leftTopIn">
<!--ro, opt, enum, switching effect, subType:string, attr:opt{req, string}, desc:switching effect-->random
</switchEffect>
<pageTime min="1" max="10">
<!--ro, opt, int, page turning time, unit:s, attr:min{req, int},max{req, int}, desc:page turning time-->1
</pageTime>
<scrollSpeed min="1" max="10">
<!--ro, req, int, scrolling speed, attr:min{req, int},max{req, int}, desc:scrolling speed-->1
</scrollSpeed>
<scaleType opt="fitXY,fitCenter,centerCrop,originalScale">
<!--ro, opt, enum, subType:string, attr:opt{req, string}-->centerCrop
</scaleType>
</PlayItem>
</PlayItemList>
<enabledAudio opt="true,false">
<!--ro, opt, bool, whether to enable audio, attr:opt{req, string}-->true
</enabledAudio>
<enableHide opt="true,false">
<!--ro, opt, bool, whether to enable hiding, attr:opt{req, string}-->true
</enableHide>
<enableLock opt="true,false">
<!--ro, opt, bool, whether to enable lock, attr:opt{req, string}-->true
</enableLock>
<AppWindow>
<!--ro, opt, object-->
<WindowInfoList size="10">
<!--ro, req, array, subType:object, attr:size{req, int}-->
<WindowInfo>
<!--ro, req, object, window information-->
<id>
<!--ro, req, int, ID-->1
</id>
<materialNo>
<!--ro, req, int, material No.-->1
</materialNo>
</WindowInfo>
</WindowInfoList>
</AppWindow>
<DataSource>
<!--ro, opt, object, data source-->
<materialNo>
<!--ro, req, int, material No.-->1
</materialNo>
</DataSource>
<Call>
<!--ro, opt, object, calling data-->
<materialNo>
<!--ro, req, int, material No.-->1
</materialNo>
<tableRow min="1" max="10">
<!--ro, req, int, row of the table, attr:min{req, int},max{req, int}-->1
</tableRow>
<tableColumn min="1" max="10">
<!--ro, req, int, column of the table, attr:min{req, int},max{req, int}-->1
</tableColumn>
<tableDirection opt="vertical,horizontal">
<!--ro, req, enum, table direction, subType:string, attr:opt{req, string}, desc:"vertical", "horizontal"-->vertical
</tableDirection>
<tableType opt="template1,template2,template3,template4,template5,template6">
<!--ro, req, enum, table template, subType:string, attr:opt{req, string}, desc:"template1”, “template2”, “template3”, “template4”,
“template5”, “template6"-->template1
</tableType>
<backPicId>
<!--ro, opt, int, background picture No.-->1
</backPicId>
<alignType opt="left,right,middle">
<!--ro, req, enum, alignment mode, subType:string, attr:opt{req, string}, desc:alignment mode-->left
</alignType>
<refreshDirection opt="upTodown,downToup ,leftToright,rightToleft">
<!--ro, req, enum, refreshing direction, subType:string, attr:opt{req, string}, desc:refreshing direction-->upTodown
</refreshDirection>
<HeadDataList size="10">
<!--ro, opt, array, subType:object, attr:size{req, int}-->
<HeadData>
<!--ro, opt, object, table head data-->
<id>
<!--ro, req, int, ID-->1
</id>
<data min="1" max="10">
<!--ro, req, string, data, attr:min{req, int},max{req, int}-->test
</data>
</HeadData>


</HeadDataList>
<ItemStyleList size="10">
<!--ro, opt, array, subType:object, attr:size{req, int}-->
<ItemStyle>
<!--ro, opt, object, style of the table's row or column-->
<id>
<!--ro, req, int, ID-->1
</id>
<width min="1" max="10">
<!--ro, req, int, attr:min{req, int},max{req, int}-->1
</width>
<fontSize min="1" max="10">
<!--ro, req, int, font size, attr:min{req, int},max{req, int}-->1
</fontSize>
<FontColor>
<!--ro, req, object, font color-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g., 16777215 indicates 0xFFFFFF-->1
</RGB>
</FontColor>
<BackColor>
<!--ro, req, object, background color-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g., 16777215 indicates 0xFFFFFF-->1
</RGB>
</BackColor>
</ItemStyle>
</ItemStyleList>
</Call>
<DynamicPic>
<!--ro, opt, object, dynamic pop-up window parameters-->
<materialNo>
<!--ro, req, int, material No.-->1
</materialNo>
<backPicId>
<!--ro, opt, int, background picture ID-->1
</backPicId>
</DynamicPic>
<CapturePic>
<!--ro, opt, object, picture capturing parameters-->
<backPicId>
<!--ro, opt, int, background picture ID-->1
</backPicId>
<ipcMaterialNo>
<!--ro, req, int-->1
</ipcMaterialNo>
<cancelType opt="auto,manual">
<!--ro, req, enum, cancel mode, subType:string, attr:opt{req, string}, desc:cancel mode-->manual
</cancelType>
<duration min="1" max="10" default="null">
<!--ro, opt, int, duration, unit:s, attr:min{req, int},max{req, int},default{opt, string}-->1
</duration>
</CapturePic>
<ClockParam>
<!--ro, opt, object-->
<backPicId>
<!--ro, opt, int, background picture ID-->1
</backPicId>
<ClockIcon>
<!--ro, req, object, clock icon parameters-->
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<type opt="clock1,clock2">
<!--ro, opt, enum, clock type, subType:string, attr:opt{req, string}, desc:"clock1", "clock2"-->clock1
</type>
<Position>
<!--ro, opt, object, coordinates, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX min="1" max="10">
<!--ro, req, int, X-coordinate, attr:min{req, int},max{req, int}-->1
</positionX>
<positionY min="1" max="10">
<!--ro, req, int, Y-coordinate, attr:min{req, int},max{req, int}-->1
</positionY>
<height min="1" max="10">
<!--ro, req, int, width, attr:min{req, int},max{req, int}-->1
</height>
<width min="1" max="10">
<!--ro, req, int, height, attr:min{req, int},max{req, int}-->1
</width>
</Position>
</ClockIcon>
<YmdParam>
<!--ro, req, object, the parameters of year, month, and day in the clock-->
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<fontSize min="1" max="10">
<!--ro, req, int, font size, attr:min{req, int},max{req, int}-->1
</fontSize>
<FontColor>
<!--ro, req, object, font color-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g., 16777215 indicates 0xFFFFFF-->1


<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g., 16777215 indicates 0xFFFFFF-->1
</RGB>
</FontColor>
<BackColor>
<!--ro, req, object, background color-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g., 16777215 indicates 0xFFFFFF-->1
</RGB>
</BackColor>
<Position>
<!--ro, opt, object, coordinates, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX min="1" max="10">
<!--ro, req, int, X-coordinate, attr:min{req, int},max{req, int}-->1
</positionX>
<positionY min="1" max="10">
<!--ro, req, int, Y-coordinate, attr:min{req, int},max{req, int}-->1
</positionY>
<height min="1" max="10">
<!--ro, req, int, width, attr:min{req, int},max{req, int}-->1
</height>
<width min="1" max="10">
<!--ro, req, int, height, attr:min{req, int},max{req, int}-->1
</width>
</Position>
</YmdParam>
<HmsParam>
<!--ro, req, object, the parameters of hour, minute, and second in the clock-->
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<fontSize min="1" max="10">
<!--ro, req, int, font size, attr:min{req, int},max{req, int}-->1
</fontSize>
<FontColor>
<!--ro, req, object, font color-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g., 16777215 indicates 0xFFFFFF-->1
</RGB>
</FontColor>
<BackColor>
<!--ro, req, object, background color-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g., 16777215 indicates 0xFFFFFF-->1
</RGB>
</BackColor>
<Position>
<!--ro, opt, object, coordinates, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX min="1" max="10">
<!--ro, req, int, X-coordinate, attr:min{req, int},max{req, int}-->1
</positionX>
<positionY min="1" max="10">
<!--ro, req, int, Y-coordinate, attr:min{req, int},max{req, int}-->1
</positionY>
<height min="1" max="10">
<!--ro, req, int, width, attr:min{req, int},max{req, int}-->1
</height>
<width min="1" max="10">
<!--ro, req, int, height, attr:min{req, int},max{req, int}-->1
</width>
</Position>
</HmsParam>
<WeekParam>
<!--ro, req, object, week parameters-->
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<fontSize min="1" max="10">
<!--ro, req, int, font size, attr:min{req, int},max{req, int}-->1
</fontSize>
<FontColor>
<!--ro, req, object, font color-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g., 16777215 indicates 0xFFFFFF-->1
</RGB>
</FontColor>
<BackColor>
<!--ro, req, object, background color-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g., 16777215 indicates 0xFFFFFF-->1
</RGB>
</BackColor>
<Position>
<!--ro, opt, object, coordinates, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX min="1" max="10">
<!--ro, req, int, X-coordinate, attr:min{req, int},max{req, int}-->1
</positionX>
<positionY min="1" max="10">
<!--ro, req, int, Y-coordinate, attr:min{req, int},max{req, int}-->1
</positionY>
<height min="1" max="10">
<!--ro, req, int, width, attr:min{req, int},max{req, int}-->1
</height>
<width min="1" max="10">
<!--ro, req, int, height, attr:min{req, int},max{req, int}-->1


<!--ro, req, int, height, attr:min{req, int},max{req, int}-->1
</width>
</Position>
</WeekParam>
</ClockParam>
<WeatherParam>
<!--ro, opt, object, weather parameters-->
<backPicId>
<!--ro, opt, int, control's background picture-->1
</backPicId>
<WeatherIcon>
<!--ro, opt, object, weather icon parameters-->
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<Position>
<!--ro, opt, object, coordinates, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX min="1" max="10">
<!--ro, req, int, X-coordinate, attr:min{req, int},max{req, int}-->1
</positionX>
<positionY min="1" max="10">
<!--ro, req, int, Y-coordinate, attr:min{req, int},max{req, int}-->1
</positionY>
<height min="1" max="10">
<!--ro, req, int, width, attr:min{req, int},max{req, int}-->1
</height>
<width min="1" max="10">
<!--ro, req, int, height, attr:min{req, int},max{req, int}-->1
</width>
</Position>
</WeatherIcon>
<Date>
<!--ro, opt, object, date parameters-->
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<fontSize min="1" max="10">
<!--ro, req, int, font size, attr:min{req, int},max{req, int}-->1
</fontSize>
<FontColor>
<!--ro, req, object, font color-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g., 16777215 indicates 0xFFFFFF-->1
</RGB>
</FontColor>
<BackColor>
<!--ro, req, object, background color-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g., 16777215 indicates 0xFFFFFF-->1
</RGB>
</BackColor>
<Position>
<!--ro, opt, object, coordinates, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX min="1" max="10">
<!--ro, req, int, X-coordinate, attr:min{req, int},max{req, int}-->1
</positionX>
<positionY min="1" max="10">
<!--ro, req, int, Y-coordinate, attr:min{req, int},max{req, int}-->1
</positionY>
<height min="1" max="10">
<!--ro, req, int, width, attr:min{req, int},max{req, int}-->1
</height>
<width min="1" max="10">
<!--ro, req, int, height, attr:min{req, int},max{req, int}-->1
</width>
</Position>
</Date>
<Temperature>
<!--ro, opt, object, temperature parameters-->
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<fontSize min="1" max="10">
<!--ro, req, int, font size, attr:min{req, int},max{req, int}-->1
</fontSize>
<FontColor>
<!--ro, req, object, font color-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g., 16777215 indicates 0xFFFFFF-->1
</RGB>
</FontColor>
<BackColor>
<!--ro, req, object, background color-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g., 16777215 indicates 0xFFFFFF-->1
</RGB>
</BackColor>
<Position>
<!--ro, opt, object, coordinates, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX min="1" max="10">
<!--ro, req, int, X-coordinate, attr:min{req, int},max{req, int}-->1
</positionX>
<positionY min="1" max="10">
<!--ro, req, int, Y-coordinate, attr:min{req, int},max{req, int}-->1
</positionY>


</positionY>
<height min="1" max="10">
<!--ro, req, int, width, attr:min{req, int},max{req, int}-->1
</height>
<width min="1" max="10">
<!--ro, req, int, height, attr:min{req, int},max{req, int}-->1
</width>
</Position>
</Temperature>
<WeatherContent>
<!--ro, opt, object, weather parameters-->
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<fontSize min="1" max="10">
<!--ro, req, int, font size, attr:min{req, int},max{req, int}-->1
</fontSize>
<FontColor>
<!--ro, req, object, font color-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g., 16777215 indicates 0xFFFFFF-->1
</RGB>
</FontColor>
<BackColor>
<!--ro, req, object, background color-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g., 16777215 indicates 0xFFFFFF-->1
</RGB>
</BackColor>
<Position>
<!--ro, opt, object, coordinates, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX min="1" max="10">
<!--ro, req, int, X-coordinate, attr:min{req, int},max{req, int}-->1
</positionX>
<positionY min="1" max="10">
<!--ro, req, int, Y-coordinate, attr:min{req, int},max{req, int}-->1
</positionY>
<height min="1" max="10">
<!--ro, req, int, width, attr:min{req, int},max{req, int}-->1
</height>
<width min="1" max="10">
<!--ro, req, int, height, attr:min{req, int},max{req, int}-->1
</width>
</Position>
</WeatherContent>
<City>
<!--ro, opt, object-->
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<cityId min="1" max="10">
<!--ro, req, string, attr:min{req, int},max{req, int}-->test
</cityId>
<cityName min="1" max="10">
<!--ro, req, string, city name, attr:min{req, int},max{req, int}-->test
</cityName>
<fontSize min="1" max="10">
<!--ro, req, int, font size, attr:min{req, int},max{req, int}-->1
</fontSize>
<FontColor>
<!--ro, req, object, font color-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g., 16777215 indicates 0xFFFFFF-->1
</RGB>
</FontColor>
<BackColor>
<!--ro, req, object, background color-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g., 16777215 indicates 0xFFFFFF-->1
</RGB>
</BackColor>
<Position>
<!--ro, opt, object, coordinates, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX min="1" max="10">
<!--ro, req, int, X-coordinate, attr:min{req, int},max{req, int}-->1
</positionX>
<positionY min="1" max="10">
<!--ro, req, int, Y-coordinate, attr:min{req, int},max{req, int}-->1
</positionY>
<height min="1" max="10">
<!--ro, req, int, width, attr:min{req, int},max{req, int}-->1
</height>
<width min="1" max="10">
<!--ro, req, int, height, attr:min{req, int},max{req, int}-->1
</width>
</Position>
</City>
<Humidity>
<!--ro, opt, object, humidity parameters-->
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<fontSize min="1" max="10">
<!--ro, req, int, font size, attr:min{req, int},max{req, int}-->1


<!--ro, req, int, font size, attr:min{req, int},max{req, int}-->1
</fontSize>
<FontColor>
<!--ro, req, object, font color-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g., 16777215 indicates 0xFFFFFF-->1
</RGB>
</FontColor>
<BackColor>
<!--ro, req, object, background color-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g., 16777215 indicates 0xFFFFFF-->1
</RGB>
</BackColor>
<Position>
<!--ro, opt, object, coordinates, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX min="1" max="10">
<!--ro, req, int, X-coordinate, attr:min{req, int},max{req, int}-->1
</positionX>
<positionY min="1" max="10">
<!--ro, req, int, Y-coordinate, attr:min{req, int},max{req, int}-->1
</positionY>
<height min="1" max="10">
<!--ro, req, int, width, attr:min{req, int},max{req, int}-->1
</height>
<width min="1" max="10">
<!--ro, req, int, height, attr:min{req, int},max{req, int}-->1
</width>
</Position>
</Humidity>
<AirQuality>
<!--ro, opt, object, air quality parameters-->
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<fontSize min="1" max="10">
<!--ro, req, int, font size, attr:min{req, int},max{req, int}-->1
</fontSize>
<FontColor>
<!--ro, req, object, font color-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g., 16777215 indicates 0xFFFFFF-->1
</RGB>
</FontColor>
<BackColor>
<!--ro, req, object, background color-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g., 16777215 indicates 0xFFFFFF-->1
</RGB>
</BackColor>
<Position>
<!--ro, opt, object, coordinates, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX min="1" max="10">
<!--ro, req, int, X-coordinate, attr:min{req, int},max{req, int}-->1
</positionX>
<positionY min="1" max="10">
<!--ro, req, int, Y-coordinate, attr:min{req, int},max{req, int}-->1
</positionY>
<height min="1" max="10">
<!--ro, req, int, width, attr:min{req, int},max{req, int}-->1
</height>
<width min="1" max="10">
<!--ro, req, int, height, attr:min{req, int},max{req, int}-->1
</width>
</Position>
</AirQuality>
<UpdateTime>
<!--ro, opt, object-->
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<refreshTime>
<!--ro, req, string, refreshing time, desc:refreshing time-->20200826T051500+08
</refreshTime>
<updateInterval min="1" max="10">
<!--ro, req, int, refresh interval, unit:minute, attr:min{req, int},max{req, int}-->1
</updateInterval>
<fontSize min="1" max="10">
<!--ro, req, int, font size, attr:min{req, int},max{req, int}-->1
</fontSize>
<FontColor>
<!--ro, req, object, font color-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g., 16777215 indicates 0xFFFFFF-->1
</RGB>
</FontColor>
<BackColor>
<!--ro, req, object, background color-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g., 16777215 indicates 0xFFFFFF-->1
</RGB>
</BackColor>
<Position>
<!--ro, opt, object, coordinates, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->


<positionX min="1" max="10">
<!--ro, req, int, X-coordinate, attr:min{req, int},max{req, int}-->1
</positionX>
<positionY min="1" max="10">
<!--ro, req, int, Y-coordinate, attr:min{req, int},max{req, int}-->1
</positionY>
<height min="1" max="10">
<!--ro, req, int, width, attr:min{req, int},max{req, int}-->1
</height>
<width min="1" max="10">
<!--ro, req, int, height, attr:min{req, int},max{req, int}-->1
</width>
</Position>
</UpdateTime>
<Wind>
<!--ro, opt, object, wind power parameters-->
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<fontSize min="1" max="10">
<!--ro, req, int, font size, attr:min{req, int},max{req, int}-->1
</fontSize>
<FontColor>
<!--ro, req, object, font color-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g., 16777215 indicates 0xFFFFFF-->1
</RGB>
</FontColor>
<BackColor>
<!--ro, req, object, background color-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g., 16777215 indicates 0xFFFFFF-->1
</RGB>
</BackColor>
<Position>
<!--ro, opt, object, coordinates, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX min="1" max="10">
<!--ro, req, int, X-coordinate, attr:min{req, int},max{req, int}-->1
</positionX>
<positionY min="1" max="10">
<!--ro, req, int, Y-coordinate, attr:min{req, int},max{req, int}-->1
</positionY>
<height min="1" max="10">
<!--ro, req, int, width, attr:min{req, int},max{req, int}-->1
</height>
<width min="1" max="10">
<!--ro, req, int, height, attr:min{req, int},max{req, int}-->1
</width>
</Position>
</Wind>
</WeatherParam>
<Countdown>
<!--ro, opt, object, countdown material-->
<endTime>
<!--ro, req, string, countdown time, desc:countdown time-->20200826T051500+08
</endTime>
<template
opt="template1,template2,openingActivity1,openingActivity2,commercialActivity1,commercialActivity2,salesPromotion,collegeEntranceExam,overseasTimeFormat">
<!--ro, req, enum, template, subType:string, attr:opt{req, string}-->template1
</template>
<timeUnit opt="year,month,day,week,hour,minute,second">
<!--ro, req, enum, time unit, subType:string, attr:opt{req, string}-->year
</timeUnit>
<backPicId>
<!--ro, opt, int, background picture ID-->1
</backPicId>
<TimeFontCfg>
<!--ro, opt, object-->
<fontSize min="1" max="10">
<!--ro, req, int, font size, attr:min{req, int},max{req, int}-->1
</fontSize>
<FontColor>
<!--ro, req, object, font color-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g., 16777215 indicates 0xFFFFFF-->1
</RGB>
</FontColor>
<Position>
<!--ro, opt, object, coordinates, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX min="1" max="10">
<!--ro, req, int, X-coordinate, attr:min{req, int},max{req, int}-->1
</positionX>
<positionY min="1" max="10">
<!--ro, req, int, Y-coordinate, attr:min{req, int},max{req, int}-->1
</positionY>
<height min="1" max="10">
<!--ro, req, int, width, attr:min{req, int},max{req, int}-->1
</height>
<width min="1" max="10">
<!--ro, req, int, height, attr:min{req, int},max{req, int}-->1
</width>
</Position>
</TimeFontCfg>
<timeUnitEnabled opt="true,false">


<timeUnitEnabled opt="true,false">
<!--ro, opt, bool, attr:opt{req, string}-->true
</timeUnitEnabled>
</Countdown>
<localInputNo opt="VGA,HDMI">
<!--ro, req, enum, subType:string, attr:opt{req, string}-->VGA
</localInputNo>
<HyperlinkBtn>
<!--ro, opt, object-->
<backPicId>
<!--ro, opt, int, background picture ID-->1
</backPicId>
</HyperlinkBtn>
<CharactersAttribute>
<!--ro, opt, object, character attribute, desc:this node is valid when <dynamicType> is character-->
<fontSize min="1" max="10">
<!--ro, req, int, font size, attr:min{req, int},max{req, int}-->1
</fontSize>
<FontColor>
<!--ro, req, object, font color-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g., 16777215 indicates 0xFFFFFF-->1
</RGB>
</FontColor>
<backgroundType opt="color,picture">
<!--ro, req, enum, subType:string, attr:opt{req, string}-->color
</backgroundType>
<BackColor>
<!--ro, req, object, background color-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g., 16777215 indicates 0xFFFFFF-->1
</RGB>
<fillEnabled opt="true,false">
<!--ro, opt, bool, attr:opt{req, string}-->true
</fillEnabled>
</BackColor>
<backTransparent min="1" max="10">
<!--ro, opt, int, background transparency, attr:min{req, int},max{req, int}-->1
</backTransparent>
<alignType opt="left,right,middle">
<!--ro, req, enum, alignment mode, subType:string, attr:opt{req, string}, desc:alignment mode-->middle
</alignType>
<verticaAlignType opt="top,bottom,verticalCenter">
<!--ro, req, enum, vertical alignment mode, subType:string, attr:opt{req, string}, desc:vertical alignment mode-->top
</verticaAlignType>
<characterContent min="1" max="512">
<!--ro, opt, string, text content, range:[0,512], attr:min{req, int},max{req, int}-->test
</characterContent>
<backPicId min="1" max="10">
<!--ro, opt, int, background picture ID, attr:min{req, int},max{req, int}-->1
</backPicId>
<characterStyle opt="normal,bold">
<!--ro, req, enum, subType:string, attr:opt{req, string}-->normal
</characterStyle>
<characterType opt="mainTitle,subTitle,subTitle2">
<!--ro, req, enum, font type, subType:string, attr:opt{req, string}, desc:font type-->mainTitle
</characterType>
<scrollDirection opt="left,right,up,down,turePage">
<!--ro, opt, enum, character scrolling direction, subType:string, attr:opt{req, string}, desc:character scrolling direction-->left
</scrollDirection>
<scrollSpeed min="1" max="10">
<!--ro, opt, int, character scrolling speed, range:[1,10], attr:min{req, int, range:[1,10]},max{req, int, range:[1,10]}-->1
</scrollSpeed>
</CharactersAttribute>
<SignIn>
<!--ro, opt, object-->
<backPicId>
<!--ro, opt, int, background picture ID-->1
</backPicId>
<ShowInfo>
<!--ro, opt, object-->
<row min="1" max="10">
<!--ro, opt, int, attr:min{req, int},max{req, int}-->1
</row>
<column min="1" max="10">
<!--ro, opt, int, attr:min{req, int},max{req, int}-->1
</column>
<Position>
<!--ro, opt, object, coordinates, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX min="1" max="10">
<!--ro, req, int, X-coordinate, attr:min{req, int},max{req, int}-->1
</positionX>
<positionY min="1" max="10">
<!--ro, req, int, Y-coordinate, attr:min{req, int},max{req, int}-->1
</positionY>
<height min="1" max="10">
<!--ro, req, int, width, attr:min{req, int},max{req, int}-->1
</height>
<width min="1" max="10">
<!--ro, req, int, height, attr:min{req, int},max{req, int}-->1
</width>
</Position>
<inLib>
<!--ro, opt, object-->


<nameEnabled opt="true,false">
<!--ro, opt, bool, attr:opt{req, string}-->true
</nameEnabled>
<genderEnabled opt="true,false">
<!--ro, opt, bool, attr:opt{req, string}-->true
</genderEnabled>
<selfDefine1Enabled opt="true,false">
<!--ro, opt, bool, attr:opt{req, string}-->true
</selfDefine1Enabled>
<selfDefine2Enabled opt="true,false">
<!--ro, opt, bool, attr:opt{req, string}-->true
</selfDefine2Enabled>
<signInTimeEnabled opt="true,false">
<!--ro, opt, bool, attr:opt{req, string}-->true
</signInTimeEnabled>
<temperatureEnabled opt="true,false">
<!--ro, opt, bool, attr:opt{req, string}-->true
</temperatureEnabled>
</inLib>
<outLib>
<!--ro, opt, object-->
<nameEnabled opt="true,false">
<!--ro, opt, bool, attr:opt{req, string}-->true
</nameEnabled>
<name min="1" max="10">
<!--ro, opt, string, attr:min{req, int},max{req, int}-->test
</name>
<genderEnabled opt="true,false">
<!--ro, opt, bool, attr:opt{req, string}-->true
</genderEnabled>
<signInTimeEnabled opt="true,false">
<!--ro, opt, bool, attr:opt{req, string}-->true
</signInTimeEnabled>
<temperatureEnabled opt="true,false">
<!--ro, opt, bool, attr:opt{req, string}-->true
</temperatureEnabled>
</outLib>
<showDuration opt="always,10s,20s,30s,no">
<!--ro, req, enum, subType:string, attr:opt{req, string}-->always
</showDuration>
</ShowInfo>
<MainTitle>
<!--ro, opt, object-->
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<fontSize min="1" max="10">
<!--ro, req, int, font size, attr:min{req, int},max{req, int}-->1
</fontSize>
<FontColor>
<!--ro, req, object, font color-->
<RGB>
<!--ro, opt, int, three primary colors in decimal format-->1
</RGB>
</FontColor>
<text min="1" max="10">
<!--ro, opt, string, attr:min{req, int},max{req, int}-->test
</text>
</MainTitle>
<SubTitle>
<!--ro, opt, object-->
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<fontSize min="1" max="10">
<!--ro, req, int, font size, attr:min{req, int},max{req, int}-->1
</fontSize>
<FontColor>
<!--ro, req, object, font color-->
<RGB>
<!--ro, opt, int, three primary colors in decimal format-->1
</RGB>
</FontColor>
<text min="1" max="10">
<!--ro, opt, string, attr:min{req, int},max{req, int}-->test
</text>
</SubTitle>
<NormalTemperature>
<!--ro, opt, object-->
<PeopleNumber>
<!--ro, opt, object-->
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<fontSize min="1" max="10">
<!--ro, req, int, font size, attr:min{req, int},max{req, int}-->1
</fontSize>
<FontColor>
<!--ro, req, object, font color-->
<RGB>
<!--ro, opt, int, three primary colors in decimal format-->1
</RGB>
</FontColor>
<Position>


<Position>
<!--ro, opt, object, coordinates, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution->
<positionX
min="1" max="10">
<!--ro, req, int, X-coordinate, attr:min{req, int},max{req, int}-->1
</positionX>
<positionY min="1" max="10">
<!--ro, req, int, Y-coordinate, attr:min{req, int},max{req, int}-->1
</positionY>
<height min="1" max="10">
<!--ro, req, int, width, attr:min{req, int},max{req, int}-->1
</height>
<width min="1" max="10">
<!--ro, req, int, height, attr:min{req, int},max{req, int}-->1
</width>
</Position>
<text min="1" max="10">
<!--ro, opt, string, attr:min{req, int},max{req, int}-->test
</text>
</PeopleNumber>
<Icon>
<!--ro, opt, object-->
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<Position>
<!--ro, opt, object, coordinates, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution->
<positionX
min="1" max="10">
<!--ro, req, int, X-coordinate, attr:min{req, int},max{req, int}-->1
</positionX>
<positionY min="1" max="10">
<!--ro, req, int, Y-coordinate, attr:min{req, int},max{req, int}-->1
</positionY>
<height min="1" max="10">
<!--ro, req, int, width, attr:min{req, int},max{req, int}-->1
</height>
<width min="1" max="10">
<!--ro, req, int, height, attr:min{req, int},max{req, int}-->1
</width>
</Position>
<materialNo min="1" max="10">
<!--ro, opt, int, material ID, attr:min{req, int},max{req, int}-->1
</materialNo>
</Icon>
</NormalTemperature>
<AbnormalTemperature>
<!--ro, opt, object-->
<PeopleNumber>
<!--ro, opt, object-->
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<fontSize min="1" max="10">
<!--ro, req, int, font size, attr:min{req, int},max{req, int}-->1
</fontSize>
<FontColor>
<!--ro, req, object, font color-->
<RGB>
<!--ro, opt, int, three primary colors in decimal format-->1
</RGB>
</FontColor>
<Position>
<!--ro, opt, object, coordinates, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution->
<positionX
min="1" max="10">
<!--ro, req, int, X-coordinate, attr:min{req, int},max{req, int}-->1
</positionX>
<positionY min="1" max="10">
<!--ro, req, int, Y-coordinate, attr:min{req, int},max{req, int}-->1
</positionY>
<height min="1" max="10">
<!--ro, req, int, width, attr:min{req, int},max{req, int}-->1
</height>
<width min="1" max="10">
<!--ro, req, int, height, attr:min{req, int},max{req, int}-->1
</width>
</Position>
<text min="1" max="10">
<!--ro, opt, string, attr:min{req, int},max{req, int}-->test
</text>
</PeopleNumber>
<Icon>
<!--ro, opt, object-->
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<Position>
<!--ro, opt, object, coordinates, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution->
<positionX
min="1" max="10">
<!--ro, req, int, X-coordinate, attr:min{req, int},max{req, int}-->1
</positionX>
<positionY min="1" max="10">


<positionY min="1" max="10">
<!--ro, req, int, Y-coordinate, attr:min{req, int},max{req, int}-->1
</positionY>
<height min="1" max="10">
<!--ro, req, int, width, attr:min{req, int},max{req, int}-->1
</height>
<width min="1" max="10">
<!--ro, req, int, height, attr:min{req, int},max{req, int}-->1
</width>
</Position>
<materialNo min="1" max="10">
<!--ro, opt, int, material ID, attr:min{req, int},max{req, int}-->1
</materialNo>
</Icon>
</AbnormalTemperature>
</SignIn>
<EventParam>
<!--ro, opt, object, event parameters-->
<EventResourceList size="10">
<!--ro, opt, array, subType:object, attr:size{req, int}-->
<EventResource>
<!--ro, opt, object-->
<ipVersion opt="v4,v6,dual">
<!--ro, req, enum, IP address version, subType:string, attr:opt{req, string}-->v4
</ipVersion>
<ipAddress>
<!--ro, opt, string, IPv4 address-->test
</ipAddress>
<ipv6Address>
<!--ro, opt, string, IPv6 address-->test
</ipv6Address>
<portNo>
<!--ro, req, int, port No.-->1
</portNo>
<userName min="1" max="10">
<!--ro, req, string, user name, attr:min{req, int},max{req, int}-->test
</userName>
<passWord min="1" max="10">
<!--ro, req, string, password, attr:min{req, int},max{req, int}-->test
</passWord>
<BindIPC>
<!--ro, opt, string, channel No., desc:channel No.-->1,2
</BindIPC>
</EventResource>
</EventResourceList>
<backPicId>
<!--ro, opt, int, background picture ID-->1
</backPicId>
<Title>
<!--ro, opt, object, title-->
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<fontSize min="1" max="10">
<!--ro, req, int, font size, attr:min{req, int},max{req, int}-->1
</fontSize>
<FontColor>
<!--ro, req, object, font color-->
<RGB>
<!--ro, opt, int, three primary colors in decimal format-->1
</RGB>
</FontColor>
<Position>
<!--ro, opt, object, coordinates, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX min="1" max="10">
<!--ro, req, int, X-coordinate, attr:min{req, int},max{req, int}-->1
</positionX>
<positionY min="1" max="10">
<!--ro, req, int, Y-coordinate, attr:min{req, int},max{req, int}-->1
</positionY>
<height min="1" max="10">
<!--ro, req, int, width, attr:min{req, int},max{req, int}-->1
</height>
<width min="1" max="10">
<!--ro, req, int, height, attr:min{req, int},max{req, int}-->1
</width>
</Position>
<text min="1" max="10">
<!--ro, opt, string, attr:min{req, int},max{req, int}-->test
</text>
</Title>
<PeopleCounting>
<!--ro, opt, object-->
<maxPeopleNumber min="1" max="10">
<!--ro, opt, int, attr:min{req, int},max{req, int}-->1
</maxPeopleNumber>
<unavailableBackPicId>
<!--ro, opt, int-->1
</unavailableBackPicId>
<supportChangeByPeople opt="prompt,peopleIcon,availablePeopleNumber">
<!--ro, req, enum, subType:string, attr:opt{req, string}-->prompt
</supportChangeByPeople>
<Prompt>
<!--ro, opt, object, Prompt-->
<enabled>


<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<fontSize min="1" max="10">
<!--ro, req, int, font size, attr:min{req, int},max{req, int}-->1
</fontSize>
<Position>
<!--ro, opt, object, coordinates, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution->
<positionX
min="1" max="10">
<!--ro, req, int, X-coordinate, attr:min{req, int},max{req, int}-->1
</positionX>
<positionY min="1" max="10">
<!--ro, req, int, Y-coordinate, attr:min{req, int},max{req, int}-->1
</positionY>
<height min="1" max="10">
<!--ro, req, int, width, attr:min{req, int},max{req, int}-->1
</height>
<width min="1" max="10">
<!--ro, req, int, height, attr:min{req, int},max{req, int}-->1
</width>
</Position>
<text min="1" max="10">
<!--ro, opt, string, attr:min{req, int},max{req, int}-->test
</text>
<FontColor>
<!--ro, opt, object, font color-->
<RGB>
<!--ro, opt, int, three primary colors in decimal format-->1
</RGB>
</FontColor>
<unavailableText min="1" max="10">
<!--ro, opt, string, attr:min{req, int},max{req, int}-->test
</unavailableText>
<UnavailableFontColor>
<!--ro, opt, object-->
<RGB>
<!--ro, opt, int, three primary colors in decimal format-->1
</RGB>
</UnavailableFontColor>
</Prompt>
<PeopleIcon>
<!--ro, opt, object-->
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<Position>
<!--ro, opt, object, coordinates, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution->
<positionX
min="1" max="10">
<!--ro, req, int, X-coordinate, attr:min{req, int},max{req, int}-->1
</positionX>
<positionY min="1" max="10">
<!--ro, req, int, Y-coordinate, attr:min{req, int},max{req, int}-->1
</positionY>
<height min="1" max="10">
<!--ro, req, int, width, attr:min{req, int},max{req, int}-->1
</height>
<width min="1" max="10">
<!--ro, req, int, height, attr:min{req, int},max{req, int}-->1
</width>
</Position>
<materialNo min="1" max="10">
<!--ro, opt, int, material ID, attr:min{req, int},max{req, int}-->1
</materialNo>
</PeopleIcon>
<InsidePeopleTitle>
<!--ro, opt, object-->
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<fontSize min="1" max="10">
<!--ro, req, int, font size, attr:min{req, int},max{req, int}-->1
</fontSize>
<FontColor>
<!--ro, req, object, font color-->
<RGB>
<!--ro, opt, int, three primary colors in decimal format-->1
</RGB>
</FontColor>
<Position>
<!--ro, opt, object, coordinates, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution->
<positionX
min="1" max="10">
<!--ro, req, int, X-coordinate, attr:min{req, int},max{req, int}-->1
</positionX>
<positionY min="1" max="10">
<!--ro, req, int, Y-coordinate, attr:min{req, int},max{req, int}-->1
</positionY>
<height min="1" max="10">
<!--ro, req, int, width, attr:min{req, int},max{req, int}-->1
</height>
<width min="1" max="10">
<!--ro, req, int, height, attr:min{req, int},max{req, int}-->1


<!--ro, req, int, height, attr:min{req, int},max{req, int}-->1
</width>
</Position>
<text min="1" max="10">
<!--ro, opt, string, attr:min{req, int},max{req, int}-->test
</text>
</InsidePeopleTitle>
<InsidePeopleNumber>
<!--ro, opt, object-->
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<fontSize min="1" max="10">
<!--ro, req, int, font size, attr:min{req, int},max{req, int}-->1
</fontSize>
<FontColor>
<!--ro, req, object, font color-->
<RGB>
<!--ro, opt, int, three primary colors in decimal format-->1
</RGB>
</FontColor>
<Position>
<!--ro, opt, object, coordinates, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution->
<positionX
min="1" max="10">
<!--ro, req, int, X-coordinate, attr:min{req, int},max{req, int}-->1
</positionX>
<positionY min="1" max="10">
<!--ro, req, int, Y-coordinate, attr:min{req, int},max{req, int}-->1
</positionY>
<height min="1" max="10">
<!--ro, req, int, width, attr:min{req, int},max{req, int}-->1
</height>
<width min="1" max="10">
<!--ro, req, int, height, attr:min{req, int},max{req, int}-->1
</width>
</Position>
</InsidePeopleNumber>
<AvailablePeopleTitle>
<!--ro, opt, object-->
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<fontSize min="1" max="10">
<!--ro, req, int, font size, attr:min{req, int},max{req, int}-->1
</fontSize>
<FontColor>
<!--ro, req, object, font color-->
<RGB>
<!--ro, opt, int, three primary colors in decimal format-->1
</RGB>
</FontColor>
<Position>
<!--ro, opt, object, coordinates, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution->
<positionX
min="1" max="10">
<!--ro, req, int, X-coordinate, attr:min{req, int},max{req, int}-->1
</positionX>
<positionY min="1" max="10">
<!--ro, req, int, Y-coordinate, attr:min{req, int},max{req, int}-->1
</positionY>
<height min="1" max="10">
<!--ro, req, int, width, attr:min{req, int},max{req, int}-->1
</height>
<width min="1" max="10">
<!--ro, req, int, height, attr:min{req, int},max{req, int}-->1
</width>
</Position>
<text min="1" max="10">
<!--ro, opt, string, attr:min{req, int},max{req, int}-->test
</text>
</AvailablePeopleTitle>
<AvailablePeopleNumber>
<!--ro, opt, object-->
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<fontSize min="1" max="10">
<!--ro, req, int, font size, attr:min{req, int},max{req, int}-->1
</fontSize>
<Position>
<!--ro, opt, object, coordinates, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution->
<positionX
min="1" max="10">
<!--ro, req, int, X-coordinate, attr:min{req, int},max{req, int}-->1
</positionX>
<positionY min="1" max="10">
<!--ro, req, int, Y-coordinate, attr:min{req, int},max{req, int}-->1
</positionY>
<height min="1" max="10">
<!--ro, req, int, width, attr:min{req, int},max{req, int}-->1
</height>
<width min="1" max="10">
<!--ro, req, int, height, attr:min{req, int},max{req, int}-->1


</width>
</Position>
<FontColor>
<!--ro, opt, object, font color-->
<RGB>
<!--ro, opt, int, three primary colors in decimal format-->1
</RGB>
</FontColor>
<UnavailableFontColor>
<!--ro, opt, object-->
<RGB>
<!--ro, opt, int, three primary colors in decimal format-->1
</RGB>
</UnavailableFontColor>
</AvailablePeopleNumber>
<UnavailablePeopleIcon>
<!--ro, opt, object-->
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<Position>
<!--ro, opt, object, coordinates, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution->
<positionX
min="1" max="10">
<!--ro, req, int, X-coordinate, attr:min{req, int},max{req, int}-->1
</positionX>
<positionY min="1" max="10">
<!--ro, req, int, Y-coordinate, attr:min{req, int},max{req, int}-->1
</positionY>
<height min="1" max="10">
<!--ro, req, int, width, attr:min{req, int},max{req, int}-->1
</height>
<width min="1" max="10">
<!--ro, req, int, height, attr:min{req, int},max{req, int}-->1
</width>
</Position>
<materialNo min="1" max="10">
<!--ro, opt, int, material ID, attr:min{req, int},max{req, int}-->1
</materialNo>
</UnavailablePeopleIcon>
<AudioAlarm>
<!--ro, opt, object-->
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<materialNo min="1" max="10">
<!--ro, opt, int, material index No., attr:min{req, int},max{req, int}-->1
</materialNo>
</AudioAlarm>
</PeopleCounting>
<Mask>
<!--ro, opt, object-->
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<fontSize min="1" max="10">
<!--ro, req, int, font size, attr:min{req, int},max{req, int}-->1
</fontSize>
<FontColor>
<!--ro, req, object, font color-->
<RGB>
<!--ro, opt, int, three primary colors in decimal format-->1
</RGB>
</FontColor>
<BackColor>
<!--ro, req, object, background color-->
<RGB>
<!--ro, opt, int, three primary colors in decimal format-->1
</RGB>
</BackColor>
<Position>
<!--ro, opt, object, coordinates, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX min="1" max="10">
<!--ro, req, int, X-coordinate, attr:min{req, int},max{req, int}-->1
</positionX>
<positionY min="1" max="10">
<!--ro, req, int, Y-coordinate, attr:min{req, int},max{req, int}-->1
</positionY>
<height min="1" max="10">
<!--ro, req, int, width, attr:min{req, int},max{req, int}-->1
</height>
<width min="1" max="10">
<!--ro, req, int, height, attr:min{req, int},max{req, int}-->1
</width>
</Position>
<text min="1" max="10">
<!--ro, opt, string, attr:min{req, int},max{req, int}-->test
</text>
<MaskIcon>
<!--ro, opt, object-->
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<Position>


<Position>
<!--ro, opt, object, coordinates, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution->
<positionX
min="1" max="10">
<!--ro, req, int, X-coordinate, attr:min{req, int},max{req, int}-->1
</positionX>
<positionY min="1" max="10">
<!--ro, req, int, Y-coordinate, attr:min{req, int},max{req, int}-->1
</positionY>
<height min="1" max="10">
<!--ro, req, int, width, attr:min{req, int},max{req, int}-->1
</height>
<width min="1" max="10">
<!--ro, req, int, height, attr:min{req, int},max{req, int}-->1
</width>
</Position>
<materialNo min="1" max="10">
<!--ro, opt, int, material ID, attr:min{req, int},max{req, int}-->1
</materialNo>
</MaskIcon>
<AudioAlarm>
<!--ro, opt, object-->
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<materialNo min="1" max="10">
<!--ro, opt, int, material index No., attr:min{req, int},max{req, int}-->1
</materialNo>
</AudioAlarm>
</Mask>
<Temperature>
<!--ro, opt, object, temperature parameters-->
<Prompt>
<!--ro, opt, object, Prompt-->
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<fontSize min="1" max="10">
<!--ro, req, int, font size, attr:min{req, int},max{req, int}-->1
</fontSize>
<FontColor>
<!--ro, req, object, font color-->
<RGB>
<!--ro, opt, int, three primary colors in decimal format-->1
</RGB>
</FontColor>
<BackColor>
<!--ro, req, object, background color-->
<RGB>
<!--ro, opt, int, three primary colors in decimal format-->1
</RGB>
</BackColor>
<Position>
<!--ro, opt, object, coordinates, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution->
<positionX
min="1" max="10">
<!--ro, req, int, X-coordinate, attr:min{req, int},max{req, int}-->1
</positionX>
<positionY min="1" max="10">
<!--ro, req, int, Y-coordinate, attr:min{req, int},max{req, int}-->1
</positionY>
<height min="1" max="10">
<!--ro, req, int, width, attr:min{req, int},max{req, int}-->1
</height>
<width min="1" max="10">
<!--ro, req, int, height, attr:min{req, int},max{req, int}-->1
</width>
</Position>
<text min="1" max="10">
<!--ro, opt, string, attr:min{req, int},max{req, int}-->test
</text>
</Prompt>
<TemperatureIcon>
<!--ro, opt, object-->
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<Position>
<!--ro, opt, object, coordinates, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution->
<positionX
min="1" max="10">
<!--ro, req, int, X-coordinate, attr:min{req, int},max{req, int}-->1
</positionX>
<positionY min="1" max="10">
<!--ro, req, int, Y-coordinate, attr:min{req, int},max{req, int}-->1
</positionY>
<height min="1" max="10">
<!--ro, req, int, width, attr:min{req, int},max{req, int}-->1
</height>
<width min="1" max="10">
<!--ro, req, int, height, attr:min{req, int},max{req, int}-->1
</width>
</Position>
<materialNo min="1" max="10">


<!--ro, opt, int, material ID, attr:min{req, int},max{req, int}-->1
</materialNo>
</TemperatureIcon>
<AudioAlarm>
<!--ro, opt, object-->
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<materialNo min="1" max="10">
<!--ro, opt, int, material index No., attr:min{req, int},max{req, int}-->1
</materialNo>
</AudioAlarm>
<abnormalHighTemperature min="1" max="10">
<!--ro, opt, float, unit:℃, attr:min{req, int},max{req, int}-->37.5
</abnormalHighTemperature>
</Temperature>
</EventParam>
<ConferenceParam>
<!--ro, opt, object, meeting information, desc:meeting information-->
<backPicId>
<!--ro, opt, int, background picture ID-->1
</backPicId>
<Title>
<!--ro, opt, object-->
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<fontSize min="1" max="10">
<!--ro, req, int, font size, attr:min{req, int},max{req, int}-->1
</fontSize>
<FontColor>
<!--ro, req, object, font color-->
<RGB>
<!--ro, opt, int, three primary colors in decimal format-->1
</RGB>
</FontColor>
<BackColor>
<!--ro, req, object, background color-->
<RGB>
<!--ro, opt, int, three primary colors in decimal format-->1
</RGB>
</BackColor>
<Position>
<!--ro, opt, object, coordinates, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX min="1" max="10">
<!--ro, req, int, X-coordinate, attr:min{req, int},max{req, int}-->1
</positionX>
<positionY min="1" max="10">
<!--ro, req, int, Y-coordinate, attr:min{req, int},max{req, int}-->1
</positionY>
<height min="1" max="10">
<!--ro, req, int, width, attr:min{req, int},max{req, int}-->1
</height>
<width min="1" max="10">
<!--ro, req, int, height, attr:min{req, int},max{req, int}-->1
</width>
</Position>
</Title>
<VoiceBroadcast>
<!--ro, opt, object-->
<enabled opt="true,false">
<!--ro, opt, bool, attr:opt{req, string}-->true
</enabled>
<broadcastSpeed opt="slower,slow,medium,fast,faster">
<!--ro, opt, enum, subType:string, attr:opt{req, string}-->slower
</broadcastSpeed>
<inLibVoice min="1" max="10">
<!--ro, opt, string, voice prompt content of people in database, attr:min{req, int},max{req, int}-->test
</inLibVoice>
<outLibVoice min="1" max="10">
<!--ro, opt, string, attr:min{req, int},max{req, int}-->test
</outLibVoice>
</VoiceBroadcast>
<WelcomeWord>
<!--ro, opt, object, welcome words-->
<enabled opt="true,false">
<!--ro, opt, bool, attr:opt{req, string}-->true
</enabled>
<inLibWord min="1" max="128">
<!--ro, opt, string, range:[1,128], attr:min{req, int},max{req, int}-->test
</inLibWord>
<outLibWord min="1" max="128">
<!--ro, opt, string, range:[1,128], attr:min{req, int},max{req, int}-->test
</outLibWord>
</WelcomeWord>
<ShowInfo>
<!--ro, opt, object-->
<row min="1" max="10">
<!--ro, opt, int, attr:min{req, int},max{req, int}-->1
</row>
<column min="1" max="10">
<!--ro, opt, int, attr:min{req, int},max{req, int}-->1
</column>
<Position>


<Position>
<!--ro, opt, object, coordinates, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX min="1" max="10">
<!--ro, req, int, X-coordinate, attr:min{req, int},max{req, int}-->1
</positionX>
<positionY min="1" max="10">
<!--ro, req, int, Y-coordinate, attr:min{req, int},max{req, int}-->1
</positionY>
<height min="1" max="10">
<!--ro, req, int, width, attr:min{req, int},max{req, int}-->1
</height>
<width min="1" max="10">
<!--ro, req, int, height, attr:min{req, int},max{req, int}-->1
</width>
</Position>
<inLib>
<!--ro, opt, object-->
<nameEnabled opt="true,false">
<!--ro, opt, bool, attr:opt{req, string}-->true
</nameEnabled>
</inLib>
</ShowInfo>
<ModuleInfoList>
<!--ro, opt, array, subType:object-->
<ModuleInfo>
<!--ro, opt, object-->
<moduleType
opt="conferenceTime,conferenceSite,conferenceStatus,signInPersonNum,totalPersonNum,unSignInPersonNum,signInAndTotalPersonNum,QRCode,meetingHostName,employee
No,customKey,nextMeeting">
<!--ro, req, enum, module type, subType:string, attr:opt{req, string}-->conferenceTime
</moduleType>
<enabled>
<!--ro, req, bool-->true
</enabled>
<fontSize min="1" max="10">
<!--ro, req, int, font size, attr:min{req, int},max{req, int}-->1
</fontSize>
<FontColor>
<!--ro, req, object-->
<RGB>
<!--ro, opt, int, three primary colors in decimal format-->1
</RGB>
</FontColor>
<BackColor>
<!--ro, opt, object, background color-->
<RGB>
<!--ro, opt, int, three primary colors in decimal format-->1
</RGB>
</BackColor>
<backPicId>
<!--ro, opt, int, background picture ID-->1
</backPicId>
<Position>
<!--ro, opt, object, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX min="1" max="10">
<!--ro, req, int, attr:min{req, int},max{req, int}-->1
</positionX>
<positionY min="1" max="10">
<!--ro, req, int, attr:min{req, int},max{req, int}-->1
</positionY>
<height min="1" max="10">
<!--ro, req, int, width, attr:min{req, int},max{req, int}-->1
</height>
<width min="1" max="10">
<!--ro, req, int, attr:min{req, int},max{req, int}-->1
</width>
</Position>
</ModuleInfo>
</ModuleInfoList>
</ConferenceParam>
<CallBtn>
<!--ro, opt, object-->
<backPicId min="0" max="10">
<!--ro, opt, int, background picture ID, attr:min{req, int},max{req, int}-->1
</backPicId>
</CallBtn>
<OpenDoorBtn>
<!--ro, opt, object-->
<backPicId min="0" max="10">
<!--ro, opt, int, background picture ID, attr:min{req, int},max{req, int}-->1
</backPicId>
</OpenDoorBtn>
<QRCodeBtn>
<!--ro, opt, object-->
<backPicId min="0" max="10">
<!--ro, opt, int, background picture ID, attr:min{req, int},max{req, int}-->1
</backPicId>
</QRCodeBtn>
<AuthenticationSuccess>
<!--ro, opt, object-->
<BackColor>
<!--ro, opt, object, background color-->
<RGB>
<!--ro, opt, int, three primary colors in decimal format-->1


<!--ro, opt, int, three primary colors in decimal format-->1
</RGB>
</BackColor>
<backPicId min="0" max="10">
<!--ro, opt, int, background picture ID, attr:min{req, int},max{req, int}, desc:background picture ID-->1
</backPicId>
<SubWindowList>
<!--ro, opt, object-->
<SubWindow>
<!--ro, opt, object-->
<subWindowType opt="temperature,facePic,name,employeeNo,group,tips">
<!--ro, req, enum, sub-window type, subType:string, attr:opt{req, string}-->temperature
</subWindowType>
<enabled opt="true,false">
<!--ro, req, bool, whether to enable the function, attr:opt{req, string}-->true
</enabled>
<fontSize min="6" max="72">
<!--ro, opt, int, font size, unit:px, attr:min{req, int},max{req, int}-->1
</fontSize>
<fontColor>
<!--ro, opt, int, font color-->1
</fontColor>
<fontStyle opt="bold,italic,underline,strikeout">
<!--ro, opt, string, font style, attr:opt{req, string}-->bold,italic,underline,strikeout
</fontStyle>
<Position>
<!--ro, opt, object, coordinates, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution->
<positionX
min="1" max="10">
<!--ro, req, int, X-coordinate, attr:min{req, int},max{req, int}-->1
</positionX>
<positionY min="1" max="10">
<!--ro, req, int, Y-coordinate, attr:min{req, int},max{req, int}-->1
</positionY>
<height min="1" max="10">
<!--ro, req, int, width, attr:min{req, int},max{req, int}-->1
</height>
<width min="1" max="10">
<!--ro, req, int, height, attr:min{req, int},max{req, int}-->1
</width>
</Position>
</SubWindow>
</SubWindowList>
</AuthenticationSuccess>
<AuthenticationFail>
<!--ro, opt, object-->
<BackColor>
<!--ro, opt, object, background color-->
<RGB>
<!--ro, opt, int, three primary colors in decimal format-->1
</RGB>
</BackColor>
<backPicId min="0" max="10">
<!--ro, opt, int, background picture ID, attr:min{req, int},max{req, int}, desc:background picture ID-->1
</backPicId>
<SubWindowList>
<!--ro, opt, object-->
<SubWindow>
<!--ro, opt, object-->
<subWindowType opt="temperature,facePic,name,employeeNo,group,tips">
<!--ro, req, enum, sub-window type, subType:string, attr:opt{req, string}-->temperature
</subWindowType>
<enabled opt="true,false">
<!--ro, req, bool, whether to enable the function, attr:opt{req, string}-->true
</enabled>
<fontSize min="6" max="72">
<!--ro, opt, int, font size, unit:px, attr:min{req, int},max{req, int}-->1
</fontSize>
<fontColor>
<!--ro, opt, int, font color-->1
</fontColor>
<fontStyle opt="bold,italic,underline,strikeout">
<!--ro, opt, string, font style, attr:opt{req, string}-->bold,italic,underline,strikeout
</fontStyle>
<Position>
<!--ro, opt, object, coordinates, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution->
<positionX
min="1" max="10">
<!--ro, req, int, X-coordinate, attr:min{req, int},max{req, int}-->1
</positionX>
<positionY min="1" max="10">
<!--ro, req, int, Y-coordinate, attr:min{req, int},max{req, int}-->1
</positionY>
<height min="1" max="10">
<!--ro, req, int, width, attr:min{req, int},max{req, int}-->1
</height>
<width min="1" max="10">
<!--ro, req, int, height, attr:min{req, int},max{req, int}-->1
</width>
</Position>
<facePicID min="1" max="100">
<!--ro, opt, int, step:1, dep:and,
{$.PageList.Page.WindowsList[*].Windows.AuthenticationFail.SubWindowList.SubWindow.subWindowType,eq,facePic}, attr:min{req, int},max{req, int}-->1
</facePicID>
</SubWindow>


</SubWindow>
</SubWindowList>
</AuthenticationFail>
<StatusBar>
<!--ro, opt, object-->
<backPicId min="0" max="10">
<!--ro, opt, int, background picture ID, attr:min{req, int},max{req, int}, desc:background picture ID-->1
</backPicId>
<statusBarType opt="fixed">
<!--ro, req, enum, subType:string, attr:opt{req, string}-->fixed
</statusBarType>
<SubStatusList size="5">
<!--ro, opt, object, attr:size{req, int}-->
<SubStatus>
<!--ro, opt, object, sub status-->
<statusType opt="dial,wifi,EZVIZ,wiredNetwork,deploy,temperature">
<!--ro, req, enum, sub status, subType:string, attr:opt{req, string}, desc:sub status-->dial
</statusType>
<enabled opt="true,false">
<!--ro, req, bool, attr:opt{req, string}-->true
</enabled>
</SubStatus>
</SubStatusList>
</StatusBar>
</Windows>
</WindowsList>
</Page>
</PageList>
<programSize>
<!--ro, opt, int, read-only,page list,unit: byte, unit:Byte-->1
</programSize>
<programLength>
<!--ro, opt, int, program duration, unit:s-->1
</programLength>
<coordinateType opt="uniformCoordinate,resolutionCoordinate">
<!--ro, opt, enum, subType:string, attr:opt{req, string}-->uniformCoordinate
</coordinateType>
<screenType opt="first,second">
<!--ro, opt, enum, subType:string, attr:opt{req, string}-->first
</screenType>
<audioEnabled opt="true,false">
<!--ro, opt, bool, attr:opt{req, string}-->true
</audioEnabled>
<PageIdList size="10">
<!--ro, opt, array, subType:object, attr:size{req, int}-->
<PageId>
<!--ro, opt, object, page ID-->
<id min="1" max="10">
<!--ro, req, int, program ID, attr:min{req, int},max{req, int}-->1
</id>
</PageId>
</PageIdList>
</Program>
21.40.2 Set a specific program
Request URL
PUT /ISAPI/Publish/ProgramMgr/program/<programID>
Query Parameter
Parameter Name Parameter Type Description
programID
string
Request Message
<?xml version="1.0" encoding="UTF-8"?>
<Program xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--req, object, page list, attr:version{req, string, protocolVersion}-->
<id>
<!--req, int, program ID-->1
</id>
<programName>
<!--req, string, program name-->test
</programName>
<programRemarks>
<!--req, string, program description-->test
</programRemarks>
<shareProperty>
<!--opt, enum, shared property, subType:string, desc:public, private-->public
</shareProperty>
<approveState>
<!--opt, enum, approval status, subType:string, desc:"approved" (pass), "notPass" (deny), "notApprove" (not approved)-->approved
</approveState>
-


<approveRemarks>
<!--opt, string, approval remarks-->test
</approveRemarks>
<programType>
<!--opt, enum, program type, subType:string, desc:program type: normal,decode,touch,"decodeTouch"-decode and touch,character (welcome words,which is
used for access control devices)-->normal
</programType>
<orgNo>
<!--opt, int, organization No.-->1
</orgNo>
<Resolution>
<!--req, object, resolution-->
<resolutionName>
<!--opt, string, resolution name-->test
</resolutionName>
<imageWidth>
<!--req, int, resolution (width)-->1
</imageWidth>
<imageHeight>
<!--req, int, resolution (height)-->1
</imageHeight>
</Resolution>
<PageList>
<!--opt, array, subType:object-->
<Page>
<!--opt, object-->
<id>
<!--req, int, ID-->1
</id>
<PageBasicInfo>
<!--req, object-->
<pageName>
<!--opt, string-->test
</pageName>
<BackgroundColor>
<!--opt, object, background color-->
<RGB>
<!--opt, int, RGB value, desc:three primary colors in decimal format, e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</BackgroundColor>
<playDurationMode>
<!--opt, enum, playing time mode, subType:string-->selfDefine
</playDurationMode>
<playDuration>
<!--opt, int, unit:s-->1
</playDuration>
<playCount>
<!--opt, int-->1
</playCount>
<switchDuration>
<!--req, int, switch interval, unit:s-->1
</switchDuration>
<switchEffect>
<!--req, enum, switching effect, subType:string-->none
</switchEffect>
<backgroundPic>
<!--opt, int, background picture ID-->1
</backgroundPic>
<SignInCfg>
<!--opt, object, check-in information-->
<VoiceBroadcast>
<!--opt, object, audio prompt-->
<enabled>
<!--opt, bool-->true
</enabled>
<broadcastSpeed>
<!--opt, enum, subType:string-->slower
</broadcastSpeed>
<inLibVoice>
<!--opt, string-->test
</inLibVoice>
<outLibVoice>
<!--opt, string-->test
</outLibVoice>
</VoiceBroadcast>
<WelcomeWord>
<!--opt, object, welcome words-->
<enabled>
<!--opt, bool-->true
</enabled>
<inLibWord>
<!--opt, string-->test
</inLibWord>
<outLibWord>
<!--opt, string-->test
</outLibWord>
</WelcomeWord>
<SignCartoon>
<!--opt, object-->
<signCartoonSpeed>
<!--opt, enum, subType:string-->fast
</signCartoonSpeed>
</SignCartoon>
<backgroundSignEnabled>


<backgroundSignEnabled>
<!--opt, bool-->true
</backgroundSignEnabled>
<TemperatureDetection>
<!--opt, object, screen temperature parameter-->
<enabled>
<!--req, bool, whether to enable-->true
</enabled>
<threshold>
<!--req, float-->0.000
</threshold>
</TemperatureDetection>
</SignInCfg>
</PageBasicInfo>
<characterMode>
<!--opt, enum, welcome word mode on the page, subType:string, desc:mode1,mode2,mode3. For access control devices, the position of the welcome words
is fixed and can be in three modes-->mode1
</characterMode>
<WindowsSplitMode>
<!--ro, opt, enum, subType:string-->SLIP4
</WindowsSplitMode>
<WindowsList>
<!--opt, array, window information list, subType:object-->
<Windows>
<!--opt, object, window information-->
<id>
<!--req, int, content No.-->1
</id>
<Position>
<!--opt, object, content's position, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX>
<!--req, int, X-coordinate-->1
</positionX>
<positionY>
<!--req, int, Y-coordinate-->1
</positionY>
<height>
<!--req, int, width-->1
</height>
<width>
<!--req, int, height-->1
</width>
</Position>
<CornerRadius>
<!--opt, object-->
<TopLeft>
<!--opt, int-->1
</TopLeft>
<TopRight>
<!--opt, int-->1
</TopRight>
<BottomLeft>
<!--opt, int-->1
</BottomLeft>
<BottomRight>
<!--opt, int-->1
</BottomRight>
</CornerRadius>
<layerNo>
<!--req, int, layer No.-->1
</layerNo>
<WinMaterialInfo>
<!--opt, object, window material information-->
<materialType>
<!--req, enum, material type, subType:string, desc:“static” (static material), “dynamic” (dynamic material), “other” (other material)-->static
</materialType>
<staticMaterialType>
<!--opt, enum, static material type, subType:string-->picture
</staticMaterialType>
<dynamicType>
<!--opt, enum, dynamic material type, subType:string-->web
</dynamicType>
<otherType>
<!--opt, enum, other material type, subType:string-->clock
</otherType>
</WinMaterialInfo>
<TouchProperty>
<!--opt, object, touching attributes-->
<windType>
<!--opt, enum, subType:string-->popup
</windType>
<hyperlinkType>
<!--opt, enum, hyperlink type, subType:string-->window
</hyperlinkType>
<windowId>
<!--opt, string, window No., desc:it is the window of current page. This node is valid when <hyperlinkType> is window-->test
</windowId>
<pageId>
<!--opt, string, page No., desc:this node is valid when <hyperlinkType> is page-->test
</pageId>
</TouchProperty>
<PlayItemList>
<!--opt, array, subType:object-->
<PlayItem>


<!--req, object-->
<id>
<!--req, int, program ID-->1
</id>
<materialNo>
<!--opt, int, material No.-->1
</materialNo>
<inputChannel>
<!--opt, int, linked channel No. of the network camera-->1
</inputChannel>
<playEffect>
<!--req, enum, playing effect, subType:string-->none
</playEffect>
<MarqueeInfo>
<!--opt, object-->
<scrollType>
<!--req, enum, marquee scrolling type, subType:string-->none
</scrollType>
<scrollDeriction>
<!--req, enum, marquee scrolling direction, subType:string-->none
</scrollDeriction>
<scrollSpeed>
<!--req, int, marquee scrolling speed-->1
</scrollSpeed>
</MarqueeInfo>
<PlayDuration>
<!--opt, object, desc:this node can be configured for local materials, live video, and network camera channels-->
<durationType>
<!--req, enum, subType:string-->selfDefine
</durationType>
<duration>
<!--req, int, duration, unit:s-->1
</duration>
</PlayDuration>
<CharactersEffect>
<!--opt, object, character display effect, desc:this node is valid when the material type is text or TXT file-->
<fontSize>
<!--req, int, font size-->1
</fontSize>
<FontColor>
<!--req, object, font color-->
<RGB>
<!--opt, int, RGB value, desc:three primary colors in decimal format, e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</FontColor>
<backgroundType>
<!--opt, enum, subType:string-->color
</backgroundType>
<backPicId>
<!--opt, int-->1
</backPicId>
<BackColor>
<!--req, object, background color-->
<RGB>
<!--opt, int, RGB value, desc:three primary colors in decimal format, e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</BackColor>
<backTransparent>
<!--req, int, background transparency-->1
</backTransparent>
<subtitlesEnabled>
<!--req, bool-->true
</subtitlesEnabled>
<scrollDirection>
<!--req, enum, character scrolling direction, subType:string-->left
</scrollDirection>
<scrollSpeed>
<!--req, int, character scrolling speed-->1
</scrollSpeed>
</CharactersEffect>
<switchEffect>
<!--opt, enum, switching effect, subType:string-->random
</switchEffect>
<pageTime>
<!--opt, int, paging time, unit:s-->1
</pageTime>
<scrollSpeed>
<!--req, int, scrolling speed-->1
</scrollSpeed>
<scaleType>
<!--opt, enum, subType:string-->centerCrop
</scaleType>
<playType>
<!--opt, enum, subType:string-->normal
</playType>
</PlayItem>
</PlayItemList>
<enabledAudio>
<!--opt, bool, whether to enable audio-->true
</enabledAudio>
<enableHide>
<!--opt, bool, whether to enable hiding-->true
</enableHide>
<enableLock>


<enableLock>
<!--opt, bool, whether to enable lock-->true
</enableLock>
<AppWindow>
<!--opt, object-->
<WindowInfoList>
<!--req, array, window information list, subType:object-->
<WindowInfo>
<!--req, object, window information-->
<id>
<!--req, int, ID-->1
</id>
<materialNo>
<!--req, int, material No.-->1
</materialNo>
</WindowInfo>
</WindowInfoList>
</AppWindow>
<DataSource>
<!--opt, object, data source-->
<materialNo>
<!--req, int, material No.-->1
</materialNo>
</DataSource>
<Call>
<!--opt, object, calling data-->
<materialNo>
<!--req, int, material No.-->1
</materialNo>
<tableRow>
<!--req, int, row of the table-->1
</tableRow>
<tableColumn>
<!--req, int, column of the table-->1
</tableColumn>
<tableDirection>
<!--req, enum, table direction, subType:string-->vertical
</tableDirection>
<tableType>
<!--req, enum, subType:string-->template1
</tableType>
<backPicId>
<!--opt, int-->1
</backPicId>
<alignType>
<!--req, enum, alignment mode, subType:string-->left
</alignType>
<refreshDirection>
<!--req, enum, subType:string-->upTodown
</refreshDirection>
<HeadDataList>
<!--opt, array, subType:object-->
<HeadData>
<!--opt, object-->
<id>
<!--req, int, ID-->1
</id>
<data>
<!--req, string, data-->test
</data>
</HeadData>
</HeadDataList>
<ItemStyleList>
<!--opt, array, subType:object-->
<ItemStyle>
<!--opt, object-->
<id>
<!--req, int, ID-->1
</id>
<width>
<!--req, int-->1
</width>
<fontSize>
<!--req, int, font size-->1
</fontSize>
<FontColor>
<!--req, object, font color-->
<RGB>
<!--opt, int, RGB value, desc:three primary colors in decimal format, e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</FontColor>
<BackColor>
<!--req, object, background color-->
<RGB>
<!--opt, int, RGB value, desc:three primary colors in decimal format, e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</BackColor>
</ItemStyle>
</ItemStyleList>
</Call>
<DynamicPic>
<!--opt, object-->
<materialNo>
<!--req, int, material No.-->1


<!--req, int, material No.-->1
</materialNo>
<backPicId>
<!--opt, int, background picture ID-->1
</backPicId>
</DynamicPic>
<CapturePic>
<!--opt, object, picture capturing parameters-->
<backPicId>
<!--opt, int, background picture ID-->1
</backPicId>
<ipcMaterialNo>
<!--req, int-->1
</ipcMaterialNo>
<cancelType>
<!--req, enum, subType:string-->manual
</cancelType>
<duration>
<!--opt, int, duration, unit:s-->1
</duration>
</CapturePic>
<ClockParam>
<!--opt, object-->
<backPicId>
<!--opt, int, background picture ID-->1
</backPicId>
<ClockIcon>
<!--req, object-->
<enabled>
<!--req, bool, whether to enable the function-->true
</enabled>
<type>
<!--opt, enum, subType:string-->clock1
</type>
<Position>
<!--opt, object, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX>
<!--req, int, X-coordinate-->1
</positionX>
<positionY>
<!--req, int, Y-coordinate-->1
</positionY>
<height>
<!--req, int, width-->1
</height>
<width>
<!--req, int, height-->1
</width>
</Position>
</ClockIcon>
<YmdParam>
<!--req, object, the parameters of year, month, and day in the clock-->
<enabled>
<!--req, bool, whether to enable the function-->true
</enabled>
<fontSize>
<!--req, int, font size-->1
</fontSize>
<FontColor>
<!--req, object, font color-->
<RGB>
<!--opt, int, RGB value, desc:three primary colors in decimal format, e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</FontColor>
<BackColor>
<!--req, object, background color-->
<RGB>
<!--opt, int, RGB value, desc:three primary colors in decimal format, e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</BackColor>
<Position>
<!--opt, object, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX>
<!--req, int, X-coordinate-->1
</positionX>
<positionY>
<!--req, int, Y-coordinate-->1
</positionY>
<height>
<!--req, int, width-->1
</height>
<width>
<!--req, int, height-->1
</width>
</Position>
</YmdParam>
<HmsParam>
<!--req, object, the parameters of hour, minute, and second in the clock-->
<enabled>
<!--req, bool, whether to enable the function-->true
</enabled>
<fontSize>
<!--req, int, font size-->1
</fontSize>
<FontColor>


<FontColor>
<!--req, object, font color-->
<RGB>
<!--opt, int, RGB value, desc:three primary colors in decimal format, e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</FontColor>
<BackColor>
<!--req, object, background color-->
<RGB>
<!--opt, int, RGB value, desc:three primary colors in decimal format, e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</BackColor>
<Position>
<!--opt, object, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX>
<!--req, int, X-coordinate-->1
</positionX>
<positionY>
<!--req, int, Y-coordinate-->1
</positionY>
<height>
<!--req, int, width-->1
</height>
<width>
<!--req, int, height-->1
</width>
</Position>
</HmsParam>
<WeekParam>
<!--req, object-->
<enabled>
<!--req, bool, whether to enable the function-->true
</enabled>
<fontSize>
<!--req, int, font size-->1
</fontSize>
<FontColor>
<!--req, object, font color-->
<RGB>
<!--opt, int, RGB value, desc:three primary colors in decimal format, e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</FontColor>
<BackColor>
<!--req, object, background color-->
<RGB>
<!--opt, int, RGB value, desc:three primary colors in decimal format, e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</BackColor>
<Position>
<!--opt, object, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX>
<!--req, int, X-coordinate-->1
</positionX>
<positionY>
<!--req, int, Y-coordinate-->1
</positionY>
<height>
<!--req, int, width-->1
</height>
<width>
<!--req, int, height-->1
</width>
</Position>
</WeekParam>
</ClockParam>
<WeatherParam>
<!--opt, object-->
<backPicId>
<!--opt, int-->1
</backPicId>
<WeatherIcon>
<!--opt, object-->
<enabled>
<!--req, bool, whether to enable the function-->true
</enabled>
<Position>
<!--opt, object, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX>
<!--req, int, X-coordinate-->1
</positionX>
<positionY>
<!--req, int, Y-coordinate-->1
</positionY>
<height>
<!--req, int, width-->1
</height>
<width>
<!--req, int, height-->1
</width>
</Position>
</WeatherIcon>
<Date>
<!--opt, object-->
<enabled>


<enabled>
<!--req, bool, whether to enable the function-->true
</enabled>
<fontSize>
<!--req, int, font size-->1
</fontSize>
<FontColor>
<!--req, object, font color-->
<RGB>
<!--opt, int, RGB value, desc:three primary colors in decimal format, e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</FontColor>
<BackColor>
<!--req, object, background color-->
<RGB>
<!--opt, int, RGB value, desc:three primary colors in decimal format, e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</BackColor>
<Position>
<!--opt, object, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX>
<!--req, int, X-coordinate-->1
</positionX>
<positionY>
<!--req, int, Y-coordinate-->1
</positionY>
<height>
<!--req, int, width-->1
</height>
<width>
<!--req, int, height-->1
</width>
</Position>
</Date>
<Temperature>
<!--opt, object-->
<enabled>
<!--req, bool, whether to enable the function-->true
</enabled>
<fontSize>
<!--req, int, font size-->1
</fontSize>
<FontColor>
<!--req, object, font color-->
<RGB>
<!--opt, int, RGB value, desc:three primary colors in decimal format, e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</FontColor>
<BackColor>
<!--req, object, background color-->
<RGB>
<!--opt, int, RGB value, desc:three primary colors in decimal format, e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</BackColor>
<Position>
<!--opt, object, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX>
<!--req, int, X-coordinate-->1
</positionX>
<positionY>
<!--req, int, Y-coordinate-->1
</positionY>
<height>
<!--req, int, width-->1
</height>
<width>
<!--req, int, height-->1
</width>
</Position>
</Temperature>
<WeatherContent>
<!--opt, object-->
<enabled>
<!--req, bool, whether to enable the function-->true
</enabled>
<fontSize>
<!--req, int, font size-->1
</fontSize>
<FontColor>
<!--req, object, font color-->
<RGB>
<!--opt, int, RGB value, desc:three primary colors in decimal format, e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</FontColor>
<BackColor>
<!--req, object, background color-->
<RGB>
<!--opt, int, RGB value, desc:three primary colors in decimal format, e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</BackColor>
<Position>
<!--opt, object, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX>
<!--req, int, X-coordinate-->1


</positionX>
<positionY>
<!--req, int, Y-coordinate-->1
</positionY>
<height>
<!--req, int, width-->1
</height>
<width>
<!--req, int, height-->1
</width>
</Position>
</WeatherContent>
<City>
<!--opt, object-->
<enabled>
<!--req, bool, whether to enable the function-->true
</enabled>
<cityId>
<!--req, string-->test
</cityId>
<cityName>
<!--req, string, city name-->test
</cityName>
<fontSize>
<!--req, int, font size-->1
</fontSize>
<FontColor>
<!--req, object, font color-->
<RGB>
<!--opt, int, RGB value, desc:three primary colors in decimal format, e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</FontColor>
<BackColor>
<!--req, object, background color-->
<RGB>
<!--opt, int, RGB value, desc:three primary colors in decimal format, e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</BackColor>
<Position>
<!--opt, object, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX>
<!--req, int, X-coordinate-->1
</positionX>
<positionY>
<!--req, int, Y-coordinate-->1
</positionY>
<height>
<!--req, int, width-->1
</height>
<width>
<!--req, int, height-->1
</width>
</Position>
</City>
<Humidity>
<!--opt, object-->
<enabled>
<!--req, bool, whether to enable the function-->true
</enabled>
<fontSize>
<!--req, int, font size-->1
</fontSize>
<FontColor>
<!--req, object, font color-->
<RGB>
<!--opt, int, RGB value, desc:three primary colors in decimal format, e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</FontColor>
<BackColor>
<!--req, object, background color-->
<RGB>
<!--opt, int, RGB value, desc:three primary colors in decimal format, e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</BackColor>
<Position>
<!--opt, object, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX>
<!--req, int, X-coordinate-->1
</positionX>
<positionY>
<!--req, int, Y-coordinate-->1
</positionY>
<height>
<!--req, int, width-->1
</height>
<width>
<!--req, int, height-->1
</width>
</Position>
</Humidity>
<AirQuality>
<!--opt, object-->
<enabled>
<!--req, bool, whether to enable the function-->true


<!--req, bool, whether to enable the function-->true
</enabled>
<fontSize>
<!--req, int, font size-->1
</fontSize>
<FontColor>
<!--req, object, font color-->
<RGB>
<!--opt, int, RGB value, desc:three primary colors in decimal format, e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</FontColor>
<BackColor>
<!--req, object, background color-->
<RGB>
<!--opt, int, RGB value, desc:three primary colors in decimal format, e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</BackColor>
<Position>
<!--opt, object, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX>
<!--req, int, X-coordinate-->1
</positionX>
<positionY>
<!--req, int, Y-coordinate-->1
</positionY>
<height>
<!--req, int, width-->1
</height>
<width>
<!--req, int, height-->1
</width>
</Position>
</AirQuality>
<UpdateTime>
<!--opt, object-->
<enabled>
<!--req, bool, whether to enable the function-->true
</enabled>
<refreshTime>
<!--req, string-->20200826T051500+08
</refreshTime>
<updateInterval>
<!--req, int, unit:minute-->1
</updateInterval>
<fontSize>
<!--req, int, font size-->1
</fontSize>
<FontColor>
<!--req, object, font color-->
<RGB>
<!--opt, int, RGB value, desc:three primary colors in decimal format, e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</FontColor>
<BackColor>
<!--req, object, background color-->
<RGB>
<!--opt, int, RGB value, desc:three primary colors in decimal format, e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</BackColor>
<Position>
<!--opt, object, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX>
<!--req, int, X-coordinate-->1
</positionX>
<positionY>
<!--req, int, Y-coordinate-->1
</positionY>
<height>
<!--req, int, width-->1
</height>
<width>
<!--req, int, height-->1
</width>
</Position>
</UpdateTime>
<Wind>
<!--opt, object-->
<enabled>
<!--req, bool, whether to enable the function-->true
</enabled>
<fontSize>
<!--req, int, font size-->1
</fontSize>
<FontColor>
<!--req, object, font color-->
<RGB>
<!--opt, int, RGB value, desc:three primary colors in decimal format, e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</FontColor>
<BackColor>
<!--req, object, background color-->
<RGB>
<!--opt, int, RGB value, desc:three primary colors in decimal format, e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>


</BackColor>
<Position>
<!--opt, object, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX>
<!--req, int, X-coordinate-->1
</positionX>
<positionY>
<!--req, int, Y-coordinate-->1
</positionY>
<height>
<!--req, int, width-->1
</height>
<width>
<!--req, int, height-->1
</width>
</Position>
</Wind>
</WeatherParam>
<Countdown>
<!--opt, object-->
<endTime>
<!--req, string-->20200826T051500+08
</endTime>
<template>
<!--req, enum, subType:string-->template1
</template>
<timeUnit>
<!--req, enum, subType:string-->year
</timeUnit>
<backPicId>
<!--opt, int, background picture ID-->1
</backPicId>
<TimeFontCfg>
<!--opt, object-->
<fontSize>
<!--req, int, font size-->1
</fontSize>
<FontColor>
<!--req, object, font color-->
<RGB>
<!--opt, int, RGB value, desc:three primary colors in decimal format, e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</FontColor>
<Position>
<!--opt, object, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX>
<!--req, int, X-coordinate-->1
</positionX>
<positionY>
<!--req, int, Y-coordinate-->1
</positionY>
<height>
<!--req, int, width-->1
</height>
<width>
<!--req, int, height-->1
</width>
</Position>
</TimeFontCfg>
<timeUnitEnabled>
<!--opt, bool-->true
</timeUnitEnabled>
</Countdown>
<localInputNo>
<!--req, enum, subType:string-->VGA
</localInputNo>
<HyperlinkBtn>
<!--opt, object-->
<backPicId>
<!--opt, int, background picture ID-->1
</backPicId>
</HyperlinkBtn>
<CharactersAttribute>
<!--opt, object-->
<fontSize>
<!--req, int, font size-->1
</fontSize>
<FontColor>
<!--req, object, font color-->
<RGB>
<!--opt, int, RGB value, desc:three primary colors in decimal format, e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</FontColor>
<backgroundType>
<!--req, enum, subType:string-->color
</backgroundType>
<BackColor>
<!--req, object, background color-->
<RGB>
<!--opt, int, RGB value, desc:three primary colors in decimal format, e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
<fillEnabled>
<!--opt, bool-->true
</fillEnabled>


</fillEnabled>
</BackColor>
<backTransparent>
<!--opt, int, background transparency-->1
</backTransparent>
<alignType>
<!--req, enum, alignment mode, subType:string-->middle
</alignType>
<verticaAlignType>
<!--req, enum, vertical alignment mode, subType:string-->top
</verticaAlignType>
<characterContent>
<!--opt, string, text content, range:[0,512]-->test
</characterContent>
<backPicId>
<!--opt, int, background picture ID-->1
</backPicId>
<characterStyle>
<!--req, enum, subType:string-->normal
</characterStyle>
<characterType>
<!--req, enum, font type, subType:string-->mainTitle
</characterType>
<scrollDirection>
<!--opt, enum, character scrolling direction, subType:string-->left
</scrollDirection>
<scrollSpeed>
<!--opt, int, character scrolling speed, range:[1,10]-->1
</scrollSpeed>
</CharactersAttribute>
<SignIn>
<!--opt, object-->
<backPicId>
<!--opt, int, background picture ID-->1
</backPicId>
<ShowInfo>
<!--opt, object-->
<row>
<!--opt, int-->1
</row>
<column>
<!--opt, int-->1
</column>
<Position>
<!--opt, object, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX>
<!--req, int, X-coordinate-->1
</positionX>
<positionY>
<!--req, int, Y-coordinate-->1
</positionY>
<height>
<!--req, int, width-->1
</height>
<width>
<!--req, int, height-->1
</width>
</Position>
<inLib>
<!--opt, object-->
<nameEnabled>
<!--opt, bool-->true
</nameEnabled>
<genderEnabled>
<!--opt, bool-->true
</genderEnabled>
<selfDefine1Enabled>
<!--opt, bool-->true
</selfDefine1Enabled>
<selfDefine2Enabled>
<!--opt, bool-->true
</selfDefine2Enabled>
<signInTimeEnabled>
<!--opt, bool-->true
</signInTimeEnabled>
<temperatureEnabled>
<!--opt, bool-->true
</temperatureEnabled>
</inLib>
<outLib>
<!--opt, object-->
<nameEnabled>
<!--opt, bool-->true
</nameEnabled>
<name>
<!--opt, string-->test
</name>
<genderEnabled>
<!--opt, bool-->true
</genderEnabled>
<signInTimeEnabled>
<!--opt, bool-->true
</signInTimeEnabled>
<temperatureEnabled>


<temperatureEnabled>
<!--opt, bool-->true
</temperatureEnabled>
</outLib>
<showDuration>
<!--req, enum, subType:string-->always
</showDuration>
</ShowInfo>
<MainTitle>
<!--opt, object-->
<enabled>
<!--req, bool, whether to enable the function-->true
</enabled>
<fontSize>
<!--req, int, font size-->1
</fontSize>
<FontColor>
<!--req, object, font color-->
<RGB>
<!--opt, int-->1
</RGB>
</FontColor>
<text>
<!--opt, string-->test
</text>
</MainTitle>
<SubTitle>
<!--opt, object-->
<enabled>
<!--req, bool, whether to enable the function-->true
</enabled>
<fontSize>
<!--req, int, font size-->1
</fontSize>
<FontColor>
<!--req, object, font color-->
<RGB>
<!--opt, int-->1
</RGB>
</FontColor>
<text>
<!--opt, string-->test
</text>
</SubTitle>
<NormalTemperature>
<!--opt, object-->
<PeopleNumber>
<!--opt, object-->
<enabled>
<!--req, bool, whether to enable the function-->true
</enabled>
<fontSize>
<!--req, int, font size-->1
</fontSize>
<FontColor>
<!--req, object, font color-->
<RGB>
<!--opt, int-->1
</RGB>
</FontColor>
<Position>
<!--opt, object, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX>
<!--req, int, X-coordinate-->1
</positionX>
<positionY>
<!--req, int, Y-coordinate-->1
</positionY>
<height>
<!--req, int, width-->1
</height>
<width>
<!--req, int, height-->1
</width>
</Position>
<text>
<!--opt, string-->test
</text>
</PeopleNumber>
<Icon>
<!--opt, object-->
<enabled>
<!--req, bool, whether to enable the function-->true
</enabled>
<Position>
<!--opt, object, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX>
<!--req, int, X-coordinate-->1
</positionX>
<positionY>
<!--req, int, Y-coordinate-->1
</positionY>
<height>
<!--req, int, width-->1
</height>


</height>
<width>
<!--req, int, height-->1
</width>
</Position>
<materialNo>
<!--opt, int, material ID-->1
</materialNo>
</Icon>
</NormalTemperature>
<AbnormalTemperature>
<!--opt, object-->
<PeopleNumber>
<!--opt, object-->
<enabled>
<!--req, bool, whether to enable the function-->true
</enabled>
<fontSize>
<!--req, int, font size-->1
</fontSize>
<FontColor>
<!--req, object, font color-->
<RGB>
<!--opt, int-->1
</RGB>
</FontColor>
<Position>
<!--opt, object, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX>
<!--req, int, X-coordinate-->1
</positionX>
<positionY>
<!--req, int, Y-coordinate-->1
</positionY>
<height>
<!--req, int, width-->1
</height>
<width>
<!--req, int, height-->1
</width>
</Position>
<text>
<!--opt, string-->test
</text>
</PeopleNumber>
<Icon>
<!--opt, object-->
<enabled>
<!--req, bool, whether to enable the function-->true
</enabled>
<Position>
<!--opt, object, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX>
<!--req, int, X-coordinate-->1
</positionX>
<positionY>
<!--req, int, Y-coordinate-->1
</positionY>
<height>
<!--req, int, width-->1
</height>
<width>
<!--req, int, height-->1
</width>
</Position>
<materialNo>
<!--opt, int, material ID-->1
</materialNo>
</Icon>
</AbnormalTemperature>
</SignIn>
<EventParam>
<!--opt, object-->
<EventResourceList>
<!--opt, array, subType:object-->
<EventResource>
<!--opt, object-->
<ipVersion>
<!--req, enum, subType:string-->v4
</ipVersion>
<ipAddress>
<!--opt, string, IPv4 address-->test
</ipAddress>
<ipv6Address>
<!--opt, string, IPv6 address-->test
</ipv6Address>
<portNo>
<!--req, int, port No.-->1
</portNo>
<userName>
<!--req, string, user name-->test
</userName>
<passWord>
<!--req, string, password-->test


<!--req, string, password-->test
</passWord>
<BindIPC>
<!--opt, string, channel No.-->1,2
</BindIPC>
</EventResource>
</EventResourceList>
<backPicId>
<!--opt, int, background picture ID-->1
</backPicId>
<Title>
<!--opt, object-->
<enabled>
<!--req, bool, whether to enable the function-->true
</enabled>
<fontSize>
<!--req, int, font size-->1
</fontSize>
<FontColor>
<!--req, object, font color-->
<RGB>
<!--opt, int-->1
</RGB>
</FontColor>
<Position>
<!--opt, object, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX>
<!--req, int, X-coordinate-->1
</positionX>
<positionY>
<!--req, int, Y-coordinate-->1
</positionY>
<height>
<!--req, int, width-->1
</height>
<width>
<!--req, int, height-->1
</width>
</Position>
<text>
<!--opt, string-->test
</text>
</Title>
<PeopleCounting>
<!--opt, object-->
<maxPeopleNumber>
<!--opt, int-->1
</maxPeopleNumber>
<unavailableBackPicId>
<!--opt, int-->1
</unavailableBackPicId>
<Prompt>
<!--opt, object-->
<enabled>
<!--req, bool, whether to enable the function-->true
</enabled>
<fontSize>
<!--req, int, font size-->1
</fontSize>
<Position>
<!--opt, object, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX>
<!--req, int, X-coordinate-->1
</positionX>
<positionY>
<!--req, int, Y-coordinate-->1
</positionY>
<height>
<!--req, int, width-->1
</height>
<width>
<!--req, int, height-->1
</width>
</Position>
<text>
<!--opt, string-->test
</text>
<FontColor>
<!--opt, object-->
<RGB>
<!--opt, int-->1
</RGB>
</FontColor>
<unavailableText>
<!--opt, string-->test
</unavailableText>
<UnavailableFontColor>
<!--opt, object-->
<RGB>
<!--opt, int-->1
</RGB>
</UnavailableFontColor>
</Prompt>
<PeopleIcon>


<!--opt, object-->
<enabled>
<!--req, bool, whether to enable the function-->true
</enabled>
<Position>
<!--opt, object, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX>
<!--req, int, X-coordinate-->1
</positionX>
<positionY>
<!--req, int, Y-coordinate-->1
</positionY>
<height>
<!--req, int, width-->1
</height>
<width>
<!--req, int, height-->1
</width>
</Position>
<materialNo>
<!--opt, int, material ID-->1
</materialNo>
</PeopleIcon>
<InsidePeopleTitle>
<!--opt, object-->
<enabled>
<!--req, bool, whether to enable the function-->true
</enabled>
<fontSize>
<!--req, int, font size-->1
</fontSize>
<FontColor>
<!--req, object, font color-->
<RGB>
<!--opt, int-->1
</RGB>
</FontColor>
<Position>
<!--opt, object, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX>
<!--req, int, X-coordinate-->1
</positionX>
<positionY>
<!--req, int, Y-coordinate-->1
</positionY>
<height>
<!--req, int, width-->1
</height>
<width>
<!--req, int, height-->1
</width>
</Position>
<text>
<!--opt, string-->test
</text>
</InsidePeopleTitle>
<InsidePeopleNumber>
<!--opt, object-->
<enabled>
<!--req, bool, whether to enable the function-->true
</enabled>
<fontSize>
<!--req, int, font size-->1
</fontSize>
<FontColor>
<!--req, object, font color-->
<RGB>
<!--opt, int-->1
</RGB>
</FontColor>
<Position>
<!--opt, object, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX>
<!--req, int, X-coordinate-->1
</positionX>
<positionY>
<!--req, int, Y-coordinate-->1
</positionY>
<height>
<!--req, int, width-->1
</height>
<width>
<!--req, int, height-->1
</width>
</Position>
</InsidePeopleNumber>
<AvailablePeopleTitle>
<!--opt, object-->
<enabled>
<!--req, bool, whether to enable the function-->true
</enabled>
<fontSize>
<!--req, int, font size-->1
</fontSize>


</fontSize>
<FontColor>
<!--req, object, font color-->
<RGB>
<!--opt, int-->1
</RGB>
</FontColor>
<Position>
<!--opt, object, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX>
<!--req, int, X-coordinate-->1
</positionX>
<positionY>
<!--req, int, Y-coordinate-->1
</positionY>
<height>
<!--req, int, width-->1
</height>
<width>
<!--req, int, height-->1
</width>
</Position>
<text>
<!--opt, string-->test
</text>
</AvailablePeopleTitle>
<AvailablePeopleNumber>
<!--opt, object-->
<enabled>
<!--req, bool, whether to enable the function-->true
</enabled>
<fontSize>
<!--req, int, font size-->1
</fontSize>
<Position>
<!--opt, object, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX>
<!--req, int, X-coordinate-->1
</positionX>
<positionY>
<!--req, int, Y-coordinate-->1
</positionY>
<height>
<!--req, int, width-->1
</height>
<width>
<!--req, int, height-->1
</width>
</Position>
<FontColor>
<!--opt, object-->
<RGB>
<!--opt, int-->1
</RGB>
</FontColor>
<UnavailableFontColor>
<!--opt, object-->
<RGB>
<!--opt, int-->1
</RGB>
</UnavailableFontColor>
</AvailablePeopleNumber>
<UnavailablePeopleIcon>
<!--opt, object-->
<enabled>
<!--req, bool, whether to enable the function-->true
</enabled>
<Position>
<!--opt, object, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX>
<!--req, int, X-coordinate-->1
</positionX>
<positionY>
<!--req, int, Y-coordinate-->1
</positionY>
<height>
<!--req, int, width-->1
</height>
<width>
<!--req, int, height-->1
</width>
</Position>
<materialNo>
<!--opt, int, material ID-->1
</materialNo>
</UnavailablePeopleIcon>
<AudioAlarm>
<!--opt, object-->
<enabled>
<!--req, bool, whether to enable the function-->true
</enabled>
<materialNo>
<!--opt, int-->1
</materialNo>


</AudioAlarm>
</PeopleCounting>
<Mask>
<!--opt, object-->
<enabled>
<!--req, bool, whether to enable the function-->true
</enabled>
<fontSize>
<!--req, int, font size-->1
</fontSize>
<FontColor>
<!--req, object, font color-->
<RGB>
<!--opt, int-->1
</RGB>
</FontColor>
<BackColor>
<!--req, object, background color-->
<RGB>
<!--opt, int-->1
</RGB>
</BackColor>
<Position>
<!--opt, object, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX>
<!--req, int, X-coordinate-->1
</positionX>
<positionY>
<!--req, int, Y-coordinate-->1
</positionY>
<height>
<!--req, int, width-->1
</height>
<width>
<!--req, int, height-->1
</width>
</Position>
<text>
<!--opt, string-->test
</text>
<MaskIcon>
<!--opt, object-->
<enabled>
<!--req, bool, whether to enable the function-->true
</enabled>
<Position>
<!--opt, object, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX>
<!--req, int, X-coordinate-->1
</positionX>
<positionY>
<!--req, int, Y-coordinate-->1
</positionY>
<height>
<!--req, int, width-->1
</height>
<width>
<!--req, int, height-->1
</width>
</Position>
<materialNo>
<!--opt, int, material ID-->1
</materialNo>
</MaskIcon>
<AudioAlarm>
<!--opt, object-->
<enabled>
<!--req, bool, whether to enable the function-->true
</enabled>
<materialNo>
<!--opt, int-->1
</materialNo>
</AudioAlarm>
</Mask>
<Temperature>
<!--opt, object-->
<Prompt>
<!--opt, object-->
<enabled>
<!--req, bool, whether to enable the function-->true
</enabled>
<fontSize>
<!--req, int, font size-->1
</fontSize>
<FontColor>
<!--req, object, font color-->
<RGB>
<!--opt, int-->1
</RGB>
</FontColor>
<BackColor>
<!--req, object, background color-->
<RGB>
<!--opt, int-->1


<!--opt, int-->1
</RGB>
</BackColor>
<Position>
<!--opt, object, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX>
<!--req, int, X-coordinate-->1
</positionX>
<positionY>
<!--req, int, Y-coordinate-->1
</positionY>
<height>
<!--req, int, width-->1
</height>
<width>
<!--req, int, height-->1
</width>
</Position>
<text>
<!--opt, string-->test
</text>
</Prompt>
<TemperatureIcon>
<!--opt, object-->
<enabled>
<!--req, bool, whether to enable the function-->true
</enabled>
<Position>
<!--opt, object, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX>
<!--req, int, X-coordinate-->1
</positionX>
<positionY>
<!--req, int, Y-coordinate-->1
</positionY>
<height>
<!--req, int, width-->1
</height>
<width>
<!--req, int, height-->1
</width>
</Position>
<materialNo>
<!--opt, int, material ID-->1
</materialNo>
</TemperatureIcon>
<AudioAlarm>
<!--opt, object-->
<enabled>
<!--req, bool, whether to enable the function-->true
</enabled>
<materialNo>
<!--opt, int-->1
</materialNo>
</AudioAlarm>
<abnormalHighTemperature>
<!--opt, float, unit:℃-->37.5
</abnormalHighTemperature>
</Temperature>
</EventParam>
<AlarmDataSourceProperty>
<!--opt, object-->
<PictureProperty>
<!--opt, object-->
<PictureSwitchEffect>
<!--opt, enum, subType:string-->leftInRightOut
</PictureSwitchEffect>
<PictureScaleType>
<!--opt, enum, subType:string-->fitCenter
</PictureScaleType>
</PictureProperty>
<AlarmDataSource>
<!--opt, object-->
<MaterialNo>
<!--opt, int, material No.-->1
</MaterialNo>
<Name>
<!--opt, string, material name-->test
</Name>
<Address>
<!--opt, string-->test
</Address>
</AlarmDataSource>
</AlarmDataSourceProperty>
<ConferenceParam>
<!--opt, object-->
<backPicId>
<!--opt, int, background picture ID-->1
</backPicId>
<Title>
<!--opt, object-->
<enabled>
<!--req, bool, whether to enable the function-->true
</enabled>


</enabled>
<fontSize>
<!--req, int, font size-->1
</fontSize>
<FontColor>
<!--req, object, font color-->
<RGB>
<!--opt, int-->1
</RGB>
</FontColor>
<BackColor>
<!--req, object, background color-->
<RGB>
<!--opt, int-->1
</RGB>
</BackColor>
<Position>
<!--opt, object, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX>
<!--req, int, X-coordinate-->1
</positionX>
<positionY>
<!--req, int, Y-coordinate-->1
</positionY>
<height>
<!--req, int, width-->1
</height>
<width>
<!--req, int, height-->1
</width>
</Position>
<alignType>
<!--req, enum, subType:string-->middle
</alignType>
</Title>
<VoiceBroadcast>
<!--opt, object, audio prompt-->
<enabled>
<!--opt, bool-->true
</enabled>
<broadcastSpeed>
<!--opt, enum, subType:string-->slower
</broadcastSpeed>
<inLibVoice>
<!--opt, string-->test
</inLibVoice>
<outLibVoice>
<!--opt, string-->test
</outLibVoice>
</VoiceBroadcast>
<WelcomeWord>
<!--opt, object, welcome words-->
<enabled>
<!--opt, bool-->true
</enabled>
<inLibWord>
<!--opt, string, range:[1,128]-->test
</inLibWord>
<outLibWord>
<!--opt, string, range:[1,128]-->test
</outLibWord>
</WelcomeWord>
<ShowInfo>
<!--opt, object-->
<row>
<!--opt, int-->1
</row>
<column>
<!--opt, int-->1
</column>
<Position>
<!--opt, object, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX>
<!--req, int, X-coordinate-->1
</positionX>
<positionY>
<!--req, int, Y-coordinate-->1
</positionY>
<height>
<!--req, int, width-->1
</height>
<width>
<!--req, int, height-->1
</width>
</Position>
<inLib>
<!--opt, object-->
<nameEnabled>
<!--opt, bool-->true
</nameEnabled>
</inLib>
<defaultShowInfoEnabled>
<!--opt, bool-->true
</defaultShowInfoEnabled>
</ShowInfo>


</ShowInfo>
<ModuleInfoList>
<!--opt, array, subType:object-->
<ModuleInfo>
<!--opt, object-->
<moduleType>
<!--req, enum, subType:string-->conferenceTime
</moduleType>
<enabled>
<!--req, bool-->true
</enabled>
<fontSize>
<!--req, int-->1
</fontSize>
<FontColor>
<!--req, object-->
<RGB>
<!--opt, int-->1
</RGB>
</FontColor>
<BackColor>
<!--opt, object-->
<RGB>
<!--opt, int-->1
</RGB>
</BackColor>
<backPicId>
<!--opt, int-->1
</backPicId>
<Position>
<!--opt, object-->
<positionX>
<!--req, int-->1
</positionX>
<positionY>
<!--req, int-->1
</positionY>
<height>
<!--req, int-->1
</height>
<width>
<!--req, int-->1
</width>
</Position>
<alignType>
<!--req, enum, subType:string-->middle
</alignType>
<CustomKey>
<!--opt, object-->
<key>
<!--opt, string-->test
</key>
<associateProtocolURL>
<!--opt, string-->test
</associateProtocolURL>
</CustomKey>
</ModuleInfo>
</ModuleInfoList>
<conferenceStatus>
<!--opt, enum, subType:string-->idle
</conferenceStatus>
<BackColor>
<!--opt, object-->
<RGB>
<!--opt, int-->1
</RGB>
</BackColor>
</ConferenceParam>
<CallBtn>
<!--opt, object-->
<backPicId>
<!--opt, int, background picture ID-->1
</backPicId>
</CallBtn>
<OpenDoorBtn>
<!--opt, object-->
<backPicId>
<!--opt, int, background picture ID-->1
</backPicId>
</OpenDoorBtn>
<QRCodeBtn>
<!--opt, object-->
<backPicId>
<!--opt, int, background picture ID-->1
</backPicId>
</QRCodeBtn>
<AuthenticationSuccess>
<!--opt, object-->
<BackColor>
<!--opt, object, background color-->
<RGB>
<!--opt, int-->1
</RGB>
</BackColor>


</BackColor>
<backPicId>
<!--opt, int, background picture ID-->1
</backPicId>
<SubWindowList>
<!--opt, object-->
<SubWindow>
<!--opt, object-->
<subWindowType>
<!--req, enum, subType:string-->temperature
</subWindowType>
<enabled>
<!--req, bool, whether to enable the function-->true
</enabled>
<fontSize>
<!--opt, int, font size, unit:px-->1
</fontSize>
<fontColor>
<!--opt, int, font color-->1
</fontColor>
<fontStyle>
<!--opt, string-->bold,italic,underline,strikeout
</fontStyle>
<Position>
<!--opt, object, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX>
<!--req, int, X-coordinate-->1
</positionX>
<positionY>
<!--req, int, Y-coordinate-->1
</positionY>
<height>
<!--req, int, width-->1
</height>
<width>
<!--req, int, height-->1
</width>
</Position>
</SubWindow>
</SubWindowList>
</AuthenticationSuccess>
<AuthenticationFail>
<!--opt, object-->
<BackColor>
<!--opt, object, background color-->
<RGB>
<!--opt, int-->1
</RGB>
</BackColor>
<backPicId>
<!--opt, int, background picture ID-->1
</backPicId>
<SubWindowList>
<!--opt, object-->
<SubWindow>
<!--opt, object-->
<subWindowType>
<!--req, enum, subType:string-->temperature
</subWindowType>
<enabled>
<!--req, bool, whether to enable the function-->true
</enabled>
<fontSize>
<!--opt, int, font size, unit:px-->1
</fontSize>
<fontColor>
<!--opt, int, font color-->1
</fontColor>
<fontStyle>
<!--opt, string-->bold,italic,underline,strikeout
</fontStyle>
<Position>
<!--opt, object, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX>
<!--req, int, X-coordinate-->1
</positionX>
<positionY>
<!--req, int, Y-coordinate-->1
</positionY>
<height>
<!--req, int, width-->1
</height>
<width>
<!--req, int, height-->1
</width>
</Position>
<facePicID>
<!--ro, opt, int, step:1, dep:and,
{$.PageList.Page.WindowsList[*].Windows.AuthenticationFail.SubWindowList.SubWindow.subWindowType,eq,facePic}-->1
</facePicID>
</SubWindow>
</SubWindowList>
</AuthenticationFail>
<StatusBar>


<!--opt, object-->
<backPicId>
<!--opt, int, background picture ID-->1
</backPicId>
<statusBarType>
<!--req, enum, subType:string-->fixed
</statusBarType>
<SubStatusList>
<!--opt, object-->
<SubStatus>
<!--opt, object, sub status-->
<statusType>
<!--req, enum, sub status, subType:string-->dial
</statusType>
<enabled>
<!--req, bool-->true
</enabled>
</SubStatus>
</SubStatusList>
</StatusBar>
</Windows>
</WindowsList>
</Page>
</PageList>
<programSize>
<!--opt, int, read-only,page list,unit: byte, unit:Byte-->1
</programSize>
<programLength>
<!--opt, int, program duration, unit:s-->1
</programLength>
<coordinateType>
<!--opt, enum, subType:string-->uniformCoordinate
</coordinateType>
<screenType>
<!--opt, enum, cut-in content type, subType:string-->first
</screenType>
<audioEnabled>
<!--opt, bool-->true
</audioEnabled>
<PageIdList>
<!--opt, array, subType:object-->
<PageId>
<!--opt, object-->
<id>
<!--req, int, program ID-->1
</id>
</PageId>
</PageIdList>
<programUUID>
<!--ro, opt, string, range:[1,32]-->test
</programUUID>
</Program>
Response Message
<?xml version="1.0" encoding="UTF-8"?>
<ResponseStatus xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--ro, req, object, response message, attr:version{ro, req, string, protocolVersion}-->
<requestURL>
<!--ro, req, string, request URL-->null
</requestURL>
<statusCode>
<!--ro, req, enum, status code, subType:int, desc:0 (OK), 1 (OK), 2 (Device Busy), 3 (Device Error), 4 (Invalid Operation), 5 (Invalid XML Format), 6
(Invalid XML Content), 7 (Reboot Required)-->0
</statusCode>
<statusString>
<!--ro, req, enum, status description, subType:string, desc:“OK” (succeeded), “Device Busy”, “Device Error”, “Invalid Operation”, “Invalid XML Format”,
“Invalid XML Content”, “Reboot” (reboot device)-->OK
</statusString>
<subStatusCode>
<!--ro, req, string, error reason description in detail, desc:error reason description in detail-->OK
</subStatusCode>
</ResponseStatus>
21.40.3 Get a specific program
Request URL
GET /ISAPI/Publish/ProgramMgr/program/<programID>
Query Parameter


Parameter Name Parameter Type Description
programID
string
Request Message
None
Response Message
<?xml version="1.0" encoding="UTF-8"?>
<Program xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--ro, req, object, program information, attr:version{req, string, protocolVersion}-->
<id>
<!--ro, req, int, program ID-->1
</id>
<programName>
<!--ro, req, string, program name-->test
</programName>
<programRemarks>
<!--ro, req, string, program description-->test
</programRemarks>
<shareProperty>
<!--ro, opt, enum, shared property: public,private, subType:string, desc:shared property: public,private-->public
</shareProperty>
<approveState>
<!--ro, opt, enum, approval status, subType:string, desc:approval status: "approved"-pass,"notPass"-not pass,"notApprove"-not approved-->approved
</approveState>
<approveRemarks>
<!--ro, opt, string, approval remarks-->test
</approveRemarks>
<programType>
<!--ro, opt, enum, program type, subType:string, desc:program type: normal,decode,touch,"decodeTouch"-decode and touch,character (welcome words,which is
used for access control devices)-->normal
</programType>
<orgNo>
<!--ro, opt, int, organization No.-->1
</orgNo>
<Resolution>
<!--ro, req, object-->
<resolutionName>
<!--ro, opt, string, resolution-->test
</resolutionName>
<imageWidth>
<!--ro, req, int, resolution (width)-->1
</imageWidth>
<imageHeight>
<!--ro, req, int, resolution (height)-->1
</imageHeight>
</Resolution>
<PageList>
<!--ro, opt, array, page list, subType:object-->
<Page>
<!--ro, opt, object, page-->
<id>
<!--ro, req, int, program ID-->1
</id>
<PageBasicInfo>
<!--ro, req, object-->
<pageName>
<!--ro, opt, string, page name-->test
</pageName>
<BackgroundColor>
<!--ro, opt, object, background color-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</BackgroundColor>
<playDurationMode>
<!--ro, opt, enum, playing time mode, subType:string-->selfDefine
</playDurationMode>
<playDuration>
<!--ro, opt, int, playing duration, unit:s-->1
</playDuration>
<playCount>
<!--ro, opt, int, playback times-->1
</playCount>
<switchDuration>
<!--ro, req, int, switch interval, unit:s-->1
</switchDuration>
<switchEffect>
<!--ro, req, enum, switching effect, subType:string-->none
</switchEffect>
<backgroundPic>
<!--ro, opt, int, background picture ID-->1
</backgroundPic>
<SignInCfg>
<!--ro, opt, object, check-in information-->
<VoiceBroadcast>
-


<VoiceBroadcast>
<!--ro, opt, object-->
<enabled>
<!--ro, opt, bool-->true
</enabled>
<broadcastSpeed>
<!--ro, opt, enum, subType:string-->slower
</broadcastSpeed>
<inLibVoice>
<!--ro, opt, string, voice prompt content of people in database-->test
</inLibVoice>
<outLibVoice>
<!--ro, opt, string-->test
</outLibVoice>
</VoiceBroadcast>
<WelcomeWord>
<!--ro, opt, object-->
<enabled>
<!--ro, opt, bool-->true
</enabled>
<inLibWord>
<!--ro, opt, string-->test
</inLibWord>
<outLibWord>
<!--ro, opt, string-->test
</outLibWord>
</WelcomeWord>
<SignCartoon>
<!--ro, opt, object-->
<signCartoonSpeed>
<!--ro, opt, enum, subType:string-->fast
</signCartoonSpeed>
</SignCartoon>
<backgroundSignEnabled>
<!--ro, opt, bool-->true
</backgroundSignEnabled>
<TemperatureDetection>
<!--ro, opt, object-->
<enabled>
<!--ro, req, bool-->true
</enabled>
<threshold>
<!--ro, req, float-->0.000
</threshold>
</TemperatureDetection>
</SignInCfg>
</PageBasicInfo>
<characterMode>
<!--ro, opt, enum, welcome word mode on the page, subType:string, desc:for access control devices, the position of the welcome words is fixed and
can be in three modes: “mode1”, “mode2”, “mode3”-->mode1
</characterMode>
<WindowsSplitMode>
<!--ro, opt, enum, subType:string-->SLIP4
</WindowsSplitMode>
<WindowsList>
<!--ro, opt, array, subType:object-->
<Windows>
<!--ro, opt, object, window information-->
<id>
<!--ro, req, int, content No.-->1
</id>
<Position>
<!--ro, opt, object, content's position, desc:the origin is the upper-left corner of the screen. The value range equals to the device
resolution-->
<positionX>
<!--ro, req, int-->1
</positionX>
<positionY>
<!--ro, req, int-->1
</positionY>
<height>
<!--ro, req, int, width-->1
</height>
<width>
<!--ro, req, int, height-->1
</width>
</Position>
<CornerRadius>
<!--ro, opt, object-->
<TopLeft>
<!--ro, opt, int-->1
</TopLeft>
<TopRight>
<!--ro, opt, int-->1
</TopRight>
<BottomLeft>
<!--ro, opt, int-->1
</BottomLeft>
<BottomRight>
<!--ro, opt, int-->1
</BottomRight>
</CornerRadius>
<layerNo>
<!--ro, req, int-->1


<!--ro, req, int-->1
</layerNo>
<WinMaterialInfo>
<!--ro, opt, object, window material information-->
<materialType>
<!--ro, req, enum, subType:string, desc:“static” (static material), “dynamic” (dynamic material), “other” (other material)-->static
</materialType>
<staticMaterialType>
<!--ro, opt, enum, static material type, subType:string-->picture
</staticMaterialType>
<dynamicType>
<!--ro, opt, enum, dynamic material type, subType:string-->web
</dynamicType>
<otherType>
<!--ro, opt, enum, other material type, subType:string-->clock
</otherType>
</WinMaterialInfo>
<TouchProperty>
<!--ro, opt, object, touching attributes-->
<windType>
<!--ro, opt, enum, window type, subType:string-->popup
</windType>
<hyperlinkType>
<!--ro, opt, enum, hyperlink type, subType:string-->window
</hyperlinkType>
<windowId>
<!--ro, opt, string, desc:it is the window of current page. This node is valid when <hyperlinkType> is window-->test
</windowId>
<pageId>
<!--ro, opt, string, page No., desc:this node is valid when <hyperlinkType> is page-->test
</pageId>
</TouchProperty>
<PlayItemList>
<!--ro, opt, array, subType:object-->
<PlayItem>
<!--ro, req, object-->
<id>
<!--ro, req, int, program ID-->1
</id>
<materialNo>
<!--ro, opt, int, material No.-->1
</materialNo>
<inputChannel>
<!--ro, opt, int, linked channel No. of the network camera-->1
</inputChannel>
<playEffect>
<!--ro, req, enum, playing effect, subType:string-->none
</playEffect>
<MarqueeInfo>
<!--ro, opt, object-->
<scrollType>
<!--ro, req, enum, marquee scrolling type, subType:string-->none
</scrollType>
<scrollDeriction>
<!--ro, req, enum, marquee scrolling direction, subType:string-->none
</scrollDeriction>
<scrollSpeed>
<!--ro, req, int, marquee scrolling speed-->1
</scrollSpeed>
</MarqueeInfo>
<PlayDuration>
<!--ro, opt, object, desc:this node can be configured for local materials, live video, and network camera channels-->
<durationType>
<!--ro, req, enum, subType:string-->selfDefine
</durationType>
<duration>
<!--ro, req, int, unit:s-->1
</duration>
</PlayDuration>
<CharactersEffect>
<!--ro, opt, object, character display effect, desc:this node is valid when the material type is text or TXT file-->
<fontSize>
<!--ro, req, int-->1
</fontSize>
<FontColor>
<!--ro, req, object-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</FontColor>
<backgroundType>
<!--ro, opt, enum, subType:string-->color
</backgroundType>
<backPicId>
<!--ro, opt, int-->1
</backPicId>
<BackColor>
<!--ro, req, object-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</BackColor>
<backTransparent>
<!--ro, req, int-->1
</backTransparent>


</backTransparent>
<subtitlesEnabled>
<!--ro, req, bool-->true
</subtitlesEnabled>
<scrollDirection>
<!--ro, req, enum, character scrolling direction, subType:string-->left
</scrollDirection>
<scrollSpeed>
<!--ro, req, int, character scrolling speed-->1
</scrollSpeed>
</CharactersEffect>
<switchEffect>
<!--ro, opt, enum, switching effect, subType:string-->random
</switchEffect>
<pageTime>
<!--ro, opt, int, unit:s-->1
</pageTime>
<scrollSpeed>
<!--ro, req, int-->1
</scrollSpeed>
<scaleType>
<!--ro, opt, enum, subType:string-->centerCrop
</scaleType>
<playType>
<!--ro, opt, enum, subType:string-->normal
</playType>
</PlayItem>
</PlayItemList>
<enabledAudio>
<!--ro, opt, bool, whether to enable audio-->true
</enabledAudio>
<enableHide>
<!--ro, opt, bool, whether to enable hiding-->true
</enableHide>
<enableLock>
<!--ro, opt, bool, whether to enable lock-->true
</enableLock>
<AppWindow>
<!--ro, opt, object-->
<WindowInfoList>
<!--ro, req, array, subType:object-->
<WindowInfo>
<!--ro, req, object, window information-->
<id>
<!--ro, req, int, program ID-->1
</id>
<materialNo>
<!--ro, req, int, material No.-->1
</materialNo>
</WindowInfo>
</WindowInfoList>
</AppWindow>
<DataSource>
<!--ro, opt, object-->
<materialNo>
<!--ro, req, int, material No.-->1
</materialNo>
</DataSource>
<Call>
<!--ro, opt, object, calling data-->
<materialNo>
<!--ro, req, int, material No.-->1
</materialNo>
<tableRow>
<!--ro, req, int, row of the table-->1
</tableRow>
<tableColumn>
<!--ro, req, int, column of the table-->1
</tableColumn>
<tableDirection>
<!--ro, req, enum, table direction, subType:string-->vertical
</tableDirection>
<tableType>
<!--ro, req, enum, table template, subType:string, desc:"template1,template2,template3,template4,template5,template6"-->template1
</tableType>
<backPicId>
<!--ro, opt, int, background picture No.-->1
</backPicId>
<alignType>
<!--ro, req, enum, alignment mode, subType:string-->left
</alignType>
<refreshDirection>
<!--ro, req, enum, subType:string-->upTodown
</refreshDirection>
<HeadDataList>
<!--ro, opt, array, subType:object-->
<HeadData>
<!--ro, opt, object, table head data-->
<id>
<!--ro, req, int, program ID-->1
</id>
<data>
<!--ro, req, string-->test
</data>


</data>
</HeadData>
</HeadDataList>
<ItemStyleList>
<!--ro, opt, array, subType:object-->
<ItemStyle>
<!--ro, opt, object, style of the table's row or column-->
<id>
<!--ro, req, int, program ID-->1
</id>
<width>
<!--ro, req, int-->1
</width>
<fontSize>
<!--ro, req, int-->1
</fontSize>
<FontColor>
<!--ro, req, object-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</FontColor>
<BackColor>
<!--ro, req, object, background color-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</BackColor>
</ItemStyle>
</ItemStyleList>
</Call>
<DynamicPic>
<!--ro, opt, object, dynamic pop-up window parameters-->
<materialNo>
<!--ro, req, int, material No.-->1
</materialNo>
<backPicId>
<!--ro, opt, int, background picture ID-->1
</backPicId>
</DynamicPic>
<CapturePic>
<!--ro, opt, object, picture capturing parameters-->
<backPicId>
<!--ro, opt, int, background picture ID-->1
</backPicId>
<ipcMaterialNo>
<!--ro, req, int-->1
</ipcMaterialNo>
<cancelType>
<!--ro, req, enum, subType:string-->manual
</cancelType>
<duration>
<!--ro, opt, int, unit:s-->1
</duration>
</CapturePic>
<ClockParam>
<!--ro, opt, object-->
<backPicId>
<!--ro, opt, int, background picture ID-->1
</backPicId>
<ClockIcon>
<!--ro, req, object, clock icon paameters-->
<enabled>
<!--ro, req, bool-->true
</enabled>
<type>
<!--ro, opt, enum, clock type, subType:string, desc:"clock1", "clock2"-->clock1
</type>
<Position>
<!--ro, opt, object, position, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX>
<!--ro, req, int-->1
</positionX>
<positionY>
<!--ro, req, int-->1
</positionY>
<height>
<!--ro, req, int, width-->1
</height>
<width>
<!--ro, req, int, height-->1
</width>
</Position>
</ClockIcon>
<YmdParam>
<!--ro, req, object, the parameters of year, month, and day in the clock-->
<enabled>
<!--ro, req, bool-->true
</enabled>
<fontSize>
<!--ro, req, int, font size-->1
</fontSize>
<FontColor>
<!--ro, req, object-->
<RGB>


<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</FontColor>
<BackColor>
<!--ro, req, object, background color-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</BackColor>
<Position>
<!--ro, opt, object, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX>
<!--ro, req, int-->1
</positionX>
<positionY>
<!--ro, req, int-->1
</positionY>
<height>
<!--ro, req, int, width-->1
</height>
<width>
<!--ro, req, int, height-->1
</width>
</Position>
</YmdParam>
<HmsParam>
<!--ro, req, object, the parameters of hour, minute, and second in the clock-->
<enabled>
<!--ro, req, bool-->true
</enabled>
<fontSize>
<!--ro, req, int, font size-->1
</fontSize>
<FontColor>
<!--ro, req, object-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</FontColor>
<BackColor>
<!--ro, req, object, background color-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</BackColor>
<Position>
<!--ro, opt, object, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX>
<!--ro, req, int-->1
</positionX>
<positionY>
<!--ro, req, int-->1
</positionY>
<height>
<!--ro, req, int, width-->1
</height>
<width>
<!--ro, req, int, height-->1
</width>
</Position>
</HmsParam>
<WeekParam>
<!--ro, req, object, week parameters-->
<enabled>
<!--ro, req, bool-->true
</enabled>
<fontSize>
<!--ro, req, int, font size-->1
</fontSize>
<FontColor>
<!--ro, req, object-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</FontColor>
<BackColor>
<!--ro, req, object, background color-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</BackColor>
<Position>
<!--ro, opt, object, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX>
<!--ro, req, int-->1
</positionX>
<positionY>
<!--ro, req, int-->1
</positionY>
<height>
<!--ro, req, int, width-->1
</height>
<width>


<width>
<!--ro, req, int, height-->1
</width>
</Position>
</WeekParam>
</ClockParam>
<WeatherParam>
<!--ro, opt, object, weather parameters-->
<backPicId>
<!--ro, opt, int-->1
</backPicId>
<WeatherIcon>
<!--ro, opt, object-->
<enabled>
<!--ro, req, bool-->true
</enabled>
<Position>
<!--ro, opt, object, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX>
<!--ro, req, int-->1
</positionX>
<positionY>
<!--ro, req, int-->1
</positionY>
<height>
<!--ro, req, int, width-->1
</height>
<width>
<!--ro, req, int, height-->1
</width>
</Position>
</WeatherIcon>
<Date>
<!--ro, opt, object-->
<enabled>
<!--ro, req, bool-->true
</enabled>
<fontSize>
<!--ro, req, int, font size-->1
</fontSize>
<FontColor>
<!--ro, req, object-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</FontColor>
<BackColor>
<!--ro, req, object, background color-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</BackColor>
<Position>
<!--ro, opt, object, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX>
<!--ro, req, int-->1
</positionX>
<positionY>
<!--ro, req, int-->1
</positionY>
<height>
<!--ro, req, int, width-->1
</height>
<width>
<!--ro, req, int, height-->1
</width>
</Position>
</Date>
<Temperature>
<!--ro, opt, object-->
<enabled>
<!--ro, req, bool-->true
</enabled>
<fontSize>
<!--ro, req, int, font size-->1
</fontSize>
<FontColor>
<!--ro, req, object-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</FontColor>
<BackColor>
<!--ro, req, object, background color-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</BackColor>
<Position>
<!--ro, opt, object, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX>
<!--ro, req, int-->1
</positionX>
<positionY>


<!--ro, req, int-->1
</positionY>
<height>
<!--ro, req, int, width-->1
</height>
<width>
<!--ro, req, int, height-->1
</width>
</Position>
</Temperature>
<WeatherContent>
<!--ro, opt, object, weather parameters-->
<enabled>
<!--ro, req, bool-->true
</enabled>
<fontSize>
<!--ro, req, int, font size-->1
</fontSize>
<FontColor>
<!--ro, req, object-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</FontColor>
<BackColor>
<!--ro, req, object, background color-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</BackColor>
<Position>
<!--ro, opt, object, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX>
<!--ro, req, int-->1
</positionX>
<positionY>
<!--ro, req, int-->1
</positionY>
<height>
<!--ro, req, int, width-->1
</height>
<width>
<!--ro, req, int, height-->1
</width>
</Position>
</WeatherContent>
<City>
<!--ro, opt, object-->
<enabled>
<!--ro, req, bool-->true
</enabled>
<cityId>
<!--ro, req, string-->test
</cityId>
<cityName>
<!--ro, req, string-->test
</cityName>
<fontSize>
<!--ro, req, int-->1
</fontSize>
<FontColor>
<!--ro, req, object-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</FontColor>
<BackColor>
<!--ro, req, object, background color-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</BackColor>
<Position>
<!--ro, opt, object, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX>
<!--ro, req, int-->1
</positionX>
<positionY>
<!--ro, req, int-->1
</positionY>
<height>
<!--ro, req, int, width-->1
</height>
<width>
<!--ro, req, int, height-->1
</width>
</Position>
</City>
<Humidity>
<!--ro, opt, object-->
<enabled>
<!--ro, req, bool-->true
</enabled>
<fontSize>


<fontSize>
<!--ro, req, int, font size-->1
</fontSize>
<FontColor>
<!--ro, req, object-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</FontColor>
<BackColor>
<!--ro, req, object, background color-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</BackColor>
<Position>
<!--ro, opt, object, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX>
<!--ro, req, int-->1
</positionX>
<positionY>
<!--ro, req, int-->1
</positionY>
<height>
<!--ro, req, int, width-->1
</height>
<width>
<!--ro, req, int, height-->1
</width>
</Position>
</Humidity>
<AirQuality>
<!--ro, opt, object-->
<enabled>
<!--ro, req, bool-->true
</enabled>
<fontSize>
<!--ro, req, int, font size-->1
</fontSize>
<FontColor>
<!--ro, req, object-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</FontColor>
<BackColor>
<!--ro, req, object, background color-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</BackColor>
<Position>
<!--ro, opt, object, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX>
<!--ro, req, int-->1
</positionX>
<positionY>
<!--ro, req, int-->1
</positionY>
<height>
<!--ro, req, int, width-->1
</height>
<width>
<!--ro, req, int, height-->1
</width>
</Position>
</AirQuality>
<UpdateTime>
<!--ro, opt, object-->
<enabled>
<!--ro, req, bool-->true
</enabled>
<refreshTime>
<!--ro, req, string-->20200826T051500+08
</refreshTime>
<updateInterval>
<!--ro, req, int, unit:minute-->1
</updateInterval>
<fontSize>
<!--ro, req, int-->1
</fontSize>
<FontColor>
<!--ro, req, object-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</FontColor>
<BackColor>
<!--ro, req, object, background color-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</BackColor>
<Position>


<Position>
<!--ro, opt, object, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX>
<!--ro, req, int-->1
</positionX>
<positionY>
<!--ro, req, int-->1
</positionY>
<height>
<!--ro, req, int, width-->1
</height>
<width>
<!--ro, req, int, height-->1
</width>
</Position>
</UpdateTime>
<Wind>
<!--ro, opt, object, wind power parameters-->
<enabled>
<!--ro, req, bool-->true
</enabled>
<fontSize>
<!--ro, req, int, font size-->1
</fontSize>
<FontColor>
<!--ro, req, object-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</FontColor>
<BackColor>
<!--ro, req, object, background color-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</BackColor>
<Position>
<!--ro, opt, object, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX>
<!--ro, req, int-->1
</positionX>
<positionY>
<!--ro, req, int-->1
</positionY>
<height>
<!--ro, req, int, width-->1
</height>
<width>
<!--ro, req, int, height-->1
</width>
</Position>
</Wind>
</WeatherParam>
<Countdown>
<!--ro, opt, object, countdown material-->
<endTime>
<!--ro, req, string-->20200826T051500+08
</endTime>
<template>
<!--ro, req, enum, template, subType:string-->template1
</template>
<timeUnit>
<!--ro, req, enum, subType:string-->year
</timeUnit>
<backPicId>
<!--ro, opt, int, background picture ID-->1
</backPicId>
<TimeFontCfg>
<!--ro, opt, object-->
<fontSize>
<!--ro, req, int-->1
</fontSize>
<FontColor>
<!--ro, req, object-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</FontColor>
<Position>
<!--ro, opt, object, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX>
<!--ro, req, int-->1
</positionX>
<positionY>
<!--ro, req, int-->1
</positionY>
<height>
<!--ro, req, int, width-->1
</height>
<width>
<!--ro, req, int, height-->1
</width>
</Position>
</TimeFontCfg>
<timeUnitEnabled>


<timeUnitEnabled>
<!--ro, opt, bool-->true
</timeUnitEnabled>
</Countdown>
<localInputNo>
<!--ro, req, enum, subType:string-->VGA
</localInputNo>
<HyperlinkBtn>
<!--ro, opt, object-->
<backPicId>
<!--ro, opt, int, background picture ID-->1
</backPicId>
</HyperlinkBtn>
<CharactersAttribute>
<!--ro, opt, object-->
<fontType>
<!--ro, req, enum, subType:string-->normal
</fontType>
<fontSize>
<!--ro, req, int-->1
</fontSize>
<FontColor>
<!--ro, req, object-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
</FontColor>
<backgroundType>
<!--ro, req, enum, subType:string-->color
</backgroundType>
<BackColor>
<!--ro, req, object-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g.,16777215 indicates 0xFFFFFF-->1
</RGB>
<fillEnabled>
<!--ro, opt, bool-->true
</fillEnabled>
</BackColor>
<backTransparent>
<!--ro, opt, int-->1
</backTransparent>
<alignType>
<!--ro, req, enum, alignment mode, subType:string-->middle
</alignType>
<verticaAlignType>
<!--ro, req, enum, vertical alignment mode, subType:string-->top
</verticaAlignType>
<characterContent>
<!--ro, opt, string, text content, range:[0,512]-->test
</characterContent>
<backPicId>
<!--ro, opt, int, background picture ID-->1
</backPicId>
<characterStyle>
<!--ro, req, enum, subType:string-->normal
</characterStyle>
<characterType>
<!--ro, opt, enum, font type, subType:string-->mainTitle
</characterType>
<scrollDirection>
<!--ro, opt, enum, character scrolling direction, subType:string-->left
</scrollDirection>
<scrollSpeed>
<!--ro, opt, int, character scrolling speed, range:[1,10]-->1
</scrollSpeed>
</CharactersAttribute>
<SignIn>
<!--ro, opt, object-->
<backPicId>
<!--ro, opt, int, background picture ID-->1
</backPicId>
<ShowInfo>
<!--ro, opt, object-->
<row>
<!--ro, opt, int-->1
</row>
<column>
<!--ro, opt, int-->1
</column>
<Position>
<!--ro, opt, object, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX>
<!--ro, req, int-->1
</positionX>
<positionY>
<!--ro, req, int-->1
</positionY>
<height>
<!--ro, req, int, width-->1
</height>
<width>
<!--ro, req, int, height-->1
</width>


</width>
</Position>
<inLib>
<!--ro, opt, object-->
<nameEnabled>
<!--ro, opt, bool-->true
</nameEnabled>
<genderEnabled>
<!--ro, opt, bool-->true
</genderEnabled>
<selfDefine1Enabled>
<!--ro, opt, bool-->true
</selfDefine1Enabled>
<selfDefine2Enabled>
<!--ro, opt, bool-->true
</selfDefine2Enabled>
<signInTimeEnabled>
<!--ro, opt, bool-->true
</signInTimeEnabled>
<temperatureEnabled>
<!--ro, opt, bool-->true
</temperatureEnabled>
</inLib>
<outLib>
<!--ro, opt, object-->
<nameEnabled>
<!--ro, opt, bool-->true
</nameEnabled>
<name>
<!--ro, opt, string-->test
</name>
<genderEnabled>
<!--ro, opt, bool-->true
</genderEnabled>
<signInTimeEnabled>
<!--ro, opt, bool-->true
</signInTimeEnabled>
<temperatureEnabled>
<!--ro, opt, bool-->true
</temperatureEnabled>
</outLib>
<showDuration>
<!--ro, req, enum, subType:string-->always
</showDuration>
</ShowInfo>
<MainTitle>
<!--ro, opt, object-->
<enabled>
<!--ro, req, bool-->true
</enabled>
<fontSize>
<!--ro, req, int, font size-->1
</fontSize>
<FontColor>
<!--ro, req, object-->
<RGB>
<!--ro, opt, int-->1
</RGB>
</FontColor>
<text>
<!--ro, opt, string-->test
</text>
</MainTitle>
<SubTitle>
<!--ro, opt, object-->
<enabled>
<!--ro, req, bool-->true
</enabled>
<fontSize>
<!--ro, req, int, font size-->1
</fontSize>
<FontColor>
<!--ro, req, object-->
<RGB>
<!--ro, opt, int-->1
</RGB>
</FontColor>
<text>
<!--ro, opt, string-->test
</text>
</SubTitle>
<NormalTemperature>
<!--ro, opt, object-->
<PeopleNumber>
<!--ro, opt, object-->
<enabled>
<!--ro, req, bool-->true
</enabled>
<fontSize>
<!--ro, req, int, font size-->1
</fontSize>
<FontColor>
<!--ro, req, object-->
<RGB>
<!--ro, opt, int-->1


<!--ro, opt, int-->1
</RGB>
</FontColor>
<Position>
<!--ro, opt, object, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX>
<!--ro, req, int-->1
</positionX>
<positionY>
<!--ro, req, int-->1
</positionY>
<height>
<!--ro, req, int, width-->1
</height>
<width>
<!--ro, req, int, height-->1
</width>
</Position>
<text>
<!--ro, opt, string-->test
</text>
</PeopleNumber>
<Icon>
<!--ro, opt, object-->
<enabled>
<!--ro, req, bool-->true
</enabled>
<Position>
<!--ro, opt, object, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX>
<!--ro, req, int-->1
</positionX>
<positionY>
<!--ro, req, int-->1
</positionY>
<height>
<!--ro, req, int, width-->1
</height>
<width>
<!--ro, req, int, height-->1
</width>
</Position>
<materialNo>
<!--ro, opt, int, material ID-->1
</materialNo>
</Icon>
</NormalTemperature>
<AbnormalTemperature>
<!--ro, opt, object-->
<PeopleNumber>
<!--ro, opt, object-->
<enabled>
<!--ro, req, bool-->true
</enabled>
<fontSize>
<!--ro, req, int, font size-->1
</fontSize>
<FontColor>
<!--ro, req, object-->
<RGB>
<!--ro, opt, int-->1
</RGB>
</FontColor>
<Position>
<!--ro, opt, object, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX>
<!--ro, req, int-->1
</positionX>
<positionY>
<!--ro, req, int-->1
</positionY>
<height>
<!--ro, req, int, width-->1
</height>
<width>
<!--ro, req, int, height-->1
</width>
</Position>
<text>
<!--ro, opt, string-->test
</text>
</PeopleNumber>
<Icon>
<!--ro, opt, object-->
<enabled>
<!--ro, req, bool-->true
</enabled>
<Position>
<!--ro, opt, object, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX>
<!--ro, req, int-->1
</positionX>
<positionY>
<!--ro, req, int-->1


<!--ro, req, int-->1
</positionY>
<height>
<!--ro, req, int, width-->1
</height>
<width>
<!--ro, req, int, height-->1
</width>
</Position>
<materialNo>
<!--ro, opt, int, material ID-->1
</materialNo>
</Icon>
</AbnormalTemperature>
</SignIn>
<EventParam>
<!--ro, opt, object-->
<EventResourceList>
<!--ro, opt, array, subType:object-->
<EventResource>
<!--ro, opt, object-->
<ipVersion>
<!--ro, req, enum, subType:string-->v4
</ipVersion>
<ipAddress>
<!--ro, opt, string, IPv4 address-->test
</ipAddress>
<ipv6Address>
<!--ro, opt, string-->test
</ipv6Address>
<portNo>
<!--ro, req, int-->1
</portNo>
<userName>
<!--ro, req, string-->test
</userName>
<passWord>
<!--ro, req, string-->test
</passWord>
<BindIPC>
<!--ro, opt, string, channel No.-->1,2
</BindIPC>
</EventResource>
</EventResourceList>
<backPicId>
<!--ro, opt, int, background picture ID-->1
</backPicId>
<Title>
<!--ro, opt, object, title-->
<enabled>
<!--ro, req, bool, whether to enable the scene-->true
</enabled>
<fontSize>
<!--ro, req, int, font size-->1
</fontSize>
<FontColor>
<!--ro, req, object-->
<RGB>
<!--ro, opt, int-->1
</RGB>
</FontColor>
<Position>
<!--ro, opt, object, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX>
<!--ro, req, int-->1
</positionX>
<positionY>
<!--ro, req, int-->1
</positionY>
<height>
<!--ro, req, int, width-->1
</height>
<width>
<!--ro, req, int, height-->1
</width>
</Position>
<text>
<!--ro, opt, string-->test
</text>
</Title>
<PeopleCounting>
<!--ro, opt, object-->
<maxPeopleNumber>
<!--ro, opt, int-->1
</maxPeopleNumber>
<unavailableBackPicId>
<!--ro, opt, int-->1
</unavailableBackPicId>
<Prompt>
<!--ro, opt, object-->
<enabled>
<!--ro, req, bool-->true
</enabled>
<fontSize>


<!--ro, req, int, font size-->1
</fontSize>
<Position>
<!--ro, opt, object, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX>
<!--ro, req, int-->1
</positionX>
<positionY>
<!--ro, req, int-->1
</positionY>
<height>
<!--ro, req, int, width-->1
</height>
<width>
<!--ro, req, int, height-->1
</width>
</Position>
<text>
<!--ro, opt, string-->test
</text>
<FontColor>
<!--ro, opt, object-->
<RGB>
<!--ro, opt, int-->1
</RGB>
</FontColor>
<unavailableText>
<!--ro, opt, string-->test
</unavailableText>
<UnavailableFontColor>
<!--ro, opt, object-->
<RGB>
<!--ro, opt, int-->1
</RGB>
</UnavailableFontColor>
</Prompt>
<PeopleIcon>
<!--ro, opt, object-->
<enabled>
<!--ro, req, bool-->true
</enabled>
<Position>
<!--ro, opt, object, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX>
<!--ro, req, int-->1
</positionX>
<positionY>
<!--ro, req, int-->1
</positionY>
<height>
<!--ro, req, int, width-->1
</height>
<width>
<!--ro, req, int, height-->1
</width>
</Position>
<materialNo>
<!--ro, opt, int, material ID-->1
</materialNo>
</PeopleIcon>
<InsidePeopleTitle>
<!--ro, opt, object-->
<enabled>
<!--ro, req, bool-->true
</enabled>
<fontSize>
<!--ro, req, int, font size-->1
</fontSize>
<FontColor>
<!--ro, req, object-->
<RGB>
<!--ro, opt, int-->1
</RGB>
</FontColor>
<Position>
<!--ro, opt, object, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX>
<!--ro, req, int-->1
</positionX>
<positionY>
<!--ro, req, int-->1
</positionY>
<height>
<!--ro, req, int, width-->1
</height>
<width>
<!--ro, req, int, height-->1
</width>
</Position>
<text>
<!--ro, opt, string-->test
</text>
</InsidePeopleTitle>
<InsidePeopleNumber>


<InsidePeopleNumber>
<!--ro, opt, object-->
<enabled>
<!--ro, req, bool-->true
</enabled>
<fontSize>
<!--ro, req, int, font size-->1
</fontSize>
<FontColor>
<!--ro, req, object-->
<RGB>
<!--ro, opt, int-->1
</RGB>
</FontColor>
<Position>
<!--ro, opt, object, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX>
<!--ro, req, int-->1
</positionX>
<positionY>
<!--ro, req, int-->1
</positionY>
<height>
<!--ro, req, int, width-->1
</height>
<width>
<!--ro, req, int, height-->1
</width>
</Position>
</InsidePeopleNumber>
<AvailablePeopleTitle>
<!--ro, opt, object-->
<enabled>
<!--ro, req, bool-->true
</enabled>
<fontSize>
<!--ro, req, int, font size-->1
</fontSize>
<FontColor>
<!--ro, req, object-->
<RGB>
<!--ro, opt, int-->1
</RGB>
</FontColor>
<Position>
<!--ro, opt, object, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX>
<!--ro, req, int-->1
</positionX>
<positionY>
<!--ro, req, int-->1
</positionY>
<height>
<!--ro, req, int, width-->1
</height>
<width>
<!--ro, req, int, height-->1
</width>
</Position>
<text>
<!--ro, opt, string-->test
</text>
</AvailablePeopleTitle>
<AvailablePeopleNumber>
<!--ro, opt, object-->
<enabled>
<!--ro, req, bool-->true
</enabled>
<fontSize>
<!--ro, req, int, font size-->1
</fontSize>
<Position>
<!--ro, opt, object, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX>
<!--ro, req, int-->1
</positionX>
<positionY>
<!--ro, req, int-->1
</positionY>
<height>
<!--ro, req, int, width-->1
</height>
<width>
<!--ro, req, int, height-->1
</width>
</Position>
<FontColor>
<!--ro, opt, object-->
<RGB>
<!--ro, opt, int-->1
</RGB>
</FontColor>
<UnavailableFontColor>
<!--ro, opt, object-->


<!--ro, opt, object-->
<RGB>
<!--ro, opt, int-->1
</RGB>
</UnavailableFontColor>
</AvailablePeopleNumber>
<UnavailablePeopleIcon>
<!--ro, opt, object-->
<enabled>
<!--ro, req, bool-->true
</enabled>
<Position>
<!--ro, opt, object, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX>
<!--ro, req, int-->1
</positionX>
<positionY>
<!--ro, req, int-->1
</positionY>
<height>
<!--ro, req, int, width-->1
</height>
<width>
<!--ro, req, int, height-->1
</width>
</Position>
<materialNo>
<!--ro, opt, int, material ID-->1
</materialNo>
</UnavailablePeopleIcon>
<AudioAlarm>
<!--ro, opt, object-->
<enabled>
<!--ro, req, bool-->true
</enabled>
<materialNo>
<!--ro, opt, int-->1
</materialNo>
</AudioAlarm>
</PeopleCounting>
<Mask>
<!--ro, opt, object-->
<enabled>
<!--ro, req, bool-->true
</enabled>
<fontSize>
<!--ro, req, int, font size-->1
</fontSize>
<FontColor>
<!--ro, req, object-->
<RGB>
<!--ro, opt, int-->1
</RGB>
</FontColor>
<BackColor>
<!--ro, req, object-->
<RGB>
<!--ro, opt, int-->1
</RGB>
</BackColor>
<Position>
<!--ro, opt, object, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX>
<!--ro, req, int-->1
</positionX>
<positionY>
<!--ro, req, int-->1
</positionY>
<height>
<!--ro, req, int, width-->1
</height>
<width>
<!--ro, req, int, height-->1
</width>
</Position>
<text>
<!--ro, opt, string-->test
</text>
<MaskIcon>
<!--ro, opt, object-->
<enabled>
<!--ro, req, bool-->true
</enabled>
<Position>
<!--ro, opt, object, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX>
<!--ro, req, int-->1
</positionX>
<positionY>
<!--ro, req, int-->1
</positionY>
<height>
<!--ro, req, int, width-->1
</height>
<width>


<width>
<!--ro, req, int, height-->1
</width>
</Position>
<materialNo>
<!--ro, opt, int, material ID-->1
</materialNo>
</MaskIcon>
<AudioAlarm>
<!--ro, opt, object-->
<enabled>
<!--ro, req, bool-->true
</enabled>
<materialNo>
<!--ro, opt, int-->1
</materialNo>
</AudioAlarm>
</Mask>
<Temperature>
<!--ro, opt, object-->
<Prompt>
<!--ro, opt, object-->
<enabled>
<!--ro, req, bool-->true
</enabled>
<fontSize>
<!--ro, req, int, font size-->1
</fontSize>
<FontColor>
<!--ro, req, object-->
<RGB>
<!--ro, opt, int-->1
</RGB>
</FontColor>
<BackColor>
<!--ro, req, object-->
<RGB>
<!--ro, opt, int-->1
</RGB>
</BackColor>
<Position>
<!--ro, opt, object, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX>
<!--ro, req, int-->1
</positionX>
<positionY>
<!--ro, req, int-->1
</positionY>
<height>
<!--ro, req, int, width-->1
</height>
<width>
<!--ro, req, int, height-->1
</width>
</Position>
<text>
<!--ro, opt, string-->test
</text>
</Prompt>
<TemperatureIcon>
<!--ro, opt, object-->
<enabled>
<!--ro, req, bool-->true
</enabled>
<Position>
<!--ro, opt, object, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX>
<!--ro, req, int-->1
</positionX>
<positionY>
<!--ro, req, int-->1
</positionY>
<height>
<!--ro, req, int, width-->1
</height>
<width>
<!--ro, req, int, height-->1
</width>
</Position>
<materialNo>
<!--ro, opt, int, material ID-->1
</materialNo>
</TemperatureIcon>
<AudioAlarm>
<!--ro, opt, object-->
<enabled>
<!--ro, req, bool-->true
</enabled>
<materialNo>
<!--ro, opt, int-->1
</materialNo>
</AudioAlarm>
<abnormalHighTemperature>
<!--ro, opt, float, unit:℃-->37.5


<!--ro, opt, float, unit:℃-->37.5
</abnormalHighTemperature>
</Temperature>
</EventParam>
<AlarmDataSourceProperty>
<!--ro, opt, object-->
<PictureProperty>
<!--ro, opt, object-->
<PictureSwitchEffect>
<!--ro, opt, enum, subType:string-->leftInRightOut
</PictureSwitchEffect>
<PictureScaleType>
<!--ro, opt, enum, subType:string-->fitCenter
</PictureScaleType>
</PictureProperty>
<AlarmDataSource>
<!--ro, opt, object, data source-->
<MaterialNo>
<!--ro, opt, int, material No.-->1
</MaterialNo>
<Name>
<!--ro, opt, string, material name-->test
</Name>
<Address>
<!--ro, opt, string-->test
</Address>
</AlarmDataSource>
</AlarmDataSourceProperty>
<ConferenceParam>
<!--ro, opt, object, meeting information-->
<backPicId>
<!--ro, opt, int, background picture ID-->1
</backPicId>
<Title>
<!--ro, opt, object-->
<enabled>
<!--ro, req, bool-->true
</enabled>
<fontSize>
<!--ro, req, int, font size-->1
</fontSize>
<FontColor>
<!--ro, req, object-->
<RGB>
<!--ro, opt, int-->1
</RGB>
</FontColor>
<BackColor>
<!--ro, req, object-->
<RGB>
<!--ro, opt, int-->1
</RGB>
</BackColor>
<Position>
<!--ro, opt, object, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX>
<!--ro, req, int-->1
</positionX>
<positionY>
<!--ro, req, int-->1
</positionY>
<height>
<!--ro, req, int, width-->1
</height>
<width>
<!--ro, req, int, height-->1
</width>
</Position>
<alignType>
<!--ro, req, enum, subType:string-->middle
</alignType>
</Title>
<VoiceBroadcast>
<!--ro, opt, object-->
<enabled>
<!--ro, opt, bool-->true
</enabled>
<broadcastSpeed>
<!--ro, opt, enum, subType:string-->slower
</broadcastSpeed>
<inLibVoice>
<!--ro, opt, string, voice prompt content of people in database-->test
</inLibVoice>
<outLibVoice>
<!--ro, opt, string-->test
</outLibVoice>
</VoiceBroadcast>
<WelcomeWord>
<!--ro, opt, object-->
<enabled>
<!--ro, opt, bool-->true
</enabled>
<inLibWord>
<!--ro, opt, string, range:[1,128]-->test
</inLibWord>


</inLibWord>
<outLibWord>
<!--ro, opt, string, range:[1,128]-->test
</outLibWord>
</WelcomeWord>
<ShowInfo>
<!--ro, opt, object-->
<row>
<!--ro, opt, int-->1
</row>
<column>
<!--ro, opt, int-->1
</column>
<Position>
<!--ro, opt, object, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX>
<!--ro, req, int-->1
</positionX>
<positionY>
<!--ro, req, int-->1
</positionY>
<height>
<!--ro, req, int, width-->1
</height>
<width>
<!--ro, req, int, height-->1
</width>
</Position>
<inLib>
<!--ro, opt, object-->
<nameEnabled>
<!--ro, opt, bool-->true
</nameEnabled>
</inLib>
<defaultShowInfoEnabled>
<!--ro, opt, bool-->true
</defaultShowInfoEnabled>
</ShowInfo>
<ModuleInfoList>
<!--ro, opt, array, subType:object-->
<ModuleInfo>
<!--ro, opt, object-->
<moduleType>
<!--ro, req, enum, module type, subType:string-->conferenceTime
</moduleType>
<enabled>
<!--ro, req, bool-->true
</enabled>
<fontSize>
<!--ro, req, int, font size-->1
</fontSize>
<FontColor>
<!--ro, req, object-->
<RGB>
<!--ro, opt, int-->1
</RGB>
</FontColor>
<BackColor>
<!--ro, opt, object-->
<RGB>
<!--ro, opt, int-->1
</RGB>
</BackColor>
<backPicId>
<!--ro, opt, int, background picture ID-->1
</backPicId>
<Position>
<!--ro, opt, object, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX>
<!--ro, req, int-->1
</positionX>
<positionY>
<!--ro, req, int-->1
</positionY>
<height>
<!--ro, req, int, width-->1
</height>
<width>
<!--ro, req, int, height-->1
</width>
</Position>
<alignType>
<!--ro, req, enum, subType:string-->middle
</alignType>
<CustomKey>
<!--ro, opt, object-->
<key>
<!--ro, opt, string-->test
</key>
<associateProtocolURL>
<!--ro, opt, string-->test
</associateProtocolURL>
</CustomKey>
</ModuleInfo>


</ModuleInfo>
</ModuleInfoList>
<conferenceStatus>
<!--ro, opt, enum, subType:string-->idle
</conferenceStatus>
<BackColor>
<!--ro, opt, object-->
<RGB>
<!--ro, opt, int-->1
</RGB>
</BackColor>
</ConferenceParam>
<CallBtn>
<!--ro, opt, object-->
<backPicId>
<!--ro, opt, int, background picture ID-->1
</backPicId>
</CallBtn>
<OpenDoorBtn>
<!--ro, opt, object-->
<backPicId>
<!--ro, opt, int, background picture ID-->1
</backPicId>
</OpenDoorBtn>
<QRCodeBtn>
<!--ro, opt, object-->
<backPicId>
<!--ro, opt, int, background picture ID-->1
</backPicId>
</QRCodeBtn>
<AuthenticationSuccess>
<!--ro, opt, object-->
<BackColor>
<!--ro, opt, object-->
<RGB>
<!--ro, opt, int-->1
</RGB>
</BackColor>
<backPicId>
<!--ro, opt, int, background picture ID-->1
</backPicId>
<SubWindowList>
<!--ro, opt, object-->
<SubWindow>
<!--ro, opt, object-->
<subWindowType>
<!--ro, req, enum, subType:string-->temperature
</subWindowType>
<enabled>
<!--ro, req, bool-->true
</enabled>
<fontSize>
<!--ro, opt, int, font size, unit:px-->1
</fontSize>
<fontColor>
<!--ro, opt, int-->1
</fontColor>
<fontStyle>
<!--ro, opt, string, font style-->bold,italic,underline,strikeout
</fontStyle>
<Position>
<!--ro, opt, object, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX>
<!--ro, req, int-->1
</positionX>
<positionY>
<!--ro, req, int-->1
</positionY>
<height>
<!--ro, req, int, width-->1
</height>
<width>
<!--ro, req, int, height-->1
</width>
</Position>
</SubWindow>
</SubWindowList>
</AuthenticationSuccess>
<AuthenticationFail>
<!--ro, opt, object-->
<BackColor>
<!--ro, opt, object-->
<RGB>
<!--ro, opt, int-->1
</RGB>
</BackColor>
<backPicId>
<!--ro, opt, int, background picture ID-->1
</backPicId>
<SubWindowList>
<!--ro, opt, object-->
<SubWindow>
<!--ro, opt, object-->
<subWindowType>


<!--ro, req, enum, subType:string-->temperature
</subWindowType>
<enabled>
<!--ro, req, bool-->true
</enabled>
<fontSize>
<!--ro, opt, int, font size, unit:px-->1
</fontSize>
<fontColor>
<!--ro, opt, int-->1
</fontColor>
<fontStyle>
<!--ro, opt, string, font style-->bold,italic,underline,strikeout
</fontStyle>
<Position>
<!--ro, opt, object, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX>
<!--ro, req, int-->1
</positionX>
<positionY>
<!--ro, req, int-->1
</positionY>
<height>
<!--ro, req, int, width-->1
</height>
<width>
<!--ro, req, int, height-->1
</width>
</Position>
<facePicID>
<!--ro, opt, int, step:1, dep:and,
{$.PageList.Page.WindowsList[*].Windows.AuthenticationFail.SubWindowList.SubWindow.subWindowType,eq,facePic}-->1
</facePicID>
</SubWindow>
</SubWindowList>
</AuthenticationFail>
<StatusBar>
<!--ro, opt, object, status bar-->
<backPicId>
<!--ro, opt, int, background picture ID-->1
</backPicId>
<statusBarType>
<!--ro, req, enum, subType:string-->fixed
</statusBarType>
<SubStatusList>
<!--ro, opt, object-->
<SubStatus>
<!--ro, opt, object, sub status-->
<statusType>
<!--ro, req, enum, sub status, subType:string-->dial
</statusType>
<enabled>
<!--ro, req, bool-->true
</enabled>
</SubStatus>
</SubStatusList>
</StatusBar>
</Windows>
</WindowsList>
</Page>
</PageList>
<programSize>
<!--ro, opt, int, read-only,page list,unit: byte, unit:Byte-->1
</programSize>
<programLength>
<!--ro, opt, int, program duration, unit:s-->1
</programLength>
<coordinateType>
<!--ro, opt, enum, subType:string-->uniformCoordinate
</coordinateType>
<screenType>
<!--ro, opt, enum, subType:string-->first
</screenType>
<audioEnabled>
<!--ro, opt, bool-->true
</audioEnabled>
<PageIdList>
<!--ro, opt, array, subType:object-->
<PageId>
<!--ro, opt, object-->
<id>
<!--ro, req, int, program ID-->1
</id>
</PageId>
</PageIdList>
<programUUID>
<!--ro, opt, string, range:[1,32]-->test
</programUUID>
</Program>


21.40.4 Get all programs' parameters
Request URL
GET /ISAPI/Publish/ProgramMgr/program
Query Parameter
None
Request Message
None
Response Message
<?xml version="1.0" encoding="UTF-8"?>
<ProgramList xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--ro, req, array, program list, subType:object, attr:version{req, string, protocolVersion}-->
<Program>
<!--ro, req, object, program information-->
<id>
<!--ro, req, int, program ID-->1
</id>
<programName>
<!--ro, req, string, program name-->test
</programName>
<programRemarks>
<!--ro, req, string, program description-->test
</programRemarks>
<shareProperty>
<!--ro, opt, enum, shared property, subType:string, desc:"public", "private"-->public
</shareProperty>
<approveState>
<!--ro, opt, enum, approval status, subType:string, desc:"approved" (approved), "notPass" (not approved), "notApprove" (not reviewed)-->approved
</approveState>
<approveRemarks>
<!--ro, opt, string, approval remarks-->test
</approveRemarks>
<programType>
<!--ro, opt, enum, program type, subType:string-->normal
</programType>
<orgNo>
<!--ro, opt, int, organization No.-->1
</orgNo>
<Resolution>
<!--ro, req, object, resolution-->
<resolutionName>
<!--ro, opt, string, resolution name-->test
</resolutionName>
<imageWidth>
<!--ro, req, int, resolution (width)-->1
</imageWidth>
<imageHeight>
<!--ro, req, int, resolution (height)-->1
</imageHeight>
</Resolution>
<PageList>
<!--ro, opt, array, page list, subType:object-->
<Page>
<!--ro, opt, object, page-->
<id>
<!--ro, req, int, ID-->1
</id>
<PageBasicInfo>
<!--ro, req, object, page information of application program-->
<pageName>
<!--ro, opt, string, page name-->test
</pageName>
<BackgroundColor>
<!--ro, opt, object, background color-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g., 16777215 indicates 0xFFFFFF-->1
</RGB>
</BackgroundColor>
<playDurationMode>
<!--ro, opt, enum, playing time mode, subType:string-->selfDefine
</playDurationMode>
<playDuration>
<!--ro, opt, int, unit:s-->1
</playDuration>
<playCount>
<!--ro, opt, int, playback times-->1
</playCount>
<switchDuration>
<!--ro, req, int, switch interval, unit:s-->1
</switchDuration>
<switchEffect>
<!--ro, req, enum, switching effect, subType:string, desc:Switching Effect-->none
</switchEffect>


</switchEffect>
<backgroundPic>
<!--ro, opt, int, background picture ID-->1
</backgroundPic>
<SignInCfg>
<!--ro, opt, object, check-in information-->
<VoiceBroadcast>
<!--ro, opt, object, audio prompt-->
<enabled>
<!--ro, opt, bool-->true
</enabled>
<broadcastSpeed>
<!--ro, opt, enum, subType:string-->slower
</broadcastSpeed>
<inLibVoice>
<!--ro, opt, string-->test
</inLibVoice>
<outLibVoice>
<!--ro, opt, string-->test
</outLibVoice>
</VoiceBroadcast>
<WelcomeWord>
<!--ro, opt, object, welcome words-->
<enabled>
<!--ro, opt, bool-->true
</enabled>
<inLibWord>
<!--ro, opt, string-->test
</inLibWord>
<outLibWord>
<!--ro, opt, string-->test
</outLibWord>
</WelcomeWord>
<SignCartoon>
<!--ro, opt, object-->
<signCartoonSpeed>
<!--ro, opt, enum, subType:string-->fast
</signCartoonSpeed>
</SignCartoon>
<backgroundSignEnabled>
<!--ro, opt, bool-->true
</backgroundSignEnabled>
<TemperatureDetection>
<!--ro, opt, object-->
<enabled>
<!--ro, req, bool-->true
</enabled>
<threshold>
<!--ro, req, float-->0.000
</threshold>
</TemperatureDetection>
</SignInCfg>
</PageBasicInfo>
<characterMode>
<!--ro, opt, enum, subType:string-->mode1
</characterMode>
<WindowsList>
<!--ro, opt, array, subType:object-->
<Windows>
<!--ro, opt, object-->
<id>
<!--ro, req, int-->1
</id>
<Position>
<!--ro, opt, object, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX>
<!--ro, req, int, X-coordinate-->1
</positionX>
<positionY>
<!--ro, req, int, Y-coordinate-->1
</positionY>
<height>
<!--ro, req, int, width-->1
</height>
<width>
<!--ro, req, int, height-->1
</width>
</Position>
<CornerRadius>
<!--ro, opt, object-->
<TopLeft>
<!--ro, opt, int-->1
</TopLeft>
<TopRight>
<!--ro, opt, int-->1
</TopRight>
<BottomLeft>
<!--ro, opt, int-->1
</BottomLeft>
<BottomRight>
<!--ro, opt, int-->1
</BottomRight>
</CornerRadius>
<layerNo>


<layerNo>
<!--ro, req, int, layer No.-->1
</layerNo>
<WinMaterialInfo>
<!--ro, opt, object, window material information-->
<materialType>
<!--ro, req, enum, material type, subType:string, desc:“static” (static material), “dynamic” (dynamic material), “other” (other material)-
>static
</materialType>
<staticMaterialType>
<!--ro, opt, enum, static material type, subType:string, desc:static material type-->picture
</staticMaterialType>
<dynamicType>
<!--ro, opt, enum, dynamic material type, subType:string, desc:dynamic material type-->web
</dynamicType>
<otherType>
<!--ro, opt, enum, other material type, subType:string-->clock
</otherType>
</WinMaterialInfo>
<TouchProperty>
<!--ro, opt, object, touching attributes-->
<windType>
<!--ro, opt, enum, window type, subType:string, desc:Window Type-->popup
</windType>
<hyperlinkType>
<!--ro, opt, enum, hyperlink type, subType:string-->window
</hyperlinkType>
<windowId>
<!--ro, opt, int, window No., desc:it is the window of current page. This node is valid when <hyperlinkType> is window-->1
</windowId>
<pageId>
<!--ro, opt, int, page No., desc:this node is valid when <hyperlinkType> is page-->1
</pageId>
</TouchProperty>
<PlayItemList>
<!--ro, opt, array, window playing list, subType:object-->
<PlayItem>
<!--ro, req, object-->
<id>
<!--ro, req, int-->1
</id>
<materialNo>
<!--ro, opt, int, material No.-->1
</materialNo>
<inputChannel>
<!--ro, opt, int, linked channel No. of the network camera-->1
</inputChannel>
<playEffect>
<!--ro, req, enum, playing effect, subType:string-->none
</playEffect>
<MarqueeInfo>
<!--ro, opt, object-->
<scrollType>
<!--ro, req, enum, marquee scrolling type, subType:string-->none
</scrollType>
<scrollDeriction>
<!--ro, req, enum, marquee scrolling direction, subType:string-->none
</scrollDeriction>
<scrollSpeed>
<!--ro, req, int, marquee scrolling speed-->1
</scrollSpeed>
</MarqueeInfo>
<PlayDuration>
<!--ro, opt, object, desc:this node can be configured for local materials, live video, and network camera channels-->
<durationType>
<!--ro, req, enum, subType:string-->selfDefine
</durationType>
<duration>
<!--ro, req, int, duration, unit:s-->1
</duration>
</PlayDuration>
<CharactersEffect>
<!--ro, opt, object, character display effect, desc:this node is valid when the material type is text or TXT file-->
<fontSize>
<!--ro, req, int, font size-->1
</fontSize>
<FontColor>
<!--ro, req, object, font color-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g., 16777215 indicates 0xFFFFFF-->1
</RGB>
</FontColor>
<backgroundType>
<!--ro, opt, enum, subType:string-->color
</backgroundType>
<backPicId>
<!--ro, opt, int-->1
</backPicId>
<BackColor>
<!--ro, req, object, background color-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g., 16777215 indicates 0xFFFFFF-->1
</RGB>
</BackColor>
<backTransparent>


<backTransparent>
<!--ro, req, int, background transparency-->1
</backTransparent>
<subtitlesEnabled>
<!--ro, req, bool-->true
</subtitlesEnabled>
<scrollDirection>
<!--ro, req, enum, character scrolling direction, subType:string-->left
</scrollDirection>
<scrollSpeed>
<!--ro, req, int, character scrolling speed-->1
</scrollSpeed>
</CharactersEffect>
<switchEffect>
<!--ro, opt, enum, switching effect, subType:string-->random
</switchEffect>
<pageTime>
<!--ro, opt, int, page turning time, unit:s, desc:Paging Time-->1
</pageTime>
<scrollSpeed>
<!--ro, req, int, scrolling speed-->1
</scrollSpeed>
<scaleType>
<!--ro, opt, enum, subType:string-->centerCrop
</scaleType>
<playType>
<!--ro, opt, enum, subType:string-->normal
</playType>
</PlayItem>
</PlayItemList>
<enabledAudio>
<!--ro, opt, bool, whether to enable audio-->true
</enabledAudio>
<enableHide>
<!--ro, opt, bool-->true
</enableHide>
<enableLock>
<!--ro, opt, bool, whether to enable lock-->true
</enableLock>
<AppWindow>
<!--ro, opt, object-->
<WindowInfoList>
<!--ro, req, array, window information list, subType:object-->
<WindowInfo>
<!--ro, req, object, window information-->
<id>
<!--ro, req, int, ID-->1
</id>
<materialNo>
<!--ro, req, int, material No.-->1
</materialNo>
</WindowInfo>
</WindowInfoList>
</AppWindow>
<DataSource>
<!--ro, opt, object, data source, desc:Data Source-->
<materialNo>
<!--ro, req, int, material No.-->1
</materialNo>
</DataSource>
<Call>
<!--ro, opt, object, calling data-->
<materialNo>
<!--ro, req, int, material No.-->1
</materialNo>
<tableRow>
<!--ro, req, int, row of the table-->1
</tableRow>
<tableColumn>
<!--ro, req, int, column of the table-->1
</tableColumn>
<tableDirection>
<!--ro, req, enum, table direction, subType:string, desc:"vertical", "horizontal"-->vertical
</tableDirection>
<tableType>
<!--ro, req, enum, table template, subType:string, desc:"template1,template2,template3,template4,template5,template6"-->template1
</tableType>
<backPicId>
<!--ro, opt, int, background picture No.-->1
</backPicId>
<alignType>
<!--ro, req, enum, alignment mode, subType:string, desc:Alignment-->left
</alignType>
<refreshDirection>
<!--ro, req, enum, refreshing direction, subType:string, desc:Refreshing Direction-->upTodown
</refreshDirection>
<HeadDataList>
<!--ro, opt, array, subType:object-->
<HeadData>
<!--ro, opt, object-->
<id>
<!--ro, req, int, ID-->1
</id>
<data>


<data>
<!--ro, req, string, data-->test
</data>
</HeadData>
</HeadDataList>
<ItemStyleList>
<!--ro, opt, array, subType:object-->
<ItemStyle>
<!--ro, opt, object, style of the table's row or column-->
<id>
<!--ro, req, int, ID-->1
</id>
<width>
<!--ro, req, int-->1
</width>
<fontSize>
<!--ro, req, int, font size-->1
</fontSize>
<FontColor>
<!--ro, req, object, font color-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g., 16777215 indicates 0xFFFFFF-->1
</RGB>
</FontColor>
<BackColor>
<!--ro, req, object, background color-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g., 16777215 indicates 0xFFFFFF-->1
</RGB>
</BackColor>
</ItemStyle>
</ItemStyleList>
</Call>
<DynamicPic>
<!--ro, opt, object, dynamic pop-up window parameters-->
<materialNo>
<!--ro, req, int, material No.-->1
</materialNo>
<backPicId>
<!--ro, opt, int, background picture ID-->1
</backPicId>
</DynamicPic>
<CapturePic>
<!--ro, opt, object, picture capturing parameters-->
<backPicId>
<!--ro, opt, int, background picture ID-->1
</backPicId>
<ipcMaterialNo>
<!--ro, req, int-->1
</ipcMaterialNo>
<cancelType>
<!--ro, req, enum, cancel mode, subType:string, desc:Cancel Mode-->manual
</cancelType>
<duration>
<!--ro, opt, int, duration, unit:s-->1
</duration>
</CapturePic>
<ClockParam>
<!--ro, opt, object-->
<backPicId>
<!--ro, opt, int, background picture ID-->1
</backPicId>
<ClockIcon>
<!--ro, req, object, clock icon parameters-->
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<type>
<!--ro, opt, enum, clock type, subType:string, desc:"clock1", "clock2"-->clock1
</type>
<Position>
<!--ro, opt, object, coordinates, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution->
<positionX>
<!--ro,
req, int, X-coordinate-->1
</positionX>
<positionY>
<!--ro, req, int, Y-coordinate-->1
</positionY>
<height>
<!--ro, req, int, width-->1
</height>
<width>
<!--ro, req, int, height-->1
</width>
</Position>
</ClockIcon>
<YmdParam>
<!--ro, req, object, the parameters of year, month, and day in the clock-->
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<fontSize>
<!--ro, req, int, font size-->1


</fontSize>
<FontColor>
<!--ro, req, object, font color-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g., 16777215 indicates 0xFFFFFF-->1
</RGB>
</FontColor>
<BackColor>
<!--ro, req, object, background color-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g., 16777215 indicates 0xFFFFFF-->1
</RGB>
</BackColor>
<Position>
<!--ro, opt, object, coordinates, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution->
<positionX>
<!--ro,
req, int, X-coordinate-->1
</positionX>
<positionY>
<!--ro, req, int, Y-coordinate-->1
</positionY>
<height>
<!--ro, req, int, width-->1
</height>
<width>
<!--ro, req, int, height-->1
</width>
</Position>
</YmdParam>
<HmsParam>
<!--ro, req, object, the parameters of hour, minute, and second in the clock-->
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<fontSize>
<!--ro, req, int, font size-->1
</fontSize>
<FontColor>
<!--ro, req, object, font color-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g., 16777215 indicates 0xFFFFFF-->1
</RGB>
</FontColor>
<BackColor>
<!--ro, req, object, background color-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g., 16777215 indicates 0xFFFFFF-->1
</RGB>
</BackColor>
<Position>
<!--ro, opt, object, coordinates, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution->
<positionX>
<!--ro,
req, int, X-coordinate-->1
</positionX>
<positionY>
<!--ro, req, int, Y-coordinate-->1
</positionY>
<height>
<!--ro, req, int, width-->1
</height>
<width>
<!--ro, req, int, height-->1
</width>
</Position>
</HmsParam>
<WeekParam>
<!--ro, req, object, week parameters-->
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<fontSize>
<!--ro, req, int, font size-->1
</fontSize>
<FontColor>
<!--ro, req, object, font color-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g., 16777215 indicates 0xFFFFFF-->1
</RGB>
</FontColor>
<BackColor>
<!--ro, req, object, background color-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g., 16777215 indicates 0xFFFFFF-->1
</RGB>
</BackColor>
<Position>
<!--ro, opt, object, coordinates, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution->
<positionX>
<!--ro,
req, int, X-coordinate-->1
</positionX>
<positionY>


<positionY>
<!--ro, req, int, Y-coordinate-->1
</positionY>
<height>
<!--ro, req, int, width-->1
</height>
<width>
<!--ro, req, int, height-->1
</width>
</Position>
</WeekParam>
</ClockParam>
<WeatherParam>
<!--ro, opt, object, weather parameters-->
<backPicId>
<!--ro, opt, int, control's background picture-->1
</backPicId>
<WeatherIcon>
<!--ro, opt, object, weather icon parameters-->
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<Position>
<!--ro, opt, object, position, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX>
<!--ro, req, int, X-coordinate-->1
</positionX>
<positionY>
<!--ro, req, int, Y-coordinate-->1
</positionY>
<height>
<!--ro, req, int, width-->1
</height>
<width>
<!--ro, req, int, height-->1
</width>
</Position>
</WeatherIcon>
<Date>
<!--ro, opt, object, date parameters-->
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<fontSize>
<!--ro, req, int, font size-->1
</fontSize>
<FontColor>
<!--ro, req, object, font color-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g., 16777215 indicates 0xFFFFFF-->1
</RGB>
</FontColor>
<BackColor>
<!--ro, req, object, background color-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g., 16777215 indicates 0xFFFFFF-->1
</RGB>
</BackColor>
<Position>
<!--ro, opt, object, coordinates, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution->
<positionX>
<!--ro,
req, int, X-coordinate-->1
</positionX>
<positionY>
<!--ro, req, int, Y-coordinate-->1
</positionY>
<height>
<!--ro, req, int, width-->1
</height>
<width>
<!--ro, req, int, height-->1
</width>
</Position>
</Date>
<Temperature>
<!--ro, opt, object, temperature parameters-->
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<fontSize>
<!--ro, req, int, font size-->1
</fontSize>
<FontColor>
<!--ro, req, object, font color-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g., 16777215 indicates 0xFFFFFF-->1
</RGB>
</FontColor>
<BackColor>
<!--ro, req, object, background color-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g., 16777215 indicates 0xFFFFFF-->1
</RGB>


</BackColor>
<Position>
<!--ro, opt, object, coordinates, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution->
<positionX>
<!--ro,
req, int, X-coordinate-->1
</positionX>
<positionY>
<!--ro, req, int, Y-coordinate-->1
</positionY>
<height>
<!--ro, req, int, width-->1
</height>
<width>
<!--ro, req, int, height-->1
</width>
</Position>
</Temperature>
<WeatherContent>
<!--ro, opt, object, weather parameters-->
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<fontSize>
<!--ro, req, int, font size-->1
</fontSize>
<FontColor>
<!--ro, req, object, font color-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g., 16777215 indicates 0xFFFFFF-->1
</RGB>
</FontColor>
<BackColor>
<!--ro, req, object, background color-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g., 16777215 indicates 0xFFFFFF-->1
</RGB>
</BackColor>
<Position>
<!--ro, opt, object, coordinates, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution->
<positionX>
<!--ro,
req, int, X-coordinate-->1
</positionX>
<positionY>
<!--ro, req, int, Y-coordinate-->1
</positionY>
<height>
<!--ro, req, int, width-->1
</height>
<width>
<!--ro, req, int, height-->1
</width>
</Position>
</WeatherContent>
<City>
<!--ro, opt, object-->
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<cityId>
<!--ro, req, string-->test
</cityId>
<cityName>
<!--ro, req, string, city name-->test
</cityName>
<fontSize>
<!--ro, req, int, font size-->1
</fontSize>
<FontColor>
<!--ro, req, object, font color-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g., 16777215 indicates 0xFFFFFF-->1
</RGB>
</FontColor>
<BackColor>
<!--ro, req, object, background color-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g., 16777215 indicates 0xFFFFFF-->1
</RGB>
</BackColor>
<Position>
<!--ro, opt, object, coordinates, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution->
<positionX>
<!--ro,
req, int, X-coordinate-->1
</positionX>
<positionY>
<!--ro, req, int, Y-coordinate-->1
</positionY>
<height>
<!--ro, req, int, width-->1
</height>
<width>


<width>
<!--ro, req, int, height-->1
</width>
</Position>
</City>
<Humidity>
<!--ro, opt, object, humidity parameters-->
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<fontSize>
<!--ro, req, int, font size-->1
</fontSize>
<FontColor>
<!--ro, req, object, font color-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g., 16777215 indicates 0xFFFFFF-->1
</RGB>
</FontColor>
<BackColor>
<!--ro, req, object, background color-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g., 16777215 indicates 0xFFFFFF-->1
</RGB>
</BackColor>
<Position>
<!--ro, opt, object, coordinates, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution->
<positionX>
<!--ro,
req, int, X-coordinate-->1
</positionX>
<positionY>
<!--ro, req, int, Y-coordinate-->1
</positionY>
<height>
<!--ro, req, int, width-->1
</height>
<width>
<!--ro, req, int, height-->1
</width>
</Position>
</Humidity>
<AirQuality>
<!--ro, opt, object, air quality parameters-->
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<fontSize>
<!--ro, req, int, font size-->1
</fontSize>
<FontColor>
<!--ro, req, object, font color-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g., 16777215 indicates 0xFFFFFF-->1
</RGB>
</FontColor>
<BackColor>
<!--ro, req, object, background color-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g., 16777215 indicates 0xFFFFFF-->1
</RGB>
</BackColor>
<Position>
<!--ro, opt, object, coordinates, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution->
<positionX>
<!--ro,
req, int, X-coordinate-->1
</positionX>
<positionY>
<!--ro, req, int, Y-coordinate-->1
</positionY>
<height>
<!--ro, req, int, width-->1
</height>
<width>
<!--ro, req, int, height-->1
</width>
</Position>
</AirQuality>
<UpdateTime>
<!--ro, opt, object-->
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<refreshTime>
<!--ro, req, string, refreshing time-->20200826T051500+08
</refreshTime>
<updateInterval>
<!--ro, req, int, refresh interval, unit:minute-->1
</updateInterval>
<fontSize>
<!--ro, req, int, font size-->1
</fontSize>
<FontColor>


<FontColor>
<!--ro, req, object, font color-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g., 16777215 indicates 0xFFFFFF-->1
</RGB>
</FontColor>
<BackColor>
<!--ro, req, object, background color-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g., 16777215 indicates 0xFFFFFF-->1
</RGB>
</BackColor>
<Position>
<!--ro, opt, object, coordinates, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution->
<positionX>
<!--ro,
req, int, X-coordinate-->1
</positionX>
<positionY>
<!--ro, req, int, Y-coordinate-->1
</positionY>
<height>
<!--ro, req, int, width-->1
</height>
<width>
<!--ro, req, int, height-->1
</width>
</Position>
</UpdateTime>
<Wind>
<!--ro, opt, object, wind power parameters-->
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<fontSize>
<!--ro, req, int, font size-->1
</fontSize>
<FontColor>
<!--ro, req, object, font color-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g., 16777215 indicates 0xFFFFFF-->1
</RGB>
</FontColor>
<BackColor>
<!--ro, req, object, background color-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g., 16777215 indicates 0xFFFFFF-->1
</RGB>
</BackColor>
<Position>
<!--ro, opt, object, coordinates, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution->
<positionX>
<!--ro,
req, int, X-coordinate-->1
</positionX>
<positionY>
<!--ro, req, int, Y-coordinate-->1
</positionY>
<height>
<!--ro, req, int, width-->1
</height>
<width>
<!--ro, req, int, height-->1
</width>
</Position>
</Wind>
</WeatherParam>
<Countdown>
<!--ro, opt, object, countdown material-->
<endTime>
<!--ro, req, string, countdown time-->20200826T051500+08
</endTime>
<template>
<!--ro, req, enum, template, subType:string-->template1
</template>
<timeUnit>
<!--ro, req, enum, time unit, subType:string-->year
</timeUnit>
<backPicId>
<!--ro, opt, int, background picture ID-->1
</backPicId>
<TimeFontCfg>
<!--ro, opt, object-->
<fontSize>
<!--ro, req, int, font size-->1
</fontSize>
<FontColor>
<!--ro, req, object, font color-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g., 16777215 indicates 0xFFFFFF-->1
</RGB>
</FontColor>
<Position>
<!--ro, opt, object, coordinates, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution->


->
<positionX>
<!--ro, req, int, X-coordinate-->1
</positionX>
<positionY>
<!--ro, req, int, Y-coordinate-->1
</positionY>
<height>
<!--ro, req, int, width-->1
</height>
<width>
<!--ro, req, int, height-->1
</width>
</Position>
</TimeFontCfg>
<timeUnitEnabled>
<!--ro, opt, bool-->true
</timeUnitEnabled>
</Countdown>
<localInputNo>
<!--ro, req, enum, subType:string-->VGA
</localInputNo>
<HyperlinkBtn>
<!--ro, opt, object-->
<backPicId>
<!--ro, opt, int, background picture ID-->1
</backPicId>
</HyperlinkBtn>
<CharactersAttribute>
<!--ro, opt, object, character attribute, desc:this node is valid when <dynamicType> is character-->
<fontSize>
<!--ro, req, int, font size-->1
</fontSize>
<FontColor>
<!--ro, req, object, font color-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g., 16777215 indicates 0xFFFFFF-->1
</RGB>
</FontColor>
<backgroundType>
<!--ro, req, enum, subType:string-->color
</backgroundType>
<BackColor>
<!--ro, req, object, background color-->
<RGB>
<!--ro, opt, int, RGB value, desc:three primary colors in decimal format, e.g., 16777215 indicates 0xFFFFFF-->1
</RGB>
<fillEnabled>
<!--ro, opt, bool-->true
</fillEnabled>
</BackColor>
<backTransparent>
<!--ro, opt, int, background transparency-->1
</backTransparent>
<alignType>
<!--ro, req, enum, alignment mode, subType:string, desc:Alignment-->middle
</alignType>
<verticaAlignType>
<!--ro, req, enum, vertical alignment mode, subType:string-->top
</verticaAlignType>
<characterContent>
<!--ro, opt, string, text content, range:[0,512]-->test
</characterContent>
<backPicId>
<!--ro, opt, int, background picture ID-->1
</backPicId>
<characterStyle>
<!--ro, req, enum, subType:string-->normal
</characterStyle>
<characterType>
<!--ro, req, enum, font type, subType:string-->mainTitle
</characterType>
<scrollDirection>
<!--ro, opt, enum, character scrolling direction, subType:string-->left
</scrollDirection>
<scrollSpeed>
<!--ro, opt, int, character scrolling speed, range:[1,10]-->1
</scrollSpeed>
</CharactersAttribute>
<SignIn>
<!--ro, opt, object-->
<backPicId>
<!--ro, opt, int, background picture ID-->1
</backPicId>
<ShowInfo>
<!--ro, opt, object-->
<row>
<!--ro, opt, int-->1
</row>
<column>
<!--ro, opt, int-->1
</column>
<Position>
<!--ro, opt, object, position, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->


<!--ro, opt, object, position, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX>
<!--ro, req, int, X-coordinate-->1
</positionX>
<positionY>
<!--ro, req, int, Y-coordinate-->1
</positionY>
<height>
<!--ro, req, int, width-->1
</height>
<width>
<!--ro, req, int, height-->1
</width>
</Position>
<inLib>
<!--ro, opt, object-->
<nameEnabled>
<!--ro, opt, bool-->true
</nameEnabled>
<genderEnabled>
<!--ro, opt, bool-->true
</genderEnabled>
<selfDefine1Enabled>
<!--ro, opt, bool-->true
</selfDefine1Enabled>
<selfDefine2Enabled>
<!--ro, opt, bool-->true
</selfDefine2Enabled>
<signInTimeEnabled>
<!--ro, opt, bool-->true
</signInTimeEnabled>
<temperatureEnabled>
<!--ro, opt, bool-->true
</temperatureEnabled>
</inLib>
<outLib>
<!--ro, opt, object-->
<nameEnabled>
<!--ro, opt, bool-->true
</nameEnabled>
<name>
<!--ro, opt, string-->test
</name>
<genderEnabled>
<!--ro, opt, bool-->true
</genderEnabled>
<signInTimeEnabled>
<!--ro, opt, bool-->true
</signInTimeEnabled>
<temperatureEnabled>
<!--ro, opt, bool-->true
</temperatureEnabled>
</outLib>
<showDuration>
<!--ro, req, enum, subType:string-->always
</showDuration>
</ShowInfo>
<MainTitle>
<!--ro, opt, object-->
<enabled>
<!--ro, req, bool-->true
</enabled>
<fontSize>
<!--ro, req, int, font size-->1
</fontSize>
<FontColor>
<!--ro, req, object, font color-->
<RGB>
<!--ro, opt, int, three primary colors in decimal format-->1
</RGB>
</FontColor>
<text>
<!--ro, opt, string-->test
</text>
</MainTitle>
<SubTitle>
<!--ro, opt, object-->
<enabled>
<!--ro, req, bool-->true
</enabled>
<fontSize>
<!--ro, req, int, font size-->1
</fontSize>
<FontColor>
<!--ro, req, object, font color-->
<RGB>
<!--ro, opt, int, three primary colors in decimal format-->1
</RGB>
</FontColor>
<text>
<!--ro, opt, string-->test
</text>
</SubTitle>
<NormalTemperature>


<!--ro, opt, object-->
<PeopleNumber>
<!--ro, opt, object-->
<enabled>
<!--ro, req, bool-->true
</enabled>
<fontSize>
<!--ro, req, int, font size-->1
</fontSize>
<FontColor>
<!--ro, req, object, font color-->
<RGB>
<!--ro, opt, int, three primary colors in decimal format-->1
</RGB>
</FontColor>
<Position>
<!--ro, opt, object, coordinates, desc:the origin is the upper-left corner of the screen. The value range equals to the device
resolution-->
<positionX>
<!--ro, req, int, X-coordinate-->1
</positionX>
<positionY>
<!--ro, req, int, Y-coordinate-->1
</positionY>
<height>
<!--ro, req, int, width-->1
</height>
<width>
<!--ro, req, int, height-->1
</width>
</Position>
<text>
<!--ro, opt, string-->test
</text>
</PeopleNumber>
<Icon>
<!--ro, opt, object-->
<enabled>
<!--ro, req, bool-->true
</enabled>
<Position>
<!--ro, opt, object, coordinates, desc:the origin is the upper-left corner of the screen. The value range equals to the device
resolution-->
<positionX>
<!--ro, req, int, X-coordinate-->1
</positionX>
<positionY>
<!--ro, req, int, Y-coordinate-->1
</positionY>
<height>
<!--ro, req, int, width-->1
</height>
<width>
<!--ro, req, int, height-->1
</width>
</Position>
<materialNo>
<!--ro, opt, int, material ID-->1
</materialNo>
</Icon>
</NormalTemperature>
<AbnormalTemperature>
<!--ro, opt, object-->
<PeopleNumber>
<!--ro, opt, object-->
<enabled>
<!--ro, req, bool-->true
</enabled>
<fontSize>
<!--ro, req, int, font size-->1
</fontSize>
<FontColor>
<!--ro, req, object, font color-->
<RGB>
<!--ro, opt, int, three primary colors in decimal format-->1
</RGB>
</FontColor>
<Position>
<!--ro, opt, object, coordinates, desc:the origin is the upper-left corner of the screen. The value range equals to the device
resolution-->
<positionX>
<!--ro, req, int, X-coordinate-->1
</positionX>
<positionY>
<!--ro, req, int, Y-coordinate-->1
</positionY>
<height>
<!--ro, req, int, width-->1
</height>
<width>
<!--ro, req, int, height-->1
</width>
</Position>
<text>


<text>
<!--ro, opt, string-->test
</text>
</PeopleNumber>
<Icon>
<!--ro, opt, object-->
<enabled>
<!--ro, req, bool-->true
</enabled>
<Position>
<!--ro, opt, object, coordinates, desc:the origin is the upper-left corner of the screen. The value range equals to the device
resolution-->
<positionX>
<!--ro, req, int, X-coordinate-->1
</positionX>
<positionY>
<!--ro, req, int, Y-coordinate-->1
</positionY>
<height>
<!--ro, req, int, width-->1
</height>
<width>
<!--ro, req, int, height-->1
</width>
</Position>
<materialNo>
<!--ro, opt, int, material ID-->1
</materialNo>
</Icon>
</AbnormalTemperature>
</SignIn>
<EventParam>
<!--ro, opt, object, event parameters-->
<EventResourceList>
<!--ro, opt, array, subType:object-->
<EventResource>
<!--ro, opt, object-->
<ipVersion>
<!--ro, req, enum, IP address version, subType:string-->v4
</ipVersion>
<ipAddress>
<!--ro, opt, string, IPv4 address-->test
</ipAddress>
<ipv6Address>
<!--ro, opt, string, IPv6 Address-->test
</ipv6Address>
<portNo>
<!--ro, req, int, port No.-->1
</portNo>
<userName>
<!--ro, req, string, user name-->test
</userName>
<passWord>
<!--ro, req, string, password-->test
</passWord>
<BindIPC>
<!--ro, opt, string, channel No., desc:channel No.-->1,2
</BindIPC>
</EventResource>
</EventResourceList>
<backPicId>
<!--ro, opt, int, background picture ID-->1
</backPicId>
<Title>
<!--ro, opt, object, title-->
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<fontSize>
<!--ro, req, int, font size-->1
</fontSize>
<FontColor>
<!--ro, req, object, font color-->
<RGB>
<!--ro, opt, int, three primary colors in decimal format-->1
</RGB>
</FontColor>
<Position>
<!--ro, opt, object, position, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-->
<positionX>
<!--ro, req, int, X-coordinate-->1
</positionX>
<positionY>
<!--ro, req, int, Y-coordinate-->1
</positionY>
<height>
<!--ro, req, int, width-->1
</height>
<width>
<!--ro, req, int, height-->1
</width>
</Position>
<text>
<!--ro, opt, string-->test


</text>
</Title>
<PeopleCounting>
<!--ro, opt, object-->
<maxPeopleNumber>
<!--ro, opt, int-->1
</maxPeopleNumber>
<unavailableBackPicId>
<!--ro, opt, int-->1
</unavailableBackPicId>
<Prompt>
<!--ro, opt, object, prompt-->
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<fontSize>
<!--ro, req, int, font size-->1
</fontSize>
<Position>
<!--ro, opt, object, coordinates, desc:the origin is the upper-left corner of the screen. The value range equals to the device
resolution-->
<positionX>
<!--ro, req, int, X-coordinate-->1
</positionX>
<positionY>
<!--ro, req, int, Y-coordinate-->1
</positionY>
<height>
<!--ro, req, int, width-->1
</height>
<width>
<!--ro, req, int, height-->1
</width>
</Position>
<text>
<!--ro, opt, string-->test
</text>
<FontColor>
<!--ro, opt, object-->
<RGB>
<!--ro, opt, int, three primary colors in decimal format-->1
</RGB>
</FontColor>
<unavailableText>
<!--ro, opt, string-->test
</unavailableText>
<UnavailableFontColor>
<!--ro, opt, object-->
<RGB>
<!--ro, opt, int, three primary colors in decimal format-->1
</RGB>
</UnavailableFontColor>
</Prompt>
<PeopleIcon>
<!--ro, opt, object-->
<enabled>
<!--ro, req, bool-->true
</enabled>
<Position>
<!--ro, opt, object, coordinates, desc:the origin is the upper-left corner of the screen. The value range equals to the device
resolution-->
<positionX>
<!--ro, req, int, X-coordinate-->1
</positionX>
<positionY>
<!--ro, req, int, Y-coordinate-->1
</positionY>
<height>
<!--ro, req, int, width-->1
</height>
<width>
<!--ro, req, int, height-->1
</width>
</Position>
<materialNo>
<!--ro, opt, int, material ID-->1
</materialNo>
</PeopleIcon>
<InsidePeopleTitle>
<!--ro, opt, object-->
<enabled>
<!--ro, req, bool-->true
</enabled>
<fontSize>
<!--ro, req, int, font size-->1
</fontSize>
<FontColor>
<!--ro, req, object, font color-->
<RGB>
<!--ro, opt, int, three primary colors in decimal format-->1
</RGB>
</FontColor>
<Position>
<!--ro, opt, object, coordinates, desc:the origin is the upper-left corner of the screen. The value range equals to the device


<!--ro, opt, object, coordinates, desc:the origin is the upper-left corner of the screen. The value range equals to the device
resolution-->
<positionX>
<!--ro, req, int, X-coordinate-->1
</positionX>
<positionY>
<!--ro, req, int, Y-coordinate-->1
</positionY>
<height>
<!--ro, req, int, width-->1
</height>
<width>
<!--ro, req, int, height-->1
</width>
</Position>
<text>
<!--ro, opt, string-->test
</text>
</InsidePeopleTitle>
<InsidePeopleNumber>
<!--ro, opt, object-->
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<fontSize>
<!--ro, req, int, font size-->1
</fontSize>
<FontColor>
<!--ro, req, object, font color-->
<RGB>
<!--ro, opt, int, three primary colors in decimal format-->1
</RGB>
</FontColor>
<Position>
<!--ro, opt, object, coordinates, desc:the origin is the upper-left corner of the screen. The value range equals to the device
resolution-->
<positionX>
<!--ro, req, int, X-coordinate-->1
</positionX>
<positionY>
<!--ro, req, int, Y-coordinate-->1
</positionY>
<height>
<!--ro, req, int, width-->1
</height>
<width>
<!--ro, req, int, height-->1
</width>
</Position>
</InsidePeopleNumber>
<AvailablePeopleTitle>
<!--ro, opt, object-->
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<fontSize>
<!--ro, req, int, font size-->1
</fontSize>
<FontColor>
<!--ro, req, object, font color-->
<RGB>
<!--ro, opt, int, three primary colors in decimal format-->1
</RGB>
</FontColor>
<Position>
<!--ro, opt, object, position, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution-
>
<positionX>
<!--ro, req, int, X-coordinate-->1
</positionX>
<positionY>
<!--ro, req, int, Y-coordinate-->1
</positionY>
<height>
<!--ro, req, int, width-->1
</height>
<width>
<!--ro, req, int, height-->1
</width>
</Position>
<text>
<!--ro, opt, string-->test
</text>
</AvailablePeopleTitle>
<AvailablePeopleNumber>
<!--ro, opt, object-->
<enabled>
<!--ro, req, bool-->true
</enabled>
<fontSize>
<!--ro, req, int, font size-->1
</fontSize>
<Position>
<!--ro, opt, object, coordinates, desc:the origin is the upper-left corner of the screen. The value range equals to the device


<!--ro, opt, object, coordinates, desc:the origin is the upper-left corner of the screen. The value range equals to the device
resolution-->
<positionX>
<!--ro, req, int, X-coordinate-->1
</positionX>
<positionY>
<!--ro, req, int, Y-coordinate-->1
</positionY>
<height>
<!--ro, req, int, width-->1
</height>
<width>
<!--ro, req, int, height-->1
</width>
</Position>
<FontColor>
<!--ro, opt, object-->
<RGB>
<!--ro, opt, int, three primary colors in decimal format-->1
</RGB>
</FontColor>
<UnavailableFontColor>
<!--ro, opt, object-->
<RGB>
<!--ro, opt, int, three primary colors in decimal format-->1
</RGB>
</UnavailableFontColor>
</AvailablePeopleNumber>
<UnavailablePeopleIcon>
<!--ro, opt, object-->
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<Position>
<!--ro, opt, object, coordinates, desc:the origin is the upper-left corner of the screen. The value range equals to the device
resolution-->
<positionX>
<!--ro, req, int, X-coordinate-->1
</positionX>
<positionY>
<!--ro, req, int, Y-coordinate-->1
</positionY>
<height>
<!--ro, req, int, width-->1
</height>
<width>
<!--ro, req, int, height-->1
</width>
</Position>
<materialNo>
<!--ro, opt, int, material ID-->1
</materialNo>
</UnavailablePeopleIcon>
<AudioAlarm>
<!--ro, opt, object-->
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<materialNo>
<!--ro, opt, int, material index No.-->1
</materialNo>
</AudioAlarm>
</PeopleCounting>
<Mask>
<!--ro, opt, object-->
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<fontSize>
<!--ro, req, int, font size-->1
</fontSize>
<FontColor>
<!--ro, req, object, font color-->
<RGB>
<!--ro, opt, int, three primary colors in decimal format-->1
</RGB>
</FontColor>
<BackColor>
<!--ro, req, object, background color-->
<RGB>
<!--ro, opt, int, three primary colors in decimal format-->1
</RGB>
</BackColor>
<Position>
<!--ro, opt, object, coordinates, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution->
<positionX>
<!--ro,
req, int, X-coordinate-->1
</positionX>
<positionY>
<!--ro, req, int, Y-coordinate-->1
</positionY>
<height>
<!--ro, req, int, width-->1
</height>


</height>
<width>
<!--ro, req, int, height-->1
</width>
</Position>
<text>
<!--ro, opt, string-->test
</text>
<MaskIcon>
<!--ro, opt, object-->
<enabled>
<!--ro, req, bool, whether to enable the function-->true
</enabled>
<Position>
<!--ro, opt, object, coordinates, desc:the origin is the upper-left corner of the screen. The value range equals to the device
resolution-->
<positionX>
<!--ro, req, int, X-coordinate-->1
</positionX>
<positionY>
<!--ro, req, int, Y-coordinate-->1
</positionY>
<height>
<!--ro, req, int, width-->1
</height>
<width>
<!--ro, req, int, height-->1
</width>
</Position>
<materialNo>
<!--ro, opt, int, material ID-->1
</materialNo>
</MaskIcon>
<AudioAlarm>
<!--ro, opt, object-->
<enabled>
<!--ro, req, bool-->true
</enabled>
<materialNo>
<!--ro, opt, int-->1
</materialNo>
</AudioAlarm>
</Mask>
<Temperature>
<!--ro, opt, object-->
<Prompt>
<!--ro, opt, object, Prompt-->
<enabled>
<!--ro, req, bool-->true
</enabled>
<fontSize>
<!--ro, req, int, font size-->1
</fontSize>
<FontColor>
<!--ro, req, object, font color-->
<RGB>
<!--ro, opt, int, three primary colors in decimal format-->1
</RGB>
</FontColor>
<BackColor>
<!--ro, req, object, background color-->
<RGB>
<!--ro, opt, int, three primary colors in decimal format-->1
</RGB>
</BackColor>
<Position>
<!--ro, opt, object, coordinates, desc:the origin is the upper-left corner of the screen. The value range equals to the device
resolution-->
<positionX>
<!--ro, req, int, X-coordinate-->1
</positionX>
<positionY>
<!--ro, req, int, Y-coordinate-->1
</positionY>
<height>
<!--ro, req, int, width-->1
</height>
<width>
<!--ro, req, int, height-->1
</width>
</Position>
<text>
<!--ro, opt, string-->test
</text>
</Prompt>
<TemperatureIcon>
<!--ro, opt, object-->
<enabled>
<!--ro, req, bool-->true
</enabled>
<Position>
<!--ro, opt, object, coordinates, desc:the origin is the upper-left corner of the screen. The value range equals to the device
resolution-->
<positionX>


<positionX>
<!--ro, req, int, X-coordinate-->1
</positionX>
<positionY>
<!--ro, req, int, Y-coordinate-->1
</positionY>
<height>
<!--ro, req, int, width-->1
</height>
<width>
<!--ro, req, int, height-->1
</width>
</Position>
<materialNo>
<!--ro, opt, int, material ID-->1
</materialNo>
</TemperatureIcon>
<AudioAlarm>
<!--ro, opt, object-->
<enabled>
<!--ro, req, bool-->true
</enabled>
<materialNo>
<!--ro, opt, int-->1
</materialNo>
</AudioAlarm>
<abnormalHighTemperature>
<!--ro, opt, float, unit:℃-->37.5
</abnormalHighTemperature>
</Temperature>
</EventParam>
<AlarmDataSourceProperty>
<!--ro, opt, object-->
<PictureProperty>
<!--ro, opt, object-->
<PictureSwitchEffect>
<!--ro, opt, enum, subType:string-->leftInRightOut
</PictureSwitchEffect>
<PictureScaleType>
<!--ro, opt, enum, subType:string-->fitCenter
</PictureScaleType>
</PictureProperty>
<AlarmDataSource>
<!--ro, opt, object, data source-->
<MaterialNo>
<!--ro, opt, int, material No.-->1
</MaterialNo>
<Name>
<!--ro, opt, string, material name-->test
</Name>
<Address>
<!--ro, opt, string-->test
</Address>
</AlarmDataSource>
</AlarmDataSourceProperty>
<ConferenceParam>
<!--ro, opt, object, meeting information, desc:Meeting Information-->
<backPicId>
<!--ro, opt, int, background picture ID-->1
</backPicId>
<Title>
<!--ro, opt, object-->
<enabled>
<!--ro, req, bool-->true
</enabled>
<fontSize>
<!--ro, req, int, font size-->1
</fontSize>
<FontColor>
<!--ro, req, object, font color-->
<RGB>
<!--ro, opt, int, three primary colors in decimal format-->1
</RGB>
</FontColor>
<BackColor>
<!--ro, req, object, background color-->
<RGB>
<!--ro, opt, int, three primary colors in decimal format-->1
</RGB>
</BackColor>
<Position>
<!--ro, opt, object, coordinates, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution->
<positionX>
<!--ro,
req, int, X-coordinate-->1
</positionX>
<positionY>
<!--ro, req, int, Y-coordinate-->1
</positionY>
<height>
<!--ro, req, int, width-->1
</height>
<width>
<!--ro, req, int, height-->1


</width>
</Position>
<alignType>
<!--ro, req, enum, subType:string-->middle
</alignType>
</Title>
<VoiceBroadcast>
<!--ro, opt, object, audio prompt-->
<enabled>
<!--ro, opt, bool-->true
</enabled>
<broadcastSpeed>
<!--ro, opt, enum, subType:string-->slower
</broadcastSpeed>
<inLibVoice>
<!--ro, opt, string-->test
</inLibVoice>
<outLibVoice>
<!--ro, opt, string-->test
</outLibVoice>
</VoiceBroadcast>
<WelcomeWord>
<!--ro, opt, object, Welcome Words-->
<enabled>
<!--ro, opt, bool-->true
</enabled>
<inLibWord>
<!--ro, opt, string, range:[1,128]-->test
</inLibWord>
<outLibWord>
<!--ro, opt, string, range:[1,128]-->test
</outLibWord>
</WelcomeWord>
<ShowInfo>
<!--ro, opt, object-->
<row>
<!--ro, opt, int-->1
</row>
<column>
<!--ro, opt, int-->1
</column>
<Position>
<!--ro, opt, object, coordinates, desc:the origin is the upper-left corner of the screen. The value range equals to the device resolution->
<positionX>
<!--ro,
req, int, X-coordinate-->1
</positionX>
<positionY>
<!--ro, req, int, Y-coordinate-->1
</positionY>
<height>
<!--ro, req, int, width-->1
</height>
<width>
<!--ro, req, int, height-->1
</width>
</Position>
<inLib>
<!--ro, opt, object-->
<nameEnabled>
<!--ro, opt, bool-->true
</nameEnabled>
</inLib>
<defaultShowInfoEnabled>
<!--ro, opt, bool-->true
</defaultShowInfoEnabled>
</ShowInfo>
<ModuleInfoList>
<!--ro, opt, array, subType:object-->
<ModuleInfo>
<!--ro, opt, object-->
<moduleType>
<!--ro, req, enum, subType:string-->conferenceTime
</moduleType>
<enabled>
<!--ro, req, bool-->true
</enabled>
<fontSize>
<!--ro, req, int-->1
</fontSize>
<FontColor>
<!--ro, req, object-->
<RGB>
<!--ro, opt, int-->1
</RGB>
</FontColor>
<BackColor>
<!--ro, opt, object-->
<RGB>
<!--ro, opt, int-->1
</RGB>
</BackColor>
<backPicId>
<!--ro, opt, int-->1


<!--ro, opt, int-->1
</backPicId>
<Position>
<!--ro, opt, object-->
<positionX>
<!--ro, req, int-->1
</positionX>
<positionY>
<!--ro, req, int-->1
</positionY>
<height>
<!--ro, req, int-->1
</height>
<width>
<!--ro, req, int-->1
</width>
</Position>
<alignType>
<!--ro, req, enum, subType:string-->middle
</alignType>
<CustomKey>
<!--ro, opt, object-->
<key>
<!--ro, opt, string-->test
</key>
<associateProtocolURL>
<!--ro, opt, string-->test
</associateProtocolURL>
</CustomKey>
</ModuleInfo>
</ModuleInfoList>
<conferenceStatus>
<!--ro, opt, enum, subType:string-->idle
</conferenceStatus>
<BackColor>
<!--ro, opt, object-->
<RGB>
<!--ro, opt, int-->1
</RGB>
</BackColor>
</ConferenceParam>
<CallBtn>
<!--ro, opt, object-->
<backPicId>
<!--ro, opt, int, background picture ID-->1
</backPicId>
</CallBtn>
<OpenDoorBtn>
<!--ro, opt, object-->
<backPicId>
<!--ro, opt, int, background picture ID-->1
</backPicId>
</OpenDoorBtn>
<QRCodeBtn>
<!--ro, opt, object-->
<backPicId>
<!--ro, opt, int, background picture ID-->1
</backPicId>
</QRCodeBtn>
<AuthenticationSuccess>
<!--ro, opt, object-->
<BackColor>
<!--ro, opt, object, background color-->
<RGB>
<!--ro, opt, int, three primary colors in decimal format-->1
</RGB>
</BackColor>
<backPicId>
<!--ro, opt, int, background picture ID-->1
</backPicId>
<SubWindowList>
<!--ro, opt, object-->
<SubWindow>
<!--ro, opt, object, sub-window-->
<subWindowType>
<!--ro, req, enum, sub-window type, subType:string-->temperature
</subWindowType>
<enabled>
<!--ro, req, bool-->true
</enabled>
<fontSize>
<!--ro, opt, int, font size, unit:px-->1
</fontSize>
<fontColor>
<!--ro, opt, int, font color-->1
</fontColor>
<fontStyle>
<!--ro, opt, string, font style, desc:Font Style-->bold,italic,underline,strikeout
</fontStyle>
<Position>
<!--ro, opt, object, coordinates, desc:the origin is the upper-left corner of the screen. The value range equals to the device
resolution-->
<positionX>
<!--ro, req, int, X-coordinate-->1


</positionX>
<positionY>
<!--ro, req, int, Y-coordinate-->1
</positionY>
<height>
<!--ro, req, int, width-->1
</height>
<width>
<!--ro, req, int, height-->1
</width>
</Position>
</SubWindow>
</SubWindowList>
</AuthenticationSuccess>
<AuthenticationFail>
<!--ro, opt, object-->
<BackColor>
<!--ro, opt, object, background color-->
<RGB>
<!--ro, opt, int, three primary colors in decimal format-->1
</RGB>
</BackColor>
<backPicId>
<!--ro, opt, int, background picture ID-->1
</backPicId>
<SubWindowList>
<!--ro, opt, object-->
<SubWindow>
<!--ro, opt, object, sub-window-->
<subWindowType>
<!--ro, req, enum, sub-window type, subType:string-->temperature
</subWindowType>
<enabled>
<!--ro, req, bool-->true
</enabled>
<fontSize>
<!--ro, opt, int, font size, unit:px-->1
</fontSize>
<fontColor>
<!--ro, opt, int, font color-->1
</fontColor>
<fontStyle>
<!--ro, opt, string, font style, desc:Font Style-->bold,italic,underline,strikeout
</fontStyle>
<Position>
<!--ro, opt, object, coordinates, desc:the origin is the upper-left corner of the screen. The value range equals to the device
resolution-->
<positionX>
<!--ro, req, int, X-coordinate-->1
</positionX>
<positionY>
<!--ro, req, int, Y-coordinate-->1
</positionY>
<height>
<!--ro, req, int, width-->1
</height>
<width>
<!--ro, req, int, height-->1
</width>
</Position>
<facePicID>
<!--ro, opt, int, step:1, dep:and,
{$.PageList.Page.WindowsList[*].Windows.AuthenticationFail.SubWindowList.SubWindow.subWindowType,eq,facePic}-->1
</facePicID>
</SubWindow>
</SubWindowList>
</AuthenticationFail>
<StatusBar>
<!--ro, opt, object, status bar, desc:Status Bar-->
<backPicId>
<!--ro, opt, int, background picture ID-->1
</backPicId>
<statusBarType>
<!--ro, req, enum, subType:string-->fixed
</statusBarType>
<SubStatusList>
<!--ro, opt, object-->
<SubStatus>
<!--ro, opt, object, sub status-->
<statusType>
<!--ro, req, enum, sub status, subType:string-->dial
</statusType>
<enabled>
<!--ro, req, bool-->true
</enabled>
</SubStatus>
</SubStatusList>
</StatusBar>
</Windows>
</WindowsList>
</Page>
</PageList>
<programSize>
<!--ro, opt, int, unit:Byte-->1


<!--ro, opt, int, unit:Byte-->1
</programSize>
<programLength>
<!--ro, opt, int, program duration, unit:s-->1
</programLength>
<coordinateType>
<!--ro, opt, enum, subType:string-->uniformCoordinate
</coordinateType>
<screenType>
<!--ro, opt, enum, screen type, subType:string, desc:Screen Type-->first
</screenType>
<audioEnabled>
<!--ro, opt, bool-->true
</audioEnabled>
<PageIdList>
<!--ro, opt, array, subType:object-->
<PageId>
<!--ro, opt, object, page ID-->
<id>
<!--ro, req, int, page ID-->1
</id>
</PageId>
</PageIdList>
</Program>
</ProgramList>
21.40.5 Delete a specific program
Request URL
DELETE /ISAPI/Publish/ProgramMgr/program/<programID>
Query Parameter
Parameter Name Parameter Type Description
programID
string
Request Message
None
Response Message
<?xml version="1.0" encoding="UTF-8"?>
<ResponseStatus xmlns="http://www.isapi.org/ver20/XMLSchema" version="2.0">
<!--ro, req, object, response message, attr:version{ro, req, string, protocolVersion}-->
<requestURL>
<!--ro, req, string, request URL-->null
</requestURL>
<statusCode>
<!--ro, req, enum, status code, subType:int, desc:0-OK, 1-OK, 2-Device Busy, 3-Device Error, 4-Invalid Operation, 5-Invalid XML Format, 6-Invalid XML
Content, 7-Reboot Required-->0
</statusCode>
<statusString>
<!--ro, req, enum, status description, subType:string, desc:“OK” (succeeded), “Device Busy”, “Device Error”, “Invalid Operation”, “Invalid XML Format”,
“Invalid XML Content”, “Reboot” (reboot device)-->OK
</statusString>
<subStatusCode>
<!--ro, req, string, sub status code, desc:sub status code-->OK
</subStatusCode>
</ResponseStatus>
-


